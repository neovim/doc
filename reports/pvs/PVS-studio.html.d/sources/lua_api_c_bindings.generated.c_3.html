<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>lua_api_c_bindings.generated.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3">#include &lt;lua.h&gt;</a>
<a name="ln4">#include &lt;lualib.h&gt;</a>
<a name="ln5">#include &lt;lauxlib.h&gt;</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln8">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln9">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln10">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln11">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln12">#include &quot;nvim/api/private/dispatch.h&quot;</a>
<a name="ln13">#include &quot;nvim/lua/converter.h&quot;</a>
<a name="ln14">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln15">#include &quot;nvim/memory.h&quot;</a>
<a name="ln16"> </a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;nvim/api/autocmd.h&quot;</a>
<a name="ln19">#include &quot;nvim/api/buffer.h&quot;</a>
<a name="ln20">#include &quot;nvim/api/command.h&quot;</a>
<a name="ln21">#include &quot;nvim/api/deprecated.h&quot;</a>
<a name="ln22">#include &quot;nvim/api/extmark.h&quot;</a>
<a name="ln23">#include &quot;nvim/api/keysets.h&quot;</a>
<a name="ln24">#include &quot;nvim/api/options.h&quot;</a>
<a name="ln25">#include &quot;nvim/api/tabpage.h&quot;</a>
<a name="ln26">#include &quot;nvim/api/ui.h&quot;</a>
<a name="ln27">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln28">#include &quot;nvim/api/vimscript.h&quot;</a>
<a name="ln29">#include &quot;nvim/api/win_config.h&quot;</a>
<a name="ln30">#include &quot;nvim/api/window.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">static int nlua_api_nvim_get_autocmds(lua_State *lstate)</a>
<a name="ln33">{</a>
<a name="ln34">  Error err = ERROR_INIT;</a>
<a name="ln35">  char *err_param = 0;</a>
<a name="ln36">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln37">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln38">    goto exit_0;</a>
<a name="ln39">  }</a>
<a name="ln40">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln41">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_autocmds&quot;);</a>
<a name="ln42">  }</a>
<a name="ln43">    KeyDict_get_autocmds arg1 = { 0 }; nlua_pop_keydict(lstate, &amp;arg1, KeyDict_get_autocmds_get_field, &amp;err_param, &amp;err);</a>
<a name="ln44">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln45">  }</a>
<a name="ln46"> </a>
<a name="ln47">  const Array ret = nvim_get_autocmds(&amp;arg1, &amp;err);</a>
<a name="ln48">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln49">api_free_array(ret);</a>
<a name="ln50"> </a>
<a name="ln51">exit_1:</a>
<a name="ln52">  api_free_keydict_get_autocmds(&amp;arg1);</a>
<a name="ln53"> </a>
<a name="ln54">exit_0:</a>
<a name="ln55">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln56">    luaL_where(lstate, 1);</a>
<a name="ln57">    if (err_param) {</a>
<a name="ln58">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln59">      lua_pushstring(lstate, err_param);</a>
<a name="ln60">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln61">    }</a>
<a name="ln62">    lua_pushstring(lstate, err.msg);</a>
<a name="ln63">    api_clear_error(&amp;err);</a>
<a name="ln64">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln65">    return lua_error(lstate);</a>
<a name="ln66">  }</a>
<a name="ln67"> </a>
<a name="ln68">  return 1;</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">static int nlua_api_nvim_create_autocmd(lua_State *lstate)</a>
<a name="ln72">{</a>
<a name="ln73">  Error err = ERROR_INIT;</a>
<a name="ln74">  char *err_param = 0;</a>
<a name="ln75">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln76">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln77">    goto exit_0;</a>
<a name="ln78">  }</a>
<a name="ln79">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln80">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_create_autocmd&quot;);</a>
<a name="ln81">  }</a>
<a name="ln82">    KeyDict_create_autocmd arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_create_autocmd_get_field, &amp;err_param, &amp;err);</a>
<a name="ln83">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln84">  }</a>
<a name="ln85"> </a>
<a name="ln86">    const Object arg1 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln87">  if (ERROR_SET(&amp;err)) {      err_param = &quot;event&quot;;      goto exit_1;</a>
<a name="ln88">  }</a>
<a name="ln89"> </a>
<a name="ln90">  const Integer ret = nvim_create_autocmd(LUA_INTERNAL_CALL, arg1, &amp;arg2, &amp;err);</a>
<a name="ln91">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln92">api_free_integer(ret);</a>
<a name="ln93"> </a>
<a name="ln94">  api_free_object(arg1);</a>
<a name="ln95">exit_1:</a>
<a name="ln96">  api_free_keydict_create_autocmd(&amp;arg2);</a>
<a name="ln97"> </a>
<a name="ln98">exit_0:</a>
<a name="ln99">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln100">    luaL_where(lstate, 1);</a>
<a name="ln101">    if (err_param) {</a>
<a name="ln102">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln103">      lua_pushstring(lstate, err_param);</a>
<a name="ln104">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln105">    }</a>
<a name="ln106">    lua_pushstring(lstate, err.msg);</a>
<a name="ln107">    api_clear_error(&amp;err);</a>
<a name="ln108">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln109">    return lua_error(lstate);</a>
<a name="ln110">  }</a>
<a name="ln111"> </a>
<a name="ln112">  return 1;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">static int nlua_api_nvim_del_autocmd(lua_State *lstate)</a>
<a name="ln116">{</a>
<a name="ln117">  Error err = ERROR_INIT;</a>
<a name="ln118">  char *err_param = 0;</a>
<a name="ln119">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln120">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln121">    goto exit_0;</a>
<a name="ln122">  }</a>
<a name="ln123">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln124">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_autocmd&quot;);</a>
<a name="ln125">  }</a>
<a name="ln126">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln127">  if (ERROR_SET(&amp;err)) {      err_param = &quot;id&quot;;      goto exit_0;</a>
<a name="ln128">  }</a>
<a name="ln129"> </a>
<a name="ln130">  nvim_del_autocmd(arg1, &amp;err);</a>
<a name="ln131"> </a>
<a name="ln132">  api_free_integer(arg1);</a>
<a name="ln133"> </a>
<a name="ln134">exit_0:</a>
<a name="ln135">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln136">    luaL_where(lstate, 1);</a>
<a name="ln137">    if (err_param) {</a>
<a name="ln138">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln139">      lua_pushstring(lstate, err_param);</a>
<a name="ln140">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln141">    }</a>
<a name="ln142">    lua_pushstring(lstate, err.msg);</a>
<a name="ln143">    api_clear_error(&amp;err);</a>
<a name="ln144">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln145">    return lua_error(lstate);</a>
<a name="ln146">  }</a>
<a name="ln147"> </a>
<a name="ln148">  return 0;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">static int nlua_api_nvim_clear_autocmds(lua_State *lstate)</a>
<a name="ln152">{</a>
<a name="ln153">  Error err = ERROR_INIT;</a>
<a name="ln154">  char *err_param = 0;</a>
<a name="ln155">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln156">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln157">    goto exit_0;</a>
<a name="ln158">  }</a>
<a name="ln159">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln160">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_clear_autocmds&quot;);</a>
<a name="ln161">  }</a>
<a name="ln162">    KeyDict_clear_autocmds arg1 = { 0 }; nlua_pop_keydict(lstate, &amp;arg1, KeyDict_clear_autocmds_get_field, &amp;err_param, &amp;err);</a>
<a name="ln163">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln164">  }</a>
<a name="ln165"> </a>
<a name="ln166">  nvim_clear_autocmds(&amp;arg1, &amp;err);</a>
<a name="ln167"> </a>
<a name="ln168">exit_1:</a>
<a name="ln169">  api_free_keydict_clear_autocmds(&amp;arg1);</a>
<a name="ln170"> </a>
<a name="ln171">exit_0:</a>
<a name="ln172">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln173">    luaL_where(lstate, 1);</a>
<a name="ln174">    if (err_param) {</a>
<a name="ln175">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln176">      lua_pushstring(lstate, err_param);</a>
<a name="ln177">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln178">    }</a>
<a name="ln179">    lua_pushstring(lstate, err.msg);</a>
<a name="ln180">    api_clear_error(&amp;err);</a>
<a name="ln181">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln182">    return lua_error(lstate);</a>
<a name="ln183">  }</a>
<a name="ln184"> </a>
<a name="ln185">  return 0;</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">static int nlua_api_nvim_create_augroup(lua_State *lstate)</a>
<a name="ln189">{</a>
<a name="ln190">  Error err = ERROR_INIT;</a>
<a name="ln191">  char *err_param = 0;</a>
<a name="ln192">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln193">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln194">    goto exit_0;</a>
<a name="ln195">  }</a>
<a name="ln196">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln197">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_create_augroup&quot;);</a>
<a name="ln198">  }</a>
<a name="ln199">    KeyDict_create_augroup arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_create_augroup_get_field, &amp;err_param, &amp;err);</a>
<a name="ln200">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln201">  }</a>
<a name="ln202"> </a>
<a name="ln203">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln204">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln205">  }</a>
<a name="ln206"> </a>
<a name="ln207">  const Integer ret = nvim_create_augroup(LUA_INTERNAL_CALL, arg1, &amp;arg2, &amp;err);</a>
<a name="ln208">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln209">api_free_integer(ret);</a>
<a name="ln210"> </a>
<a name="ln211">  api_free_string(arg1);</a>
<a name="ln212">exit_1:</a>
<a name="ln213">  api_free_keydict_create_augroup(&amp;arg2);</a>
<a name="ln214"> </a>
<a name="ln215">exit_0:</a>
<a name="ln216">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln217">    luaL_where(lstate, 1);</a>
<a name="ln218">    if (err_param) {</a>
<a name="ln219">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln220">      lua_pushstring(lstate, err_param);</a>
<a name="ln221">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln222">    }</a>
<a name="ln223">    lua_pushstring(lstate, err.msg);</a>
<a name="ln224">    api_clear_error(&amp;err);</a>
<a name="ln225">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln226">    return lua_error(lstate);</a>
<a name="ln227">  }</a>
<a name="ln228"> </a>
<a name="ln229">  return 1;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">static int nlua_api_nvim_del_augroup_by_id(lua_State *lstate)</a>
<a name="ln233">{</a>
<a name="ln234">  Error err = ERROR_INIT;</a>
<a name="ln235">  char *err_param = 0;</a>
<a name="ln236">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln237">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln238">    goto exit_0;</a>
<a name="ln239">  }</a>
<a name="ln240">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln241">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_augroup_by_id&quot;);</a>
<a name="ln242">  }</a>
<a name="ln243">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln244">  if (ERROR_SET(&amp;err)) {      err_param = &quot;id&quot;;      goto exit_0;</a>
<a name="ln245">  }</a>
<a name="ln246"> </a>
<a name="ln247">  nvim_del_augroup_by_id(arg1, &amp;err);</a>
<a name="ln248"> </a>
<a name="ln249">  api_free_integer(arg1);</a>
<a name="ln250"> </a>
<a name="ln251">exit_0:</a>
<a name="ln252">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln253">    luaL_where(lstate, 1);</a>
<a name="ln254">    if (err_param) {</a>
<a name="ln255">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln256">      lua_pushstring(lstate, err_param);</a>
<a name="ln257">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln258">    }</a>
<a name="ln259">    lua_pushstring(lstate, err.msg);</a>
<a name="ln260">    api_clear_error(&amp;err);</a>
<a name="ln261">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln262">    return lua_error(lstate);</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265">  return 0;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">static int nlua_api_nvim_del_augroup_by_name(lua_State *lstate)</a>
<a name="ln269">{</a>
<a name="ln270">  Error err = ERROR_INIT;</a>
<a name="ln271">  char *err_param = 0;</a>
<a name="ln272">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln273">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln274">    goto exit_0;</a>
<a name="ln275">  }</a>
<a name="ln276">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln277">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_augroup_by_name&quot;);</a>
<a name="ln278">  }</a>
<a name="ln279">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln280">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln281">  }</a>
<a name="ln282"> </a>
<a name="ln283">  nvim_del_augroup_by_name(arg1, &amp;err);</a>
<a name="ln284"> </a>
<a name="ln285">  api_free_string(arg1);</a>
<a name="ln286"> </a>
<a name="ln287">exit_0:</a>
<a name="ln288">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln289">    luaL_where(lstate, 1);</a>
<a name="ln290">    if (err_param) {</a>
<a name="ln291">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln292">      lua_pushstring(lstate, err_param);</a>
<a name="ln293">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln294">    }</a>
<a name="ln295">    lua_pushstring(lstate, err.msg);</a>
<a name="ln296">    api_clear_error(&amp;err);</a>
<a name="ln297">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln298">    return lua_error(lstate);</a>
<a name="ln299">  }</a>
<a name="ln300"> </a>
<a name="ln301">  return 0;</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">static int nlua_api_nvim_exec_autocmds(lua_State *lstate)</a>
<a name="ln305">{</a>
<a name="ln306">  Error err = ERROR_INIT;</a>
<a name="ln307">  char *err_param = 0;</a>
<a name="ln308">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln309">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln310">    goto exit_0;</a>
<a name="ln311">  }</a>
<a name="ln312">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln313">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_exec_autocmds&quot;);</a>
<a name="ln314">  }</a>
<a name="ln315">    KeyDict_exec_autocmds arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_exec_autocmds_get_field, &amp;err_param, &amp;err);</a>
<a name="ln316">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln317">  }</a>
<a name="ln318"> </a>
<a name="ln319">    const Object arg1 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln320">  if (ERROR_SET(&amp;err)) {      err_param = &quot;event&quot;;      goto exit_1;</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">  nvim_exec_autocmds(arg1, &amp;arg2, &amp;err);</a>
<a name="ln324"> </a>
<a name="ln325">  api_free_object(arg1);</a>
<a name="ln326">exit_1:</a>
<a name="ln327">  api_free_keydict_exec_autocmds(&amp;arg2);</a>
<a name="ln328"> </a>
<a name="ln329">exit_0:</a>
<a name="ln330">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln331">    luaL_where(lstate, 1);</a>
<a name="ln332">    if (err_param) {</a>
<a name="ln333">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln334">      lua_pushstring(lstate, err_param);</a>
<a name="ln335">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln336">    }</a>
<a name="ln337">    lua_pushstring(lstate, err.msg);</a>
<a name="ln338">    api_clear_error(&amp;err);</a>
<a name="ln339">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln340">    return lua_error(lstate);</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  return 0;</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">static int nlua_api_nvim_buf_line_count(lua_State *lstate)</a>
<a name="ln347">{</a>
<a name="ln348">  Error err = ERROR_INIT;</a>
<a name="ln349">  char *err_param = 0;</a>
<a name="ln350">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln351">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln352">    goto exit_0;</a>
<a name="ln353">  }</a>
<a name="ln354">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln355">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_line_count&quot;);</a>
<a name="ln356">  }</a>
<a name="ln357">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln358">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln359">  }</a>
<a name="ln360"> </a>
<a name="ln361">  const Integer ret = nvim_buf_line_count(arg1, &amp;err);</a>
<a name="ln362">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln363">api_free_integer(ret);</a>
<a name="ln364"> </a>
<a name="ln365">  api_free_buffer(arg1);</a>
<a name="ln366"> </a>
<a name="ln367">exit_0:</a>
<a name="ln368">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln369">    luaL_where(lstate, 1);</a>
<a name="ln370">    if (err_param) {</a>
<a name="ln371">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln372">      lua_pushstring(lstate, err_param);</a>
<a name="ln373">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln374">    }</a>
<a name="ln375">    lua_pushstring(lstate, err.msg);</a>
<a name="ln376">    api_clear_error(&amp;err);</a>
<a name="ln377">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln378">    return lua_error(lstate);</a>
<a name="ln379">  }</a>
<a name="ln380"> </a>
<a name="ln381">  return 1;</a>
<a name="ln382">}</a>
<a name="ln383"> </a>
<a name="ln384">static int nlua_api_nvim_buf_attach(lua_State *lstate)</a>
<a name="ln385">{</a>
<a name="ln386">  Error err = ERROR_INIT;</a>
<a name="ln387">  char *err_param = 0;</a>
<a name="ln388">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln389">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln390">    goto exit_0;</a>
<a name="ln391">  }</a>
<a name="ln392">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln393">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_attach&quot;);</a>
<a name="ln394">  }</a>
<a name="ln395">    const DictionaryOf(LuaRef) arg3 = nlua_pop_Dictionary(lstate, true, &amp;err);</a>
<a name="ln396">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln400">  if (ERROR_SET(&amp;err)) {      err_param = &quot;send_buffer&quot;;      goto exit_1;</a>
<a name="ln401">  }</a>
<a name="ln402"> </a>
<a name="ln403">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln404">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln405">  }</a>
<a name="ln406"> </a>
<a name="ln407">  const Boolean ret = nvim_buf_attach(LUA_INTERNAL_CALL, arg1, arg2, arg3, &amp;err);</a>
<a name="ln408">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln409">api_free_boolean(ret);</a>
<a name="ln410"> </a>
<a name="ln411">  api_free_buffer(arg1);</a>
<a name="ln412">exit_2:</a>
<a name="ln413">  api_free_boolean(arg2);</a>
<a name="ln414">exit_1:</a>
<a name="ln415">  api_free_dictionary(arg3);</a>
<a name="ln416"> </a>
<a name="ln417">exit_0:</a>
<a name="ln418">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln419">    luaL_where(lstate, 1);</a>
<a name="ln420">    if (err_param) {</a>
<a name="ln421">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln422">      lua_pushstring(lstate, err_param);</a>
<a name="ln423">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln424">    }</a>
<a name="ln425">    lua_pushstring(lstate, err.msg);</a>
<a name="ln426">    api_clear_error(&amp;err);</a>
<a name="ln427">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln428">    return lua_error(lstate);</a>
<a name="ln429">  }</a>
<a name="ln430"> </a>
<a name="ln431">  return 1;</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">static int nlua_api_nvim__buf_redraw_range(lua_State *lstate)</a>
<a name="ln435">{</a>
<a name="ln436">  Error err = ERROR_INIT;</a>
<a name="ln437">  char *err_param = 0;</a>
<a name="ln438">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln439">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln440">    goto exit_0;</a>
<a name="ln441">  }</a>
<a name="ln442">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln443">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__buf_redraw_range&quot;);</a>
<a name="ln444">  }</a>
<a name="ln445">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln446">  if (ERROR_SET(&amp;err)) {      err_param = &quot;last&quot;;      goto exit_0;</a>
<a name="ln447">  }</a>
<a name="ln448"> </a>
<a name="ln449">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln450">  if (ERROR_SET(&amp;err)) {      err_param = &quot;first&quot;;      goto exit_1;</a>
<a name="ln451">  }</a>
<a name="ln452"> </a>
<a name="ln453">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln454">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln455">  }</a>
<a name="ln456"> </a>
<a name="ln457">  nvim__buf_redraw_range(arg1, arg2, arg3, &amp;err);</a>
<a name="ln458"> </a>
<a name="ln459">  api_free_buffer(arg1);</a>
<a name="ln460">exit_2:</a>
<a name="ln461">  api_free_integer(arg2);</a>
<a name="ln462">exit_1:</a>
<a name="ln463">  api_free_integer(arg3);</a>
<a name="ln464"> </a>
<a name="ln465">exit_0:</a>
<a name="ln466">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln467">    luaL_where(lstate, 1);</a>
<a name="ln468">    if (err_param) {</a>
<a name="ln469">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln470">      lua_pushstring(lstate, err_param);</a>
<a name="ln471">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln472">    }</a>
<a name="ln473">    lua_pushstring(lstate, err.msg);</a>
<a name="ln474">    api_clear_error(&amp;err);</a>
<a name="ln475">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln476">    return lua_error(lstate);</a>
<a name="ln477">  }</a>
<a name="ln478"> </a>
<a name="ln479">  return 0;</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">static int nlua_api_nvim_buf_get_lines(lua_State *lstate)</a>
<a name="ln483">{</a>
<a name="ln484">  Error err = ERROR_INIT;</a>
<a name="ln485">  char *err_param = 0;</a>
<a name="ln486">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln487">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln488">    goto exit_0;</a>
<a name="ln489">  }</a>
<a name="ln490">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln491">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_lines&quot;);</a>
<a name="ln492">  }</a>
<a name="ln493">    const Boolean arg4 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln494">  if (ERROR_SET(&amp;err)) {      err_param = &quot;strict_indexing&quot;;      goto exit_0;</a>
<a name="ln495">  }</a>
<a name="ln496"> </a>
<a name="ln497">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln498">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end&quot;;      goto exit_1;</a>
<a name="ln499">  }</a>
<a name="ln500"> </a>
<a name="ln501">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln502">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start&quot;;      goto exit_2;</a>
<a name="ln503">  }</a>
<a name="ln504"> </a>
<a name="ln505">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln506">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_3;</a>
<a name="ln507">  }</a>
<a name="ln508"> </a>
<a name="ln509">  const ArrayOf(String) ret = nvim_buf_get_lines(LUA_INTERNAL_CALL, arg1, arg2, arg3, arg4, lstate, &amp;err);</a>
<a name="ln510">  if (lua_gettop(lstate) == 0) {</a>
<a name="ln511">    nlua_push_Array(lstate, ret, true);</a>
<a name="ln512">  }</a>
<a name="ln513">api_free_array(ret);</a>
<a name="ln514"> </a>
<a name="ln515">  api_free_buffer(arg1);</a>
<a name="ln516">exit_3:</a>
<a name="ln517">  api_free_integer(arg2);</a>
<a name="ln518">exit_2:</a>
<a name="ln519">  api_free_integer(arg3);</a>
<a name="ln520">exit_1:</a>
<a name="ln521">  api_free_boolean(arg4);</a>
<a name="ln522"> </a>
<a name="ln523">exit_0:</a>
<a name="ln524">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln525">    luaL_where(lstate, 1);</a>
<a name="ln526">    if (err_param) {</a>
<a name="ln527">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln528">      lua_pushstring(lstate, err_param);</a>
<a name="ln529">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln530">    }</a>
<a name="ln531">    lua_pushstring(lstate, err.msg);</a>
<a name="ln532">    api_clear_error(&amp;err);</a>
<a name="ln533">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln534">    return lua_error(lstate);</a>
<a name="ln535">  }</a>
<a name="ln536"> </a>
<a name="ln537">  return 1;</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">static int nlua_api_nvim_buf_set_lines(lua_State *lstate)</a>
<a name="ln541">{</a>
<a name="ln542">  Error err = ERROR_INIT;</a>
<a name="ln543">  char *err_param = 0;</a>
<a name="ln544">  if (lua_gettop(lstate) != 5) {</a>
<a name="ln545">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 5 arguments&quot;);</a>
<a name="ln546">    goto exit_0;</a>
<a name="ln547">  }</a>
<a name="ln548">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln549">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_lines&quot;);</a>
<a name="ln550">  }</a>
<a name="ln551">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln552">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln553">    goto exit_0;</a>
<a name="ln554">  }</a>
<a name="ln555">    const ArrayOf(String) arg5 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln556">  if (ERROR_SET(&amp;err)) {      err_param = &quot;replacement&quot;;      goto exit_0;</a>
<a name="ln557">  }</a>
<a name="ln558"> </a>
<a name="ln559">    const Boolean arg4 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln560">  if (ERROR_SET(&amp;err)) {      err_param = &quot;strict_indexing&quot;;      goto exit_1;</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln564">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end&quot;;      goto exit_2;</a>
<a name="ln565">  }</a>
<a name="ln566"> </a>
<a name="ln567">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln568">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start&quot;;      goto exit_3;</a>
<a name="ln569">  }</a>
<a name="ln570"> </a>
<a name="ln571">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln572">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_4;</a>
<a name="ln573">  }</a>
<a name="ln574"> </a>
<a name="ln575">  nvim_buf_set_lines(LUA_INTERNAL_CALL, arg1, arg2, arg3, arg4, arg5, &amp;err);</a>
<a name="ln576"> </a>
<a name="ln577">  api_free_buffer(arg1);</a>
<a name="ln578">exit_4:</a>
<a name="ln579">  api_free_integer(arg2);</a>
<a name="ln580">exit_3:</a>
<a name="ln581">  api_free_integer(arg3);</a>
<a name="ln582">exit_2:</a>
<a name="ln583">  api_free_boolean(arg4);</a>
<a name="ln584">exit_1:</a>
<a name="ln585">  api_free_array(arg5);</a>
<a name="ln586"> </a>
<a name="ln587">exit_0:</a>
<a name="ln588">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln589">    luaL_where(lstate, 1);</a>
<a name="ln590">    if (err_param) {</a>
<a name="ln591">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln592">      lua_pushstring(lstate, err_param);</a>
<a name="ln593">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln594">    }</a>
<a name="ln595">    lua_pushstring(lstate, err.msg);</a>
<a name="ln596">    api_clear_error(&amp;err);</a>
<a name="ln597">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln598">    return lua_error(lstate);</a>
<a name="ln599">  }</a>
<a name="ln600"> </a>
<a name="ln601">  return 0;</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">static int nlua_api_nvim_buf_set_text(lua_State *lstate)</a>
<a name="ln605">{</a>
<a name="ln606">  Error err = ERROR_INIT;</a>
<a name="ln607">  char *err_param = 0;</a>
<a name="ln608">  if (lua_gettop(lstate) != 6) {</a>
<a name="ln609">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 6 arguments&quot;);</a>
<a name="ln610">    goto exit_0;</a>
<a name="ln611">  }</a>
<a name="ln612">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln613">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_text&quot;);</a>
<a name="ln614">  }</a>
<a name="ln615">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln616">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln617">    goto exit_0;</a>
<a name="ln618">  }</a>
<a name="ln619">    const ArrayOf(String) arg6 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln620">  if (ERROR_SET(&amp;err)) {      err_param = &quot;replacement&quot;;      goto exit_0;</a>
<a name="ln621">  }</a>
<a name="ln622"> </a>
<a name="ln623">    const Integer arg5 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln624">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end_col&quot;;      goto exit_1;</a>
<a name="ln625">  }</a>
<a name="ln626"> </a>
<a name="ln627">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln628">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end_row&quot;;      goto exit_2;</a>
<a name="ln629">  }</a>
<a name="ln630"> </a>
<a name="ln631">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln632">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start_col&quot;;      goto exit_3;</a>
<a name="ln633">  }</a>
<a name="ln634"> </a>
<a name="ln635">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln636">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start_row&quot;;      goto exit_4;</a>
<a name="ln637">  }</a>
<a name="ln638"> </a>
<a name="ln639">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln640">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_5;</a>
<a name="ln641">  }</a>
<a name="ln642"> </a>
<a name="ln643">  nvim_buf_set_text(LUA_INTERNAL_CALL, arg1, arg2, arg3, arg4, arg5, arg6, &amp;err);</a>
<a name="ln644"> </a>
<a name="ln645">  api_free_buffer(arg1);</a>
<a name="ln646">exit_5:</a>
<a name="ln647">  api_free_integer(arg2);</a>
<a name="ln648">exit_4:</a>
<a name="ln649">  api_free_integer(arg3);</a>
<a name="ln650">exit_3:</a>
<a name="ln651">  api_free_integer(arg4);</a>
<a name="ln652">exit_2:</a>
<a name="ln653">  api_free_integer(arg5);</a>
<a name="ln654">exit_1:</a>
<a name="ln655">  api_free_array(arg6);</a>
<a name="ln656"> </a>
<a name="ln657">exit_0:</a>
<a name="ln658">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln659">    luaL_where(lstate, 1);</a>
<a name="ln660">    if (err_param) {</a>
<a name="ln661">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln662">      lua_pushstring(lstate, err_param);</a>
<a name="ln663">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln664">    }</a>
<a name="ln665">    lua_pushstring(lstate, err.msg);</a>
<a name="ln666">    api_clear_error(&amp;err);</a>
<a name="ln667">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln668">    return lua_error(lstate);</a>
<a name="ln669">  }</a>
<a name="ln670"> </a>
<a name="ln671">  return 0;</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">static int nlua_api_nvim_buf_get_text(lua_State *lstate)</a>
<a name="ln675">{</a>
<a name="ln676">  Error err = ERROR_INIT;</a>
<a name="ln677">  char *err_param = 0;</a>
<a name="ln678">  if (lua_gettop(lstate) != 6) {</a>
<a name="ln679">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 6 arguments&quot;);</a>
<a name="ln680">    goto exit_0;</a>
<a name="ln681">  }</a>
<a name="ln682">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln683">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_text&quot;);</a>
<a name="ln684">  }</a>
<a name="ln685">    const Dictionary arg6 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln686">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln687">  }</a>
<a name="ln688"> </a>
<a name="ln689">    const Integer arg5 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln690">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end_col&quot;;      goto exit_1;</a>
<a name="ln691">  }</a>
<a name="ln692"> </a>
<a name="ln693">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln694">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end_row&quot;;      goto exit_2;</a>
<a name="ln695">  }</a>
<a name="ln696"> </a>
<a name="ln697">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln698">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start_col&quot;;      goto exit_3;</a>
<a name="ln699">  }</a>
<a name="ln700"> </a>
<a name="ln701">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln702">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start_row&quot;;      goto exit_4;</a>
<a name="ln703">  }</a>
<a name="ln704"> </a>
<a name="ln705">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln706">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_5;</a>
<a name="ln707">  }</a>
<a name="ln708"> </a>
<a name="ln709">  const ArrayOf(String) ret = nvim_buf_get_text(LUA_INTERNAL_CALL, arg1, arg2, arg3, arg4, arg5, arg6, lstate, &amp;err);</a>
<a name="ln710">  if (lua_gettop(lstate) == 0) {</a>
<a name="ln711">    nlua_push_Array(lstate, ret, true);</a>
<a name="ln712">  }</a>
<a name="ln713">api_free_array(ret);</a>
<a name="ln714"> </a>
<a name="ln715">  api_free_buffer(arg1);</a>
<a name="ln716">exit_5:</a>
<a name="ln717">  api_free_integer(arg2);</a>
<a name="ln718">exit_4:</a>
<a name="ln719">  api_free_integer(arg3);</a>
<a name="ln720">exit_3:</a>
<a name="ln721">  api_free_integer(arg4);</a>
<a name="ln722">exit_2:</a>
<a name="ln723">  api_free_integer(arg5);</a>
<a name="ln724">exit_1:</a>
<a name="ln725">  api_free_dictionary(arg6);</a>
<a name="ln726"> </a>
<a name="ln727">exit_0:</a>
<a name="ln728">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln729">    luaL_where(lstate, 1);</a>
<a name="ln730">    if (err_param) {</a>
<a name="ln731">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln732">      lua_pushstring(lstate, err_param);</a>
<a name="ln733">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln734">    }</a>
<a name="ln735">    lua_pushstring(lstate, err.msg);</a>
<a name="ln736">    api_clear_error(&amp;err);</a>
<a name="ln737">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln738">    return lua_error(lstate);</a>
<a name="ln739">  }</a>
<a name="ln740"> </a>
<a name="ln741">  return 1;</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">static int nlua_api_nvim_buf_get_offset(lua_State *lstate)</a>
<a name="ln745">{</a>
<a name="ln746">  Error err = ERROR_INIT;</a>
<a name="ln747">  char *err_param = 0;</a>
<a name="ln748">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln749">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln750">    goto exit_0;</a>
<a name="ln751">  }</a>
<a name="ln752">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln753">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_offset&quot;);</a>
<a name="ln754">  }</a>
<a name="ln755">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln756">  if (ERROR_SET(&amp;err)) {      err_param = &quot;index&quot;;      goto exit_0;</a>
<a name="ln757">  }</a>
<a name="ln758"> </a>
<a name="ln759">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln760">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln761">  }</a>
<a name="ln762"> </a>
<a name="ln763">  const Integer ret = nvim_buf_get_offset(arg1, arg2, &amp;err);</a>
<a name="ln764">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln765">api_free_integer(ret);</a>
<a name="ln766"> </a>
<a name="ln767">  api_free_buffer(arg1);</a>
<a name="ln768">exit_1:</a>
<a name="ln769">  api_free_integer(arg2);</a>
<a name="ln770"> </a>
<a name="ln771">exit_0:</a>
<a name="ln772">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln773">    luaL_where(lstate, 1);</a>
<a name="ln774">    if (err_param) {</a>
<a name="ln775">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln776">      lua_pushstring(lstate, err_param);</a>
<a name="ln777">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln778">    }</a>
<a name="ln779">    lua_pushstring(lstate, err.msg);</a>
<a name="ln780">    api_clear_error(&amp;err);</a>
<a name="ln781">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln782">    return lua_error(lstate);</a>
<a name="ln783">  }</a>
<a name="ln784"> </a>
<a name="ln785">  return 1;</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788">static int nlua_api_nvim_buf_get_var(lua_State *lstate)</a>
<a name="ln789">{</a>
<a name="ln790">  Error err = ERROR_INIT;</a>
<a name="ln791">  char *err_param = 0;</a>
<a name="ln792">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln793">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln794">    goto exit_0;</a>
<a name="ln795">  }</a>
<a name="ln796">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln797">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_var&quot;);</a>
<a name="ln798">  }</a>
<a name="ln799">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln800">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln801">  }</a>
<a name="ln802"> </a>
<a name="ln803">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln804">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln805">  }</a>
<a name="ln806"> </a>
<a name="ln807">  const Object ret = nvim_buf_get_var(arg1, arg2, &amp;err);</a>
<a name="ln808">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln809">api_free_object(ret);</a>
<a name="ln810"> </a>
<a name="ln811">  api_free_buffer(arg1);</a>
<a name="ln812">exit_1:</a>
<a name="ln813">  api_free_string(arg2);</a>
<a name="ln814"> </a>
<a name="ln815">exit_0:</a>
<a name="ln816">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln817">    luaL_where(lstate, 1);</a>
<a name="ln818">    if (err_param) {</a>
<a name="ln819">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln820">      lua_pushstring(lstate, err_param);</a>
<a name="ln821">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln822">    }</a>
<a name="ln823">    lua_pushstring(lstate, err.msg);</a>
<a name="ln824">    api_clear_error(&amp;err);</a>
<a name="ln825">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln826">    return lua_error(lstate);</a>
<a name="ln827">  }</a>
<a name="ln828"> </a>
<a name="ln829">  return 1;</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">static int nlua_api_nvim_buf_get_changedtick(lua_State *lstate)</a>
<a name="ln833">{</a>
<a name="ln834">  Error err = ERROR_INIT;</a>
<a name="ln835">  char *err_param = 0;</a>
<a name="ln836">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln837">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln838">    goto exit_0;</a>
<a name="ln839">  }</a>
<a name="ln840">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln841">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_changedtick&quot;);</a>
<a name="ln842">  }</a>
<a name="ln843">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln844">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln845">  }</a>
<a name="ln846"> </a>
<a name="ln847">  const Integer ret = nvim_buf_get_changedtick(arg1, &amp;err);</a>
<a name="ln848">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln849">api_free_integer(ret);</a>
<a name="ln850"> </a>
<a name="ln851">  api_free_buffer(arg1);</a>
<a name="ln852"> </a>
<a name="ln853">exit_0:</a>
<a name="ln854">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln855">    luaL_where(lstate, 1);</a>
<a name="ln856">    if (err_param) {</a>
<a name="ln857">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln858">      lua_pushstring(lstate, err_param);</a>
<a name="ln859">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln860">    }</a>
<a name="ln861">    lua_pushstring(lstate, err.msg);</a>
<a name="ln862">    api_clear_error(&amp;err);</a>
<a name="ln863">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln864">    return lua_error(lstate);</a>
<a name="ln865">  }</a>
<a name="ln866"> </a>
<a name="ln867">  return 1;</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">static int nlua_api_nvim_buf_get_keymap(lua_State *lstate)</a>
<a name="ln871">{</a>
<a name="ln872">  Error err = ERROR_INIT;</a>
<a name="ln873">  char *err_param = 0;</a>
<a name="ln874">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln875">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln876">    goto exit_0;</a>
<a name="ln877">  }</a>
<a name="ln878">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln879">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_keymap&quot;);</a>
<a name="ln880">  }</a>
<a name="ln881">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln882">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_0;</a>
<a name="ln883">  }</a>
<a name="ln884"> </a>
<a name="ln885">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln886">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln887">  }</a>
<a name="ln888"> </a>
<a name="ln889">  const ArrayOf(Dictionary) ret = nvim_buf_get_keymap(arg1, arg2, &amp;err);</a>
<a name="ln890">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln891">api_free_array(ret);</a>
<a name="ln892"> </a>
<a name="ln893">  api_free_buffer(arg1);</a>
<a name="ln894">exit_1:</a>
<a name="ln895">  api_free_string(arg2);</a>
<a name="ln896"> </a>
<a name="ln897">exit_0:</a>
<a name="ln898">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln899">    luaL_where(lstate, 1);</a>
<a name="ln900">    if (err_param) {</a>
<a name="ln901">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln902">      lua_pushstring(lstate, err_param);</a>
<a name="ln903">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln904">    }</a>
<a name="ln905">    lua_pushstring(lstate, err.msg);</a>
<a name="ln906">    api_clear_error(&amp;err);</a>
<a name="ln907">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln908">    return lua_error(lstate);</a>
<a name="ln909">  }</a>
<a name="ln910"> </a>
<a name="ln911">  return 1;</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914">static int nlua_api_nvim_buf_set_keymap(lua_State *lstate)</a>
<a name="ln915">{</a>
<a name="ln916">  Error err = ERROR_INIT;</a>
<a name="ln917">  char *err_param = 0;</a>
<a name="ln918">  if (lua_gettop(lstate) != 5) {</a>
<a name="ln919">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 5 arguments&quot;);</a>
<a name="ln920">    goto exit_0;</a>
<a name="ln921">  }</a>
<a name="ln922">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln923">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_keymap&quot;);</a>
<a name="ln924">  }</a>
<a name="ln925">    KeyDict_keymap arg5 = { 0 }; nlua_pop_keydict(lstate, &amp;arg5, KeyDict_keymap_get_field, &amp;err_param, &amp;err);</a>
<a name="ln926">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln927">  }</a>
<a name="ln928"> </a>
<a name="ln929">    const String arg4 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln930">  if (ERROR_SET(&amp;err)) {      err_param = &quot;rhs&quot;;      goto exit_1;</a>
<a name="ln931">  }</a>
<a name="ln932"> </a>
<a name="ln933">    const String arg3 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln934">  if (ERROR_SET(&amp;err)) {      err_param = &quot;lhs&quot;;      goto exit_2;</a>
<a name="ln935">  }</a>
<a name="ln936"> </a>
<a name="ln937">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln938">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_3;</a>
<a name="ln939">  }</a>
<a name="ln940"> </a>
<a name="ln941">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln942">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_4;</a>
<a name="ln943">  }</a>
<a name="ln944"> </a>
<a name="ln945">  nvim_buf_set_keymap(LUA_INTERNAL_CALL, arg1, arg2, arg3, arg4, &amp;arg5, &amp;err);</a>
<a name="ln946"> </a>
<a name="ln947">  api_free_buffer(arg1);</a>
<a name="ln948">exit_4:</a>
<a name="ln949">  api_free_string(arg2);</a>
<a name="ln950">exit_3:</a>
<a name="ln951">  api_free_string(arg3);</a>
<a name="ln952">exit_2:</a>
<a name="ln953">  api_free_string(arg4);</a>
<a name="ln954">exit_1:</a>
<a name="ln955">  api_free_keydict_keymap(&amp;arg5);</a>
<a name="ln956"> </a>
<a name="ln957">exit_0:</a>
<a name="ln958">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln959">    luaL_where(lstate, 1);</a>
<a name="ln960">    if (err_param) {</a>
<a name="ln961">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln962">      lua_pushstring(lstate, err_param);</a>
<a name="ln963">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln964">    }</a>
<a name="ln965">    lua_pushstring(lstate, err.msg);</a>
<a name="ln966">    api_clear_error(&amp;err);</a>
<a name="ln967">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln968">    return lua_error(lstate);</a>
<a name="ln969">  }</a>
<a name="ln970"> </a>
<a name="ln971">  return 0;</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974">static int nlua_api_nvim_buf_del_keymap(lua_State *lstate)</a>
<a name="ln975">{</a>
<a name="ln976">  Error err = ERROR_INIT;</a>
<a name="ln977">  char *err_param = 0;</a>
<a name="ln978">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln979">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln980">    goto exit_0;</a>
<a name="ln981">  }</a>
<a name="ln982">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln983">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_del_keymap&quot;);</a>
<a name="ln984">  }</a>
<a name="ln985">    const String arg3 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln986">  if (ERROR_SET(&amp;err)) {      err_param = &quot;lhs&quot;;      goto exit_0;</a>
<a name="ln987">  }</a>
<a name="ln988"> </a>
<a name="ln989">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln990">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_1;</a>
<a name="ln991">  }</a>
<a name="ln992"> </a>
<a name="ln993">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln994">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln995">  }</a>
<a name="ln996"> </a>
<a name="ln997">  nvim_buf_del_keymap(LUA_INTERNAL_CALL, arg1, arg2, arg3, &amp;err);</a>
<a name="ln998"> </a>
<a name="ln999">  api_free_buffer(arg1);</a>
<a name="ln1000">exit_2:</a>
<a name="ln1001">  api_free_string(arg2);</a>
<a name="ln1002">exit_1:</a>
<a name="ln1003">  api_free_string(arg3);</a>
<a name="ln1004"> </a>
<a name="ln1005">exit_0:</a>
<a name="ln1006">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1007">    luaL_where(lstate, 1);</a>
<a name="ln1008">    if (err_param) {</a>
<a name="ln1009">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1010">      lua_pushstring(lstate, err_param);</a>
<a name="ln1011">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1012">    }</a>
<a name="ln1013">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1014">    api_clear_error(&amp;err);</a>
<a name="ln1015">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1016">    return lua_error(lstate);</a>
<a name="ln1017">  }</a>
<a name="ln1018"> </a>
<a name="ln1019">  return 0;</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022">static int nlua_api_nvim_buf_set_var(lua_State *lstate)</a>
<a name="ln1023">{</a>
<a name="ln1024">  Error err = ERROR_INIT;</a>
<a name="ln1025">  char *err_param = 0;</a>
<a name="ln1026">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln1027">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln1028">    goto exit_0;</a>
<a name="ln1029">  }</a>
<a name="ln1030">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1031">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_var&quot;);</a>
<a name="ln1032">  }</a>
<a name="ln1033">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln1034">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln1035">  }</a>
<a name="ln1036"> </a>
<a name="ln1037">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1038">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln1039">  }</a>
<a name="ln1040"> </a>
<a name="ln1041">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1042">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln1043">  }</a>
<a name="ln1044"> </a>
<a name="ln1045">  nvim_buf_set_var(arg1, arg2, arg3, &amp;err);</a>
<a name="ln1046"> </a>
<a name="ln1047">  api_free_buffer(arg1);</a>
<a name="ln1048">exit_2:</a>
<a name="ln1049">  api_free_string(arg2);</a>
<a name="ln1050">exit_1:</a>
<a name="ln1051">  api_free_object(arg3);</a>
<a name="ln1052"> </a>
<a name="ln1053">exit_0:</a>
<a name="ln1054">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1055">    luaL_where(lstate, 1);</a>
<a name="ln1056">    if (err_param) {</a>
<a name="ln1057">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1058">      lua_pushstring(lstate, err_param);</a>
<a name="ln1059">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1060">    }</a>
<a name="ln1061">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1062">    api_clear_error(&amp;err);</a>
<a name="ln1063">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1064">    return lua_error(lstate);</a>
<a name="ln1065">  }</a>
<a name="ln1066"> </a>
<a name="ln1067">  return 0;</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">static int nlua_api_nvim_buf_del_var(lua_State *lstate)</a>
<a name="ln1071">{</a>
<a name="ln1072">  Error err = ERROR_INIT;</a>
<a name="ln1073">  char *err_param = 0;</a>
<a name="ln1074">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1075">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1076">    goto exit_0;</a>
<a name="ln1077">  }</a>
<a name="ln1078">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1079">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_del_var&quot;);</a>
<a name="ln1080">  }</a>
<a name="ln1081">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1082">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln1083">  }</a>
<a name="ln1084"> </a>
<a name="ln1085">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1086">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1087">  }</a>
<a name="ln1088"> </a>
<a name="ln1089">  nvim_buf_del_var(arg1, arg2, &amp;err);</a>
<a name="ln1090"> </a>
<a name="ln1091">  api_free_buffer(arg1);</a>
<a name="ln1092">exit_1:</a>
<a name="ln1093">  api_free_string(arg2);</a>
<a name="ln1094"> </a>
<a name="ln1095">exit_0:</a>
<a name="ln1096">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1097">    luaL_where(lstate, 1);</a>
<a name="ln1098">    if (err_param) {</a>
<a name="ln1099">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1100">      lua_pushstring(lstate, err_param);</a>
<a name="ln1101">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1102">    }</a>
<a name="ln1103">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1104">    api_clear_error(&amp;err);</a>
<a name="ln1105">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1106">    return lua_error(lstate);</a>
<a name="ln1107">  }</a>
<a name="ln1108"> </a>
<a name="ln1109">  return 0;</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112">static int nlua_api_nvim_buf_get_name(lua_State *lstate)</a>
<a name="ln1113">{</a>
<a name="ln1114">  Error err = ERROR_INIT;</a>
<a name="ln1115">  char *err_param = 0;</a>
<a name="ln1116">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1117">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1118">    goto exit_0;</a>
<a name="ln1119">  }</a>
<a name="ln1120">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1121">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_name&quot;);</a>
<a name="ln1122">  }</a>
<a name="ln1123">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1124">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln1125">  }</a>
<a name="ln1126"> </a>
<a name="ln1127">  Arena arena = ARENA_EMPTY;</a>
<a name="ln1128">  const String ret = nvim_buf_get_name(arg1, &amp;arena, &amp;err);</a>
<a name="ln1129">  nlua_push_String(lstate, ret, true);</a>
<a name="ln1130">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln1131"> </a>
<a name="ln1132">  api_free_buffer(arg1);</a>
<a name="ln1133"> </a>
<a name="ln1134">exit_0:</a>
<a name="ln1135">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1136">    luaL_where(lstate, 1);</a>
<a name="ln1137">    if (err_param) {</a>
<a name="ln1138">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1139">      lua_pushstring(lstate, err_param);</a>
<a name="ln1140">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1141">    }</a>
<a name="ln1142">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1143">    api_clear_error(&amp;err);</a>
<a name="ln1144">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1145">    return lua_error(lstate);</a>
<a name="ln1146">  }</a>
<a name="ln1147"> </a>
<a name="ln1148">  return 1;</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151">static int nlua_api_nvim_buf_set_name(lua_State *lstate)</a>
<a name="ln1152">{</a>
<a name="ln1153">  Error err = ERROR_INIT;</a>
<a name="ln1154">  char *err_param = 0;</a>
<a name="ln1155">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1156">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1157">    goto exit_0;</a>
<a name="ln1158">  }</a>
<a name="ln1159">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1160">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_name&quot;);</a>
<a name="ln1161">  }</a>
<a name="ln1162">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1163">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln1164">  }</a>
<a name="ln1165"> </a>
<a name="ln1166">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1167">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1168">  }</a>
<a name="ln1169"> </a>
<a name="ln1170">  nvim_buf_set_name(arg1, arg2, &amp;err);</a>
<a name="ln1171"> </a>
<a name="ln1172">  api_free_buffer(arg1);</a>
<a name="ln1173">exit_1:</a>
<a name="ln1174">  api_free_string(arg2);</a>
<a name="ln1175"> </a>
<a name="ln1176">exit_0:</a>
<a name="ln1177">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1178">    luaL_where(lstate, 1);</a>
<a name="ln1179">    if (err_param) {</a>
<a name="ln1180">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1181">      lua_pushstring(lstate, err_param);</a>
<a name="ln1182">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1183">    }</a>
<a name="ln1184">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1185">    api_clear_error(&amp;err);</a>
<a name="ln1186">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1187">    return lua_error(lstate);</a>
<a name="ln1188">  }</a>
<a name="ln1189"> </a>
<a name="ln1190">  return 0;</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193">static int nlua_api_nvim_buf_is_loaded(lua_State *lstate)</a>
<a name="ln1194">{</a>
<a name="ln1195">  Error err = ERROR_INIT;</a>
<a name="ln1196">  char *err_param = 0;</a>
<a name="ln1197">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1198">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1199">    goto exit_0;</a>
<a name="ln1200">  }</a>
<a name="ln1201">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1202">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_is_loaded&quot;);</a>
<a name="ln1203">  }</a>
<a name="ln1204">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1205">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln1206">  }</a>
<a name="ln1207"> </a>
<a name="ln1208">  const Boolean ret = nvim_buf_is_loaded(arg1);</a>
<a name="ln1209">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln1210">api_free_boolean(ret);</a>
<a name="ln1211"> </a>
<a name="ln1212">  api_free_buffer(arg1);</a>
<a name="ln1213"> </a>
<a name="ln1214">exit_0:</a>
<a name="ln1215">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1216">    luaL_where(lstate, 1);</a>
<a name="ln1217">    if (err_param) {</a>
<a name="ln1218">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1219">      lua_pushstring(lstate, err_param);</a>
<a name="ln1220">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1221">    }</a>
<a name="ln1222">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1223">    api_clear_error(&amp;err);</a>
<a name="ln1224">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1225">    return lua_error(lstate);</a>
<a name="ln1226">  }</a>
<a name="ln1227"> </a>
<a name="ln1228">  return 1;</a>
<a name="ln1229">}</a>
<a name="ln1230"> </a>
<a name="ln1231">static int nlua_api_nvim_buf_delete(lua_State *lstate)</a>
<a name="ln1232">{</a>
<a name="ln1233">  Error err = ERROR_INIT;</a>
<a name="ln1234">  char *err_param = 0;</a>
<a name="ln1235">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1236">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1237">    goto exit_0;</a>
<a name="ln1238">  }</a>
<a name="ln1239">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1240">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_delete&quot;);</a>
<a name="ln1241">  }</a>
<a name="ln1242">  if (text_locked()) {</a>
<a name="ln1243">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, get_text_locked_msg());</a>
<a name="ln1244">    goto exit_0;</a>
<a name="ln1245">  }</a>
<a name="ln1246">    const Dictionary arg2 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln1247">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln1248">  }</a>
<a name="ln1249"> </a>
<a name="ln1250">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1251">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1252">  }</a>
<a name="ln1253"> </a>
<a name="ln1254">  nvim_buf_delete(arg1, arg2, &amp;err);</a>
<a name="ln1255"> </a>
<a name="ln1256">  api_free_buffer(arg1);</a>
<a name="ln1257">exit_1:</a>
<a name="ln1258">  api_free_dictionary(arg2);</a>
<a name="ln1259"> </a>
<a name="ln1260">exit_0:</a>
<a name="ln1261">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1262">    luaL_where(lstate, 1);</a>
<a name="ln1263">    if (err_param) {</a>
<a name="ln1264">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1265">      lua_pushstring(lstate, err_param);</a>
<a name="ln1266">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1267">    }</a>
<a name="ln1268">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1269">    api_clear_error(&amp;err);</a>
<a name="ln1270">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1271">    return lua_error(lstate);</a>
<a name="ln1272">  }</a>
<a name="ln1273"> </a>
<a name="ln1274">  return 0;</a>
<a name="ln1275">}</a>
<a name="ln1276"> </a>
<a name="ln1277">static int nlua_api_nvim_buf_is_valid(lua_State *lstate)</a>
<a name="ln1278">{</a>
<a name="ln1279">  Error err = ERROR_INIT;</a>
<a name="ln1280">  char *err_param = 0;</a>
<a name="ln1281">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1282">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1283">    goto exit_0;</a>
<a name="ln1284">  }</a>
<a name="ln1285">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1286">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_is_valid&quot;);</a>
<a name="ln1287">  }</a>
<a name="ln1288">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1289">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln1290">  }</a>
<a name="ln1291"> </a>
<a name="ln1292">  const Boolean ret = nvim_buf_is_valid(arg1);</a>
<a name="ln1293">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln1294">api_free_boolean(ret);</a>
<a name="ln1295"> </a>
<a name="ln1296">  api_free_buffer(arg1);</a>
<a name="ln1297"> </a>
<a name="ln1298">exit_0:</a>
<a name="ln1299">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1300">    luaL_where(lstate, 1);</a>
<a name="ln1301">    if (err_param) {</a>
<a name="ln1302">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1303">      lua_pushstring(lstate, err_param);</a>
<a name="ln1304">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1305">    }</a>
<a name="ln1306">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1307">    api_clear_error(&amp;err);</a>
<a name="ln1308">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1309">    return lua_error(lstate);</a>
<a name="ln1310">  }</a>
<a name="ln1311"> </a>
<a name="ln1312">  return 1;</a>
<a name="ln1313">}</a>
<a name="ln1314"> </a>
<a name="ln1315">static int nlua_api_nvim_buf_del_mark(lua_State *lstate)</a>
<a name="ln1316">{</a>
<a name="ln1317">  Error err = ERROR_INIT;</a>
<a name="ln1318">  char *err_param = 0;</a>
<a name="ln1319">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1320">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1321">    goto exit_0;</a>
<a name="ln1322">  }</a>
<a name="ln1323">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1324">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_del_mark&quot;);</a>
<a name="ln1325">  }</a>
<a name="ln1326">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1327">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln1328">  }</a>
<a name="ln1329"> </a>
<a name="ln1330">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1331">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1332">  }</a>
<a name="ln1333"> </a>
<a name="ln1334">  const Boolean ret = nvim_buf_del_mark(arg1, arg2, &amp;err);</a>
<a name="ln1335">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln1336">api_free_boolean(ret);</a>
<a name="ln1337"> </a>
<a name="ln1338">  api_free_buffer(arg1);</a>
<a name="ln1339">exit_1:</a>
<a name="ln1340">  api_free_string(arg2);</a>
<a name="ln1341"> </a>
<a name="ln1342">exit_0:</a>
<a name="ln1343">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1344">    luaL_where(lstate, 1);</a>
<a name="ln1345">    if (err_param) {</a>
<a name="ln1346">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1347">      lua_pushstring(lstate, err_param);</a>
<a name="ln1348">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1349">    }</a>
<a name="ln1350">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1351">    api_clear_error(&amp;err);</a>
<a name="ln1352">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1353">    return lua_error(lstate);</a>
<a name="ln1354">  }</a>
<a name="ln1355"> </a>
<a name="ln1356">  return 1;</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>
<a name="ln1359">static int nlua_api_nvim_buf_set_mark(lua_State *lstate)</a>
<a name="ln1360">{</a>
<a name="ln1361">  Error err = ERROR_INIT;</a>
<a name="ln1362">  char *err_param = 0;</a>
<a name="ln1363">  if (lua_gettop(lstate) != 5) {</a>
<a name="ln1364">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 5 arguments&quot;);</a>
<a name="ln1365">    goto exit_0;</a>
<a name="ln1366">  }</a>
<a name="ln1367">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1368">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_mark&quot;);</a>
<a name="ln1369">  }</a>
<a name="ln1370">    const Dictionary arg5 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln1371">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln1372">  }</a>
<a name="ln1373"> </a>
<a name="ln1374">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln1375">  if (ERROR_SET(&amp;err)) {      err_param = &quot;col&quot;;      goto exit_1;</a>
<a name="ln1376">  }</a>
<a name="ln1377"> </a>
<a name="ln1378">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln1379">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line&quot;;      goto exit_2;</a>
<a name="ln1380">  }</a>
<a name="ln1381"> </a>
<a name="ln1382">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1383">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_3;</a>
<a name="ln1384">  }</a>
<a name="ln1385"> </a>
<a name="ln1386">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1387">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_4;</a>
<a name="ln1388">  }</a>
<a name="ln1389"> </a>
<a name="ln1390">  const Boolean ret = nvim_buf_set_mark(arg1, arg2, arg3, arg4, arg5, &amp;err);</a>
<a name="ln1391">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln1392">api_free_boolean(ret);</a>
<a name="ln1393"> </a>
<a name="ln1394">  api_free_buffer(arg1);</a>
<a name="ln1395">exit_4:</a>
<a name="ln1396">  api_free_string(arg2);</a>
<a name="ln1397">exit_3:</a>
<a name="ln1398">  api_free_integer(arg3);</a>
<a name="ln1399">exit_2:</a>
<a name="ln1400">  api_free_integer(arg4);</a>
<a name="ln1401">exit_1:</a>
<a name="ln1402">  api_free_dictionary(arg5);</a>
<a name="ln1403"> </a>
<a name="ln1404">exit_0:</a>
<a name="ln1405">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1406">    luaL_where(lstate, 1);</a>
<a name="ln1407">    if (err_param) {</a>
<a name="ln1408">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1409">      lua_pushstring(lstate, err_param);</a>
<a name="ln1410">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1411">    }</a>
<a name="ln1412">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1413">    api_clear_error(&amp;err);</a>
<a name="ln1414">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1415">    return lua_error(lstate);</a>
<a name="ln1416">  }</a>
<a name="ln1417"> </a>
<a name="ln1418">  return 1;</a>
<a name="ln1419">}</a>
<a name="ln1420"> </a>
<a name="ln1421">static int nlua_api_nvim_buf_get_mark(lua_State *lstate)</a>
<a name="ln1422">{</a>
<a name="ln1423">  Error err = ERROR_INIT;</a>
<a name="ln1424">  char *err_param = 0;</a>
<a name="ln1425">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1426">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1427">    goto exit_0;</a>
<a name="ln1428">  }</a>
<a name="ln1429">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1430">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_mark&quot;);</a>
<a name="ln1431">  }</a>
<a name="ln1432">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1433">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln1434">  }</a>
<a name="ln1435"> </a>
<a name="ln1436">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1437">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1438">  }</a>
<a name="ln1439"> </a>
<a name="ln1440">  const ArrayOf(Integer, 2) ret = nvim_buf_get_mark(arg1, arg2, &amp;err);</a>
<a name="ln1441">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln1442">api_free_array(ret);</a>
<a name="ln1443"> </a>
<a name="ln1444">  api_free_buffer(arg1);</a>
<a name="ln1445">exit_1:</a>
<a name="ln1446">  api_free_string(arg2);</a>
<a name="ln1447"> </a>
<a name="ln1448">exit_0:</a>
<a name="ln1449">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1450">    luaL_where(lstate, 1);</a>
<a name="ln1451">    if (err_param) {</a>
<a name="ln1452">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1453">      lua_pushstring(lstate, err_param);</a>
<a name="ln1454">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1455">    }</a>
<a name="ln1456">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1457">    api_clear_error(&amp;err);</a>
<a name="ln1458">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1459">    return lua_error(lstate);</a>
<a name="ln1460">  }</a>
<a name="ln1461"> </a>
<a name="ln1462">  return 1;</a>
<a name="ln1463">}</a>
<a name="ln1464"> </a>
<a name="ln1465">static int nlua_api_nvim_buf_call(lua_State *lstate)</a>
<a name="ln1466">{</a>
<a name="ln1467">  Error err = ERROR_INIT;</a>
<a name="ln1468">  char *err_param = 0;</a>
<a name="ln1469">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1470">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1471">    goto exit_0;</a>
<a name="ln1472">  }</a>
<a name="ln1473">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1474">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_call&quot;);</a>
<a name="ln1475">  }</a>
<a name="ln1476">    const LuaRef arg2 = nlua_pop_LuaRef(lstate, &amp;err);</a>
<a name="ln1477">  if (ERROR_SET(&amp;err)) {      err_param = &quot;fun&quot;;      goto exit_0;</a>
<a name="ln1478">  }</a>
<a name="ln1479"> </a>
<a name="ln1480">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1481">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1482">  }</a>
<a name="ln1483"> </a>
<a name="ln1484">  const Object ret = nvim_buf_call(arg1, arg2, &amp;err);</a>
<a name="ln1485">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln1486">api_free_object(ret);</a>
<a name="ln1487"> </a>
<a name="ln1488">  api_free_buffer(arg1);</a>
<a name="ln1489">exit_1:</a>
<a name="ln1490">  api_free_luaref(arg2);</a>
<a name="ln1491"> </a>
<a name="ln1492">exit_0:</a>
<a name="ln1493">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1494">    luaL_where(lstate, 1);</a>
<a name="ln1495">    if (err_param) {</a>
<a name="ln1496">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1497">      lua_pushstring(lstate, err_param);</a>
<a name="ln1498">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1499">    }</a>
<a name="ln1500">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1501">    api_clear_error(&amp;err);</a>
<a name="ln1502">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1503">    return lua_error(lstate);</a>
<a name="ln1504">  }</a>
<a name="ln1505"> </a>
<a name="ln1506">  return 1;</a>
<a name="ln1507">}</a>
<a name="ln1508"> </a>
<a name="ln1509">static int nlua_api_nvim__buf_stats(lua_State *lstate)</a>
<a name="ln1510">{</a>
<a name="ln1511">  Error err = ERROR_INIT;</a>
<a name="ln1512">  char *err_param = 0;</a>
<a name="ln1513">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1514">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1515">    goto exit_0;</a>
<a name="ln1516">  }</a>
<a name="ln1517">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1518">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__buf_stats&quot;);</a>
<a name="ln1519">  }</a>
<a name="ln1520">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1521">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln1522">  }</a>
<a name="ln1523"> </a>
<a name="ln1524">  const Dictionary ret = nvim__buf_stats(arg1, &amp;err);</a>
<a name="ln1525">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln1526">api_free_dictionary(ret);</a>
<a name="ln1527"> </a>
<a name="ln1528">  api_free_buffer(arg1);</a>
<a name="ln1529"> </a>
<a name="ln1530">exit_0:</a>
<a name="ln1531">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1532">    luaL_where(lstate, 1);</a>
<a name="ln1533">    if (err_param) {</a>
<a name="ln1534">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1535">      lua_pushstring(lstate, err_param);</a>
<a name="ln1536">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1537">    }</a>
<a name="ln1538">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1539">    api_clear_error(&amp;err);</a>
<a name="ln1540">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1541">    return lua_error(lstate);</a>
<a name="ln1542">  }</a>
<a name="ln1543"> </a>
<a name="ln1544">  return 1;</a>
<a name="ln1545">}</a>
<a name="ln1546"> </a>
<a name="ln1547">static int nlua_api_nvim_parse_cmd(lua_State *lstate)</a>
<a name="ln1548">{</a>
<a name="ln1549">  Error err = ERROR_INIT;</a>
<a name="ln1550">  char *err_param = 0;</a>
<a name="ln1551">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1552">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1553">    goto exit_0;</a>
<a name="ln1554">  }</a>
<a name="ln1555">    const Dictionary arg2 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln1556">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln1557">  }</a>
<a name="ln1558"> </a>
<a name="ln1559">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1560">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_1;</a>
<a name="ln1561">  }</a>
<a name="ln1562"> </a>
<a name="ln1563">  const Dictionary ret = nvim_parse_cmd(arg1, arg2, &amp;err);</a>
<a name="ln1564">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln1565">api_free_dictionary(ret);</a>
<a name="ln1566"> </a>
<a name="ln1567">  api_free_string(arg1);</a>
<a name="ln1568">exit_1:</a>
<a name="ln1569">  api_free_dictionary(arg2);</a>
<a name="ln1570"> </a>
<a name="ln1571">exit_0:</a>
<a name="ln1572">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1573">    luaL_where(lstate, 1);</a>
<a name="ln1574">    if (err_param) {</a>
<a name="ln1575">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1576">      lua_pushstring(lstate, err_param);</a>
<a name="ln1577">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1578">    }</a>
<a name="ln1579">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1580">    api_clear_error(&amp;err);</a>
<a name="ln1581">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1582">    return lua_error(lstate);</a>
<a name="ln1583">  }</a>
<a name="ln1584"> </a>
<a name="ln1585">  return 1;</a>
<a name="ln1586">}</a>
<a name="ln1587"> </a>
<a name="ln1588">static int nlua_api_nvim_cmd(lua_State *lstate)</a>
<a name="ln1589">{</a>
<a name="ln1590">  Error err = ERROR_INIT;</a>
<a name="ln1591">  char *err_param = 0;</a>
<a name="ln1592">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1593">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1594">    goto exit_0;</a>
<a name="ln1595">  }</a>
<a name="ln1596">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1597">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_cmd&quot;);</a>
<a name="ln1598">  }</a>
<a name="ln1599">    KeyDict_cmd_opts arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_cmd_opts_get_field, &amp;err_param, &amp;err);</a>
<a name="ln1600">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln1601">  }</a>
<a name="ln1602"> </a>
<a name="ln1603">    KeyDict_cmd arg1 = { 0 }; nlua_pop_keydict(lstate, &amp;arg1, KeyDict_cmd_get_field, &amp;err_param, &amp;err);</a>
<a name="ln1604">  if (ERROR_SET(&amp;err)) {      goto exit_2;</a>
<a name="ln1605">  }</a>
<a name="ln1606"> </a>
<a name="ln1607">  const String ret = nvim_cmd(LUA_INTERNAL_CALL, &amp;arg1, &amp;arg2, &amp;err);</a>
<a name="ln1608">  nlua_push_String(lstate, ret, true);</a>
<a name="ln1609">api_free_string(ret);</a>
<a name="ln1610"> </a>
<a name="ln1611">exit_2:</a>
<a name="ln1612">  api_free_keydict_cmd(&amp;arg1);</a>
<a name="ln1613">exit_1:</a>
<a name="ln1614">  api_free_keydict_cmd_opts(&amp;arg2);</a>
<a name="ln1615"> </a>
<a name="ln1616">exit_0:</a>
<a name="ln1617">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1618">    luaL_where(lstate, 1);</a>
<a name="ln1619">    if (err_param) {</a>
<a name="ln1620">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1621">      lua_pushstring(lstate, err_param);</a>
<a name="ln1622">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1623">    }</a>
<a name="ln1624">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1625">    api_clear_error(&amp;err);</a>
<a name="ln1626">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1627">    return lua_error(lstate);</a>
<a name="ln1628">  }</a>
<a name="ln1629"> </a>
<a name="ln1630">  return 1;</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">static int nlua_api_nvim_create_user_command(lua_State *lstate)</a>
<a name="ln1634">{</a>
<a name="ln1635">  Error err = ERROR_INIT;</a>
<a name="ln1636">  char *err_param = 0;</a>
<a name="ln1637">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln1638">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln1639">    goto exit_0;</a>
<a name="ln1640">  }</a>
<a name="ln1641">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1642">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_create_user_command&quot;);</a>
<a name="ln1643">  }</a>
<a name="ln1644">    KeyDict_user_command arg3 = { 0 }; nlua_pop_keydict(lstate, &amp;arg3, KeyDict_user_command_get_field, &amp;err_param, &amp;err);</a>
<a name="ln1645">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln1646">  }</a>
<a name="ln1647"> </a>
<a name="ln1648">    const Object arg2 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln1649">  if (ERROR_SET(&amp;err)) {      err_param = &quot;command&quot;;      goto exit_1;</a>
<a name="ln1650">  }</a>
<a name="ln1651"> </a>
<a name="ln1652">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1653">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_2;</a>
<a name="ln1654">  }</a>
<a name="ln1655"> </a>
<a name="ln1656">  nvim_create_user_command(LUA_INTERNAL_CALL, arg1, arg2, &amp;arg3, &amp;err);</a>
<a name="ln1657"> </a>
<a name="ln1658">  api_free_string(arg1);</a>
<a name="ln1659">exit_2:</a>
<a name="ln1660">  api_free_object(arg2);</a>
<a name="ln1661">exit_1:</a>
<a name="ln1662">  api_free_keydict_user_command(&amp;arg3);</a>
<a name="ln1663"> </a>
<a name="ln1664">exit_0:</a>
<a name="ln1665">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1666">    luaL_where(lstate, 1);</a>
<a name="ln1667">    if (err_param) {</a>
<a name="ln1668">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1669">      lua_pushstring(lstate, err_param);</a>
<a name="ln1670">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1671">    }</a>
<a name="ln1672">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1673">    api_clear_error(&amp;err);</a>
<a name="ln1674">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1675">    return lua_error(lstate);</a>
<a name="ln1676">  }</a>
<a name="ln1677"> </a>
<a name="ln1678">  return 0;</a>
<a name="ln1679">}</a>
<a name="ln1680"> </a>
<a name="ln1681">static int nlua_api_nvim_del_user_command(lua_State *lstate)</a>
<a name="ln1682">{</a>
<a name="ln1683">  Error err = ERROR_INIT;</a>
<a name="ln1684">  char *err_param = 0;</a>
<a name="ln1685">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1686">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1687">    goto exit_0;</a>
<a name="ln1688">  }</a>
<a name="ln1689">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1690">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_user_command&quot;);</a>
<a name="ln1691">  }</a>
<a name="ln1692">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1693">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln1694">  }</a>
<a name="ln1695"> </a>
<a name="ln1696">  nvim_del_user_command(arg1, &amp;err);</a>
<a name="ln1697"> </a>
<a name="ln1698">  api_free_string(arg1);</a>
<a name="ln1699"> </a>
<a name="ln1700">exit_0:</a>
<a name="ln1701">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1702">    luaL_where(lstate, 1);</a>
<a name="ln1703">    if (err_param) {</a>
<a name="ln1704">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1705">      lua_pushstring(lstate, err_param);</a>
<a name="ln1706">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1707">    }</a>
<a name="ln1708">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1709">    api_clear_error(&amp;err);</a>
<a name="ln1710">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1711">    return lua_error(lstate);</a>
<a name="ln1712">  }</a>
<a name="ln1713"> </a>
<a name="ln1714">  return 0;</a>
<a name="ln1715">}</a>
<a name="ln1716"> </a>
<a name="ln1717">static int nlua_api_nvim_buf_create_user_command(lua_State *lstate)</a>
<a name="ln1718">{</a>
<a name="ln1719">  Error err = ERROR_INIT;</a>
<a name="ln1720">  char *err_param = 0;</a>
<a name="ln1721">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln1722">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln1723">    goto exit_0;</a>
<a name="ln1724">  }</a>
<a name="ln1725">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1726">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_create_user_command&quot;);</a>
<a name="ln1727">  }</a>
<a name="ln1728">    KeyDict_user_command arg4 = { 0 }; nlua_pop_keydict(lstate, &amp;arg4, KeyDict_user_command_get_field, &amp;err_param, &amp;err);</a>
<a name="ln1729">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln1730">  }</a>
<a name="ln1731"> </a>
<a name="ln1732">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln1733">  if (ERROR_SET(&amp;err)) {      err_param = &quot;command&quot;;      goto exit_1;</a>
<a name="ln1734">  }</a>
<a name="ln1735"> </a>
<a name="ln1736">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1737">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_2;</a>
<a name="ln1738">  }</a>
<a name="ln1739"> </a>
<a name="ln1740">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1741">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_3;</a>
<a name="ln1742">  }</a>
<a name="ln1743"> </a>
<a name="ln1744">  nvim_buf_create_user_command(LUA_INTERNAL_CALL, arg1, arg2, arg3, &amp;arg4, &amp;err);</a>
<a name="ln1745"> </a>
<a name="ln1746">  api_free_buffer(arg1);</a>
<a name="ln1747">exit_3:</a>
<a name="ln1748">  api_free_string(arg2);</a>
<a name="ln1749">exit_2:</a>
<a name="ln1750">  api_free_object(arg3);</a>
<a name="ln1751">exit_1:</a>
<a name="ln1752">  api_free_keydict_user_command(&amp;arg4);</a>
<a name="ln1753"> </a>
<a name="ln1754">exit_0:</a>
<a name="ln1755">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1756">    luaL_where(lstate, 1);</a>
<a name="ln1757">    if (err_param) {</a>
<a name="ln1758">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1759">      lua_pushstring(lstate, err_param);</a>
<a name="ln1760">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1761">    }</a>
<a name="ln1762">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1763">    api_clear_error(&amp;err);</a>
<a name="ln1764">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1765">    return lua_error(lstate);</a>
<a name="ln1766">  }</a>
<a name="ln1767"> </a>
<a name="ln1768">  return 0;</a>
<a name="ln1769">}</a>
<a name="ln1770"> </a>
<a name="ln1771">static int nlua_api_nvim_buf_del_user_command(lua_State *lstate)</a>
<a name="ln1772">{</a>
<a name="ln1773">  Error err = ERROR_INIT;</a>
<a name="ln1774">  char *err_param = 0;</a>
<a name="ln1775">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1776">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1777">    goto exit_0;</a>
<a name="ln1778">  }</a>
<a name="ln1779">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1780">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_del_user_command&quot;);</a>
<a name="ln1781">  }</a>
<a name="ln1782">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1783">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln1784">  }</a>
<a name="ln1785"> </a>
<a name="ln1786">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1787">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1788">  }</a>
<a name="ln1789"> </a>
<a name="ln1790">  nvim_buf_del_user_command(arg1, arg2, &amp;err);</a>
<a name="ln1791"> </a>
<a name="ln1792">  api_free_buffer(arg1);</a>
<a name="ln1793">exit_1:</a>
<a name="ln1794">  api_free_string(arg2);</a>
<a name="ln1795"> </a>
<a name="ln1796">exit_0:</a>
<a name="ln1797">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1798">    luaL_where(lstate, 1);</a>
<a name="ln1799">    if (err_param) {</a>
<a name="ln1800">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1801">      lua_pushstring(lstate, err_param);</a>
<a name="ln1802">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1803">    }</a>
<a name="ln1804">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1805">    api_clear_error(&amp;err);</a>
<a name="ln1806">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1807">    return lua_error(lstate);</a>
<a name="ln1808">  }</a>
<a name="ln1809"> </a>
<a name="ln1810">  return 0;</a>
<a name="ln1811">}</a>
<a name="ln1812"> </a>
<a name="ln1813">static int nlua_api_nvim_get_commands(lua_State *lstate)</a>
<a name="ln1814">{</a>
<a name="ln1815">  Error err = ERROR_INIT;</a>
<a name="ln1816">  char *err_param = 0;</a>
<a name="ln1817">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1818">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1819">    goto exit_0;</a>
<a name="ln1820">  }</a>
<a name="ln1821">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1822">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_commands&quot;);</a>
<a name="ln1823">  }</a>
<a name="ln1824">    KeyDict_get_commands arg1 = { 0 }; nlua_pop_keydict(lstate, &amp;arg1, KeyDict_get_commands_get_field, &amp;err_param, &amp;err);</a>
<a name="ln1825">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln1826">  }</a>
<a name="ln1827"> </a>
<a name="ln1828">  const Dictionary ret = nvim_get_commands(&amp;arg1, &amp;err);</a>
<a name="ln1829">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln1830">api_free_dictionary(ret);</a>
<a name="ln1831"> </a>
<a name="ln1832">exit_1:</a>
<a name="ln1833">  api_free_keydict_get_commands(&amp;arg1);</a>
<a name="ln1834"> </a>
<a name="ln1835">exit_0:</a>
<a name="ln1836">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1837">    luaL_where(lstate, 1);</a>
<a name="ln1838">    if (err_param) {</a>
<a name="ln1839">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1840">      lua_pushstring(lstate, err_param);</a>
<a name="ln1841">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1842">    }</a>
<a name="ln1843">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1844">    api_clear_error(&amp;err);</a>
<a name="ln1845">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1846">    return lua_error(lstate);</a>
<a name="ln1847">  }</a>
<a name="ln1848"> </a>
<a name="ln1849">  return 1;</a>
<a name="ln1850">}</a>
<a name="ln1851"> </a>
<a name="ln1852">static int nlua_api_nvim_buf_get_commands(lua_State *lstate)</a>
<a name="ln1853">{</a>
<a name="ln1854">  Error err = ERROR_INIT;</a>
<a name="ln1855">  char *err_param = 0;</a>
<a name="ln1856">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1857">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1858">    goto exit_0;</a>
<a name="ln1859">  }</a>
<a name="ln1860">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1861">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_commands&quot;);</a>
<a name="ln1862">  }</a>
<a name="ln1863">    KeyDict_get_commands arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_get_commands_get_field, &amp;err_param, &amp;err);</a>
<a name="ln1864">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln1865">  }</a>
<a name="ln1866"> </a>
<a name="ln1867">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1868">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1869">  }</a>
<a name="ln1870"> </a>
<a name="ln1871">  const Dictionary ret = nvim_buf_get_commands(arg1, &amp;arg2, &amp;err);</a>
<a name="ln1872">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln1873">api_free_dictionary(ret);</a>
<a name="ln1874"> </a>
<a name="ln1875">  api_free_buffer(arg1);</a>
<a name="ln1876">exit_1:</a>
<a name="ln1877">  api_free_keydict_get_commands(&amp;arg2);</a>
<a name="ln1878"> </a>
<a name="ln1879">exit_0:</a>
<a name="ln1880">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1881">    luaL_where(lstate, 1);</a>
<a name="ln1882">    if (err_param) {</a>
<a name="ln1883">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1884">      lua_pushstring(lstate, err_param);</a>
<a name="ln1885">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1886">    }</a>
<a name="ln1887">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1888">    api_clear_error(&amp;err);</a>
<a name="ln1889">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1890">    return lua_error(lstate);</a>
<a name="ln1891">  }</a>
<a name="ln1892"> </a>
<a name="ln1893">  return 1;</a>
<a name="ln1894">}</a>
<a name="ln1895"> </a>
<a name="ln1896">static int nlua_api_nvim_exec(lua_State *lstate)</a>
<a name="ln1897">{</a>
<a name="ln1898">  Error err = ERROR_INIT;</a>
<a name="ln1899">  char *err_param = 0;</a>
<a name="ln1900">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1901">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1902">    goto exit_0;</a>
<a name="ln1903">  }</a>
<a name="ln1904">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1905">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_exec&quot;);</a>
<a name="ln1906">  }</a>
<a name="ln1907">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln1908">  if (ERROR_SET(&amp;err)) {      err_param = &quot;output&quot;;      goto exit_0;</a>
<a name="ln1909">  }</a>
<a name="ln1910"> </a>
<a name="ln1911">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1912">  if (ERROR_SET(&amp;err)) {      err_param = &quot;src&quot;;      goto exit_1;</a>
<a name="ln1913">  }</a>
<a name="ln1914"> </a>
<a name="ln1915">  const String ret = nvim_exec(LUA_INTERNAL_CALL, arg1, arg2, &amp;err);</a>
<a name="ln1916">  nlua_push_String(lstate, ret, true);</a>
<a name="ln1917">api_free_string(ret);</a>
<a name="ln1918"> </a>
<a name="ln1919">  api_free_string(arg1);</a>
<a name="ln1920">exit_1:</a>
<a name="ln1921">  api_free_boolean(arg2);</a>
<a name="ln1922"> </a>
<a name="ln1923">exit_0:</a>
<a name="ln1924">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1925">    luaL_where(lstate, 1);</a>
<a name="ln1926">    if (err_param) {</a>
<a name="ln1927">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1928">      lua_pushstring(lstate, err_param);</a>
<a name="ln1929">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1930">    }</a>
<a name="ln1931">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1932">    api_clear_error(&amp;err);</a>
<a name="ln1933">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1934">    return lua_error(lstate);</a>
<a name="ln1935">  }</a>
<a name="ln1936"> </a>
<a name="ln1937">  return 1;</a>
<a name="ln1938">}</a>
<a name="ln1939"> </a>
<a name="ln1940">static int nlua_api_nvim_command_output(lua_State *lstate)</a>
<a name="ln1941">{</a>
<a name="ln1942">  Error err = ERROR_INIT;</a>
<a name="ln1943">  char *err_param = 0;</a>
<a name="ln1944">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1945">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1946">    goto exit_0;</a>
<a name="ln1947">  }</a>
<a name="ln1948">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1949">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_command_output&quot;);</a>
<a name="ln1950">  }</a>
<a name="ln1951">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1952">  if (ERROR_SET(&amp;err)) {      err_param = &quot;command&quot;;      goto exit_0;</a>
<a name="ln1953">  }</a>
<a name="ln1954"> </a>
<a name="ln1955">  const String ret = nvim_command_output(LUA_INTERNAL_CALL, arg1, &amp;err);</a>
<a name="ln1956">  nlua_push_String(lstate, ret, true);</a>
<a name="ln1957">api_free_string(ret);</a>
<a name="ln1958"> </a>
<a name="ln1959">  api_free_string(arg1);</a>
<a name="ln1960"> </a>
<a name="ln1961">exit_0:</a>
<a name="ln1962">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1963">    luaL_where(lstate, 1);</a>
<a name="ln1964">    if (err_param) {</a>
<a name="ln1965">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1966">      lua_pushstring(lstate, err_param);</a>
<a name="ln1967">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1968">    }</a>
<a name="ln1969">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1970">    api_clear_error(&amp;err);</a>
<a name="ln1971">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1972">    return lua_error(lstate);</a>
<a name="ln1973">  }</a>
<a name="ln1974"> </a>
<a name="ln1975">  return 1;</a>
<a name="ln1976">}</a>
<a name="ln1977"> </a>
<a name="ln1978">static int nlua_api_nvim_buf_get_number(lua_State *lstate)</a>
<a name="ln1979">{</a>
<a name="ln1980">  Error err = ERROR_INIT;</a>
<a name="ln1981">  char *err_param = 0;</a>
<a name="ln1982">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1983">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1984">    goto exit_0;</a>
<a name="ln1985">  }</a>
<a name="ln1986">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1987">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_number&quot;);</a>
<a name="ln1988">  }</a>
<a name="ln1989">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1990">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln1991">  }</a>
<a name="ln1992"> </a>
<a name="ln1993">  const Integer ret = nvim_buf_get_number(arg1, &amp;err);</a>
<a name="ln1994">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln1995">api_free_integer(ret);</a>
<a name="ln1996"> </a>
<a name="ln1997">  api_free_buffer(arg1);</a>
<a name="ln1998"> </a>
<a name="ln1999">exit_0:</a>
<a name="ln2000">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2001">    luaL_where(lstate, 1);</a>
<a name="ln2002">    if (err_param) {</a>
<a name="ln2003">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2004">      lua_pushstring(lstate, err_param);</a>
<a name="ln2005">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2006">    }</a>
<a name="ln2007">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2008">    api_clear_error(&amp;err);</a>
<a name="ln2009">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2010">    return lua_error(lstate);</a>
<a name="ln2011">  }</a>
<a name="ln2012"> </a>
<a name="ln2013">  return 1;</a>
<a name="ln2014">}</a>
<a name="ln2015"> </a>
<a name="ln2016">static int nlua_api_nvim_buf_clear_highlight(lua_State *lstate)</a>
<a name="ln2017">{</a>
<a name="ln2018">  Error err = ERROR_INIT;</a>
<a name="ln2019">  char *err_param = 0;</a>
<a name="ln2020">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln2021">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln2022">    goto exit_0;</a>
<a name="ln2023">  }</a>
<a name="ln2024">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2025">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_clear_highlight&quot;);</a>
<a name="ln2026">  }</a>
<a name="ln2027">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2028">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line_end&quot;;      goto exit_0;</a>
<a name="ln2029">  }</a>
<a name="ln2030"> </a>
<a name="ln2031">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2032">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line_start&quot;;      goto exit_1;</a>
<a name="ln2033">  }</a>
<a name="ln2034"> </a>
<a name="ln2035">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2036">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_2;</a>
<a name="ln2037">  }</a>
<a name="ln2038"> </a>
<a name="ln2039">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2040">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_3;</a>
<a name="ln2041">  }</a>
<a name="ln2042"> </a>
<a name="ln2043">  nvim_buf_clear_highlight(arg1, arg2, arg3, arg4, &amp;err);</a>
<a name="ln2044"> </a>
<a name="ln2045">  api_free_buffer(arg1);</a>
<a name="ln2046">exit_3:</a>
<a name="ln2047">  api_free_integer(arg2);</a>
<a name="ln2048">exit_2:</a>
<a name="ln2049">  api_free_integer(arg3);</a>
<a name="ln2050">exit_1:</a>
<a name="ln2051">  api_free_integer(arg4);</a>
<a name="ln2052"> </a>
<a name="ln2053">exit_0:</a>
<a name="ln2054">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2055">    luaL_where(lstate, 1);</a>
<a name="ln2056">    if (err_param) {</a>
<a name="ln2057">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2058">      lua_pushstring(lstate, err_param);</a>
<a name="ln2059">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2060">    }</a>
<a name="ln2061">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2062">    api_clear_error(&amp;err);</a>
<a name="ln2063">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2064">    return lua_error(lstate);</a>
<a name="ln2065">  }</a>
<a name="ln2066"> </a>
<a name="ln2067">  return 0;</a>
<a name="ln2068">}</a>
<a name="ln2069"> </a>
<a name="ln2070">static int nlua_api_nvim_buf_set_virtual_text(lua_State *lstate)</a>
<a name="ln2071">{</a>
<a name="ln2072">  Error err = ERROR_INIT;</a>
<a name="ln2073">  char *err_param = 0;</a>
<a name="ln2074">  if (lua_gettop(lstate) != 5) {</a>
<a name="ln2075">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 5 arguments&quot;);</a>
<a name="ln2076">    goto exit_0;</a>
<a name="ln2077">  }</a>
<a name="ln2078">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2079">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_virtual_text&quot;);</a>
<a name="ln2080">  }</a>
<a name="ln2081">    const Dictionary arg5 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln2082">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln2083">  }</a>
<a name="ln2084"> </a>
<a name="ln2085">    const Array arg4 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln2086">  if (ERROR_SET(&amp;err)) {      err_param = &quot;chunks&quot;;      goto exit_1;</a>
<a name="ln2087">  }</a>
<a name="ln2088"> </a>
<a name="ln2089">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2090">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line&quot;;      goto exit_2;</a>
<a name="ln2091">  }</a>
<a name="ln2092"> </a>
<a name="ln2093">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2094">  if (ERROR_SET(&amp;err)) {      err_param = &quot;src_id&quot;;      goto exit_3;</a>
<a name="ln2095">  }</a>
<a name="ln2096"> </a>
<a name="ln2097">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2098">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_4;</a>
<a name="ln2099">  }</a>
<a name="ln2100"> </a>
<a name="ln2101">  const Integer ret = nvim_buf_set_virtual_text(arg1, arg2, arg3, arg4, arg5, &amp;err);</a>
<a name="ln2102">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln2103">api_free_integer(ret);</a>
<a name="ln2104"> </a>
<a name="ln2105">  api_free_buffer(arg1);</a>
<a name="ln2106">exit_4:</a>
<a name="ln2107">  api_free_integer(arg2);</a>
<a name="ln2108">exit_3:</a>
<a name="ln2109">  api_free_integer(arg3);</a>
<a name="ln2110">exit_2:</a>
<a name="ln2111">  api_free_array(arg4);</a>
<a name="ln2112">exit_1:</a>
<a name="ln2113">  api_free_dictionary(arg5);</a>
<a name="ln2114"> </a>
<a name="ln2115">exit_0:</a>
<a name="ln2116">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2117">    luaL_where(lstate, 1);</a>
<a name="ln2118">    if (err_param) {</a>
<a name="ln2119">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2120">      lua_pushstring(lstate, err_param);</a>
<a name="ln2121">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2122">    }</a>
<a name="ln2123">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2124">    api_clear_error(&amp;err);</a>
<a name="ln2125">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2126">    return lua_error(lstate);</a>
<a name="ln2127">  }</a>
<a name="ln2128"> </a>
<a name="ln2129">  return 1;</a>
<a name="ln2130">}</a>
<a name="ln2131"> </a>
<a name="ln2132">static int nlua_api_nvim_get_hl_by_id(lua_State *lstate)</a>
<a name="ln2133">{</a>
<a name="ln2134">  Error err = ERROR_INIT;</a>
<a name="ln2135">  char *err_param = 0;</a>
<a name="ln2136">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln2137">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln2138">    goto exit_0;</a>
<a name="ln2139">  }</a>
<a name="ln2140">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2141">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_hl_by_id&quot;);</a>
<a name="ln2142">  }</a>
<a name="ln2143">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln2144">  if (ERROR_SET(&amp;err)) {      err_param = &quot;rgb&quot;;      goto exit_0;</a>
<a name="ln2145">  }</a>
<a name="ln2146"> </a>
<a name="ln2147">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2148">  if (ERROR_SET(&amp;err)) {      err_param = &quot;hl_id&quot;;      goto exit_1;</a>
<a name="ln2149">  }</a>
<a name="ln2150"> </a>
<a name="ln2151">  Arena arena = ARENA_EMPTY;</a>
<a name="ln2152">  const Dictionary ret = nvim_get_hl_by_id(arg1, arg2, &amp;arena, &amp;err);</a>
<a name="ln2153">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln2154">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln2155"> </a>
<a name="ln2156">  api_free_integer(arg1);</a>
<a name="ln2157">exit_1:</a>
<a name="ln2158">  api_free_boolean(arg2);</a>
<a name="ln2159"> </a>
<a name="ln2160">exit_0:</a>
<a name="ln2161">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2162">    luaL_where(lstate, 1);</a>
<a name="ln2163">    if (err_param) {</a>
<a name="ln2164">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2165">      lua_pushstring(lstate, err_param);</a>
<a name="ln2166">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2167">    }</a>
<a name="ln2168">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2169">    api_clear_error(&amp;err);</a>
<a name="ln2170">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2171">    return lua_error(lstate);</a>
<a name="ln2172">  }</a>
<a name="ln2173"> </a>
<a name="ln2174">  return 1;</a>
<a name="ln2175">}</a>
<a name="ln2176"> </a>
<a name="ln2177">static int nlua_api_nvim_get_hl_by_name(lua_State *lstate)</a>
<a name="ln2178">{</a>
<a name="ln2179">  Error err = ERROR_INIT;</a>
<a name="ln2180">  char *err_param = 0;</a>
<a name="ln2181">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln2182">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln2183">    goto exit_0;</a>
<a name="ln2184">  }</a>
<a name="ln2185">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2186">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_hl_by_name&quot;);</a>
<a name="ln2187">  }</a>
<a name="ln2188">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln2189">  if (ERROR_SET(&amp;err)) {      err_param = &quot;rgb&quot;;      goto exit_0;</a>
<a name="ln2190">  }</a>
<a name="ln2191"> </a>
<a name="ln2192">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2193">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln2194">  }</a>
<a name="ln2195"> </a>
<a name="ln2196">  Arena arena = ARENA_EMPTY;</a>
<a name="ln2197">  const Dictionary ret = nvim_get_hl_by_name(arg1, arg2, &amp;arena, &amp;err);</a>
<a name="ln2198">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln2199">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln2200"> </a>
<a name="ln2201">  api_free_string(arg1);</a>
<a name="ln2202">exit_1:</a>
<a name="ln2203">  api_free_boolean(arg2);</a>
<a name="ln2204"> </a>
<a name="ln2205">exit_0:</a>
<a name="ln2206">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2207">    luaL_where(lstate, 1);</a>
<a name="ln2208">    if (err_param) {</a>
<a name="ln2209">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2210">      lua_pushstring(lstate, err_param);</a>
<a name="ln2211">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2212">    }</a>
<a name="ln2213">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2214">    api_clear_error(&amp;err);</a>
<a name="ln2215">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2216">    return lua_error(lstate);</a>
<a name="ln2217">  }</a>
<a name="ln2218"> </a>
<a name="ln2219">  return 1;</a>
<a name="ln2220">}</a>
<a name="ln2221"> </a>
<a name="ln2222">static int nlua_api_nvim_get_option_info(lua_State *lstate)</a>
<a name="ln2223">{</a>
<a name="ln2224">  Error err = ERROR_INIT;</a>
<a name="ln2225">  char *err_param = 0;</a>
<a name="ln2226">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln2227">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln2228">    goto exit_0;</a>
<a name="ln2229">  }</a>
<a name="ln2230">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2231">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_option_info&quot;);</a>
<a name="ln2232">  }</a>
<a name="ln2233">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2234">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln2235">  }</a>
<a name="ln2236"> </a>
<a name="ln2237">  const Dictionary ret = nvim_get_option_info(arg1, &amp;err);</a>
<a name="ln2238">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln2239">api_free_dictionary(ret);</a>
<a name="ln2240"> </a>
<a name="ln2241">  api_free_string(arg1);</a>
<a name="ln2242"> </a>
<a name="ln2243">exit_0:</a>
<a name="ln2244">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2245">    luaL_where(lstate, 1);</a>
<a name="ln2246">    if (err_param) {</a>
<a name="ln2247">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2248">      lua_pushstring(lstate, err_param);</a>
<a name="ln2249">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2250">    }</a>
<a name="ln2251">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2252">    api_clear_error(&amp;err);</a>
<a name="ln2253">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2254">    return lua_error(lstate);</a>
<a name="ln2255">  }</a>
<a name="ln2256"> </a>
<a name="ln2257">  return 1;</a>
<a name="ln2258">}</a>
<a name="ln2259"> </a>
<a name="ln2260">static int nlua_api_nvim_set_option(lua_State *lstate)</a>
<a name="ln2261">{</a>
<a name="ln2262">  Error err = ERROR_INIT;</a>
<a name="ln2263">  char *err_param = 0;</a>
<a name="ln2264">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln2265">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln2266">    goto exit_0;</a>
<a name="ln2267">  }</a>
<a name="ln2268">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2269">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_option&quot;);</a>
<a name="ln2270">  }</a>
<a name="ln2271">    const Object arg2 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln2272">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln2273">  }</a>
<a name="ln2274"> </a>
<a name="ln2275">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2276">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln2277">  }</a>
<a name="ln2278"> </a>
<a name="ln2279">  nvim_set_option(LUA_INTERNAL_CALL, arg1, arg2, &amp;err);</a>
<a name="ln2280"> </a>
<a name="ln2281">  api_free_string(arg1);</a>
<a name="ln2282">exit_1:</a>
<a name="ln2283">  api_free_object(arg2);</a>
<a name="ln2284"> </a>
<a name="ln2285">exit_0:</a>
<a name="ln2286">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2287">    luaL_where(lstate, 1);</a>
<a name="ln2288">    if (err_param) {</a>
<a name="ln2289">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2290">      lua_pushstring(lstate, err_param);</a>
<a name="ln2291">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2292">    }</a>
<a name="ln2293">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2294">    api_clear_error(&amp;err);</a>
<a name="ln2295">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2296">    return lua_error(lstate);</a>
<a name="ln2297">  }</a>
<a name="ln2298"> </a>
<a name="ln2299">  return 0;</a>
<a name="ln2300">}</a>
<a name="ln2301"> </a>
<a name="ln2302">static int nlua_api_nvim_get_option(lua_State *lstate)</a>
<a name="ln2303">{</a>
<a name="ln2304">  Error err = ERROR_INIT;</a>
<a name="ln2305">  char *err_param = 0;</a>
<a name="ln2306">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln2307">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln2308">    goto exit_0;</a>
<a name="ln2309">  }</a>
<a name="ln2310">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2311">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_option&quot;);</a>
<a name="ln2312">  }</a>
<a name="ln2313">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2314">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln2315">  }</a>
<a name="ln2316"> </a>
<a name="ln2317">  Arena arena = ARENA_EMPTY;</a>
<a name="ln2318">  const Object ret = nvim_get_option(arg1, &amp;arena, &amp;err);</a>
<a name="ln2319">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln2320">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln2321"> </a>
<a name="ln2322">  api_free_string(arg1);</a>
<a name="ln2323"> </a>
<a name="ln2324">exit_0:</a>
<a name="ln2325">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2326">    luaL_where(lstate, 1);</a>
<a name="ln2327">    if (err_param) {</a>
<a name="ln2328">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2329">      lua_pushstring(lstate, err_param);</a>
<a name="ln2330">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2331">    }</a>
<a name="ln2332">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2333">    api_clear_error(&amp;err);</a>
<a name="ln2334">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2335">    return lua_error(lstate);</a>
<a name="ln2336">  }</a>
<a name="ln2337"> </a>
<a name="ln2338">  return 1;</a>
<a name="ln2339">}</a>
<a name="ln2340"> </a>
<a name="ln2341">static int nlua_api_nvim_buf_get_option(lua_State *lstate)</a>
<a name="ln2342">{</a>
<a name="ln2343">  Error err = ERROR_INIT;</a>
<a name="ln2344">  char *err_param = 0;</a>
<a name="ln2345">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln2346">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln2347">    goto exit_0;</a>
<a name="ln2348">  }</a>
<a name="ln2349">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2350">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_option&quot;);</a>
<a name="ln2351">  }</a>
<a name="ln2352">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2353">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln2354">  }</a>
<a name="ln2355"> </a>
<a name="ln2356">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2357">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln2358">  }</a>
<a name="ln2359"> </a>
<a name="ln2360">  Arena arena = ARENA_EMPTY;</a>
<a name="ln2361">  const Object ret = nvim_buf_get_option(arg1, arg2, &amp;arena, &amp;err);</a>
<a name="ln2362">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln2363">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln2364"> </a>
<a name="ln2365">  api_free_buffer(arg1);</a>
<a name="ln2366">exit_1:</a>
<a name="ln2367">  api_free_string(arg2);</a>
<a name="ln2368"> </a>
<a name="ln2369">exit_0:</a>
<a name="ln2370">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2371">    luaL_where(lstate, 1);</a>
<a name="ln2372">    if (err_param) {</a>
<a name="ln2373">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2374">      lua_pushstring(lstate, err_param);</a>
<a name="ln2375">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2376">    }</a>
<a name="ln2377">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2378">    api_clear_error(&amp;err);</a>
<a name="ln2379">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2380">    return lua_error(lstate);</a>
<a name="ln2381">  }</a>
<a name="ln2382"> </a>
<a name="ln2383">  return 1;</a>
<a name="ln2384">}</a>
<a name="ln2385"> </a>
<a name="ln2386">static int nlua_api_nvim_buf_set_option(lua_State *lstate)</a>
<a name="ln2387">{</a>
<a name="ln2388">  Error err = ERROR_INIT;</a>
<a name="ln2389">  char *err_param = 0;</a>
<a name="ln2390">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln2391">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln2392">    goto exit_0;</a>
<a name="ln2393">  }</a>
<a name="ln2394">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2395">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_option&quot;);</a>
<a name="ln2396">  }</a>
<a name="ln2397">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln2398">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln2399">  }</a>
<a name="ln2400"> </a>
<a name="ln2401">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2402">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln2403">  }</a>
<a name="ln2404"> </a>
<a name="ln2405">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2406">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln2407">  }</a>
<a name="ln2408"> </a>
<a name="ln2409">  nvim_buf_set_option(LUA_INTERNAL_CALL, arg1, arg2, arg3, &amp;err);</a>
<a name="ln2410"> </a>
<a name="ln2411">  api_free_buffer(arg1);</a>
<a name="ln2412">exit_2:</a>
<a name="ln2413">  api_free_string(arg2);</a>
<a name="ln2414">exit_1:</a>
<a name="ln2415">  api_free_object(arg3);</a>
<a name="ln2416"> </a>
<a name="ln2417">exit_0:</a>
<a name="ln2418">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2419">    luaL_where(lstate, 1);</a>
<a name="ln2420">    if (err_param) {</a>
<a name="ln2421">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2422">      lua_pushstring(lstate, err_param);</a>
<a name="ln2423">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2424">    }</a>
<a name="ln2425">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2426">    api_clear_error(&amp;err);</a>
<a name="ln2427">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2428">    return lua_error(lstate);</a>
<a name="ln2429">  }</a>
<a name="ln2430"> </a>
<a name="ln2431">  return 0;</a>
<a name="ln2432">}</a>
<a name="ln2433"> </a>
<a name="ln2434">static int nlua_api_nvim_win_get_option(lua_State *lstate)</a>
<a name="ln2435">{</a>
<a name="ln2436">  Error err = ERROR_INIT;</a>
<a name="ln2437">  char *err_param = 0;</a>
<a name="ln2438">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln2439">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln2440">    goto exit_0;</a>
<a name="ln2441">  }</a>
<a name="ln2442">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2443">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_option&quot;);</a>
<a name="ln2444">  }</a>
<a name="ln2445">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2446">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln2447">  }</a>
<a name="ln2448"> </a>
<a name="ln2449">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln2450">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln2451">  }</a>
<a name="ln2452"> </a>
<a name="ln2453">  Arena arena = ARENA_EMPTY;</a>
<a name="ln2454">  const Object ret = nvim_win_get_option(arg1, arg2, &amp;arena, &amp;err);</a>
<a name="ln2455">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln2456">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln2457"> </a>
<a name="ln2458">  api_free_window(arg1);</a>
<a name="ln2459">exit_1:</a>
<a name="ln2460">  api_free_string(arg2);</a>
<a name="ln2461"> </a>
<a name="ln2462">exit_0:</a>
<a name="ln2463">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2464">    luaL_where(lstate, 1);</a>
<a name="ln2465">    if (err_param) {</a>
<a name="ln2466">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2467">      lua_pushstring(lstate, err_param);</a>
<a name="ln2468">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2469">    }</a>
<a name="ln2470">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2471">    api_clear_error(&amp;err);</a>
<a name="ln2472">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2473">    return lua_error(lstate);</a>
<a name="ln2474">  }</a>
<a name="ln2475"> </a>
<a name="ln2476">  return 1;</a>
<a name="ln2477">}</a>
<a name="ln2478"> </a>
<a name="ln2479">static int nlua_api_nvim_win_set_option(lua_State *lstate)</a>
<a name="ln2480">{</a>
<a name="ln2481">  Error err = ERROR_INIT;</a>
<a name="ln2482">  char *err_param = 0;</a>
<a name="ln2483">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln2484">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln2485">    goto exit_0;</a>
<a name="ln2486">  }</a>
<a name="ln2487">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2488">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_option&quot;);</a>
<a name="ln2489">  }</a>
<a name="ln2490">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln2491">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln2492">  }</a>
<a name="ln2493"> </a>
<a name="ln2494">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2495">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln2496">  }</a>
<a name="ln2497"> </a>
<a name="ln2498">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln2499">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_2;</a>
<a name="ln2500">  }</a>
<a name="ln2501"> </a>
<a name="ln2502">  nvim_win_set_option(LUA_INTERNAL_CALL, arg1, arg2, arg3, &amp;err);</a>
<a name="ln2503"> </a>
<a name="ln2504">  api_free_window(arg1);</a>
<a name="ln2505">exit_2:</a>
<a name="ln2506">  api_free_string(arg2);</a>
<a name="ln2507">exit_1:</a>
<a name="ln2508">  api_free_object(arg3);</a>
<a name="ln2509"> </a>
<a name="ln2510">exit_0:</a>
<a name="ln2511">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2512">    luaL_where(lstate, 1);</a>
<a name="ln2513">    if (err_param) {</a>
<a name="ln2514">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2515">      lua_pushstring(lstate, err_param);</a>
<a name="ln2516">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2517">    }</a>
<a name="ln2518">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2519">    api_clear_error(&amp;err);</a>
<a name="ln2520">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2521">    return lua_error(lstate);</a>
<a name="ln2522">  }</a>
<a name="ln2523"> </a>
<a name="ln2524">  return 0;</a>
<a name="ln2525">}</a>
<a name="ln2526"> </a>
<a name="ln2527">static int nlua_api_nvim_create_namespace(lua_State *lstate)</a>
<a name="ln2528">{</a>
<a name="ln2529">  Error err = ERROR_INIT;</a>
<a name="ln2530">  char *err_param = 0;</a>
<a name="ln2531">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln2532">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln2533">    goto exit_0;</a>
<a name="ln2534">  }</a>
<a name="ln2535">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2536">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_create_namespace&quot;);</a>
<a name="ln2537">  }</a>
<a name="ln2538">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2539">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln2540">  }</a>
<a name="ln2541"> </a>
<a name="ln2542">  const Integer ret = nvim_create_namespace(arg1);</a>
<a name="ln2543">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln2544">api_free_integer(ret);</a>
<a name="ln2545"> </a>
<a name="ln2546">  api_free_string(arg1);</a>
<a name="ln2547"> </a>
<a name="ln2548">exit_0:</a>
<a name="ln2549">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2550">    luaL_where(lstate, 1);</a>
<a name="ln2551">    if (err_param) {</a>
<a name="ln2552">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2553">      lua_pushstring(lstate, err_param);</a>
<a name="ln2554">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2555">    }</a>
<a name="ln2556">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2557">    api_clear_error(&amp;err);</a>
<a name="ln2558">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2559">    return lua_error(lstate);</a>
<a name="ln2560">  }</a>
<a name="ln2561"> </a>
<a name="ln2562">  return 1;</a>
<a name="ln2563">}</a>
<a name="ln2564"> </a>
<a name="ln2565">static int nlua_api_nvim_get_namespaces(lua_State *lstate)</a>
<a name="ln2566">{</a>
<a name="ln2567">  Error err = ERROR_INIT;</a>
<a name="ln2568">  char *err_param = 0;</a>
<a name="ln2569">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln2570">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln2571">    goto exit_0;</a>
<a name="ln2572">  }</a>
<a name="ln2573">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2574">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_namespaces&quot;);</a>
<a name="ln2575">  }</a>
<a name="ln2576">  const Dictionary ret = nvim_get_namespaces();</a>
<a name="ln2577">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln2578">api_free_dictionary(ret);</a>
<a name="ln2579"> </a>
<a name="ln2580"> </a>
<a name="ln2581">exit_0:</a>
<a name="ln2582">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2583">    luaL_where(lstate, 1);</a>
<a name="ln2584">    if (err_param) {</a>
<a name="ln2585">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2586">      lua_pushstring(lstate, err_param);</a>
<a name="ln2587">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2588">    }</a>
<a name="ln2589">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2590">    api_clear_error(&amp;err);</a>
<a name="ln2591">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2592">    return lua_error(lstate);</a>
<a name="ln2593">  }</a>
<a name="ln2594"> </a>
<a name="ln2595">  return 1;</a>
<a name="ln2596">}</a>
<a name="ln2597"> </a>
<a name="ln2598">static int nlua_api_nvim_buf_get_extmark_by_id(lua_State *lstate)</a>
<a name="ln2599">{</a>
<a name="ln2600">  Error err = ERROR_INIT;</a>
<a name="ln2601">  char *err_param = 0;</a>
<a name="ln2602">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln2603">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln2604">    goto exit_0;</a>
<a name="ln2605">  }</a>
<a name="ln2606">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2607">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_extmark_by_id&quot;);</a>
<a name="ln2608">  }</a>
<a name="ln2609">    const Dictionary arg4 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln2610">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln2611">  }</a>
<a name="ln2612"> </a>
<a name="ln2613">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2614">  if (ERROR_SET(&amp;err)) {      err_param = &quot;id&quot;;      goto exit_1;</a>
<a name="ln2615">  }</a>
<a name="ln2616"> </a>
<a name="ln2617">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2618">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_2;</a>
<a name="ln2619">  }</a>
<a name="ln2620"> </a>
<a name="ln2621">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2622">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_3;</a>
<a name="ln2623">  }</a>
<a name="ln2624"> </a>
<a name="ln2625">  const ArrayOf(Integer) ret = nvim_buf_get_extmark_by_id(arg1, arg2, arg3, arg4, &amp;err);</a>
<a name="ln2626">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln2627">api_free_array(ret);</a>
<a name="ln2628"> </a>
<a name="ln2629">  api_free_buffer(arg1);</a>
<a name="ln2630">exit_3:</a>
<a name="ln2631">  api_free_integer(arg2);</a>
<a name="ln2632">exit_2:</a>
<a name="ln2633">  api_free_integer(arg3);</a>
<a name="ln2634">exit_1:</a>
<a name="ln2635">  api_free_dictionary(arg4);</a>
<a name="ln2636"> </a>
<a name="ln2637">exit_0:</a>
<a name="ln2638">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2639">    luaL_where(lstate, 1);</a>
<a name="ln2640">    if (err_param) {</a>
<a name="ln2641">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2642">      lua_pushstring(lstate, err_param);</a>
<a name="ln2643">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2644">    }</a>
<a name="ln2645">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2646">    api_clear_error(&amp;err);</a>
<a name="ln2647">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2648">    return lua_error(lstate);</a>
<a name="ln2649">  }</a>
<a name="ln2650"> </a>
<a name="ln2651">  return 1;</a>
<a name="ln2652">}</a>
<a name="ln2653"> </a>
<a name="ln2654">static int nlua_api_nvim_buf_get_extmarks(lua_State *lstate)</a>
<a name="ln2655">{</a>
<a name="ln2656">  Error err = ERROR_INIT;</a>
<a name="ln2657">  char *err_param = 0;</a>
<a name="ln2658">  if (lua_gettop(lstate) != 5) {</a>
<a name="ln2659">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 5 arguments&quot;);</a>
<a name="ln2660">    goto exit_0;</a>
<a name="ln2661">  }</a>
<a name="ln2662">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2663">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_extmarks&quot;);</a>
<a name="ln2664">  }</a>
<a name="ln2665">    KeyDict_get_extmarks arg5 = { 0 }; nlua_pop_keydict(lstate, &amp;arg5, KeyDict_get_extmarks_get_field, &amp;err_param, &amp;err);</a>
<a name="ln2666">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln2667">  }</a>
<a name="ln2668"> </a>
<a name="ln2669">    const Object arg4 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln2670">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end&quot;;      goto exit_1;</a>
<a name="ln2671">  }</a>
<a name="ln2672"> </a>
<a name="ln2673">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln2674">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start&quot;;      goto exit_2;</a>
<a name="ln2675">  }</a>
<a name="ln2676"> </a>
<a name="ln2677">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2678">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_3;</a>
<a name="ln2679">  }</a>
<a name="ln2680"> </a>
<a name="ln2681">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2682">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_4;</a>
<a name="ln2683">  }</a>
<a name="ln2684"> </a>
<a name="ln2685">  const Array ret = nvim_buf_get_extmarks(arg1, arg2, arg3, arg4, &amp;arg5, &amp;err);</a>
<a name="ln2686">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln2687">api_free_array(ret);</a>
<a name="ln2688"> </a>
<a name="ln2689">  api_free_buffer(arg1);</a>
<a name="ln2690">exit_4:</a>
<a name="ln2691">  api_free_integer(arg2);</a>
<a name="ln2692">exit_3:</a>
<a name="ln2693">  api_free_object(arg3);</a>
<a name="ln2694">exit_2:</a>
<a name="ln2695">  api_free_object(arg4);</a>
<a name="ln2696">exit_1:</a>
<a name="ln2697">  api_free_keydict_get_extmarks(&amp;arg5);</a>
<a name="ln2698"> </a>
<a name="ln2699">exit_0:</a>
<a name="ln2700">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2701">    luaL_where(lstate, 1);</a>
<a name="ln2702">    if (err_param) {</a>
<a name="ln2703">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2704">      lua_pushstring(lstate, err_param);</a>
<a name="ln2705">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2706">    }</a>
<a name="ln2707">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2708">    api_clear_error(&amp;err);</a>
<a name="ln2709">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2710">    return lua_error(lstate);</a>
<a name="ln2711">  }</a>
<a name="ln2712"> </a>
<a name="ln2713">  return 1;</a>
<a name="ln2714">}</a>
<a name="ln2715"> </a>
<a name="ln2716">static int nlua_api_nvim_buf_set_extmark(lua_State *lstate)</a>
<a name="ln2717">{</a>
<a name="ln2718">  Error err = ERROR_INIT;</a>
<a name="ln2719">  char *err_param = 0;</a>
<a name="ln2720">  if (lua_gettop(lstate) != 5) {</a>
<a name="ln2721">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 5 arguments&quot;);</a>
<a name="ln2722">    goto exit_0;</a>
<a name="ln2723">  }</a>
<a name="ln2724">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2725">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_extmark&quot;);</a>
<a name="ln2726">  }</a>
<a name="ln2727">    KeyDict_set_extmark arg5 = { 0 }; nlua_pop_keydict(lstate, &amp;arg5, KeyDict_set_extmark_get_field, &amp;err_param, &amp;err);</a>
<a name="ln2728">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln2729">  }</a>
<a name="ln2730"> </a>
<a name="ln2731">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2732">  if (ERROR_SET(&amp;err)) {      err_param = &quot;col&quot;;      goto exit_1;</a>
<a name="ln2733">  }</a>
<a name="ln2734"> </a>
<a name="ln2735">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2736">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line&quot;;      goto exit_2;</a>
<a name="ln2737">  }</a>
<a name="ln2738"> </a>
<a name="ln2739">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2740">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_3;</a>
<a name="ln2741">  }</a>
<a name="ln2742"> </a>
<a name="ln2743">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2744">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_4;</a>
<a name="ln2745">  }</a>
<a name="ln2746"> </a>
<a name="ln2747">  const Integer ret = nvim_buf_set_extmark(arg1, arg2, arg3, arg4, &amp;arg5, &amp;err);</a>
<a name="ln2748">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln2749">api_free_integer(ret);</a>
<a name="ln2750"> </a>
<a name="ln2751">  api_free_buffer(arg1);</a>
<a name="ln2752">exit_4:</a>
<a name="ln2753">  api_free_integer(arg2);</a>
<a name="ln2754">exit_3:</a>
<a name="ln2755">  api_free_integer(arg3);</a>
<a name="ln2756">exit_2:</a>
<a name="ln2757">  api_free_integer(arg4);</a>
<a name="ln2758">exit_1:</a>
<a name="ln2759">  api_free_keydict_set_extmark(&amp;arg5);</a>
<a name="ln2760"> </a>
<a name="ln2761">exit_0:</a>
<a name="ln2762">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2763">    luaL_where(lstate, 1);</a>
<a name="ln2764">    if (err_param) {</a>
<a name="ln2765">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2766">      lua_pushstring(lstate, err_param);</a>
<a name="ln2767">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2768">    }</a>
<a name="ln2769">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2770">    api_clear_error(&amp;err);</a>
<a name="ln2771">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2772">    return lua_error(lstate);</a>
<a name="ln2773">  }</a>
<a name="ln2774"> </a>
<a name="ln2775">  return 1;</a>
<a name="ln2776">}</a>
<a name="ln2777"> </a>
<a name="ln2778">static int nlua_api_nvim_buf_del_extmark(lua_State *lstate)</a>
<a name="ln2779">{</a>
<a name="ln2780">  Error err = ERROR_INIT;</a>
<a name="ln2781">  char *err_param = 0;</a>
<a name="ln2782">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln2783">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln2784">    goto exit_0;</a>
<a name="ln2785">  }</a>
<a name="ln2786">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2787">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_del_extmark&quot;);</a>
<a name="ln2788">  }</a>
<a name="ln2789">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2790">  if (ERROR_SET(&amp;err)) {      err_param = &quot;id&quot;;      goto exit_0;</a>
<a name="ln2791">  }</a>
<a name="ln2792"> </a>
<a name="ln2793">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2794">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_1;</a>
<a name="ln2795">  }</a>
<a name="ln2796"> </a>
<a name="ln2797">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2798">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln2799">  }</a>
<a name="ln2800"> </a>
<a name="ln2801">  const Boolean ret = nvim_buf_del_extmark(arg1, arg2, arg3, &amp;err);</a>
<a name="ln2802">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln2803">api_free_boolean(ret);</a>
<a name="ln2804"> </a>
<a name="ln2805">  api_free_buffer(arg1);</a>
<a name="ln2806">exit_2:</a>
<a name="ln2807">  api_free_integer(arg2);</a>
<a name="ln2808">exit_1:</a>
<a name="ln2809">  api_free_integer(arg3);</a>
<a name="ln2810"> </a>
<a name="ln2811">exit_0:</a>
<a name="ln2812">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2813">    luaL_where(lstate, 1);</a>
<a name="ln2814">    if (err_param) {</a>
<a name="ln2815">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2816">      lua_pushstring(lstate, err_param);</a>
<a name="ln2817">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2818">    }</a>
<a name="ln2819">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2820">    api_clear_error(&amp;err);</a>
<a name="ln2821">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2822">    return lua_error(lstate);</a>
<a name="ln2823">  }</a>
<a name="ln2824"> </a>
<a name="ln2825">  return 1;</a>
<a name="ln2826">}</a>
<a name="ln2827"> </a>
<a name="ln2828">static int nlua_api_nvim_buf_add_highlight(lua_State *lstate)</a>
<a name="ln2829">{</a>
<a name="ln2830">  Error err = ERROR_INIT;</a>
<a name="ln2831">  char *err_param = 0;</a>
<a name="ln2832">  if (lua_gettop(lstate) != 6) {</a>
<a name="ln2833">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 6 arguments&quot;);</a>
<a name="ln2834">    goto exit_0;</a>
<a name="ln2835">  }</a>
<a name="ln2836">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2837">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_add_highlight&quot;);</a>
<a name="ln2838">  }</a>
<a name="ln2839">    const Integer arg6 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2840">  if (ERROR_SET(&amp;err)) {      err_param = &quot;col_end&quot;;      goto exit_0;</a>
<a name="ln2841">  }</a>
<a name="ln2842"> </a>
<a name="ln2843">    const Integer arg5 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2844">  if (ERROR_SET(&amp;err)) {      err_param = &quot;col_start&quot;;      goto exit_1;</a>
<a name="ln2845">  }</a>
<a name="ln2846"> </a>
<a name="ln2847">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2848">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line&quot;;      goto exit_2;</a>
<a name="ln2849">  }</a>
<a name="ln2850"> </a>
<a name="ln2851">    const String arg3 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2852">  if (ERROR_SET(&amp;err)) {      err_param = &quot;hl_group&quot;;      goto exit_3;</a>
<a name="ln2853">  }</a>
<a name="ln2854"> </a>
<a name="ln2855">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2856">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_4;</a>
<a name="ln2857">  }</a>
<a name="ln2858"> </a>
<a name="ln2859">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2860">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_5;</a>
<a name="ln2861">  }</a>
<a name="ln2862"> </a>
<a name="ln2863">  const Integer ret = nvim_buf_add_highlight(arg1, arg2, arg3, arg4, arg5, arg6, &amp;err);</a>
<a name="ln2864">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln2865">api_free_integer(ret);</a>
<a name="ln2866"> </a>
<a name="ln2867">  api_free_buffer(arg1);</a>
<a name="ln2868">exit_5:</a>
<a name="ln2869">  api_free_integer(arg2);</a>
<a name="ln2870">exit_4:</a>
<a name="ln2871">  api_free_string(arg3);</a>
<a name="ln2872">exit_3:</a>
<a name="ln2873">  api_free_integer(arg4);</a>
<a name="ln2874">exit_2:</a>
<a name="ln2875">  api_free_integer(arg5);</a>
<a name="ln2876">exit_1:</a>
<a name="ln2877">  api_free_integer(arg6);</a>
<a name="ln2878"> </a>
<a name="ln2879">exit_0:</a>
<a name="ln2880">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2881">    luaL_where(lstate, 1);</a>
<a name="ln2882">    if (err_param) {</a>
<a name="ln2883">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2884">      lua_pushstring(lstate, err_param);</a>
<a name="ln2885">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2886">    }</a>
<a name="ln2887">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2888">    api_clear_error(&amp;err);</a>
<a name="ln2889">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2890">    return lua_error(lstate);</a>
<a name="ln2891">  }</a>
<a name="ln2892"> </a>
<a name="ln2893">  return 1;</a>
<a name="ln2894">}</a>
<a name="ln2895"> </a>
<a name="ln2896">static int nlua_api_nvim_buf_clear_namespace(lua_State *lstate)</a>
<a name="ln2897">{</a>
<a name="ln2898">  Error err = ERROR_INIT;</a>
<a name="ln2899">  char *err_param = 0;</a>
<a name="ln2900">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln2901">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln2902">    goto exit_0;</a>
<a name="ln2903">  }</a>
<a name="ln2904">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2905">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_clear_namespace&quot;);</a>
<a name="ln2906">  }</a>
<a name="ln2907">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2908">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line_end&quot;;      goto exit_0;</a>
<a name="ln2909">  }</a>
<a name="ln2910"> </a>
<a name="ln2911">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2912">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line_start&quot;;      goto exit_1;</a>
<a name="ln2913">  }</a>
<a name="ln2914"> </a>
<a name="ln2915">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2916">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_2;</a>
<a name="ln2917">  }</a>
<a name="ln2918"> </a>
<a name="ln2919">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2920">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_3;</a>
<a name="ln2921">  }</a>
<a name="ln2922"> </a>
<a name="ln2923">  nvim_buf_clear_namespace(arg1, arg2, arg3, arg4, &amp;err);</a>
<a name="ln2924"> </a>
<a name="ln2925">  api_free_buffer(arg1);</a>
<a name="ln2926">exit_3:</a>
<a name="ln2927">  api_free_integer(arg2);</a>
<a name="ln2928">exit_2:</a>
<a name="ln2929">  api_free_integer(arg3);</a>
<a name="ln2930">exit_1:</a>
<a name="ln2931">  api_free_integer(arg4);</a>
<a name="ln2932"> </a>
<a name="ln2933">exit_0:</a>
<a name="ln2934">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2935">    luaL_where(lstate, 1);</a>
<a name="ln2936">    if (err_param) {</a>
<a name="ln2937">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2938">      lua_pushstring(lstate, err_param);</a>
<a name="ln2939">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2940">    }</a>
<a name="ln2941">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2942">    api_clear_error(&amp;err);</a>
<a name="ln2943">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2944">    return lua_error(lstate);</a>
<a name="ln2945">  }</a>
<a name="ln2946"> </a>
<a name="ln2947">  return 0;</a>
<a name="ln2948">}</a>
<a name="ln2949"> </a>
<a name="ln2950">static int nlua_api_nvim_set_decoration_provider(lua_State *lstate)</a>
<a name="ln2951">{</a>
<a name="ln2952">  Error err = ERROR_INIT;</a>
<a name="ln2953">  char *err_param = 0;</a>
<a name="ln2954">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln2955">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln2956">    goto exit_0;</a>
<a name="ln2957">  }</a>
<a name="ln2958">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2959">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_decoration_provider&quot;);</a>
<a name="ln2960">  }</a>
<a name="ln2961">    KeyDict_set_decoration_provider arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_set_decoration_provider_get_field, &amp;err_param, &amp;err);</a>
<a name="ln2962">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln2963">  }</a>
<a name="ln2964"> </a>
<a name="ln2965">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2966">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_1;</a>
<a name="ln2967">  }</a>
<a name="ln2968"> </a>
<a name="ln2969">  nvim_set_decoration_provider(arg1, &amp;arg2, &amp;err);</a>
<a name="ln2970"> </a>
<a name="ln2971">  api_free_integer(arg1);</a>
<a name="ln2972">exit_1:</a>
<a name="ln2973">  api_free_keydict_set_decoration_provider(&amp;arg2);</a>
<a name="ln2974"> </a>
<a name="ln2975">exit_0:</a>
<a name="ln2976">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2977">    luaL_where(lstate, 1);</a>
<a name="ln2978">    if (err_param) {</a>
<a name="ln2979">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2980">      lua_pushstring(lstate, err_param);</a>
<a name="ln2981">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2982">    }</a>
<a name="ln2983">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2984">    api_clear_error(&amp;err);</a>
<a name="ln2985">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2986">    return lua_error(lstate);</a>
<a name="ln2987">  }</a>
<a name="ln2988"> </a>
<a name="ln2989">  return 0;</a>
<a name="ln2990">}</a>
<a name="ln2991"> </a>
<a name="ln2992">static int nlua_api_nvim__buf_debug_extmarks(lua_State *lstate)</a>
<a name="ln2993">{</a>
<a name="ln2994">  Error err = ERROR_INIT;</a>
<a name="ln2995">  char *err_param = 0;</a>
<a name="ln2996">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln2997">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln2998">    goto exit_0;</a>
<a name="ln2999">  }</a>
<a name="ln3000">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3001">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__buf_debug_extmarks&quot;);</a>
<a name="ln3002">  }</a>
<a name="ln3003">    const Boolean arg3 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln3004">  if (ERROR_SET(&amp;err)) {      err_param = &quot;dot&quot;;      goto exit_0;</a>
<a name="ln3005">  }</a>
<a name="ln3006"> </a>
<a name="ln3007">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln3008">  if (ERROR_SET(&amp;err)) {      err_param = &quot;keys&quot;;      goto exit_1;</a>
<a name="ln3009">  }</a>
<a name="ln3010"> </a>
<a name="ln3011">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln3012">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln3013">  }</a>
<a name="ln3014"> </a>
<a name="ln3015">  const String ret = nvim__buf_debug_extmarks(arg1, arg2, arg3, &amp;err);</a>
<a name="ln3016">  nlua_push_String(lstate, ret, true);</a>
<a name="ln3017">api_free_string(ret);</a>
<a name="ln3018"> </a>
<a name="ln3019">  api_free_buffer(arg1);</a>
<a name="ln3020">exit_2:</a>
<a name="ln3021">  api_free_boolean(arg2);</a>
<a name="ln3022">exit_1:</a>
<a name="ln3023">  api_free_boolean(arg3);</a>
<a name="ln3024"> </a>
<a name="ln3025">exit_0:</a>
<a name="ln3026">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3027">    luaL_where(lstate, 1);</a>
<a name="ln3028">    if (err_param) {</a>
<a name="ln3029">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3030">      lua_pushstring(lstate, err_param);</a>
<a name="ln3031">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3032">    }</a>
<a name="ln3033">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3034">    api_clear_error(&amp;err);</a>
<a name="ln3035">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3036">    return lua_error(lstate);</a>
<a name="ln3037">  }</a>
<a name="ln3038"> </a>
<a name="ln3039">  return 1;</a>
<a name="ln3040">}</a>
<a name="ln3041"> </a>
<a name="ln3042">static int nlua_api_nvim_get_option_value(lua_State *lstate)</a>
<a name="ln3043">{</a>
<a name="ln3044">  Error err = ERROR_INIT;</a>
<a name="ln3045">  char *err_param = 0;</a>
<a name="ln3046">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln3047">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln3048">    goto exit_0;</a>
<a name="ln3049">  }</a>
<a name="ln3050">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3051">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_option_value&quot;);</a>
<a name="ln3052">  }</a>
<a name="ln3053">    KeyDict_option arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_option_get_field, &amp;err_param, &amp;err);</a>
<a name="ln3054">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln3055">  }</a>
<a name="ln3056"> </a>
<a name="ln3057">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3058">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln3059">  }</a>
<a name="ln3060"> </a>
<a name="ln3061">  const Object ret = nvim_get_option_value(arg1, &amp;arg2, &amp;err);</a>
<a name="ln3062">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln3063">api_free_object(ret);</a>
<a name="ln3064"> </a>
<a name="ln3065">  api_free_string(arg1);</a>
<a name="ln3066">exit_1:</a>
<a name="ln3067">  api_free_keydict_option(&amp;arg2);</a>
<a name="ln3068"> </a>
<a name="ln3069">exit_0:</a>
<a name="ln3070">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3071">    luaL_where(lstate, 1);</a>
<a name="ln3072">    if (err_param) {</a>
<a name="ln3073">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3074">      lua_pushstring(lstate, err_param);</a>
<a name="ln3075">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3076">    }</a>
<a name="ln3077">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3078">    api_clear_error(&amp;err);</a>
<a name="ln3079">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3080">    return lua_error(lstate);</a>
<a name="ln3081">  }</a>
<a name="ln3082"> </a>
<a name="ln3083">  return 1;</a>
<a name="ln3084">}</a>
<a name="ln3085"> </a>
<a name="ln3086">static int nlua_api_nvim_set_option_value(lua_State *lstate)</a>
<a name="ln3087">{</a>
<a name="ln3088">  Error err = ERROR_INIT;</a>
<a name="ln3089">  char *err_param = 0;</a>
<a name="ln3090">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln3091">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln3092">    goto exit_0;</a>
<a name="ln3093">  }</a>
<a name="ln3094">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3095">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_option_value&quot;);</a>
<a name="ln3096">  }</a>
<a name="ln3097">    KeyDict_option arg3 = { 0 }; nlua_pop_keydict(lstate, &amp;arg3, KeyDict_option_get_field, &amp;err_param, &amp;err);</a>
<a name="ln3098">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln3099">  }</a>
<a name="ln3100"> </a>
<a name="ln3101">    const Object arg2 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln3102">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_1;</a>
<a name="ln3103">  }</a>
<a name="ln3104"> </a>
<a name="ln3105">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3106">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_2;</a>
<a name="ln3107">  }</a>
<a name="ln3108"> </a>
<a name="ln3109">  nvim_set_option_value(LUA_INTERNAL_CALL, arg1, arg2, &amp;arg3, &amp;err);</a>
<a name="ln3110"> </a>
<a name="ln3111">  api_free_string(arg1);</a>
<a name="ln3112">exit_2:</a>
<a name="ln3113">  api_free_object(arg2);</a>
<a name="ln3114">exit_1:</a>
<a name="ln3115">  api_free_keydict_option(&amp;arg3);</a>
<a name="ln3116"> </a>
<a name="ln3117">exit_0:</a>
<a name="ln3118">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3119">    luaL_where(lstate, 1);</a>
<a name="ln3120">    if (err_param) {</a>
<a name="ln3121">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3122">      lua_pushstring(lstate, err_param);</a>
<a name="ln3123">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3124">    }</a>
<a name="ln3125">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3126">    api_clear_error(&amp;err);</a>
<a name="ln3127">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3128">    return lua_error(lstate);</a>
<a name="ln3129">  }</a>
<a name="ln3130"> </a>
<a name="ln3131">  return 0;</a>
<a name="ln3132">}</a>
<a name="ln3133"> </a>
<a name="ln3134">static int nlua_api_nvim_get_all_options_info(lua_State *lstate)</a>
<a name="ln3135">{</a>
<a name="ln3136">  Error err = ERROR_INIT;</a>
<a name="ln3137">  char *err_param = 0;</a>
<a name="ln3138">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln3139">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln3140">    goto exit_0;</a>
<a name="ln3141">  }</a>
<a name="ln3142">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3143">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_all_options_info&quot;);</a>
<a name="ln3144">  }</a>
<a name="ln3145">  const Dictionary ret = nvim_get_all_options_info(&amp;err);</a>
<a name="ln3146">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln3147">api_free_dictionary(ret);</a>
<a name="ln3148"> </a>
<a name="ln3149"> </a>
<a name="ln3150">exit_0:</a>
<a name="ln3151">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3152">    luaL_where(lstate, 1);</a>
<a name="ln3153">    if (err_param) {</a>
<a name="ln3154">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3155">      lua_pushstring(lstate, err_param);</a>
<a name="ln3156">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3157">    }</a>
<a name="ln3158">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3159">    api_clear_error(&amp;err);</a>
<a name="ln3160">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3161">    return lua_error(lstate);</a>
<a name="ln3162">  }</a>
<a name="ln3163"> </a>
<a name="ln3164">  return 1;</a>
<a name="ln3165">}</a>
<a name="ln3166"> </a>
<a name="ln3167">static int nlua_api_nvim_get_option_info2(lua_State *lstate)</a>
<a name="ln3168">{</a>
<a name="ln3169">  Error err = ERROR_INIT;</a>
<a name="ln3170">  char *err_param = 0;</a>
<a name="ln3171">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln3172">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln3173">    goto exit_0;</a>
<a name="ln3174">  }</a>
<a name="ln3175">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3176">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_option_info2&quot;);</a>
<a name="ln3177">  }</a>
<a name="ln3178">    KeyDict_option arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_option_get_field, &amp;err_param, &amp;err);</a>
<a name="ln3179">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln3180">  }</a>
<a name="ln3181"> </a>
<a name="ln3182">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3183">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln3184">  }</a>
<a name="ln3185"> </a>
<a name="ln3186">  const Dictionary ret = nvim_get_option_info2(arg1, &amp;arg2, &amp;err);</a>
<a name="ln3187">  nlua_push_Dictionary(lstate, ret, false);</a>
<a name="ln3188">api_free_dictionary(ret);</a>
<a name="ln3189"> </a>
<a name="ln3190">  api_free_string(arg1);</a>
<a name="ln3191">exit_1:</a>
<a name="ln3192">  api_free_keydict_option(&amp;arg2);</a>
<a name="ln3193"> </a>
<a name="ln3194">exit_0:</a>
<a name="ln3195">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3196">    luaL_where(lstate, 1);</a>
<a name="ln3197">    if (err_param) {</a>
<a name="ln3198">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3199">      lua_pushstring(lstate, err_param);</a>
<a name="ln3200">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3201">    }</a>
<a name="ln3202">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3203">    api_clear_error(&amp;err);</a>
<a name="ln3204">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3205">    return lua_error(lstate);</a>
<a name="ln3206">  }</a>
<a name="ln3207"> </a>
<a name="ln3208">  return 1;</a>
<a name="ln3209">}</a>
<a name="ln3210"> </a>
<a name="ln3211">static int nlua_api_nvim_tabpage_list_wins(lua_State *lstate)</a>
<a name="ln3212">{</a>
<a name="ln3213">  Error err = ERROR_INIT;</a>
<a name="ln3214">  char *err_param = 0;</a>
<a name="ln3215">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3216">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3217">    goto exit_0;</a>
<a name="ln3218">  }</a>
<a name="ln3219">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3220">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_list_wins&quot;);</a>
<a name="ln3221">  }</a>
<a name="ln3222">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3223">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_0;</a>
<a name="ln3224">  }</a>
<a name="ln3225"> </a>
<a name="ln3226">  const ArrayOf(Window) ret = nvim_tabpage_list_wins(arg1, &amp;err);</a>
<a name="ln3227">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln3228">api_free_array(ret);</a>
<a name="ln3229"> </a>
<a name="ln3230">  api_free_tabpage(arg1);</a>
<a name="ln3231"> </a>
<a name="ln3232">exit_0:</a>
<a name="ln3233">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3234">    luaL_where(lstate, 1);</a>
<a name="ln3235">    if (err_param) {</a>
<a name="ln3236">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3237">      lua_pushstring(lstate, err_param);</a>
<a name="ln3238">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3239">    }</a>
<a name="ln3240">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3241">    api_clear_error(&amp;err);</a>
<a name="ln3242">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3243">    return lua_error(lstate);</a>
<a name="ln3244">  }</a>
<a name="ln3245"> </a>
<a name="ln3246">  return 1;</a>
<a name="ln3247">}</a>
<a name="ln3248"> </a>
<a name="ln3249">static int nlua_api_nvim_tabpage_get_var(lua_State *lstate)</a>
<a name="ln3250">{</a>
<a name="ln3251">  Error err = ERROR_INIT;</a>
<a name="ln3252">  char *err_param = 0;</a>
<a name="ln3253">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln3254">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln3255">    goto exit_0;</a>
<a name="ln3256">  }</a>
<a name="ln3257">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3258">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_get_var&quot;);</a>
<a name="ln3259">  }</a>
<a name="ln3260">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3261">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln3262">  }</a>
<a name="ln3263"> </a>
<a name="ln3264">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3265">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_1;</a>
<a name="ln3266">  }</a>
<a name="ln3267"> </a>
<a name="ln3268">  const Object ret = nvim_tabpage_get_var(arg1, arg2, &amp;err);</a>
<a name="ln3269">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln3270">api_free_object(ret);</a>
<a name="ln3271"> </a>
<a name="ln3272">  api_free_tabpage(arg1);</a>
<a name="ln3273">exit_1:</a>
<a name="ln3274">  api_free_string(arg2);</a>
<a name="ln3275"> </a>
<a name="ln3276">exit_0:</a>
<a name="ln3277">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3278">    luaL_where(lstate, 1);</a>
<a name="ln3279">    if (err_param) {</a>
<a name="ln3280">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3281">      lua_pushstring(lstate, err_param);</a>
<a name="ln3282">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3283">    }</a>
<a name="ln3284">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3285">    api_clear_error(&amp;err);</a>
<a name="ln3286">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3287">    return lua_error(lstate);</a>
<a name="ln3288">  }</a>
<a name="ln3289"> </a>
<a name="ln3290">  return 1;</a>
<a name="ln3291">}</a>
<a name="ln3292"> </a>
<a name="ln3293">static int nlua_api_nvim_tabpage_set_var(lua_State *lstate)</a>
<a name="ln3294">{</a>
<a name="ln3295">  Error err = ERROR_INIT;</a>
<a name="ln3296">  char *err_param = 0;</a>
<a name="ln3297">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln3298">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln3299">    goto exit_0;</a>
<a name="ln3300">  }</a>
<a name="ln3301">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3302">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_set_var&quot;);</a>
<a name="ln3303">  }</a>
<a name="ln3304">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln3305">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln3306">  }</a>
<a name="ln3307"> </a>
<a name="ln3308">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3309">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln3310">  }</a>
<a name="ln3311"> </a>
<a name="ln3312">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3313">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_2;</a>
<a name="ln3314">  }</a>
<a name="ln3315"> </a>
<a name="ln3316">  nvim_tabpage_set_var(arg1, arg2, arg3, &amp;err);</a>
<a name="ln3317"> </a>
<a name="ln3318">  api_free_tabpage(arg1);</a>
<a name="ln3319">exit_2:</a>
<a name="ln3320">  api_free_string(arg2);</a>
<a name="ln3321">exit_1:</a>
<a name="ln3322">  api_free_object(arg3);</a>
<a name="ln3323"> </a>
<a name="ln3324">exit_0:</a>
<a name="ln3325">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3326">    luaL_where(lstate, 1);</a>
<a name="ln3327">    if (err_param) {</a>
<a name="ln3328">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3329">      lua_pushstring(lstate, err_param);</a>
<a name="ln3330">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3331">    }</a>
<a name="ln3332">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3333">    api_clear_error(&amp;err);</a>
<a name="ln3334">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3335">    return lua_error(lstate);</a>
<a name="ln3336">  }</a>
<a name="ln3337"> </a>
<a name="ln3338">  return 0;</a>
<a name="ln3339">}</a>
<a name="ln3340"> </a>
<a name="ln3341">static int nlua_api_nvim_tabpage_del_var(lua_State *lstate)</a>
<a name="ln3342">{</a>
<a name="ln3343">  Error err = ERROR_INIT;</a>
<a name="ln3344">  char *err_param = 0;</a>
<a name="ln3345">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln3346">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln3347">    goto exit_0;</a>
<a name="ln3348">  }</a>
<a name="ln3349">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3350">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_del_var&quot;);</a>
<a name="ln3351">  }</a>
<a name="ln3352">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3353">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln3354">  }</a>
<a name="ln3355"> </a>
<a name="ln3356">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3357">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_1;</a>
<a name="ln3358">  }</a>
<a name="ln3359"> </a>
<a name="ln3360">  nvim_tabpage_del_var(arg1, arg2, &amp;err);</a>
<a name="ln3361"> </a>
<a name="ln3362">  api_free_tabpage(arg1);</a>
<a name="ln3363">exit_1:</a>
<a name="ln3364">  api_free_string(arg2);</a>
<a name="ln3365"> </a>
<a name="ln3366">exit_0:</a>
<a name="ln3367">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3368">    luaL_where(lstate, 1);</a>
<a name="ln3369">    if (err_param) {</a>
<a name="ln3370">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3371">      lua_pushstring(lstate, err_param);</a>
<a name="ln3372">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3373">    }</a>
<a name="ln3374">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3375">    api_clear_error(&amp;err);</a>
<a name="ln3376">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3377">    return lua_error(lstate);</a>
<a name="ln3378">  }</a>
<a name="ln3379"> </a>
<a name="ln3380">  return 0;</a>
<a name="ln3381">}</a>
<a name="ln3382"> </a>
<a name="ln3383">static int nlua_api_nvim_tabpage_get_win(lua_State *lstate)</a>
<a name="ln3384">{</a>
<a name="ln3385">  Error err = ERROR_INIT;</a>
<a name="ln3386">  char *err_param = 0;</a>
<a name="ln3387">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3388">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3389">    goto exit_0;</a>
<a name="ln3390">  }</a>
<a name="ln3391">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3392">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_get_win&quot;);</a>
<a name="ln3393">  }</a>
<a name="ln3394">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3395">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_0;</a>
<a name="ln3396">  }</a>
<a name="ln3397"> </a>
<a name="ln3398">  const Window ret = nvim_tabpage_get_win(arg1, &amp;err);</a>
<a name="ln3399">  nlua_push_Window(lstate, ret, true);</a>
<a name="ln3400">api_free_window(ret);</a>
<a name="ln3401"> </a>
<a name="ln3402">  api_free_tabpage(arg1);</a>
<a name="ln3403"> </a>
<a name="ln3404">exit_0:</a>
<a name="ln3405">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3406">    luaL_where(lstate, 1);</a>
<a name="ln3407">    if (err_param) {</a>
<a name="ln3408">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3409">      lua_pushstring(lstate, err_param);</a>
<a name="ln3410">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3411">    }</a>
<a name="ln3412">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3413">    api_clear_error(&amp;err);</a>
<a name="ln3414">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3415">    return lua_error(lstate);</a>
<a name="ln3416">  }</a>
<a name="ln3417"> </a>
<a name="ln3418">  return 1;</a>
<a name="ln3419">}</a>
<a name="ln3420"> </a>
<a name="ln3421">static int nlua_api_nvim_tabpage_get_number(lua_State *lstate)</a>
<a name="ln3422">{</a>
<a name="ln3423">  Error err = ERROR_INIT;</a>
<a name="ln3424">  char *err_param = 0;</a>
<a name="ln3425">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3426">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3427">    goto exit_0;</a>
<a name="ln3428">  }</a>
<a name="ln3429">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3430">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_get_number&quot;);</a>
<a name="ln3431">  }</a>
<a name="ln3432">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3433">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_0;</a>
<a name="ln3434">  }</a>
<a name="ln3435"> </a>
<a name="ln3436">  const Integer ret = nvim_tabpage_get_number(arg1, &amp;err);</a>
<a name="ln3437">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln3438">api_free_integer(ret);</a>
<a name="ln3439"> </a>
<a name="ln3440">  api_free_tabpage(arg1);</a>
<a name="ln3441"> </a>
<a name="ln3442">exit_0:</a>
<a name="ln3443">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3444">    luaL_where(lstate, 1);</a>
<a name="ln3445">    if (err_param) {</a>
<a name="ln3446">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3447">      lua_pushstring(lstate, err_param);</a>
<a name="ln3448">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3449">    }</a>
<a name="ln3450">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3451">    api_clear_error(&amp;err);</a>
<a name="ln3452">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3453">    return lua_error(lstate);</a>
<a name="ln3454">  }</a>
<a name="ln3455"> </a>
<a name="ln3456">  return 1;</a>
<a name="ln3457">}</a>
<a name="ln3458"> </a>
<a name="ln3459">static int nlua_api_nvim_tabpage_is_valid(lua_State *lstate)</a>
<a name="ln3460">{</a>
<a name="ln3461">  Error err = ERROR_INIT;</a>
<a name="ln3462">  char *err_param = 0;</a>
<a name="ln3463">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3464">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3465">    goto exit_0;</a>
<a name="ln3466">  }</a>
<a name="ln3467">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3468">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_is_valid&quot;);</a>
<a name="ln3469">  }</a>
<a name="ln3470">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3471">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_0;</a>
<a name="ln3472">  }</a>
<a name="ln3473"> </a>
<a name="ln3474">  const Boolean ret = nvim_tabpage_is_valid(arg1);</a>
<a name="ln3475">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln3476">api_free_boolean(ret);</a>
<a name="ln3477"> </a>
<a name="ln3478">  api_free_tabpage(arg1);</a>
<a name="ln3479"> </a>
<a name="ln3480">exit_0:</a>
<a name="ln3481">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3482">    luaL_where(lstate, 1);</a>
<a name="ln3483">    if (err_param) {</a>
<a name="ln3484">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3485">      lua_pushstring(lstate, err_param);</a>
<a name="ln3486">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3487">    }</a>
<a name="ln3488">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3489">    api_clear_error(&amp;err);</a>
<a name="ln3490">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3491">    return lua_error(lstate);</a>
<a name="ln3492">  }</a>
<a name="ln3493"> </a>
<a name="ln3494">  return 1;</a>
<a name="ln3495">}</a>
<a name="ln3496"> </a>
<a name="ln3497">static int nlua_api_nvim_get_hl_id_by_name(lua_State *lstate)</a>
<a name="ln3498">{</a>
<a name="ln3499">  Error err = ERROR_INIT;</a>
<a name="ln3500">  char *err_param = 0;</a>
<a name="ln3501">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3502">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3503">    goto exit_0;</a>
<a name="ln3504">  }</a>
<a name="ln3505">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3506">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_hl_id_by_name&quot;);</a>
<a name="ln3507">  }</a>
<a name="ln3508">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3509">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln3510">  }</a>
<a name="ln3511"> </a>
<a name="ln3512">  const Integer ret = nvim_get_hl_id_by_name(arg1);</a>
<a name="ln3513">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln3514">api_free_integer(ret);</a>
<a name="ln3515"> </a>
<a name="ln3516">  api_free_string(arg1);</a>
<a name="ln3517"> </a>
<a name="ln3518">exit_0:</a>
<a name="ln3519">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3520">    luaL_where(lstate, 1);</a>
<a name="ln3521">    if (err_param) {</a>
<a name="ln3522">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3523">      lua_pushstring(lstate, err_param);</a>
<a name="ln3524">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3525">    }</a>
<a name="ln3526">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3527">    api_clear_error(&amp;err);</a>
<a name="ln3528">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3529">    return lua_error(lstate);</a>
<a name="ln3530">  }</a>
<a name="ln3531"> </a>
<a name="ln3532">  return 1;</a>
<a name="ln3533">}</a>
<a name="ln3534"> </a>
<a name="ln3535">static int nlua_api_nvim_get_hl(lua_State *lstate)</a>
<a name="ln3536">{</a>
<a name="ln3537">  Error err = ERROR_INIT;</a>
<a name="ln3538">  char *err_param = 0;</a>
<a name="ln3539">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln3540">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln3541">    goto exit_0;</a>
<a name="ln3542">  }</a>
<a name="ln3543">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3544">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_hl&quot;);</a>
<a name="ln3545">  }</a>
<a name="ln3546">    KeyDict_get_highlight arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_get_highlight_get_field, &amp;err_param, &amp;err);</a>
<a name="ln3547">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln3548">  }</a>
<a name="ln3549"> </a>
<a name="ln3550">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3551">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_1;</a>
<a name="ln3552">  }</a>
<a name="ln3553"> </a>
<a name="ln3554">  Arena arena = ARENA_EMPTY;</a>
<a name="ln3555">  const Dictionary ret = nvim_get_hl(arg1, &amp;arg2, &amp;arena, &amp;err);</a>
<a name="ln3556">  nlua_push_Dictionary(lstate, ret, false);</a>
<a name="ln3557">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln3558"> </a>
<a name="ln3559">  api_free_integer(arg1);</a>
<a name="ln3560">exit_1:</a>
<a name="ln3561">  api_free_keydict_get_highlight(&amp;arg2);</a>
<a name="ln3562"> </a>
<a name="ln3563">exit_0:</a>
<a name="ln3564">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3565">    luaL_where(lstate, 1);</a>
<a name="ln3566">    if (err_param) {</a>
<a name="ln3567">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3568">      lua_pushstring(lstate, err_param);</a>
<a name="ln3569">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3570">    }</a>
<a name="ln3571">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3572">    api_clear_error(&amp;err);</a>
<a name="ln3573">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3574">    return lua_error(lstate);</a>
<a name="ln3575">  }</a>
<a name="ln3576"> </a>
<a name="ln3577">  return 1;</a>
<a name="ln3578">}</a>
<a name="ln3579"> </a>
<a name="ln3580">static int nlua_api_nvim_set_hl(lua_State *lstate)</a>
<a name="ln3581">{</a>
<a name="ln3582">  Error err = ERROR_INIT;</a>
<a name="ln3583">  char *err_param = 0;</a>
<a name="ln3584">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln3585">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln3586">    goto exit_0;</a>
<a name="ln3587">  }</a>
<a name="ln3588">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3589">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_hl&quot;);</a>
<a name="ln3590">  }</a>
<a name="ln3591">    KeyDict_highlight arg3 = { 0 }; nlua_pop_keydict(lstate, &amp;arg3, KeyDict_highlight_get_field, &amp;err_param, &amp;err);</a>
<a name="ln3592">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln3593">  }</a>
<a name="ln3594"> </a>
<a name="ln3595">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3596">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln3597">  }</a>
<a name="ln3598"> </a>
<a name="ln3599">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3600">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_2;</a>
<a name="ln3601">  }</a>
<a name="ln3602"> </a>
<a name="ln3603">  nvim_set_hl(arg1, arg2, &amp;arg3, &amp;err);</a>
<a name="ln3604"> </a>
<a name="ln3605">  api_free_integer(arg1);</a>
<a name="ln3606">exit_2:</a>
<a name="ln3607">  api_free_string(arg2);</a>
<a name="ln3608">exit_1:</a>
<a name="ln3609">  api_free_keydict_highlight(&amp;arg3);</a>
<a name="ln3610"> </a>
<a name="ln3611">exit_0:</a>
<a name="ln3612">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3613">    luaL_where(lstate, 1);</a>
<a name="ln3614">    if (err_param) {</a>
<a name="ln3615">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3616">      lua_pushstring(lstate, err_param);</a>
<a name="ln3617">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3618">    }</a>
<a name="ln3619">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3620">    api_clear_error(&amp;err);</a>
<a name="ln3621">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3622">    return lua_error(lstate);</a>
<a name="ln3623">  }</a>
<a name="ln3624"> </a>
<a name="ln3625">  return 0;</a>
<a name="ln3626">}</a>
<a name="ln3627"> </a>
<a name="ln3628">static int nlua_api_nvim_set_hl_ns(lua_State *lstate)</a>
<a name="ln3629">{</a>
<a name="ln3630">  Error err = ERROR_INIT;</a>
<a name="ln3631">  char *err_param = 0;</a>
<a name="ln3632">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3633">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3634">    goto exit_0;</a>
<a name="ln3635">  }</a>
<a name="ln3636">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3637">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_hl_ns&quot;);</a>
<a name="ln3638">  }</a>
<a name="ln3639">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3640">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_0;</a>
<a name="ln3641">  }</a>
<a name="ln3642"> </a>
<a name="ln3643">  nvim_set_hl_ns(arg1, &amp;err);</a>
<a name="ln3644"> </a>
<a name="ln3645">  api_free_integer(arg1);</a>
<a name="ln3646"> </a>
<a name="ln3647">exit_0:</a>
<a name="ln3648">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3649">    luaL_where(lstate, 1);</a>
<a name="ln3650">    if (err_param) {</a>
<a name="ln3651">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3652">      lua_pushstring(lstate, err_param);</a>
<a name="ln3653">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3654">    }</a>
<a name="ln3655">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3656">    api_clear_error(&amp;err);</a>
<a name="ln3657">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3658">    return lua_error(lstate);</a>
<a name="ln3659">  }</a>
<a name="ln3660"> </a>
<a name="ln3661">  return 0;</a>
<a name="ln3662">}</a>
<a name="ln3663"> </a>
<a name="ln3664">static int nlua_api_nvim_set_hl_ns_fast(lua_State *lstate)</a>
<a name="ln3665">{</a>
<a name="ln3666">  Error err = ERROR_INIT;</a>
<a name="ln3667">  char *err_param = 0;</a>
<a name="ln3668">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3669">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3670">    goto exit_0;</a>
<a name="ln3671">  }</a>
<a name="ln3672">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3673">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_0;</a>
<a name="ln3674">  }</a>
<a name="ln3675"> </a>
<a name="ln3676">  nvim_set_hl_ns_fast(arg1, &amp;err);</a>
<a name="ln3677"> </a>
<a name="ln3678">  api_free_integer(arg1);</a>
<a name="ln3679"> </a>
<a name="ln3680">exit_0:</a>
<a name="ln3681">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3682">    luaL_where(lstate, 1);</a>
<a name="ln3683">    if (err_param) {</a>
<a name="ln3684">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3685">      lua_pushstring(lstate, err_param);</a>
<a name="ln3686">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3687">    }</a>
<a name="ln3688">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3689">    api_clear_error(&amp;err);</a>
<a name="ln3690">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3691">    return lua_error(lstate);</a>
<a name="ln3692">  }</a>
<a name="ln3693"> </a>
<a name="ln3694">  return 0;</a>
<a name="ln3695">}</a>
<a name="ln3696"> </a>
<a name="ln3697">static int nlua_api_nvim_feedkeys(lua_State *lstate)</a>
<a name="ln3698">{</a>
<a name="ln3699">  Error err = ERROR_INIT;</a>
<a name="ln3700">  char *err_param = 0;</a>
<a name="ln3701">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln3702">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln3703">    goto exit_0;</a>
<a name="ln3704">  }</a>
<a name="ln3705">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3706">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_feedkeys&quot;);</a>
<a name="ln3707">  }</a>
<a name="ln3708">    const Boolean arg3 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln3709">  if (ERROR_SET(&amp;err)) {      err_param = &quot;escape_ks&quot;;      goto exit_0;</a>
<a name="ln3710">  }</a>
<a name="ln3711"> </a>
<a name="ln3712">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3713">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_1;</a>
<a name="ln3714">  }</a>
<a name="ln3715"> </a>
<a name="ln3716">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3717">  if (ERROR_SET(&amp;err)) {      err_param = &quot;keys&quot;;      goto exit_2;</a>
<a name="ln3718">  }</a>
<a name="ln3719"> </a>
<a name="ln3720">  nvim_feedkeys(arg1, arg2, arg3);</a>
<a name="ln3721"> </a>
<a name="ln3722">  api_free_string(arg1);</a>
<a name="ln3723">exit_2:</a>
<a name="ln3724">  api_free_string(arg2);</a>
<a name="ln3725">exit_1:</a>
<a name="ln3726">  api_free_boolean(arg3);</a>
<a name="ln3727"> </a>
<a name="ln3728">exit_0:</a>
<a name="ln3729">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3730">    luaL_where(lstate, 1);</a>
<a name="ln3731">    if (err_param) {</a>
<a name="ln3732">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3733">      lua_pushstring(lstate, err_param);</a>
<a name="ln3734">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3735">    }</a>
<a name="ln3736">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3737">    api_clear_error(&amp;err);</a>
<a name="ln3738">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3739">    return lua_error(lstate);</a>
<a name="ln3740">  }</a>
<a name="ln3741"> </a>
<a name="ln3742">  return 0;</a>
<a name="ln3743">}</a>
<a name="ln3744"> </a>
<a name="ln3745">static int nlua_api_nvim_input(lua_State *lstate)</a>
<a name="ln3746">{</a>
<a name="ln3747">  Error err = ERROR_INIT;</a>
<a name="ln3748">  char *err_param = 0;</a>
<a name="ln3749">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3750">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3751">    goto exit_0;</a>
<a name="ln3752">  }</a>
<a name="ln3753">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3754">  if (ERROR_SET(&amp;err)) {      err_param = &quot;keys&quot;;      goto exit_0;</a>
<a name="ln3755">  }</a>
<a name="ln3756"> </a>
<a name="ln3757">  const Integer ret = nvim_input(arg1);</a>
<a name="ln3758">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln3759">api_free_integer(ret);</a>
<a name="ln3760"> </a>
<a name="ln3761">  api_free_string(arg1);</a>
<a name="ln3762"> </a>
<a name="ln3763">exit_0:</a>
<a name="ln3764">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3765">    luaL_where(lstate, 1);</a>
<a name="ln3766">    if (err_param) {</a>
<a name="ln3767">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3768">      lua_pushstring(lstate, err_param);</a>
<a name="ln3769">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3770">    }</a>
<a name="ln3771">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3772">    api_clear_error(&amp;err);</a>
<a name="ln3773">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3774">    return lua_error(lstate);</a>
<a name="ln3775">  }</a>
<a name="ln3776"> </a>
<a name="ln3777">  return 1;</a>
<a name="ln3778">}</a>
<a name="ln3779"> </a>
<a name="ln3780">static int nlua_api_nvim_input_mouse(lua_State *lstate)</a>
<a name="ln3781">{</a>
<a name="ln3782">  Error err = ERROR_INIT;</a>
<a name="ln3783">  char *err_param = 0;</a>
<a name="ln3784">  if (lua_gettop(lstate) != 6) {</a>
<a name="ln3785">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 6 arguments&quot;);</a>
<a name="ln3786">    goto exit_0;</a>
<a name="ln3787">  }</a>
<a name="ln3788">    const Integer arg6 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3789">  if (ERROR_SET(&amp;err)) {      err_param = &quot;col&quot;;      goto exit_0;</a>
<a name="ln3790">  }</a>
<a name="ln3791"> </a>
<a name="ln3792">    const Integer arg5 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3793">  if (ERROR_SET(&amp;err)) {      err_param = &quot;row&quot;;      goto exit_1;</a>
<a name="ln3794">  }</a>
<a name="ln3795"> </a>
<a name="ln3796">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3797">  if (ERROR_SET(&amp;err)) {      err_param = &quot;grid&quot;;      goto exit_2;</a>
<a name="ln3798">  }</a>
<a name="ln3799"> </a>
<a name="ln3800">    const String arg3 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3801">  if (ERROR_SET(&amp;err)) {      err_param = &quot;modifier&quot;;      goto exit_3;</a>
<a name="ln3802">  }</a>
<a name="ln3803"> </a>
<a name="ln3804">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3805">  if (ERROR_SET(&amp;err)) {      err_param = &quot;action&quot;;      goto exit_4;</a>
<a name="ln3806">  }</a>
<a name="ln3807"> </a>
<a name="ln3808">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3809">  if (ERROR_SET(&amp;err)) {      err_param = &quot;button&quot;;      goto exit_5;</a>
<a name="ln3810">  }</a>
<a name="ln3811"> </a>
<a name="ln3812">  nvim_input_mouse(arg1, arg2, arg3, arg4, arg5, arg6, &amp;err);</a>
<a name="ln3813"> </a>
<a name="ln3814">  api_free_string(arg1);</a>
<a name="ln3815">exit_5:</a>
<a name="ln3816">  api_free_string(arg2);</a>
<a name="ln3817">exit_4:</a>
<a name="ln3818">  api_free_string(arg3);</a>
<a name="ln3819">exit_3:</a>
<a name="ln3820">  api_free_integer(arg4);</a>
<a name="ln3821">exit_2:</a>
<a name="ln3822">  api_free_integer(arg5);</a>
<a name="ln3823">exit_1:</a>
<a name="ln3824">  api_free_integer(arg6);</a>
<a name="ln3825"> </a>
<a name="ln3826">exit_0:</a>
<a name="ln3827">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3828">    luaL_where(lstate, 1);</a>
<a name="ln3829">    if (err_param) {</a>
<a name="ln3830">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3831">      lua_pushstring(lstate, err_param);</a>
<a name="ln3832">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3833">    }</a>
<a name="ln3834">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3835">    api_clear_error(&amp;err);</a>
<a name="ln3836">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3837">    return lua_error(lstate);</a>
<a name="ln3838">  }</a>
<a name="ln3839"> </a>
<a name="ln3840">  return 0;</a>
<a name="ln3841">}</a>
<a name="ln3842"> </a>
<a name="ln3843">static int nlua_api_nvim_replace_termcodes(lua_State *lstate)</a>
<a name="ln3844">{</a>
<a name="ln3845">  Error err = ERROR_INIT;</a>
<a name="ln3846">  char *err_param = 0;</a>
<a name="ln3847">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln3848">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln3849">    goto exit_0;</a>
<a name="ln3850">  }</a>
<a name="ln3851">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3852">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_replace_termcodes&quot;);</a>
<a name="ln3853">  }</a>
<a name="ln3854">    const Boolean arg4 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln3855">  if (ERROR_SET(&amp;err)) {      err_param = &quot;special&quot;;      goto exit_0;</a>
<a name="ln3856">  }</a>
<a name="ln3857"> </a>
<a name="ln3858">    const Boolean arg3 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln3859">  if (ERROR_SET(&amp;err)) {      err_param = &quot;do_lt&quot;;      goto exit_1;</a>
<a name="ln3860">  }</a>
<a name="ln3861"> </a>
<a name="ln3862">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln3863">  if (ERROR_SET(&amp;err)) {      err_param = &quot;from_part&quot;;      goto exit_2;</a>
<a name="ln3864">  }</a>
<a name="ln3865"> </a>
<a name="ln3866">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3867">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_3;</a>
<a name="ln3868">  }</a>
<a name="ln3869"> </a>
<a name="ln3870">  const String ret = nvim_replace_termcodes(arg1, arg2, arg3, arg4);</a>
<a name="ln3871">  nlua_push_String(lstate, ret, true);</a>
<a name="ln3872">api_free_string(ret);</a>
<a name="ln3873"> </a>
<a name="ln3874">  api_free_string(arg1);</a>
<a name="ln3875">exit_3:</a>
<a name="ln3876">  api_free_boolean(arg2);</a>
<a name="ln3877">exit_2:</a>
<a name="ln3878">  api_free_boolean(arg3);</a>
<a name="ln3879">exit_1:</a>
<a name="ln3880">  api_free_boolean(arg4);</a>
<a name="ln3881"> </a>
<a name="ln3882">exit_0:</a>
<a name="ln3883">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3884">    luaL_where(lstate, 1);</a>
<a name="ln3885">    if (err_param) {</a>
<a name="ln3886">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3887">      lua_pushstring(lstate, err_param);</a>
<a name="ln3888">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3889">    }</a>
<a name="ln3890">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3891">    api_clear_error(&amp;err);</a>
<a name="ln3892">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3893">    return lua_error(lstate);</a>
<a name="ln3894">  }</a>
<a name="ln3895"> </a>
<a name="ln3896">  return 1;</a>
<a name="ln3897">}</a>
<a name="ln3898"> </a>
<a name="ln3899">static int nlua_api_nvim_notify(lua_State *lstate)</a>
<a name="ln3900">{</a>
<a name="ln3901">  Error err = ERROR_INIT;</a>
<a name="ln3902">  char *err_param = 0;</a>
<a name="ln3903">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln3904">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln3905">    goto exit_0;</a>
<a name="ln3906">  }</a>
<a name="ln3907">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3908">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_notify&quot;);</a>
<a name="ln3909">  }</a>
<a name="ln3910">    const Dictionary arg3 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln3911">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln3912">  }</a>
<a name="ln3913"> </a>
<a name="ln3914">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3915">  if (ERROR_SET(&amp;err)) {      err_param = &quot;log_level&quot;;      goto exit_1;</a>
<a name="ln3916">  }</a>
<a name="ln3917"> </a>
<a name="ln3918">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3919">  if (ERROR_SET(&amp;err)) {      err_param = &quot;msg&quot;;      goto exit_2;</a>
<a name="ln3920">  }</a>
<a name="ln3921"> </a>
<a name="ln3922">  const Object ret = nvim_notify(arg1, arg2, arg3, &amp;err);</a>
<a name="ln3923">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln3924">api_free_object(ret);</a>
<a name="ln3925"> </a>
<a name="ln3926">  api_free_string(arg1);</a>
<a name="ln3927">exit_2:</a>
<a name="ln3928">  api_free_integer(arg2);</a>
<a name="ln3929">exit_1:</a>
<a name="ln3930">  api_free_dictionary(arg3);</a>
<a name="ln3931"> </a>
<a name="ln3932">exit_0:</a>
<a name="ln3933">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3934">    luaL_where(lstate, 1);</a>
<a name="ln3935">    if (err_param) {</a>
<a name="ln3936">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3937">      lua_pushstring(lstate, err_param);</a>
<a name="ln3938">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3939">    }</a>
<a name="ln3940">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3941">    api_clear_error(&amp;err);</a>
<a name="ln3942">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3943">    return lua_error(lstate);</a>
<a name="ln3944">  }</a>
<a name="ln3945"> </a>
<a name="ln3946">  return 1;</a>
<a name="ln3947">}</a>
<a name="ln3948"> </a>
<a name="ln3949">static int nlua_api_nvim_strwidth(lua_State *lstate)</a>
<a name="ln3950">{</a>
<a name="ln3951">  Error err = ERROR_INIT;</a>
<a name="ln3952">  char *err_param = 0;</a>
<a name="ln3953">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3954">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3955">    goto exit_0;</a>
<a name="ln3956">  }</a>
<a name="ln3957">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3958">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_strwidth&quot;);</a>
<a name="ln3959">  }</a>
<a name="ln3960">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3961">  if (ERROR_SET(&amp;err)) {      err_param = &quot;text&quot;;      goto exit_0;</a>
<a name="ln3962">  }</a>
<a name="ln3963"> </a>
<a name="ln3964">  const Integer ret = nvim_strwidth(arg1, &amp;err);</a>
<a name="ln3965">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln3966">api_free_integer(ret);</a>
<a name="ln3967"> </a>
<a name="ln3968">  api_free_string(arg1);</a>
<a name="ln3969"> </a>
<a name="ln3970">exit_0:</a>
<a name="ln3971">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3972">    luaL_where(lstate, 1);</a>
<a name="ln3973">    if (err_param) {</a>
<a name="ln3974">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3975">      lua_pushstring(lstate, err_param);</a>
<a name="ln3976">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3977">    }</a>
<a name="ln3978">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3979">    api_clear_error(&amp;err);</a>
<a name="ln3980">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3981">    return lua_error(lstate);</a>
<a name="ln3982">  }</a>
<a name="ln3983"> </a>
<a name="ln3984">  return 1;</a>
<a name="ln3985">}</a>
<a name="ln3986"> </a>
<a name="ln3987">static int nlua_api_nvim_list_runtime_paths(lua_State *lstate)</a>
<a name="ln3988">{</a>
<a name="ln3989">  Error err = ERROR_INIT;</a>
<a name="ln3990">  char *err_param = 0;</a>
<a name="ln3991">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln3992">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln3993">    goto exit_0;</a>
<a name="ln3994">  }</a>
<a name="ln3995">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3996">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_list_runtime_paths&quot;);</a>
<a name="ln3997">  }</a>
<a name="ln3998">  const ArrayOf(String) ret = nvim_list_runtime_paths(&amp;err);</a>
<a name="ln3999">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln4000">api_free_array(ret);</a>
<a name="ln4001"> </a>
<a name="ln4002"> </a>
<a name="ln4003">exit_0:</a>
<a name="ln4004">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4005">    luaL_where(lstate, 1);</a>
<a name="ln4006">    if (err_param) {</a>
<a name="ln4007">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4008">      lua_pushstring(lstate, err_param);</a>
<a name="ln4009">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4010">    }</a>
<a name="ln4011">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4012">    api_clear_error(&amp;err);</a>
<a name="ln4013">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4014">    return lua_error(lstate);</a>
<a name="ln4015">  }</a>
<a name="ln4016"> </a>
<a name="ln4017">  return 1;</a>
<a name="ln4018">}</a>
<a name="ln4019"> </a>
<a name="ln4020">static int nlua_api_nvim__runtime_inspect(lua_State *lstate)</a>
<a name="ln4021">{</a>
<a name="ln4022">  Error err = ERROR_INIT;</a>
<a name="ln4023">  char *err_param = 0;</a>
<a name="ln4024">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4025">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4026">    goto exit_0;</a>
<a name="ln4027">  }</a>
<a name="ln4028">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4029">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__runtime_inspect&quot;);</a>
<a name="ln4030">  }</a>
<a name="ln4031">  const Array ret = nvim__runtime_inspect();</a>
<a name="ln4032">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln4033">api_free_array(ret);</a>
<a name="ln4034"> </a>
<a name="ln4035"> </a>
<a name="ln4036">exit_0:</a>
<a name="ln4037">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4038">    luaL_where(lstate, 1);</a>
<a name="ln4039">    if (err_param) {</a>
<a name="ln4040">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4041">      lua_pushstring(lstate, err_param);</a>
<a name="ln4042">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4043">    }</a>
<a name="ln4044">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4045">    api_clear_error(&amp;err);</a>
<a name="ln4046">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4047">    return lua_error(lstate);</a>
<a name="ln4048">  }</a>
<a name="ln4049"> </a>
<a name="ln4050">  return 1;</a>
<a name="ln4051">}</a>
<a name="ln4052"> </a>
<a name="ln4053">static int nlua_api_nvim_get_runtime_file(lua_State *lstate)</a>
<a name="ln4054">{</a>
<a name="ln4055">  Error err = ERROR_INIT;</a>
<a name="ln4056">  char *err_param = 0;</a>
<a name="ln4057">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln4058">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln4059">    goto exit_0;</a>
<a name="ln4060">  }</a>
<a name="ln4061">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln4062">  if (ERROR_SET(&amp;err)) {      err_param = &quot;all&quot;;      goto exit_0;</a>
<a name="ln4063">  }</a>
<a name="ln4064"> </a>
<a name="ln4065">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4066">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln4067">  }</a>
<a name="ln4068"> </a>
<a name="ln4069">  const ArrayOf(String) ret = nvim_get_runtime_file(arg1, arg2, &amp;err);</a>
<a name="ln4070">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln4071">api_free_array(ret);</a>
<a name="ln4072"> </a>
<a name="ln4073">  api_free_string(arg1);</a>
<a name="ln4074">exit_1:</a>
<a name="ln4075">  api_free_boolean(arg2);</a>
<a name="ln4076"> </a>
<a name="ln4077">exit_0:</a>
<a name="ln4078">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4079">    luaL_where(lstate, 1);</a>
<a name="ln4080">    if (err_param) {</a>
<a name="ln4081">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4082">      lua_pushstring(lstate, err_param);</a>
<a name="ln4083">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4084">    }</a>
<a name="ln4085">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4086">    api_clear_error(&amp;err);</a>
<a name="ln4087">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4088">    return lua_error(lstate);</a>
<a name="ln4089">  }</a>
<a name="ln4090"> </a>
<a name="ln4091">  return 1;</a>
<a name="ln4092">}</a>
<a name="ln4093"> </a>
<a name="ln4094">static int nlua_api_nvim__get_lib_dir(lua_State *lstate)</a>
<a name="ln4095">{</a>
<a name="ln4096">  Error err = ERROR_INIT;</a>
<a name="ln4097">  char *err_param = 0;</a>
<a name="ln4098">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4099">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4100">    goto exit_0;</a>
<a name="ln4101">  }</a>
<a name="ln4102">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4103">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__get_lib_dir&quot;);</a>
<a name="ln4104">  }</a>
<a name="ln4105">  const String ret = nvim__get_lib_dir();</a>
<a name="ln4106">  nlua_push_String(lstate, ret, true);</a>
<a name="ln4107">api_free_string(ret);</a>
<a name="ln4108"> </a>
<a name="ln4109"> </a>
<a name="ln4110">exit_0:</a>
<a name="ln4111">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4112">    luaL_where(lstate, 1);</a>
<a name="ln4113">    if (err_param) {</a>
<a name="ln4114">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4115">      lua_pushstring(lstate, err_param);</a>
<a name="ln4116">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4117">    }</a>
<a name="ln4118">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4119">    api_clear_error(&amp;err);</a>
<a name="ln4120">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4121">    return lua_error(lstate);</a>
<a name="ln4122">  }</a>
<a name="ln4123"> </a>
<a name="ln4124">  return 1;</a>
<a name="ln4125">}</a>
<a name="ln4126"> </a>
<a name="ln4127">static int nlua_api_nvim__get_runtime(lua_State *lstate)</a>
<a name="ln4128">{</a>
<a name="ln4129">  Error err = ERROR_INIT;</a>
<a name="ln4130">  char *err_param = 0;</a>
<a name="ln4131">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln4132">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln4133">    goto exit_0;</a>
<a name="ln4134">  }</a>
<a name="ln4135">    KeyDict_runtime arg3 = { 0 }; nlua_pop_keydict(lstate, &amp;arg3, KeyDict_runtime_get_field, &amp;err_param, &amp;err);</a>
<a name="ln4136">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln4137">  }</a>
<a name="ln4138"> </a>
<a name="ln4139">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln4140">  if (ERROR_SET(&amp;err)) {      err_param = &quot;all&quot;;      goto exit_1;</a>
<a name="ln4141">  }</a>
<a name="ln4142"> </a>
<a name="ln4143">    const Array arg1 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln4144">  if (ERROR_SET(&amp;err)) {      err_param = &quot;pat&quot;;      goto exit_2;</a>
<a name="ln4145">  }</a>
<a name="ln4146"> </a>
<a name="ln4147">  const ArrayOf(String) ret = nvim__get_runtime(arg1, arg2, &amp;arg3, &amp;err);</a>
<a name="ln4148">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln4149">api_free_array(ret);</a>
<a name="ln4150"> </a>
<a name="ln4151">  api_free_array(arg1);</a>
<a name="ln4152">exit_2:</a>
<a name="ln4153">  api_free_boolean(arg2);</a>
<a name="ln4154">exit_1:</a>
<a name="ln4155">  api_free_keydict_runtime(&amp;arg3);</a>
<a name="ln4156"> </a>
<a name="ln4157">exit_0:</a>
<a name="ln4158">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4159">    luaL_where(lstate, 1);</a>
<a name="ln4160">    if (err_param) {</a>
<a name="ln4161">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4162">      lua_pushstring(lstate, err_param);</a>
<a name="ln4163">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4164">    }</a>
<a name="ln4165">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4166">    api_clear_error(&amp;err);</a>
<a name="ln4167">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4168">    return lua_error(lstate);</a>
<a name="ln4169">  }</a>
<a name="ln4170"> </a>
<a name="ln4171">  return 1;</a>
<a name="ln4172">}</a>
<a name="ln4173"> </a>
<a name="ln4174">static int nlua_api_nvim_set_current_dir(lua_State *lstate)</a>
<a name="ln4175">{</a>
<a name="ln4176">  Error err = ERROR_INIT;</a>
<a name="ln4177">  char *err_param = 0;</a>
<a name="ln4178">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4179">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4180">    goto exit_0;</a>
<a name="ln4181">  }</a>
<a name="ln4182">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4183">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_current_dir&quot;);</a>
<a name="ln4184">  }</a>
<a name="ln4185">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4186">  if (ERROR_SET(&amp;err)) {      err_param = &quot;dir&quot;;      goto exit_0;</a>
<a name="ln4187">  }</a>
<a name="ln4188"> </a>
<a name="ln4189">  nvim_set_current_dir(arg1, &amp;err);</a>
<a name="ln4190"> </a>
<a name="ln4191">  api_free_string(arg1);</a>
<a name="ln4192"> </a>
<a name="ln4193">exit_0:</a>
<a name="ln4194">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4195">    luaL_where(lstate, 1);</a>
<a name="ln4196">    if (err_param) {</a>
<a name="ln4197">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4198">      lua_pushstring(lstate, err_param);</a>
<a name="ln4199">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4200">    }</a>
<a name="ln4201">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4202">    api_clear_error(&amp;err);</a>
<a name="ln4203">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4204">    return lua_error(lstate);</a>
<a name="ln4205">  }</a>
<a name="ln4206"> </a>
<a name="ln4207">  return 0;</a>
<a name="ln4208">}</a>
<a name="ln4209"> </a>
<a name="ln4210">static int nlua_api_nvim_get_current_line(lua_State *lstate)</a>
<a name="ln4211">{</a>
<a name="ln4212">  Error err = ERROR_INIT;</a>
<a name="ln4213">  char *err_param = 0;</a>
<a name="ln4214">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4215">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4216">    goto exit_0;</a>
<a name="ln4217">  }</a>
<a name="ln4218">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4219">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_current_line&quot;);</a>
<a name="ln4220">  }</a>
<a name="ln4221">  const String ret = nvim_get_current_line(&amp;err);</a>
<a name="ln4222">  nlua_push_String(lstate, ret, true);</a>
<a name="ln4223">api_free_string(ret);</a>
<a name="ln4224"> </a>
<a name="ln4225"> </a>
<a name="ln4226">exit_0:</a>
<a name="ln4227">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4228">    luaL_where(lstate, 1);</a>
<a name="ln4229">    if (err_param) {</a>
<a name="ln4230">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4231">      lua_pushstring(lstate, err_param);</a>
<a name="ln4232">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4233">    }</a>
<a name="ln4234">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4235">    api_clear_error(&amp;err);</a>
<a name="ln4236">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4237">    return lua_error(lstate);</a>
<a name="ln4238">  }</a>
<a name="ln4239"> </a>
<a name="ln4240">  return 1;</a>
<a name="ln4241">}</a>
<a name="ln4242"> </a>
<a name="ln4243">static int nlua_api_nvim_set_current_line(lua_State *lstate)</a>
<a name="ln4244">{</a>
<a name="ln4245">  Error err = ERROR_INIT;</a>
<a name="ln4246">  char *err_param = 0;</a>
<a name="ln4247">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4248">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4249">    goto exit_0;</a>
<a name="ln4250">  }</a>
<a name="ln4251">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4252">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_current_line&quot;);</a>
<a name="ln4253">  }</a>
<a name="ln4254">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln4255">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln4256">    goto exit_0;</a>
<a name="ln4257">  }</a>
<a name="ln4258">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4259">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line&quot;;      goto exit_0;</a>
<a name="ln4260">  }</a>
<a name="ln4261"> </a>
<a name="ln4262">  nvim_set_current_line(arg1, &amp;err);</a>
<a name="ln4263"> </a>
<a name="ln4264">  api_free_string(arg1);</a>
<a name="ln4265"> </a>
<a name="ln4266">exit_0:</a>
<a name="ln4267">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4268">    luaL_where(lstate, 1);</a>
<a name="ln4269">    if (err_param) {</a>
<a name="ln4270">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4271">      lua_pushstring(lstate, err_param);</a>
<a name="ln4272">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4273">    }</a>
<a name="ln4274">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4275">    api_clear_error(&amp;err);</a>
<a name="ln4276">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4277">    return lua_error(lstate);</a>
<a name="ln4278">  }</a>
<a name="ln4279"> </a>
<a name="ln4280">  return 0;</a>
<a name="ln4281">}</a>
<a name="ln4282"> </a>
<a name="ln4283">static int nlua_api_nvim_del_current_line(lua_State *lstate)</a>
<a name="ln4284">{</a>
<a name="ln4285">  Error err = ERROR_INIT;</a>
<a name="ln4286">  char *err_param = 0;</a>
<a name="ln4287">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4288">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4289">    goto exit_0;</a>
<a name="ln4290">  }</a>
<a name="ln4291">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4292">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_current_line&quot;);</a>
<a name="ln4293">  }</a>
<a name="ln4294">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln4295">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln4296">    goto exit_0;</a>
<a name="ln4297">  }</a>
<a name="ln4298">  nvim_del_current_line(&amp;err);</a>
<a name="ln4299"> </a>
<a name="ln4300"> </a>
<a name="ln4301">exit_0:</a>
<a name="ln4302">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4303">    luaL_where(lstate, 1);</a>
<a name="ln4304">    if (err_param) {</a>
<a name="ln4305">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4306">      lua_pushstring(lstate, err_param);</a>
<a name="ln4307">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4308">    }</a>
<a name="ln4309">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4310">    api_clear_error(&amp;err);</a>
<a name="ln4311">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4312">    return lua_error(lstate);</a>
<a name="ln4313">  }</a>
<a name="ln4314"> </a>
<a name="ln4315">  return 0;</a>
<a name="ln4316">}</a>
<a name="ln4317"> </a>
<a name="ln4318">static int nlua_api_nvim_get_var(lua_State *lstate)</a>
<a name="ln4319">{</a>
<a name="ln4320">  Error err = ERROR_INIT;</a>
<a name="ln4321">  char *err_param = 0;</a>
<a name="ln4322">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4323">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4324">    goto exit_0;</a>
<a name="ln4325">  }</a>
<a name="ln4326">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4327">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_var&quot;);</a>
<a name="ln4328">  }</a>
<a name="ln4329">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4330">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln4331">  }</a>
<a name="ln4332"> </a>
<a name="ln4333">  const Object ret = nvim_get_var(arg1, &amp;err);</a>
<a name="ln4334">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln4335">api_free_object(ret);</a>
<a name="ln4336"> </a>
<a name="ln4337">  api_free_string(arg1);</a>
<a name="ln4338"> </a>
<a name="ln4339">exit_0:</a>
<a name="ln4340">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4341">    luaL_where(lstate, 1);</a>
<a name="ln4342">    if (err_param) {</a>
<a name="ln4343">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4344">      lua_pushstring(lstate, err_param);</a>
<a name="ln4345">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4346">    }</a>
<a name="ln4347">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4348">    api_clear_error(&amp;err);</a>
<a name="ln4349">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4350">    return lua_error(lstate);</a>
<a name="ln4351">  }</a>
<a name="ln4352"> </a>
<a name="ln4353">  return 1;</a>
<a name="ln4354">}</a>
<a name="ln4355"> </a>
<a name="ln4356">static int nlua_api_nvim_set_var(lua_State *lstate)</a>
<a name="ln4357">{</a>
<a name="ln4358">  Error err = ERROR_INIT;</a>
<a name="ln4359">  char *err_param = 0;</a>
<a name="ln4360">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln4361">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln4362">    goto exit_0;</a>
<a name="ln4363">  }</a>
<a name="ln4364">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4365">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_var&quot;);</a>
<a name="ln4366">  }</a>
<a name="ln4367">    const Object arg2 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln4368">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln4369">  }</a>
<a name="ln4370"> </a>
<a name="ln4371">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4372">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln4373">  }</a>
<a name="ln4374"> </a>
<a name="ln4375">  nvim_set_var(arg1, arg2, &amp;err);</a>
<a name="ln4376"> </a>
<a name="ln4377">  api_free_string(arg1);</a>
<a name="ln4378">exit_1:</a>
<a name="ln4379">  api_free_object(arg2);</a>
<a name="ln4380"> </a>
<a name="ln4381">exit_0:</a>
<a name="ln4382">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4383">    luaL_where(lstate, 1);</a>
<a name="ln4384">    if (err_param) {</a>
<a name="ln4385">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4386">      lua_pushstring(lstate, err_param);</a>
<a name="ln4387">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4388">    }</a>
<a name="ln4389">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4390">    api_clear_error(&amp;err);</a>
<a name="ln4391">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4392">    return lua_error(lstate);</a>
<a name="ln4393">  }</a>
<a name="ln4394"> </a>
<a name="ln4395">  return 0;</a>
<a name="ln4396">}</a>
<a name="ln4397"> </a>
<a name="ln4398">static int nlua_api_nvim_del_var(lua_State *lstate)</a>
<a name="ln4399">{</a>
<a name="ln4400">  Error err = ERROR_INIT;</a>
<a name="ln4401">  char *err_param = 0;</a>
<a name="ln4402">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4403">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4404">    goto exit_0;</a>
<a name="ln4405">  }</a>
<a name="ln4406">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4407">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_var&quot;);</a>
<a name="ln4408">  }</a>
<a name="ln4409">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4410">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln4411">  }</a>
<a name="ln4412"> </a>
<a name="ln4413">  nvim_del_var(arg1, &amp;err);</a>
<a name="ln4414"> </a>
<a name="ln4415">  api_free_string(arg1);</a>
<a name="ln4416"> </a>
<a name="ln4417">exit_0:</a>
<a name="ln4418">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4419">    luaL_where(lstate, 1);</a>
<a name="ln4420">    if (err_param) {</a>
<a name="ln4421">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4422">      lua_pushstring(lstate, err_param);</a>
<a name="ln4423">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4424">    }</a>
<a name="ln4425">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4426">    api_clear_error(&amp;err);</a>
<a name="ln4427">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4428">    return lua_error(lstate);</a>
<a name="ln4429">  }</a>
<a name="ln4430"> </a>
<a name="ln4431">  return 0;</a>
<a name="ln4432">}</a>
<a name="ln4433"> </a>
<a name="ln4434">static int nlua_api_nvim_get_vvar(lua_State *lstate)</a>
<a name="ln4435">{</a>
<a name="ln4436">  Error err = ERROR_INIT;</a>
<a name="ln4437">  char *err_param = 0;</a>
<a name="ln4438">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4439">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4440">    goto exit_0;</a>
<a name="ln4441">  }</a>
<a name="ln4442">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4443">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_vvar&quot;);</a>
<a name="ln4444">  }</a>
<a name="ln4445">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4446">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln4447">  }</a>
<a name="ln4448"> </a>
<a name="ln4449">  const Object ret = nvim_get_vvar(arg1, &amp;err);</a>
<a name="ln4450">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln4451">api_free_object(ret);</a>
<a name="ln4452"> </a>
<a name="ln4453">  api_free_string(arg1);</a>
<a name="ln4454"> </a>
<a name="ln4455">exit_0:</a>
<a name="ln4456">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4457">    luaL_where(lstate, 1);</a>
<a name="ln4458">    if (err_param) {</a>
<a name="ln4459">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4460">      lua_pushstring(lstate, err_param);</a>
<a name="ln4461">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4462">    }</a>
<a name="ln4463">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4464">    api_clear_error(&amp;err);</a>
<a name="ln4465">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4466">    return lua_error(lstate);</a>
<a name="ln4467">  }</a>
<a name="ln4468"> </a>
<a name="ln4469">  return 1;</a>
<a name="ln4470">}</a>
<a name="ln4471"> </a>
<a name="ln4472">static int nlua_api_nvim_set_vvar(lua_State *lstate)</a>
<a name="ln4473">{</a>
<a name="ln4474">  Error err = ERROR_INIT;</a>
<a name="ln4475">  char *err_param = 0;</a>
<a name="ln4476">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln4477">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln4478">    goto exit_0;</a>
<a name="ln4479">  }</a>
<a name="ln4480">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4481">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_vvar&quot;);</a>
<a name="ln4482">  }</a>
<a name="ln4483">    const Object arg2 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln4484">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln4485">  }</a>
<a name="ln4486"> </a>
<a name="ln4487">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4488">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln4489">  }</a>
<a name="ln4490"> </a>
<a name="ln4491">  nvim_set_vvar(arg1, arg2, &amp;err);</a>
<a name="ln4492"> </a>
<a name="ln4493">  api_free_string(arg1);</a>
<a name="ln4494">exit_1:</a>
<a name="ln4495">  api_free_object(arg2);</a>
<a name="ln4496"> </a>
<a name="ln4497">exit_0:</a>
<a name="ln4498">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4499">    luaL_where(lstate, 1);</a>
<a name="ln4500">    if (err_param) {</a>
<a name="ln4501">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4502">      lua_pushstring(lstate, err_param);</a>
<a name="ln4503">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4504">    }</a>
<a name="ln4505">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4506">    api_clear_error(&amp;err);</a>
<a name="ln4507">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4508">    return lua_error(lstate);</a>
<a name="ln4509">  }</a>
<a name="ln4510"> </a>
<a name="ln4511">  return 0;</a>
<a name="ln4512">}</a>
<a name="ln4513"> </a>
<a name="ln4514">static int nlua_api_nvim_echo(lua_State *lstate)</a>
<a name="ln4515">{</a>
<a name="ln4516">  Error err = ERROR_INIT;</a>
<a name="ln4517">  char *err_param = 0;</a>
<a name="ln4518">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln4519">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln4520">    goto exit_0;</a>
<a name="ln4521">  }</a>
<a name="ln4522">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4523">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_echo&quot;);</a>
<a name="ln4524">  }</a>
<a name="ln4525">    KeyDict_echo_opts arg3 = { 0 }; nlua_pop_keydict(lstate, &amp;arg3, KeyDict_echo_opts_get_field, &amp;err_param, &amp;err);</a>
<a name="ln4526">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln4527">  }</a>
<a name="ln4528"> </a>
<a name="ln4529">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln4530">  if (ERROR_SET(&amp;err)) {      err_param = &quot;history&quot;;      goto exit_1;</a>
<a name="ln4531">  }</a>
<a name="ln4532"> </a>
<a name="ln4533">    const Array arg1 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln4534">  if (ERROR_SET(&amp;err)) {      err_param = &quot;chunks&quot;;      goto exit_2;</a>
<a name="ln4535">  }</a>
<a name="ln4536"> </a>
<a name="ln4537">  nvim_echo(arg1, arg2, &amp;arg3, &amp;err);</a>
<a name="ln4538"> </a>
<a name="ln4539">  api_free_array(arg1);</a>
<a name="ln4540">exit_2:</a>
<a name="ln4541">  api_free_boolean(arg2);</a>
<a name="ln4542">exit_1:</a>
<a name="ln4543">  api_free_keydict_echo_opts(&amp;arg3);</a>
<a name="ln4544"> </a>
<a name="ln4545">exit_0:</a>
<a name="ln4546">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4547">    luaL_where(lstate, 1);</a>
<a name="ln4548">    if (err_param) {</a>
<a name="ln4549">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4550">      lua_pushstring(lstate, err_param);</a>
<a name="ln4551">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4552">    }</a>
<a name="ln4553">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4554">    api_clear_error(&amp;err);</a>
<a name="ln4555">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4556">    return lua_error(lstate);</a>
<a name="ln4557">  }</a>
<a name="ln4558"> </a>
<a name="ln4559">  return 0;</a>
<a name="ln4560">}</a>
<a name="ln4561"> </a>
<a name="ln4562">static int nlua_api_nvim_out_write(lua_State *lstate)</a>
<a name="ln4563">{</a>
<a name="ln4564">  Error err = ERROR_INIT;</a>
<a name="ln4565">  char *err_param = 0;</a>
<a name="ln4566">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4567">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4568">    goto exit_0;</a>
<a name="ln4569">  }</a>
<a name="ln4570">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4571">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_out_write&quot;);</a>
<a name="ln4572">  }</a>
<a name="ln4573">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4574">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_0;</a>
<a name="ln4575">  }</a>
<a name="ln4576"> </a>
<a name="ln4577">  nvim_out_write(arg1);</a>
<a name="ln4578"> </a>
<a name="ln4579">  api_free_string(arg1);</a>
<a name="ln4580"> </a>
<a name="ln4581">exit_0:</a>
<a name="ln4582">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4583">    luaL_where(lstate, 1);</a>
<a name="ln4584">    if (err_param) {</a>
<a name="ln4585">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4586">      lua_pushstring(lstate, err_param);</a>
<a name="ln4587">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4588">    }</a>
<a name="ln4589">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4590">    api_clear_error(&amp;err);</a>
<a name="ln4591">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4592">    return lua_error(lstate);</a>
<a name="ln4593">  }</a>
<a name="ln4594"> </a>
<a name="ln4595">  return 0;</a>
<a name="ln4596">}</a>
<a name="ln4597"> </a>
<a name="ln4598">static int nlua_api_nvim_err_write(lua_State *lstate)</a>
<a name="ln4599">{</a>
<a name="ln4600">  Error err = ERROR_INIT;</a>
<a name="ln4601">  char *err_param = 0;</a>
<a name="ln4602">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4603">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4604">    goto exit_0;</a>
<a name="ln4605">  }</a>
<a name="ln4606">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4607">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_err_write&quot;);</a>
<a name="ln4608">  }</a>
<a name="ln4609">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4610">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_0;</a>
<a name="ln4611">  }</a>
<a name="ln4612"> </a>
<a name="ln4613">  nvim_err_write(arg1);</a>
<a name="ln4614"> </a>
<a name="ln4615">  api_free_string(arg1);</a>
<a name="ln4616"> </a>
<a name="ln4617">exit_0:</a>
<a name="ln4618">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4619">    luaL_where(lstate, 1);</a>
<a name="ln4620">    if (err_param) {</a>
<a name="ln4621">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4622">      lua_pushstring(lstate, err_param);</a>
<a name="ln4623">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4624">    }</a>
<a name="ln4625">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4626">    api_clear_error(&amp;err);</a>
<a name="ln4627">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4628">    return lua_error(lstate);</a>
<a name="ln4629">  }</a>
<a name="ln4630"> </a>
<a name="ln4631">  return 0;</a>
<a name="ln4632">}</a>
<a name="ln4633"> </a>
<a name="ln4634">static int nlua_api_nvim_err_writeln(lua_State *lstate)</a>
<a name="ln4635">{</a>
<a name="ln4636">  Error err = ERROR_INIT;</a>
<a name="ln4637">  char *err_param = 0;</a>
<a name="ln4638">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4639">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4640">    goto exit_0;</a>
<a name="ln4641">  }</a>
<a name="ln4642">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4643">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_err_writeln&quot;);</a>
<a name="ln4644">  }</a>
<a name="ln4645">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4646">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_0;</a>
<a name="ln4647">  }</a>
<a name="ln4648"> </a>
<a name="ln4649">  nvim_err_writeln(arg1);</a>
<a name="ln4650"> </a>
<a name="ln4651">  api_free_string(arg1);</a>
<a name="ln4652"> </a>
<a name="ln4653">exit_0:</a>
<a name="ln4654">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4655">    luaL_where(lstate, 1);</a>
<a name="ln4656">    if (err_param) {</a>
<a name="ln4657">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4658">      lua_pushstring(lstate, err_param);</a>
<a name="ln4659">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4660">    }</a>
<a name="ln4661">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4662">    api_clear_error(&amp;err);</a>
<a name="ln4663">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4664">    return lua_error(lstate);</a>
<a name="ln4665">  }</a>
<a name="ln4666"> </a>
<a name="ln4667">  return 0;</a>
<a name="ln4668">}</a>
<a name="ln4669"> </a>
<a name="ln4670">static int nlua_api_nvim_list_bufs(lua_State *lstate)</a>
<a name="ln4671">{</a>
<a name="ln4672">  Error err = ERROR_INIT;</a>
<a name="ln4673">  char *err_param = 0;</a>
<a name="ln4674">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4675">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4676">    goto exit_0;</a>
<a name="ln4677">  }</a>
<a name="ln4678">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4679">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_list_bufs&quot;);</a>
<a name="ln4680">  }</a>
<a name="ln4681">  const ArrayOf(Buffer) ret = nvim_list_bufs();</a>
<a name="ln4682">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln4683">api_free_array(ret);</a>
<a name="ln4684"> </a>
<a name="ln4685"> </a>
<a name="ln4686">exit_0:</a>
<a name="ln4687">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4688">    luaL_where(lstate, 1);</a>
<a name="ln4689">    if (err_param) {</a>
<a name="ln4690">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4691">      lua_pushstring(lstate, err_param);</a>
<a name="ln4692">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4693">    }</a>
<a name="ln4694">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4695">    api_clear_error(&amp;err);</a>
<a name="ln4696">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4697">    return lua_error(lstate);</a>
<a name="ln4698">  }</a>
<a name="ln4699"> </a>
<a name="ln4700">  return 1;</a>
<a name="ln4701">}</a>
<a name="ln4702"> </a>
<a name="ln4703">static int nlua_api_nvim_get_current_buf(lua_State *lstate)</a>
<a name="ln4704">{</a>
<a name="ln4705">  Error err = ERROR_INIT;</a>
<a name="ln4706">  char *err_param = 0;</a>
<a name="ln4707">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4708">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4709">    goto exit_0;</a>
<a name="ln4710">  }</a>
<a name="ln4711">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4712">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_current_buf&quot;);</a>
<a name="ln4713">  }</a>
<a name="ln4714">  const Buffer ret = nvim_get_current_buf();</a>
<a name="ln4715">  nlua_push_Buffer(lstate, ret, true);</a>
<a name="ln4716">api_free_buffer(ret);</a>
<a name="ln4717"> </a>
<a name="ln4718"> </a>
<a name="ln4719">exit_0:</a>
<a name="ln4720">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4721">    luaL_where(lstate, 1);</a>
<a name="ln4722">    if (err_param) {</a>
<a name="ln4723">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4724">      lua_pushstring(lstate, err_param);</a>
<a name="ln4725">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4726">    }</a>
<a name="ln4727">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4728">    api_clear_error(&amp;err);</a>
<a name="ln4729">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4730">    return lua_error(lstate);</a>
<a name="ln4731">  }</a>
<a name="ln4732"> </a>
<a name="ln4733">  return 1;</a>
<a name="ln4734">}</a>
<a name="ln4735"> </a>
<a name="ln4736">static int nlua_api_nvim_set_current_buf(lua_State *lstate)</a>
<a name="ln4737">{</a>
<a name="ln4738">  Error err = ERROR_INIT;</a>
<a name="ln4739">  char *err_param = 0;</a>
<a name="ln4740">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4741">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4742">    goto exit_0;</a>
<a name="ln4743">  }</a>
<a name="ln4744">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4745">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_current_buf&quot;);</a>
<a name="ln4746">  }</a>
<a name="ln4747">  if (text_locked()) {</a>
<a name="ln4748">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, get_text_locked_msg());</a>
<a name="ln4749">    goto exit_0;</a>
<a name="ln4750">  }</a>
<a name="ln4751">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln4752">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln4753">  }</a>
<a name="ln4754"> </a>
<a name="ln4755">  nvim_set_current_buf(arg1, &amp;err);</a>
<a name="ln4756"> </a>
<a name="ln4757">  api_free_buffer(arg1);</a>
<a name="ln4758"> </a>
<a name="ln4759">exit_0:</a>
<a name="ln4760">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4761">    luaL_where(lstate, 1);</a>
<a name="ln4762">    if (err_param) {</a>
<a name="ln4763">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4764">      lua_pushstring(lstate, err_param);</a>
<a name="ln4765">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4766">    }</a>
<a name="ln4767">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4768">    api_clear_error(&amp;err);</a>
<a name="ln4769">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4770">    return lua_error(lstate);</a>
<a name="ln4771">  }</a>
<a name="ln4772"> </a>
<a name="ln4773">  return 0;</a>
<a name="ln4774">}</a>
<a name="ln4775"> </a>
<a name="ln4776">static int nlua_api_nvim_list_wins(lua_State *lstate)</a>
<a name="ln4777">{</a>
<a name="ln4778">  Error err = ERROR_INIT;</a>
<a name="ln4779">  char *err_param = 0;</a>
<a name="ln4780">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4781">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4782">    goto exit_0;</a>
<a name="ln4783">  }</a>
<a name="ln4784">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4785">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_list_wins&quot;);</a>
<a name="ln4786">  }</a>
<a name="ln4787">  const ArrayOf(Window) ret = nvim_list_wins();</a>
<a name="ln4788">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln4789">api_free_array(ret);</a>
<a name="ln4790"> </a>
<a name="ln4791"> </a>
<a name="ln4792">exit_0:</a>
<a name="ln4793">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4794">    luaL_where(lstate, 1);</a>
<a name="ln4795">    if (err_param) {</a>
<a name="ln4796">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4797">      lua_pushstring(lstate, err_param);</a>
<a name="ln4798">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4799">    }</a>
<a name="ln4800">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4801">    api_clear_error(&amp;err);</a>
<a name="ln4802">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4803">    return lua_error(lstate);</a>
<a name="ln4804">  }</a>
<a name="ln4805"> </a>
<a name="ln4806">  return 1;</a>
<a name="ln4807">}</a>
<a name="ln4808"> </a>
<a name="ln4809">static int nlua_api_nvim_get_current_win(lua_State *lstate)</a>
<a name="ln4810">{</a>
<a name="ln4811">  Error err = ERROR_INIT;</a>
<a name="ln4812">  char *err_param = 0;</a>
<a name="ln4813">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4814">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4815">    goto exit_0;</a>
<a name="ln4816">  }</a>
<a name="ln4817">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4818">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_current_win&quot;);</a>
<a name="ln4819">  }</a>
<a name="ln4820">  const Window ret = nvim_get_current_win();</a>
<a name="ln4821">  nlua_push_Window(lstate, ret, true);</a>
<a name="ln4822">api_free_window(ret);</a>
<a name="ln4823"> </a>
<a name="ln4824"> </a>
<a name="ln4825">exit_0:</a>
<a name="ln4826">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4827">    luaL_where(lstate, 1);</a>
<a name="ln4828">    if (err_param) {</a>
<a name="ln4829">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4830">      lua_pushstring(lstate, err_param);</a>
<a name="ln4831">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4832">    }</a>
<a name="ln4833">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4834">    api_clear_error(&amp;err);</a>
<a name="ln4835">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4836">    return lua_error(lstate);</a>
<a name="ln4837">  }</a>
<a name="ln4838"> </a>
<a name="ln4839">  return 1;</a>
<a name="ln4840">}</a>
<a name="ln4841"> </a>
<a name="ln4842">static int nlua_api_nvim_set_current_win(lua_State *lstate)</a>
<a name="ln4843">{</a>
<a name="ln4844">  Error err = ERROR_INIT;</a>
<a name="ln4845">  char *err_param = 0;</a>
<a name="ln4846">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4847">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4848">    goto exit_0;</a>
<a name="ln4849">  }</a>
<a name="ln4850">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4851">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_current_win&quot;);</a>
<a name="ln4852">  }</a>
<a name="ln4853">  if (text_locked()) {</a>
<a name="ln4854">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, get_text_locked_msg());</a>
<a name="ln4855">    goto exit_0;</a>
<a name="ln4856">  }</a>
<a name="ln4857">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln4858">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln4859">  }</a>
<a name="ln4860"> </a>
<a name="ln4861">  nvim_set_current_win(arg1, &amp;err);</a>
<a name="ln4862"> </a>
<a name="ln4863">  api_free_window(arg1);</a>
<a name="ln4864"> </a>
<a name="ln4865">exit_0:</a>
<a name="ln4866">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4867">    luaL_where(lstate, 1);</a>
<a name="ln4868">    if (err_param) {</a>
<a name="ln4869">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4870">      lua_pushstring(lstate, err_param);</a>
<a name="ln4871">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4872">    }</a>
<a name="ln4873">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4874">    api_clear_error(&amp;err);</a>
<a name="ln4875">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4876">    return lua_error(lstate);</a>
<a name="ln4877">  }</a>
<a name="ln4878"> </a>
<a name="ln4879">  return 0;</a>
<a name="ln4880">}</a>
<a name="ln4881"> </a>
<a name="ln4882">static int nlua_api_nvim_create_buf(lua_State *lstate)</a>
<a name="ln4883">{</a>
<a name="ln4884">  Error err = ERROR_INIT;</a>
<a name="ln4885">  char *err_param = 0;</a>
<a name="ln4886">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln4887">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln4888">    goto exit_0;</a>
<a name="ln4889">  }</a>
<a name="ln4890">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4891">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_create_buf&quot;);</a>
<a name="ln4892">  }</a>
<a name="ln4893">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln4894">  if (ERROR_SET(&amp;err)) {      err_param = &quot;scratch&quot;;      goto exit_0;</a>
<a name="ln4895">  }</a>
<a name="ln4896"> </a>
<a name="ln4897">    const Boolean arg1 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln4898">  if (ERROR_SET(&amp;err)) {      err_param = &quot;listed&quot;;      goto exit_1;</a>
<a name="ln4899">  }</a>
<a name="ln4900"> </a>
<a name="ln4901">  const Buffer ret = nvim_create_buf(arg1, arg2, &amp;err);</a>
<a name="ln4902">  nlua_push_Buffer(lstate, ret, true);</a>
<a name="ln4903">api_free_buffer(ret);</a>
<a name="ln4904"> </a>
<a name="ln4905">  api_free_boolean(arg1);</a>
<a name="ln4906">exit_1:</a>
<a name="ln4907">  api_free_boolean(arg2);</a>
<a name="ln4908"> </a>
<a name="ln4909">exit_0:</a>
<a name="ln4910">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4911">    luaL_where(lstate, 1);</a>
<a name="ln4912">    if (err_param) {</a>
<a name="ln4913">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4914">      lua_pushstring(lstate, err_param);</a>
<a name="ln4915">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4916">    }</a>
<a name="ln4917">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4918">    api_clear_error(&amp;err);</a>
<a name="ln4919">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4920">    return lua_error(lstate);</a>
<a name="ln4921">  }</a>
<a name="ln4922"> </a>
<a name="ln4923">  return 1;</a>
<a name="ln4924">}</a>
<a name="ln4925"> </a>
<a name="ln4926">static int nlua_api_nvim_open_term(lua_State *lstate)</a>
<a name="ln4927">{</a>
<a name="ln4928">  Error err = ERROR_INIT;</a>
<a name="ln4929">  char *err_param = 0;</a>
<a name="ln4930">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln4931">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln4932">    goto exit_0;</a>
<a name="ln4933">  }</a>
<a name="ln4934">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4935">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_open_term&quot;);</a>
<a name="ln4936">  }</a>
<a name="ln4937">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln4938">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln4939">    goto exit_0;</a>
<a name="ln4940">  }</a>
<a name="ln4941">    const DictionaryOf(LuaRef) arg2 = nlua_pop_Dictionary(lstate, true, &amp;err);</a>
<a name="ln4942">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln4943">  }</a>
<a name="ln4944"> </a>
<a name="ln4945">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln4946">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln4947">  }</a>
<a name="ln4948"> </a>
<a name="ln4949">  const Integer ret = nvim_open_term(arg1, arg2, &amp;err);</a>
<a name="ln4950">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln4951">api_free_integer(ret);</a>
<a name="ln4952"> </a>
<a name="ln4953">  api_free_buffer(arg1);</a>
<a name="ln4954">exit_1:</a>
<a name="ln4955">  api_free_dictionary(arg2);</a>
<a name="ln4956"> </a>
<a name="ln4957">exit_0:</a>
<a name="ln4958">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4959">    luaL_where(lstate, 1);</a>
<a name="ln4960">    if (err_param) {</a>
<a name="ln4961">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4962">      lua_pushstring(lstate, err_param);</a>
<a name="ln4963">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4964">    }</a>
<a name="ln4965">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4966">    api_clear_error(&amp;err);</a>
<a name="ln4967">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4968">    return lua_error(lstate);</a>
<a name="ln4969">  }</a>
<a name="ln4970"> </a>
<a name="ln4971">  return 1;</a>
<a name="ln4972">}</a>
<a name="ln4973"> </a>
<a name="ln4974">static int nlua_api_nvim_chan_send(lua_State *lstate)</a>
<a name="ln4975">{</a>
<a name="ln4976">  Error err = ERROR_INIT;</a>
<a name="ln4977">  char *err_param = 0;</a>
<a name="ln4978">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln4979">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln4980">    goto exit_0;</a>
<a name="ln4981">  }</a>
<a name="ln4982">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4983">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_chan_send&quot;);</a>
<a name="ln4984">  }</a>
<a name="ln4985">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4986">  if (ERROR_SET(&amp;err)) {      err_param = &quot;data&quot;;      goto exit_0;</a>
<a name="ln4987">  }</a>
<a name="ln4988"> </a>
<a name="ln4989">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln4990">  if (ERROR_SET(&amp;err)) {      err_param = &quot;chan&quot;;      goto exit_1;</a>
<a name="ln4991">  }</a>
<a name="ln4992"> </a>
<a name="ln4993">  nvim_chan_send(arg1, arg2, &amp;err);</a>
<a name="ln4994"> </a>
<a name="ln4995">  api_free_integer(arg1);</a>
<a name="ln4996">exit_1:</a>
<a name="ln4997">  api_free_string(arg2);</a>
<a name="ln4998"> </a>
<a name="ln4999">exit_0:</a>
<a name="ln5000">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5001">    luaL_where(lstate, 1);</a>
<a name="ln5002">    if (err_param) {</a>
<a name="ln5003">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5004">      lua_pushstring(lstate, err_param);</a>
<a name="ln5005">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5006">    }</a>
<a name="ln5007">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5008">    api_clear_error(&amp;err);</a>
<a name="ln5009">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5010">    return lua_error(lstate);</a>
<a name="ln5011">  }</a>
<a name="ln5012"> </a>
<a name="ln5013">  return 0;</a>
<a name="ln5014">}</a>
<a name="ln5015"> </a>
<a name="ln5016">static int nlua_api_nvim_list_tabpages(lua_State *lstate)</a>
<a name="ln5017">{</a>
<a name="ln5018">  Error err = ERROR_INIT;</a>
<a name="ln5019">  char *err_param = 0;</a>
<a name="ln5020">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5021">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5022">    goto exit_0;</a>
<a name="ln5023">  }</a>
<a name="ln5024">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5025">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_list_tabpages&quot;);</a>
<a name="ln5026">  }</a>
<a name="ln5027">  const ArrayOf(Tabpage) ret = nvim_list_tabpages();</a>
<a name="ln5028">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5029">api_free_array(ret);</a>
<a name="ln5030"> </a>
<a name="ln5031"> </a>
<a name="ln5032">exit_0:</a>
<a name="ln5033">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5034">    luaL_where(lstate, 1);</a>
<a name="ln5035">    if (err_param) {</a>
<a name="ln5036">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5037">      lua_pushstring(lstate, err_param);</a>
<a name="ln5038">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5039">    }</a>
<a name="ln5040">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5041">    api_clear_error(&amp;err);</a>
<a name="ln5042">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5043">    return lua_error(lstate);</a>
<a name="ln5044">  }</a>
<a name="ln5045"> </a>
<a name="ln5046">  return 1;</a>
<a name="ln5047">}</a>
<a name="ln5048"> </a>
<a name="ln5049">static int nlua_api_nvim_get_current_tabpage(lua_State *lstate)</a>
<a name="ln5050">{</a>
<a name="ln5051">  Error err = ERROR_INIT;</a>
<a name="ln5052">  char *err_param = 0;</a>
<a name="ln5053">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5054">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5055">    goto exit_0;</a>
<a name="ln5056">  }</a>
<a name="ln5057">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5058">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_current_tabpage&quot;);</a>
<a name="ln5059">  }</a>
<a name="ln5060">  const Tabpage ret = nvim_get_current_tabpage();</a>
<a name="ln5061">  nlua_push_Tabpage(lstate, ret, true);</a>
<a name="ln5062">api_free_tabpage(ret);</a>
<a name="ln5063"> </a>
<a name="ln5064"> </a>
<a name="ln5065">exit_0:</a>
<a name="ln5066">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5067">    luaL_where(lstate, 1);</a>
<a name="ln5068">    if (err_param) {</a>
<a name="ln5069">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5070">      lua_pushstring(lstate, err_param);</a>
<a name="ln5071">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5072">    }</a>
<a name="ln5073">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5074">    api_clear_error(&amp;err);</a>
<a name="ln5075">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5076">    return lua_error(lstate);</a>
<a name="ln5077">  }</a>
<a name="ln5078"> </a>
<a name="ln5079">  return 1;</a>
<a name="ln5080">}</a>
<a name="ln5081"> </a>
<a name="ln5082">static int nlua_api_nvim_set_current_tabpage(lua_State *lstate)</a>
<a name="ln5083">{</a>
<a name="ln5084">  Error err = ERROR_INIT;</a>
<a name="ln5085">  char *err_param = 0;</a>
<a name="ln5086">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5087">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5088">    goto exit_0;</a>
<a name="ln5089">  }</a>
<a name="ln5090">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5091">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_current_tabpage&quot;);</a>
<a name="ln5092">  }</a>
<a name="ln5093">  if (text_locked()) {</a>
<a name="ln5094">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, get_text_locked_msg());</a>
<a name="ln5095">    goto exit_0;</a>
<a name="ln5096">  }</a>
<a name="ln5097">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln5098">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_0;</a>
<a name="ln5099">  }</a>
<a name="ln5100"> </a>
<a name="ln5101">  nvim_set_current_tabpage(arg1, &amp;err);</a>
<a name="ln5102"> </a>
<a name="ln5103">  api_free_tabpage(arg1);</a>
<a name="ln5104"> </a>
<a name="ln5105">exit_0:</a>
<a name="ln5106">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5107">    luaL_where(lstate, 1);</a>
<a name="ln5108">    if (err_param) {</a>
<a name="ln5109">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5110">      lua_pushstring(lstate, err_param);</a>
<a name="ln5111">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5112">    }</a>
<a name="ln5113">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5114">    api_clear_error(&amp;err);</a>
<a name="ln5115">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5116">    return lua_error(lstate);</a>
<a name="ln5117">  }</a>
<a name="ln5118"> </a>
<a name="ln5119">  return 0;</a>
<a name="ln5120">}</a>
<a name="ln5121"> </a>
<a name="ln5122">static int nlua_api_nvim_paste(lua_State *lstate)</a>
<a name="ln5123">{</a>
<a name="ln5124">  Error err = ERROR_INIT;</a>
<a name="ln5125">  char *err_param = 0;</a>
<a name="ln5126">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln5127">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln5128">    goto exit_0;</a>
<a name="ln5129">  }</a>
<a name="ln5130">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5131">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_paste&quot;);</a>
<a name="ln5132">  }</a>
<a name="ln5133">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln5134">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln5135">    goto exit_0;</a>
<a name="ln5136">  }</a>
<a name="ln5137">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5138">  if (ERROR_SET(&amp;err)) {      err_param = &quot;phase&quot;;      goto exit_0;</a>
<a name="ln5139">  }</a>
<a name="ln5140"> </a>
<a name="ln5141">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln5142">  if (ERROR_SET(&amp;err)) {      err_param = &quot;crlf&quot;;      goto exit_1;</a>
<a name="ln5143">  }</a>
<a name="ln5144"> </a>
<a name="ln5145">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5146">  if (ERROR_SET(&amp;err)) {      err_param = &quot;data&quot;;      goto exit_2;</a>
<a name="ln5147">  }</a>
<a name="ln5148"> </a>
<a name="ln5149">  const Boolean ret = nvim_paste(arg1, arg2, arg3, &amp;err);</a>
<a name="ln5150">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln5151">api_free_boolean(ret);</a>
<a name="ln5152"> </a>
<a name="ln5153">  api_free_string(arg1);</a>
<a name="ln5154">exit_2:</a>
<a name="ln5155">  api_free_boolean(arg2);</a>
<a name="ln5156">exit_1:</a>
<a name="ln5157">  api_free_integer(arg3);</a>
<a name="ln5158"> </a>
<a name="ln5159">exit_0:</a>
<a name="ln5160">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5161">    luaL_where(lstate, 1);</a>
<a name="ln5162">    if (err_param) {</a>
<a name="ln5163">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5164">      lua_pushstring(lstate, err_param);</a>
<a name="ln5165">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5166">    }</a>
<a name="ln5167">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5168">    api_clear_error(&amp;err);</a>
<a name="ln5169">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5170">    return lua_error(lstate);</a>
<a name="ln5171">  }</a>
<a name="ln5172"> </a>
<a name="ln5173">  return 1;</a>
<a name="ln5174">}</a>
<a name="ln5175"> </a>
<a name="ln5176">static int nlua_api_nvim_put(lua_State *lstate)</a>
<a name="ln5177">{</a>
<a name="ln5178">  Error err = ERROR_INIT;</a>
<a name="ln5179">  char *err_param = 0;</a>
<a name="ln5180">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln5181">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln5182">    goto exit_0;</a>
<a name="ln5183">  }</a>
<a name="ln5184">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5185">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_put&quot;);</a>
<a name="ln5186">  }</a>
<a name="ln5187">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln5188">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln5189">    goto exit_0;</a>
<a name="ln5190">  }</a>
<a name="ln5191">    const Boolean arg4 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln5192">  if (ERROR_SET(&amp;err)) {      err_param = &quot;follow&quot;;      goto exit_0;</a>
<a name="ln5193">  }</a>
<a name="ln5194"> </a>
<a name="ln5195">    const Boolean arg3 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln5196">  if (ERROR_SET(&amp;err)) {      err_param = &quot;after&quot;;      goto exit_1;</a>
<a name="ln5197">  }</a>
<a name="ln5198"> </a>
<a name="ln5199">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5200">  if (ERROR_SET(&amp;err)) {      err_param = &quot;type&quot;;      goto exit_2;</a>
<a name="ln5201">  }</a>
<a name="ln5202"> </a>
<a name="ln5203">    const ArrayOf(String) arg1 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln5204">  if (ERROR_SET(&amp;err)) {      err_param = &quot;lines&quot;;      goto exit_3;</a>
<a name="ln5205">  }</a>
<a name="ln5206"> </a>
<a name="ln5207">  nvim_put(arg1, arg2, arg3, arg4, &amp;err);</a>
<a name="ln5208"> </a>
<a name="ln5209">  api_free_array(arg1);</a>
<a name="ln5210">exit_3:</a>
<a name="ln5211">  api_free_string(arg2);</a>
<a name="ln5212">exit_2:</a>
<a name="ln5213">  api_free_boolean(arg3);</a>
<a name="ln5214">exit_1:</a>
<a name="ln5215">  api_free_boolean(arg4);</a>
<a name="ln5216"> </a>
<a name="ln5217">exit_0:</a>
<a name="ln5218">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5219">    luaL_where(lstate, 1);</a>
<a name="ln5220">    if (err_param) {</a>
<a name="ln5221">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5222">      lua_pushstring(lstate, err_param);</a>
<a name="ln5223">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5224">    }</a>
<a name="ln5225">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5226">    api_clear_error(&amp;err);</a>
<a name="ln5227">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5228">    return lua_error(lstate);</a>
<a name="ln5229">  }</a>
<a name="ln5230"> </a>
<a name="ln5231">  return 0;</a>
<a name="ln5232">}</a>
<a name="ln5233"> </a>
<a name="ln5234">static int nlua_api_nvim_get_color_by_name(lua_State *lstate)</a>
<a name="ln5235">{</a>
<a name="ln5236">  Error err = ERROR_INIT;</a>
<a name="ln5237">  char *err_param = 0;</a>
<a name="ln5238">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5239">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5240">    goto exit_0;</a>
<a name="ln5241">  }</a>
<a name="ln5242">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5243">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_color_by_name&quot;);</a>
<a name="ln5244">  }</a>
<a name="ln5245">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5246">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln5247">  }</a>
<a name="ln5248"> </a>
<a name="ln5249">  const Integer ret = nvim_get_color_by_name(arg1);</a>
<a name="ln5250">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln5251">api_free_integer(ret);</a>
<a name="ln5252"> </a>
<a name="ln5253">  api_free_string(arg1);</a>
<a name="ln5254"> </a>
<a name="ln5255">exit_0:</a>
<a name="ln5256">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5257">    luaL_where(lstate, 1);</a>
<a name="ln5258">    if (err_param) {</a>
<a name="ln5259">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5260">      lua_pushstring(lstate, err_param);</a>
<a name="ln5261">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5262">    }</a>
<a name="ln5263">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5264">    api_clear_error(&amp;err);</a>
<a name="ln5265">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5266">    return lua_error(lstate);</a>
<a name="ln5267">  }</a>
<a name="ln5268"> </a>
<a name="ln5269">  return 1;</a>
<a name="ln5270">}</a>
<a name="ln5271"> </a>
<a name="ln5272">static int nlua_api_nvim_get_color_map(lua_State *lstate)</a>
<a name="ln5273">{</a>
<a name="ln5274">  Error err = ERROR_INIT;</a>
<a name="ln5275">  char *err_param = 0;</a>
<a name="ln5276">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5277">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5278">    goto exit_0;</a>
<a name="ln5279">  }</a>
<a name="ln5280">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5281">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_color_map&quot;);</a>
<a name="ln5282">  }</a>
<a name="ln5283">  const Dictionary ret = nvim_get_color_map();</a>
<a name="ln5284">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln5285">api_free_dictionary(ret);</a>
<a name="ln5286"> </a>
<a name="ln5287"> </a>
<a name="ln5288">exit_0:</a>
<a name="ln5289">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5290">    luaL_where(lstate, 1);</a>
<a name="ln5291">    if (err_param) {</a>
<a name="ln5292">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5293">      lua_pushstring(lstate, err_param);</a>
<a name="ln5294">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5295">    }</a>
<a name="ln5296">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5297">    api_clear_error(&amp;err);</a>
<a name="ln5298">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5299">    return lua_error(lstate);</a>
<a name="ln5300">  }</a>
<a name="ln5301"> </a>
<a name="ln5302">  return 1;</a>
<a name="ln5303">}</a>
<a name="ln5304"> </a>
<a name="ln5305">static int nlua_api_nvim_get_context(lua_State *lstate)</a>
<a name="ln5306">{</a>
<a name="ln5307">  Error err = ERROR_INIT;</a>
<a name="ln5308">  char *err_param = 0;</a>
<a name="ln5309">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5310">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5311">    goto exit_0;</a>
<a name="ln5312">  }</a>
<a name="ln5313">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5314">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_context&quot;);</a>
<a name="ln5315">  }</a>
<a name="ln5316">    KeyDict_context arg1 = { 0 }; nlua_pop_keydict(lstate, &amp;arg1, KeyDict_context_get_field, &amp;err_param, &amp;err);</a>
<a name="ln5317">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln5318">  }</a>
<a name="ln5319"> </a>
<a name="ln5320">  const Dictionary ret = nvim_get_context(&amp;arg1, &amp;err);</a>
<a name="ln5321">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln5322">api_free_dictionary(ret);</a>
<a name="ln5323"> </a>
<a name="ln5324">exit_1:</a>
<a name="ln5325">  api_free_keydict_context(&amp;arg1);</a>
<a name="ln5326"> </a>
<a name="ln5327">exit_0:</a>
<a name="ln5328">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5329">    luaL_where(lstate, 1);</a>
<a name="ln5330">    if (err_param) {</a>
<a name="ln5331">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5332">      lua_pushstring(lstate, err_param);</a>
<a name="ln5333">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5334">    }</a>
<a name="ln5335">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5336">    api_clear_error(&amp;err);</a>
<a name="ln5337">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5338">    return lua_error(lstate);</a>
<a name="ln5339">  }</a>
<a name="ln5340"> </a>
<a name="ln5341">  return 1;</a>
<a name="ln5342">}</a>
<a name="ln5343"> </a>
<a name="ln5344">static int nlua_api_nvim_load_context(lua_State *lstate)</a>
<a name="ln5345">{</a>
<a name="ln5346">  Error err = ERROR_INIT;</a>
<a name="ln5347">  char *err_param = 0;</a>
<a name="ln5348">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5349">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5350">    goto exit_0;</a>
<a name="ln5351">  }</a>
<a name="ln5352">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5353">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_load_context&quot;);</a>
<a name="ln5354">  }</a>
<a name="ln5355">    const Dictionary arg1 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln5356">  if (ERROR_SET(&amp;err)) {      err_param = &quot;dict&quot;;      goto exit_0;</a>
<a name="ln5357">  }</a>
<a name="ln5358"> </a>
<a name="ln5359">  const Object ret = nvim_load_context(arg1);</a>
<a name="ln5360">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln5361">api_free_object(ret);</a>
<a name="ln5362"> </a>
<a name="ln5363">  api_free_dictionary(arg1);</a>
<a name="ln5364"> </a>
<a name="ln5365">exit_0:</a>
<a name="ln5366">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5367">    luaL_where(lstate, 1);</a>
<a name="ln5368">    if (err_param) {</a>
<a name="ln5369">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5370">      lua_pushstring(lstate, err_param);</a>
<a name="ln5371">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5372">    }</a>
<a name="ln5373">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5374">    api_clear_error(&amp;err);</a>
<a name="ln5375">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5376">    return lua_error(lstate);</a>
<a name="ln5377">  }</a>
<a name="ln5378"> </a>
<a name="ln5379">  return 1;</a>
<a name="ln5380">}</a>
<a name="ln5381"> </a>
<a name="ln5382">static int nlua_api_nvim_get_mode(lua_State *lstate)</a>
<a name="ln5383">{</a>
<a name="ln5384">  Error err = ERROR_INIT;</a>
<a name="ln5385">  char *err_param = 0;</a>
<a name="ln5386">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5387">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5388">    goto exit_0;</a>
<a name="ln5389">  }</a>
<a name="ln5390">  const Dictionary ret = nvim_get_mode();</a>
<a name="ln5391">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln5392">api_free_dictionary(ret);</a>
<a name="ln5393"> </a>
<a name="ln5394"> </a>
<a name="ln5395">exit_0:</a>
<a name="ln5396">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5397">    luaL_where(lstate, 1);</a>
<a name="ln5398">    if (err_param) {</a>
<a name="ln5399">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5400">      lua_pushstring(lstate, err_param);</a>
<a name="ln5401">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5402">    }</a>
<a name="ln5403">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5404">    api_clear_error(&amp;err);</a>
<a name="ln5405">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5406">    return lua_error(lstate);</a>
<a name="ln5407">  }</a>
<a name="ln5408"> </a>
<a name="ln5409">  return 1;</a>
<a name="ln5410">}</a>
<a name="ln5411"> </a>
<a name="ln5412">static int nlua_api_nvim_get_keymap(lua_State *lstate)</a>
<a name="ln5413">{</a>
<a name="ln5414">  Error err = ERROR_INIT;</a>
<a name="ln5415">  char *err_param = 0;</a>
<a name="ln5416">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5417">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5418">    goto exit_0;</a>
<a name="ln5419">  }</a>
<a name="ln5420">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5421">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_keymap&quot;);</a>
<a name="ln5422">  }</a>
<a name="ln5423">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5424">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_0;</a>
<a name="ln5425">  }</a>
<a name="ln5426"> </a>
<a name="ln5427">  const ArrayOf(Dictionary) ret = nvim_get_keymap(arg1);</a>
<a name="ln5428">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5429">api_free_array(ret);</a>
<a name="ln5430"> </a>
<a name="ln5431">  api_free_string(arg1);</a>
<a name="ln5432"> </a>
<a name="ln5433">exit_0:</a>
<a name="ln5434">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5435">    luaL_where(lstate, 1);</a>
<a name="ln5436">    if (err_param) {</a>
<a name="ln5437">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5438">      lua_pushstring(lstate, err_param);</a>
<a name="ln5439">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5440">    }</a>
<a name="ln5441">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5442">    api_clear_error(&amp;err);</a>
<a name="ln5443">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5444">    return lua_error(lstate);</a>
<a name="ln5445">  }</a>
<a name="ln5446"> </a>
<a name="ln5447">  return 1;</a>
<a name="ln5448">}</a>
<a name="ln5449"> </a>
<a name="ln5450">static int nlua_api_nvim_set_keymap(lua_State *lstate)</a>
<a name="ln5451">{</a>
<a name="ln5452">  Error err = ERROR_INIT;</a>
<a name="ln5453">  char *err_param = 0;</a>
<a name="ln5454">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln5455">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln5456">    goto exit_0;</a>
<a name="ln5457">  }</a>
<a name="ln5458">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5459">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_keymap&quot;);</a>
<a name="ln5460">  }</a>
<a name="ln5461">    KeyDict_keymap arg4 = { 0 }; nlua_pop_keydict(lstate, &amp;arg4, KeyDict_keymap_get_field, &amp;err_param, &amp;err);</a>
<a name="ln5462">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln5463">  }</a>
<a name="ln5464"> </a>
<a name="ln5465">    const String arg3 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5466">  if (ERROR_SET(&amp;err)) {      err_param = &quot;rhs&quot;;      goto exit_1;</a>
<a name="ln5467">  }</a>
<a name="ln5468"> </a>
<a name="ln5469">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5470">  if (ERROR_SET(&amp;err)) {      err_param = &quot;lhs&quot;;      goto exit_2;</a>
<a name="ln5471">  }</a>
<a name="ln5472"> </a>
<a name="ln5473">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5474">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_3;</a>
<a name="ln5475">  }</a>
<a name="ln5476"> </a>
<a name="ln5477">  nvim_set_keymap(LUA_INTERNAL_CALL, arg1, arg2, arg3, &amp;arg4, &amp;err);</a>
<a name="ln5478"> </a>
<a name="ln5479">  api_free_string(arg1);</a>
<a name="ln5480">exit_3:</a>
<a name="ln5481">  api_free_string(arg2);</a>
<a name="ln5482">exit_2:</a>
<a name="ln5483">  api_free_string(arg3);</a>
<a name="ln5484">exit_1:</a>
<a name="ln5485">  api_free_keydict_keymap(&amp;arg4);</a>
<a name="ln5486"> </a>
<a name="ln5487">exit_0:</a>
<a name="ln5488">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5489">    luaL_where(lstate, 1);</a>
<a name="ln5490">    if (err_param) {</a>
<a name="ln5491">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5492">      lua_pushstring(lstate, err_param);</a>
<a name="ln5493">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5494">    }</a>
<a name="ln5495">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5496">    api_clear_error(&amp;err);</a>
<a name="ln5497">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5498">    return lua_error(lstate);</a>
<a name="ln5499">  }</a>
<a name="ln5500"> </a>
<a name="ln5501">  return 0;</a>
<a name="ln5502">}</a>
<a name="ln5503"> </a>
<a name="ln5504">static int nlua_api_nvim_del_keymap(lua_State *lstate)</a>
<a name="ln5505">{</a>
<a name="ln5506">  Error err = ERROR_INIT;</a>
<a name="ln5507">  char *err_param = 0;</a>
<a name="ln5508">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln5509">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln5510">    goto exit_0;</a>
<a name="ln5511">  }</a>
<a name="ln5512">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5513">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_keymap&quot;);</a>
<a name="ln5514">  }</a>
<a name="ln5515">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5516">  if (ERROR_SET(&amp;err)) {      err_param = &quot;lhs&quot;;      goto exit_0;</a>
<a name="ln5517">  }</a>
<a name="ln5518"> </a>
<a name="ln5519">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5520">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_1;</a>
<a name="ln5521">  }</a>
<a name="ln5522"> </a>
<a name="ln5523">  nvim_del_keymap(LUA_INTERNAL_CALL, arg1, arg2, &amp;err);</a>
<a name="ln5524"> </a>
<a name="ln5525">  api_free_string(arg1);</a>
<a name="ln5526">exit_1:</a>
<a name="ln5527">  api_free_string(arg2);</a>
<a name="ln5528"> </a>
<a name="ln5529">exit_0:</a>
<a name="ln5530">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5531">    luaL_where(lstate, 1);</a>
<a name="ln5532">    if (err_param) {</a>
<a name="ln5533">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5534">      lua_pushstring(lstate, err_param);</a>
<a name="ln5535">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5536">    }</a>
<a name="ln5537">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5538">    api_clear_error(&amp;err);</a>
<a name="ln5539">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5540">    return lua_error(lstate);</a>
<a name="ln5541">  }</a>
<a name="ln5542"> </a>
<a name="ln5543">  return 0;</a>
<a name="ln5544">}</a>
<a name="ln5545"> </a>
<a name="ln5546">static int nlua_api_nvim_get_chan_info(lua_State *lstate)</a>
<a name="ln5547">{</a>
<a name="ln5548">  Error err = ERROR_INIT;</a>
<a name="ln5549">  char *err_param = 0;</a>
<a name="ln5550">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5551">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5552">    goto exit_0;</a>
<a name="ln5553">  }</a>
<a name="ln5554">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5555">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_chan_info&quot;);</a>
<a name="ln5556">  }</a>
<a name="ln5557">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5558">  if (ERROR_SET(&amp;err)) {      err_param = &quot;chan&quot;;      goto exit_0;</a>
<a name="ln5559">  }</a>
<a name="ln5560"> </a>
<a name="ln5561">  const Dictionary ret = nvim_get_chan_info(arg1, &amp;err);</a>
<a name="ln5562">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln5563">api_free_dictionary(ret);</a>
<a name="ln5564"> </a>
<a name="ln5565">  api_free_integer(arg1);</a>
<a name="ln5566"> </a>
<a name="ln5567">exit_0:</a>
<a name="ln5568">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5569">    luaL_where(lstate, 1);</a>
<a name="ln5570">    if (err_param) {</a>
<a name="ln5571">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5572">      lua_pushstring(lstate, err_param);</a>
<a name="ln5573">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5574">    }</a>
<a name="ln5575">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5576">    api_clear_error(&amp;err);</a>
<a name="ln5577">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5578">    return lua_error(lstate);</a>
<a name="ln5579">  }</a>
<a name="ln5580"> </a>
<a name="ln5581">  return 1;</a>
<a name="ln5582">}</a>
<a name="ln5583"> </a>
<a name="ln5584">static int nlua_api_nvim_list_chans(lua_State *lstate)</a>
<a name="ln5585">{</a>
<a name="ln5586">  Error err = ERROR_INIT;</a>
<a name="ln5587">  char *err_param = 0;</a>
<a name="ln5588">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5589">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5590">    goto exit_0;</a>
<a name="ln5591">  }</a>
<a name="ln5592">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5593">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_list_chans&quot;);</a>
<a name="ln5594">  }</a>
<a name="ln5595">  const Array ret = nvim_list_chans();</a>
<a name="ln5596">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5597">api_free_array(ret);</a>
<a name="ln5598"> </a>
<a name="ln5599"> </a>
<a name="ln5600">exit_0:</a>
<a name="ln5601">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5602">    luaL_where(lstate, 1);</a>
<a name="ln5603">    if (err_param) {</a>
<a name="ln5604">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5605">      lua_pushstring(lstate, err_param);</a>
<a name="ln5606">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5607">    }</a>
<a name="ln5608">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5609">    api_clear_error(&amp;err);</a>
<a name="ln5610">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5611">    return lua_error(lstate);</a>
<a name="ln5612">  }</a>
<a name="ln5613"> </a>
<a name="ln5614">  return 1;</a>
<a name="ln5615">}</a>
<a name="ln5616"> </a>
<a name="ln5617">static int nlua_api_nvim__id(lua_State *lstate)</a>
<a name="ln5618">{</a>
<a name="ln5619">  Error err = ERROR_INIT;</a>
<a name="ln5620">  char *err_param = 0;</a>
<a name="ln5621">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5622">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5623">    goto exit_0;</a>
<a name="ln5624">  }</a>
<a name="ln5625">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5626">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__id&quot;);</a>
<a name="ln5627">  }</a>
<a name="ln5628">    const Object arg1 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln5629">  if (ERROR_SET(&amp;err)) {      err_param = &quot;obj&quot;;      goto exit_0;</a>
<a name="ln5630">  }</a>
<a name="ln5631"> </a>
<a name="ln5632">  const Object ret = nvim__id(arg1);</a>
<a name="ln5633">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln5634">api_free_object(ret);</a>
<a name="ln5635"> </a>
<a name="ln5636">  api_free_object(arg1);</a>
<a name="ln5637"> </a>
<a name="ln5638">exit_0:</a>
<a name="ln5639">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5640">    luaL_where(lstate, 1);</a>
<a name="ln5641">    if (err_param) {</a>
<a name="ln5642">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5643">      lua_pushstring(lstate, err_param);</a>
<a name="ln5644">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5645">    }</a>
<a name="ln5646">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5647">    api_clear_error(&amp;err);</a>
<a name="ln5648">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5649">    return lua_error(lstate);</a>
<a name="ln5650">  }</a>
<a name="ln5651"> </a>
<a name="ln5652">  return 1;</a>
<a name="ln5653">}</a>
<a name="ln5654"> </a>
<a name="ln5655">static int nlua_api_nvim__id_array(lua_State *lstate)</a>
<a name="ln5656">{</a>
<a name="ln5657">  Error err = ERROR_INIT;</a>
<a name="ln5658">  char *err_param = 0;</a>
<a name="ln5659">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5660">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5661">    goto exit_0;</a>
<a name="ln5662">  }</a>
<a name="ln5663">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5664">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__id_array&quot;);</a>
<a name="ln5665">  }</a>
<a name="ln5666">    const Array arg1 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln5667">  if (ERROR_SET(&amp;err)) {      err_param = &quot;arr&quot;;      goto exit_0;</a>
<a name="ln5668">  }</a>
<a name="ln5669"> </a>
<a name="ln5670">  const Array ret = nvim__id_array(arg1);</a>
<a name="ln5671">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5672">api_free_array(ret);</a>
<a name="ln5673"> </a>
<a name="ln5674">  api_free_array(arg1);</a>
<a name="ln5675"> </a>
<a name="ln5676">exit_0:</a>
<a name="ln5677">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5678">    luaL_where(lstate, 1);</a>
<a name="ln5679">    if (err_param) {</a>
<a name="ln5680">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5681">      lua_pushstring(lstate, err_param);</a>
<a name="ln5682">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5683">    }</a>
<a name="ln5684">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5685">    api_clear_error(&amp;err);</a>
<a name="ln5686">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5687">    return lua_error(lstate);</a>
<a name="ln5688">  }</a>
<a name="ln5689"> </a>
<a name="ln5690">  return 1;</a>
<a name="ln5691">}</a>
<a name="ln5692"> </a>
<a name="ln5693">static int nlua_api_nvim__id_dictionary(lua_State *lstate)</a>
<a name="ln5694">{</a>
<a name="ln5695">  Error err = ERROR_INIT;</a>
<a name="ln5696">  char *err_param = 0;</a>
<a name="ln5697">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5698">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5699">    goto exit_0;</a>
<a name="ln5700">  }</a>
<a name="ln5701">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5702">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__id_dictionary&quot;);</a>
<a name="ln5703">  }</a>
<a name="ln5704">    const Dictionary arg1 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln5705">  if (ERROR_SET(&amp;err)) {      err_param = &quot;dct&quot;;      goto exit_0;</a>
<a name="ln5706">  }</a>
<a name="ln5707"> </a>
<a name="ln5708">  const Dictionary ret = nvim__id_dictionary(arg1);</a>
<a name="ln5709">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln5710">api_free_dictionary(ret);</a>
<a name="ln5711"> </a>
<a name="ln5712">  api_free_dictionary(arg1);</a>
<a name="ln5713"> </a>
<a name="ln5714">exit_0:</a>
<a name="ln5715">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5716">    luaL_where(lstate, 1);</a>
<a name="ln5717">    if (err_param) {</a>
<a name="ln5718">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5719">      lua_pushstring(lstate, err_param);</a>
<a name="ln5720">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5721">    }</a>
<a name="ln5722">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5723">    api_clear_error(&amp;err);</a>
<a name="ln5724">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5725">    return lua_error(lstate);</a>
<a name="ln5726">  }</a>
<a name="ln5727"> </a>
<a name="ln5728">  return 1;</a>
<a name="ln5729">}</a>
<a name="ln5730"> </a>
<a name="ln5731">static int nlua_api_nvim__id_float(lua_State *lstate)</a>
<a name="ln5732">{</a>
<a name="ln5733">  Error err = ERROR_INIT;</a>
<a name="ln5734">  char *err_param = 0;</a>
<a name="ln5735">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5736">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5737">    goto exit_0;</a>
<a name="ln5738">  }</a>
<a name="ln5739">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5740">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__id_float&quot;);</a>
<a name="ln5741">  }</a>
<a name="ln5742">    const Float arg1 = nlua_pop_Float(lstate, &amp;err);</a>
<a name="ln5743">  if (ERROR_SET(&amp;err)) {      err_param = &quot;flt&quot;;      goto exit_0;</a>
<a name="ln5744">  }</a>
<a name="ln5745"> </a>
<a name="ln5746">  const Float ret = nvim__id_float(arg1);</a>
<a name="ln5747">  nlua_push_Float(lstate, ret, true);</a>
<a name="ln5748">api_free_float(ret);</a>
<a name="ln5749"> </a>
<a name="ln5750">  api_free_float(arg1);</a>
<a name="ln5751"> </a>
<a name="ln5752">exit_0:</a>
<a name="ln5753">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5754">    luaL_where(lstate, 1);</a>
<a name="ln5755">    if (err_param) {</a>
<a name="ln5756">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5757">      lua_pushstring(lstate, err_param);</a>
<a name="ln5758">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5759">    }</a>
<a name="ln5760">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5761">    api_clear_error(&amp;err);</a>
<a name="ln5762">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5763">    return lua_error(lstate);</a>
<a name="ln5764">  }</a>
<a name="ln5765"> </a>
<a name="ln5766">  return 1;</a>
<a name="ln5767">}</a>
<a name="ln5768"> </a>
<a name="ln5769">static int nlua_api_nvim__stats(lua_State *lstate)</a>
<a name="ln5770">{</a>
<a name="ln5771">  Error err = ERROR_INIT;</a>
<a name="ln5772">  char *err_param = 0;</a>
<a name="ln5773">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5774">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5775">    goto exit_0;</a>
<a name="ln5776">  }</a>
<a name="ln5777">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5778">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__stats&quot;);</a>
<a name="ln5779">  }</a>
<a name="ln5780">  const Dictionary ret = nvim__stats();</a>
<a name="ln5781">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln5782">api_free_dictionary(ret);</a>
<a name="ln5783"> </a>
<a name="ln5784"> </a>
<a name="ln5785">exit_0:</a>
<a name="ln5786">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5787">    luaL_where(lstate, 1);</a>
<a name="ln5788">    if (err_param) {</a>
<a name="ln5789">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5790">      lua_pushstring(lstate, err_param);</a>
<a name="ln5791">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5792">    }</a>
<a name="ln5793">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5794">    api_clear_error(&amp;err);</a>
<a name="ln5795">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5796">    return lua_error(lstate);</a>
<a name="ln5797">  }</a>
<a name="ln5798"> </a>
<a name="ln5799">  return 1;</a>
<a name="ln5800">}</a>
<a name="ln5801"> </a>
<a name="ln5802">static int nlua_api_nvim_list_uis(lua_State *lstate)</a>
<a name="ln5803">{</a>
<a name="ln5804">  Error err = ERROR_INIT;</a>
<a name="ln5805">  char *err_param = 0;</a>
<a name="ln5806">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5807">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5808">    goto exit_0;</a>
<a name="ln5809">  }</a>
<a name="ln5810">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5811">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_list_uis&quot;);</a>
<a name="ln5812">  }</a>
<a name="ln5813">  const Array ret = nvim_list_uis();</a>
<a name="ln5814">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5815">api_free_array(ret);</a>
<a name="ln5816"> </a>
<a name="ln5817"> </a>
<a name="ln5818">exit_0:</a>
<a name="ln5819">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5820">    luaL_where(lstate, 1);</a>
<a name="ln5821">    if (err_param) {</a>
<a name="ln5822">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5823">      lua_pushstring(lstate, err_param);</a>
<a name="ln5824">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5825">    }</a>
<a name="ln5826">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5827">    api_clear_error(&amp;err);</a>
<a name="ln5828">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5829">    return lua_error(lstate);</a>
<a name="ln5830">  }</a>
<a name="ln5831"> </a>
<a name="ln5832">  return 1;</a>
<a name="ln5833">}</a>
<a name="ln5834"> </a>
<a name="ln5835">static int nlua_api_nvim_get_proc_children(lua_State *lstate)</a>
<a name="ln5836">{</a>
<a name="ln5837">  Error err = ERROR_INIT;</a>
<a name="ln5838">  char *err_param = 0;</a>
<a name="ln5839">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5840">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5841">    goto exit_0;</a>
<a name="ln5842">  }</a>
<a name="ln5843">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5844">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_proc_children&quot;);</a>
<a name="ln5845">  }</a>
<a name="ln5846">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5847">  if (ERROR_SET(&amp;err)) {      err_param = &quot;pid&quot;;      goto exit_0;</a>
<a name="ln5848">  }</a>
<a name="ln5849"> </a>
<a name="ln5850">  const Array ret = nvim_get_proc_children(arg1, &amp;err);</a>
<a name="ln5851">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5852">api_free_array(ret);</a>
<a name="ln5853"> </a>
<a name="ln5854">  api_free_integer(arg1);</a>
<a name="ln5855"> </a>
<a name="ln5856">exit_0:</a>
<a name="ln5857">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5858">    luaL_where(lstate, 1);</a>
<a name="ln5859">    if (err_param) {</a>
<a name="ln5860">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5861">      lua_pushstring(lstate, err_param);</a>
<a name="ln5862">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5863">    }</a>
<a name="ln5864">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5865">    api_clear_error(&amp;err);</a>
<a name="ln5866">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5867">    return lua_error(lstate);</a>
<a name="ln5868">  }</a>
<a name="ln5869"> </a>
<a name="ln5870">  return 1;</a>
<a name="ln5871">}</a>
<a name="ln5872"> </a>
<a name="ln5873">static int nlua_api_nvim_get_proc(lua_State *lstate)</a>
<a name="ln5874">{</a>
<a name="ln5875">  Error err = ERROR_INIT;</a>
<a name="ln5876">  char *err_param = 0;</a>
<a name="ln5877">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5878">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5879">    goto exit_0;</a>
<a name="ln5880">  }</a>
<a name="ln5881">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5882">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_proc&quot;);</a>
<a name="ln5883">  }</a>
<a name="ln5884">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5885">  if (ERROR_SET(&amp;err)) {      err_param = &quot;pid&quot;;      goto exit_0;</a>
<a name="ln5886">  }</a>
<a name="ln5887"> </a>
<a name="ln5888">  const Object ret = nvim_get_proc(arg1, &amp;err);</a>
<a name="ln5889">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln5890">api_free_object(ret);</a>
<a name="ln5891"> </a>
<a name="ln5892">  api_free_integer(arg1);</a>
<a name="ln5893"> </a>
<a name="ln5894">exit_0:</a>
<a name="ln5895">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5896">    luaL_where(lstate, 1);</a>
<a name="ln5897">    if (err_param) {</a>
<a name="ln5898">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5899">      lua_pushstring(lstate, err_param);</a>
<a name="ln5900">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5901">    }</a>
<a name="ln5902">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5903">    api_clear_error(&amp;err);</a>
<a name="ln5904">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5905">    return lua_error(lstate);</a>
<a name="ln5906">  }</a>
<a name="ln5907"> </a>
<a name="ln5908">  return 1;</a>
<a name="ln5909">}</a>
<a name="ln5910"> </a>
<a name="ln5911">static int nlua_api_nvim_select_popupmenu_item(lua_State *lstate)</a>
<a name="ln5912">{</a>
<a name="ln5913">  Error err = ERROR_INIT;</a>
<a name="ln5914">  char *err_param = 0;</a>
<a name="ln5915">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln5916">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln5917">    goto exit_0;</a>
<a name="ln5918">  }</a>
<a name="ln5919">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5920">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_select_popupmenu_item&quot;);</a>
<a name="ln5921">  }</a>
<a name="ln5922">    const Dictionary arg4 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln5923">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln5924">  }</a>
<a name="ln5925"> </a>
<a name="ln5926">    const Boolean arg3 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln5927">  if (ERROR_SET(&amp;err)) {      err_param = &quot;finish&quot;;      goto exit_1;</a>
<a name="ln5928">  }</a>
<a name="ln5929"> </a>
<a name="ln5930">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln5931">  if (ERROR_SET(&amp;err)) {      err_param = &quot;insert&quot;;      goto exit_2;</a>
<a name="ln5932">  }</a>
<a name="ln5933"> </a>
<a name="ln5934">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5935">  if (ERROR_SET(&amp;err)) {      err_param = &quot;item&quot;;      goto exit_3;</a>
<a name="ln5936">  }</a>
<a name="ln5937"> </a>
<a name="ln5938">  nvim_select_popupmenu_item(arg1, arg2, arg3, arg4, &amp;err);</a>
<a name="ln5939"> </a>
<a name="ln5940">  api_free_integer(arg1);</a>
<a name="ln5941">exit_3:</a>
<a name="ln5942">  api_free_boolean(arg2);</a>
<a name="ln5943">exit_2:</a>
<a name="ln5944">  api_free_boolean(arg3);</a>
<a name="ln5945">exit_1:</a>
<a name="ln5946">  api_free_dictionary(arg4);</a>
<a name="ln5947"> </a>
<a name="ln5948">exit_0:</a>
<a name="ln5949">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5950">    luaL_where(lstate, 1);</a>
<a name="ln5951">    if (err_param) {</a>
<a name="ln5952">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5953">      lua_pushstring(lstate, err_param);</a>
<a name="ln5954">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5955">    }</a>
<a name="ln5956">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5957">    api_clear_error(&amp;err);</a>
<a name="ln5958">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5959">    return lua_error(lstate);</a>
<a name="ln5960">  }</a>
<a name="ln5961"> </a>
<a name="ln5962">  return 0;</a>
<a name="ln5963">}</a>
<a name="ln5964"> </a>
<a name="ln5965">static int nlua_api_nvim__inspect_cell(lua_State *lstate)</a>
<a name="ln5966">{</a>
<a name="ln5967">  Error err = ERROR_INIT;</a>
<a name="ln5968">  char *err_param = 0;</a>
<a name="ln5969">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln5970">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln5971">    goto exit_0;</a>
<a name="ln5972">  }</a>
<a name="ln5973">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5974">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__inspect_cell&quot;);</a>
<a name="ln5975">  }</a>
<a name="ln5976">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5977">  if (ERROR_SET(&amp;err)) {      err_param = &quot;col&quot;;      goto exit_0;</a>
<a name="ln5978">  }</a>
<a name="ln5979"> </a>
<a name="ln5980">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5981">  if (ERROR_SET(&amp;err)) {      err_param = &quot;row&quot;;      goto exit_1;</a>
<a name="ln5982">  }</a>
<a name="ln5983"> </a>
<a name="ln5984">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5985">  if (ERROR_SET(&amp;err)) {      err_param = &quot;grid&quot;;      goto exit_2;</a>
<a name="ln5986">  }</a>
<a name="ln5987"> </a>
<a name="ln5988">  Arena arena = ARENA_EMPTY;</a>
<a name="ln5989">  const Array ret = nvim__inspect_cell(arg1, arg2, arg3, &amp;arena, &amp;err);</a>
<a name="ln5990">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5991">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln5992"> </a>
<a name="ln5993">  api_free_integer(arg1);</a>
<a name="ln5994">exit_2:</a>
<a name="ln5995">  api_free_integer(arg2);</a>
<a name="ln5996">exit_1:</a>
<a name="ln5997">  api_free_integer(arg3);</a>
<a name="ln5998"> </a>
<a name="ln5999">exit_0:</a>
<a name="ln6000">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6001">    luaL_where(lstate, 1);</a>
<a name="ln6002">    if (err_param) {</a>
<a name="ln6003">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6004">      lua_pushstring(lstate, err_param);</a>
<a name="ln6005">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6006">    }</a>
<a name="ln6007">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6008">    api_clear_error(&amp;err);</a>
<a name="ln6009">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6010">    return lua_error(lstate);</a>
<a name="ln6011">  }</a>
<a name="ln6012"> </a>
<a name="ln6013">  return 1;</a>
<a name="ln6014">}</a>
<a name="ln6015"> </a>
<a name="ln6016">static int nlua_api_nvim__screenshot(lua_State *lstate)</a>
<a name="ln6017">{</a>
<a name="ln6018">  Error err = ERROR_INIT;</a>
<a name="ln6019">  char *err_param = 0;</a>
<a name="ln6020">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6021">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6022">    goto exit_0;</a>
<a name="ln6023">  }</a>
<a name="ln6024">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6025">  if (ERROR_SET(&amp;err)) {      err_param = &quot;path&quot;;      goto exit_0;</a>
<a name="ln6026">  }</a>
<a name="ln6027"> </a>
<a name="ln6028">  nvim__screenshot(arg1);</a>
<a name="ln6029"> </a>
<a name="ln6030">  api_free_string(arg1);</a>
<a name="ln6031"> </a>
<a name="ln6032">exit_0:</a>
<a name="ln6033">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6034">    luaL_where(lstate, 1);</a>
<a name="ln6035">    if (err_param) {</a>
<a name="ln6036">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6037">      lua_pushstring(lstate, err_param);</a>
<a name="ln6038">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6039">    }</a>
<a name="ln6040">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6041">    api_clear_error(&amp;err);</a>
<a name="ln6042">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6043">    return lua_error(lstate);</a>
<a name="ln6044">  }</a>
<a name="ln6045"> </a>
<a name="ln6046">  return 0;</a>
<a name="ln6047">}</a>
<a name="ln6048"> </a>
<a name="ln6049">static int nlua_api_nvim__unpack(lua_State *lstate)</a>
<a name="ln6050">{</a>
<a name="ln6051">  Error err = ERROR_INIT;</a>
<a name="ln6052">  char *err_param = 0;</a>
<a name="ln6053">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6054">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6055">    goto exit_0;</a>
<a name="ln6056">  }</a>
<a name="ln6057">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6058">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_0;</a>
<a name="ln6059">  }</a>
<a name="ln6060"> </a>
<a name="ln6061">  const Object ret = nvim__unpack(arg1, &amp;err);</a>
<a name="ln6062">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln6063">api_free_object(ret);</a>
<a name="ln6064"> </a>
<a name="ln6065">  api_free_string(arg1);</a>
<a name="ln6066"> </a>
<a name="ln6067">exit_0:</a>
<a name="ln6068">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6069">    luaL_where(lstate, 1);</a>
<a name="ln6070">    if (err_param) {</a>
<a name="ln6071">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6072">      lua_pushstring(lstate, err_param);</a>
<a name="ln6073">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6074">    }</a>
<a name="ln6075">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6076">    api_clear_error(&amp;err);</a>
<a name="ln6077">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6078">    return lua_error(lstate);</a>
<a name="ln6079">  }</a>
<a name="ln6080"> </a>
<a name="ln6081">  return 1;</a>
<a name="ln6082">}</a>
<a name="ln6083"> </a>
<a name="ln6084">static int nlua_api_nvim_del_mark(lua_State *lstate)</a>
<a name="ln6085">{</a>
<a name="ln6086">  Error err = ERROR_INIT;</a>
<a name="ln6087">  char *err_param = 0;</a>
<a name="ln6088">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6089">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6090">    goto exit_0;</a>
<a name="ln6091">  }</a>
<a name="ln6092">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6093">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_mark&quot;);</a>
<a name="ln6094">  }</a>
<a name="ln6095">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6096">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln6097">  }</a>
<a name="ln6098"> </a>
<a name="ln6099">  const Boolean ret = nvim_del_mark(arg1, &amp;err);</a>
<a name="ln6100">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln6101">api_free_boolean(ret);</a>
<a name="ln6102"> </a>
<a name="ln6103">  api_free_string(arg1);</a>
<a name="ln6104"> </a>
<a name="ln6105">exit_0:</a>
<a name="ln6106">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6107">    luaL_where(lstate, 1);</a>
<a name="ln6108">    if (err_param) {</a>
<a name="ln6109">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6110">      lua_pushstring(lstate, err_param);</a>
<a name="ln6111">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6112">    }</a>
<a name="ln6113">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6114">    api_clear_error(&amp;err);</a>
<a name="ln6115">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6116">    return lua_error(lstate);</a>
<a name="ln6117">  }</a>
<a name="ln6118"> </a>
<a name="ln6119">  return 1;</a>
<a name="ln6120">}</a>
<a name="ln6121"> </a>
<a name="ln6122">static int nlua_api_nvim_get_mark(lua_State *lstate)</a>
<a name="ln6123">{</a>
<a name="ln6124">  Error err = ERROR_INIT;</a>
<a name="ln6125">  char *err_param = 0;</a>
<a name="ln6126">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6127">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6128">    goto exit_0;</a>
<a name="ln6129">  }</a>
<a name="ln6130">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6131">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_mark&quot;);</a>
<a name="ln6132">  }</a>
<a name="ln6133">    const Dictionary arg2 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln6134">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln6135">  }</a>
<a name="ln6136"> </a>
<a name="ln6137">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6138">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln6139">  }</a>
<a name="ln6140"> </a>
<a name="ln6141">  const Array ret = nvim_get_mark(arg1, arg2, &amp;err);</a>
<a name="ln6142">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln6143">api_free_array(ret);</a>
<a name="ln6144"> </a>
<a name="ln6145">  api_free_string(arg1);</a>
<a name="ln6146">exit_1:</a>
<a name="ln6147">  api_free_dictionary(arg2);</a>
<a name="ln6148"> </a>
<a name="ln6149">exit_0:</a>
<a name="ln6150">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6151">    luaL_where(lstate, 1);</a>
<a name="ln6152">    if (err_param) {</a>
<a name="ln6153">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6154">      lua_pushstring(lstate, err_param);</a>
<a name="ln6155">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6156">    }</a>
<a name="ln6157">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6158">    api_clear_error(&amp;err);</a>
<a name="ln6159">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6160">    return lua_error(lstate);</a>
<a name="ln6161">  }</a>
<a name="ln6162"> </a>
<a name="ln6163">  return 1;</a>
<a name="ln6164">}</a>
<a name="ln6165"> </a>
<a name="ln6166">static int nlua_api_nvim_eval_statusline(lua_State *lstate)</a>
<a name="ln6167">{</a>
<a name="ln6168">  Error err = ERROR_INIT;</a>
<a name="ln6169">  char *err_param = 0;</a>
<a name="ln6170">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6171">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6172">    goto exit_0;</a>
<a name="ln6173">  }</a>
<a name="ln6174">    KeyDict_eval_statusline arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_eval_statusline_get_field, &amp;err_param, &amp;err);</a>
<a name="ln6175">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln6176">  }</a>
<a name="ln6177"> </a>
<a name="ln6178">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6179">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_1;</a>
<a name="ln6180">  }</a>
<a name="ln6181"> </a>
<a name="ln6182">  const Dictionary ret = nvim_eval_statusline(arg1, &amp;arg2, &amp;err);</a>
<a name="ln6183">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln6184">api_free_dictionary(ret);</a>
<a name="ln6185"> </a>
<a name="ln6186">  api_free_string(arg1);</a>
<a name="ln6187">exit_1:</a>
<a name="ln6188">  api_free_keydict_eval_statusline(&amp;arg2);</a>
<a name="ln6189"> </a>
<a name="ln6190">exit_0:</a>
<a name="ln6191">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6192">    luaL_where(lstate, 1);</a>
<a name="ln6193">    if (err_param) {</a>
<a name="ln6194">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6195">      lua_pushstring(lstate, err_param);</a>
<a name="ln6196">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6197">    }</a>
<a name="ln6198">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6199">    api_clear_error(&amp;err);</a>
<a name="ln6200">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6201">    return lua_error(lstate);</a>
<a name="ln6202">  }</a>
<a name="ln6203"> </a>
<a name="ln6204">  return 1;</a>
<a name="ln6205">}</a>
<a name="ln6206"> </a>
<a name="ln6207">static int nlua_api_nvim_exec2(lua_State *lstate)</a>
<a name="ln6208">{</a>
<a name="ln6209">  Error err = ERROR_INIT;</a>
<a name="ln6210">  char *err_param = 0;</a>
<a name="ln6211">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6212">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6213">    goto exit_0;</a>
<a name="ln6214">  }</a>
<a name="ln6215">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6216">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_exec2&quot;);</a>
<a name="ln6217">  }</a>
<a name="ln6218">    KeyDict_exec_opts arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_exec_opts_get_field, &amp;err_param, &amp;err);</a>
<a name="ln6219">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln6220">  }</a>
<a name="ln6221"> </a>
<a name="ln6222">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6223">  if (ERROR_SET(&amp;err)) {      err_param = &quot;src&quot;;      goto exit_1;</a>
<a name="ln6224">  }</a>
<a name="ln6225"> </a>
<a name="ln6226">  const Dictionary ret = nvim_exec2(LUA_INTERNAL_CALL, arg1, &amp;arg2, &amp;err);</a>
<a name="ln6227">  nlua_push_Dictionary(lstate, ret, false);</a>
<a name="ln6228">api_free_dictionary(ret);</a>
<a name="ln6229"> </a>
<a name="ln6230">  api_free_string(arg1);</a>
<a name="ln6231">exit_1:</a>
<a name="ln6232">  api_free_keydict_exec_opts(&amp;arg2);</a>
<a name="ln6233"> </a>
<a name="ln6234">exit_0:</a>
<a name="ln6235">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6236">    luaL_where(lstate, 1);</a>
<a name="ln6237">    if (err_param) {</a>
<a name="ln6238">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6239">      lua_pushstring(lstate, err_param);</a>
<a name="ln6240">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6241">    }</a>
<a name="ln6242">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6243">    api_clear_error(&amp;err);</a>
<a name="ln6244">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6245">    return lua_error(lstate);</a>
<a name="ln6246">  }</a>
<a name="ln6247"> </a>
<a name="ln6248">  return 1;</a>
<a name="ln6249">}</a>
<a name="ln6250"> </a>
<a name="ln6251">static int nlua_api_nvim_command(lua_State *lstate)</a>
<a name="ln6252">{</a>
<a name="ln6253">  Error err = ERROR_INIT;</a>
<a name="ln6254">  char *err_param = 0;</a>
<a name="ln6255">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6256">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6257">    goto exit_0;</a>
<a name="ln6258">  }</a>
<a name="ln6259">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6260">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_command&quot;);</a>
<a name="ln6261">  }</a>
<a name="ln6262">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6263">  if (ERROR_SET(&amp;err)) {      err_param = &quot;command&quot;;      goto exit_0;</a>
<a name="ln6264">  }</a>
<a name="ln6265"> </a>
<a name="ln6266">  nvim_command(arg1, &amp;err);</a>
<a name="ln6267"> </a>
<a name="ln6268">  api_free_string(arg1);</a>
<a name="ln6269"> </a>
<a name="ln6270">exit_0:</a>
<a name="ln6271">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6272">    luaL_where(lstate, 1);</a>
<a name="ln6273">    if (err_param) {</a>
<a name="ln6274">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6275">      lua_pushstring(lstate, err_param);</a>
<a name="ln6276">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6277">    }</a>
<a name="ln6278">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6279">    api_clear_error(&amp;err);</a>
<a name="ln6280">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6281">    return lua_error(lstate);</a>
<a name="ln6282">  }</a>
<a name="ln6283"> </a>
<a name="ln6284">  return 0;</a>
<a name="ln6285">}</a>
<a name="ln6286"> </a>
<a name="ln6287">static int nlua_api_nvim_eval(lua_State *lstate)</a>
<a name="ln6288">{</a>
<a name="ln6289">  Error err = ERROR_INIT;</a>
<a name="ln6290">  char *err_param = 0;</a>
<a name="ln6291">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6292">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6293">    goto exit_0;</a>
<a name="ln6294">  }</a>
<a name="ln6295">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6296">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_eval&quot;);</a>
<a name="ln6297">  }</a>
<a name="ln6298">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6299">  if (ERROR_SET(&amp;err)) {      err_param = &quot;expr&quot;;      goto exit_0;</a>
<a name="ln6300">  }</a>
<a name="ln6301"> </a>
<a name="ln6302">  const Object ret = nvim_eval(arg1, &amp;err);</a>
<a name="ln6303">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln6304">api_free_object(ret);</a>
<a name="ln6305"> </a>
<a name="ln6306">  api_free_string(arg1);</a>
<a name="ln6307"> </a>
<a name="ln6308">exit_0:</a>
<a name="ln6309">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6310">    luaL_where(lstate, 1);</a>
<a name="ln6311">    if (err_param) {</a>
<a name="ln6312">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6313">      lua_pushstring(lstate, err_param);</a>
<a name="ln6314">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6315">    }</a>
<a name="ln6316">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6317">    api_clear_error(&amp;err);</a>
<a name="ln6318">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6319">    return lua_error(lstate);</a>
<a name="ln6320">  }</a>
<a name="ln6321"> </a>
<a name="ln6322">  return 1;</a>
<a name="ln6323">}</a>
<a name="ln6324"> </a>
<a name="ln6325">static int nlua_api_nvim_call_function(lua_State *lstate)</a>
<a name="ln6326">{</a>
<a name="ln6327">  Error err = ERROR_INIT;</a>
<a name="ln6328">  char *err_param = 0;</a>
<a name="ln6329">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6330">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6331">    goto exit_0;</a>
<a name="ln6332">  }</a>
<a name="ln6333">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6334">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_call_function&quot;);</a>
<a name="ln6335">  }</a>
<a name="ln6336">    const Array arg2 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln6337">  if (ERROR_SET(&amp;err)) {      err_param = &quot;args&quot;;      goto exit_0;</a>
<a name="ln6338">  }</a>
<a name="ln6339"> </a>
<a name="ln6340">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6341">  if (ERROR_SET(&amp;err)) {      err_param = &quot;fn&quot;;      goto exit_1;</a>
<a name="ln6342">  }</a>
<a name="ln6343"> </a>
<a name="ln6344">  const Object ret = nvim_call_function(arg1, arg2, &amp;err);</a>
<a name="ln6345">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln6346">api_free_object(ret);</a>
<a name="ln6347"> </a>
<a name="ln6348">  api_free_string(arg1);</a>
<a name="ln6349">exit_1:</a>
<a name="ln6350">  api_free_array(arg2);</a>
<a name="ln6351"> </a>
<a name="ln6352">exit_0:</a>
<a name="ln6353">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6354">    luaL_where(lstate, 1);</a>
<a name="ln6355">    if (err_param) {</a>
<a name="ln6356">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6357">      lua_pushstring(lstate, err_param);</a>
<a name="ln6358">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6359">    }</a>
<a name="ln6360">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6361">    api_clear_error(&amp;err);</a>
<a name="ln6362">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6363">    return lua_error(lstate);</a>
<a name="ln6364">  }</a>
<a name="ln6365"> </a>
<a name="ln6366">  return 1;</a>
<a name="ln6367">}</a>
<a name="ln6368"> </a>
<a name="ln6369">static int nlua_api_nvim_call_dict_function(lua_State *lstate)</a>
<a name="ln6370">{</a>
<a name="ln6371">  Error err = ERROR_INIT;</a>
<a name="ln6372">  char *err_param = 0;</a>
<a name="ln6373">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln6374">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln6375">    goto exit_0;</a>
<a name="ln6376">  }</a>
<a name="ln6377">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6378">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_call_dict_function&quot;);</a>
<a name="ln6379">  }</a>
<a name="ln6380">    const Array arg3 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln6381">  if (ERROR_SET(&amp;err)) {      err_param = &quot;args&quot;;      goto exit_0;</a>
<a name="ln6382">  }</a>
<a name="ln6383"> </a>
<a name="ln6384">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6385">  if (ERROR_SET(&amp;err)) {      err_param = &quot;fn&quot;;      goto exit_1;</a>
<a name="ln6386">  }</a>
<a name="ln6387"> </a>
<a name="ln6388">    const Object arg1 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln6389">  if (ERROR_SET(&amp;err)) {      err_param = &quot;dict&quot;;      goto exit_2;</a>
<a name="ln6390">  }</a>
<a name="ln6391"> </a>
<a name="ln6392">  const Object ret = nvim_call_dict_function(arg1, arg2, arg3, &amp;err);</a>
<a name="ln6393">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln6394">api_free_object(ret);</a>
<a name="ln6395"> </a>
<a name="ln6396">  api_free_object(arg1);</a>
<a name="ln6397">exit_2:</a>
<a name="ln6398">  api_free_string(arg2);</a>
<a name="ln6399">exit_1:</a>
<a name="ln6400">  api_free_array(arg3);</a>
<a name="ln6401"> </a>
<a name="ln6402">exit_0:</a>
<a name="ln6403">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6404">    luaL_where(lstate, 1);</a>
<a name="ln6405">    if (err_param) {</a>
<a name="ln6406">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6407">      lua_pushstring(lstate, err_param);</a>
<a name="ln6408">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6409">    }</a>
<a name="ln6410">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6411">    api_clear_error(&amp;err);</a>
<a name="ln6412">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6413">    return lua_error(lstate);</a>
<a name="ln6414">  }</a>
<a name="ln6415"> </a>
<a name="ln6416">  return 1;</a>
<a name="ln6417">}</a>
<a name="ln6418"> </a>
<a name="ln6419">static int nlua_api_nvim_parse_expression(lua_State *lstate)</a>
<a name="ln6420">{</a>
<a name="ln6421">  Error err = ERROR_INIT;</a>
<a name="ln6422">  char *err_param = 0;</a>
<a name="ln6423">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln6424">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln6425">    goto exit_0;</a>
<a name="ln6426">  }</a>
<a name="ln6427">    const Boolean arg3 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln6428">  if (ERROR_SET(&amp;err)) {      err_param = &quot;highlight&quot;;      goto exit_0;</a>
<a name="ln6429">  }</a>
<a name="ln6430"> </a>
<a name="ln6431">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6432">  if (ERROR_SET(&amp;err)) {      err_param = &quot;flags&quot;;      goto exit_1;</a>
<a name="ln6433">  }</a>
<a name="ln6434"> </a>
<a name="ln6435">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6436">  if (ERROR_SET(&amp;err)) {      err_param = &quot;expr&quot;;      goto exit_2;</a>
<a name="ln6437">  }</a>
<a name="ln6438"> </a>
<a name="ln6439">  const Dictionary ret = nvim_parse_expression(arg1, arg2, arg3, &amp;err);</a>
<a name="ln6440">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln6441">api_free_dictionary(ret);</a>
<a name="ln6442"> </a>
<a name="ln6443">  api_free_string(arg1);</a>
<a name="ln6444">exit_2:</a>
<a name="ln6445">  api_free_string(arg2);</a>
<a name="ln6446">exit_1:</a>
<a name="ln6447">  api_free_boolean(arg3);</a>
<a name="ln6448"> </a>
<a name="ln6449">exit_0:</a>
<a name="ln6450">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6451">    luaL_where(lstate, 1);</a>
<a name="ln6452">    if (err_param) {</a>
<a name="ln6453">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6454">      lua_pushstring(lstate, err_param);</a>
<a name="ln6455">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6456">    }</a>
<a name="ln6457">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6458">    api_clear_error(&amp;err);</a>
<a name="ln6459">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6460">    return lua_error(lstate);</a>
<a name="ln6461">  }</a>
<a name="ln6462"> </a>
<a name="ln6463">  return 1;</a>
<a name="ln6464">}</a>
<a name="ln6465"> </a>
<a name="ln6466">static int nlua_api_nvim_open_win(lua_State *lstate)</a>
<a name="ln6467">{</a>
<a name="ln6468">  Error err = ERROR_INIT;</a>
<a name="ln6469">  char *err_param = 0;</a>
<a name="ln6470">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln6471">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln6472">    goto exit_0;</a>
<a name="ln6473">  }</a>
<a name="ln6474">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6475">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_open_win&quot;);</a>
<a name="ln6476">  }</a>
<a name="ln6477">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln6478">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln6479">    goto exit_0;</a>
<a name="ln6480">  }</a>
<a name="ln6481">    KeyDict_float_config arg3 = { 0 }; nlua_pop_keydict(lstate, &amp;arg3, KeyDict_float_config_get_field, &amp;err_param, &amp;err);</a>
<a name="ln6482">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln6483">  }</a>
<a name="ln6484"> </a>
<a name="ln6485">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln6486">  if (ERROR_SET(&amp;err)) {      err_param = &quot;enter&quot;;      goto exit_1;</a>
<a name="ln6487">  }</a>
<a name="ln6488"> </a>
<a name="ln6489">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln6490">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln6491">  }</a>
<a name="ln6492"> </a>
<a name="ln6493">  const Window ret = nvim_open_win(arg1, arg2, &amp;arg3, &amp;err);</a>
<a name="ln6494">  nlua_push_Window(lstate, ret, true);</a>
<a name="ln6495">api_free_window(ret);</a>
<a name="ln6496"> </a>
<a name="ln6497">  api_free_buffer(arg1);</a>
<a name="ln6498">exit_2:</a>
<a name="ln6499">  api_free_boolean(arg2);</a>
<a name="ln6500">exit_1:</a>
<a name="ln6501">  api_free_keydict_float_config(&amp;arg3);</a>
<a name="ln6502"> </a>
<a name="ln6503">exit_0:</a>
<a name="ln6504">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6505">    luaL_where(lstate, 1);</a>
<a name="ln6506">    if (err_param) {</a>
<a name="ln6507">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6508">      lua_pushstring(lstate, err_param);</a>
<a name="ln6509">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6510">    }</a>
<a name="ln6511">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6512">    api_clear_error(&amp;err);</a>
<a name="ln6513">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6514">    return lua_error(lstate);</a>
<a name="ln6515">  }</a>
<a name="ln6516"> </a>
<a name="ln6517">  return 1;</a>
<a name="ln6518">}</a>
<a name="ln6519"> </a>
<a name="ln6520">static int nlua_api_nvim_win_set_config(lua_State *lstate)</a>
<a name="ln6521">{</a>
<a name="ln6522">  Error err = ERROR_INIT;</a>
<a name="ln6523">  char *err_param = 0;</a>
<a name="ln6524">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6525">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6526">    goto exit_0;</a>
<a name="ln6527">  }</a>
<a name="ln6528">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6529">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_config&quot;);</a>
<a name="ln6530">  }</a>
<a name="ln6531">    KeyDict_float_config arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_float_config_get_field, &amp;err_param, &amp;err);</a>
<a name="ln6532">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln6533">  }</a>
<a name="ln6534"> </a>
<a name="ln6535">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6536">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln6537">  }</a>
<a name="ln6538"> </a>
<a name="ln6539">  nvim_win_set_config(arg1, &amp;arg2, &amp;err);</a>
<a name="ln6540"> </a>
<a name="ln6541">  api_free_window(arg1);</a>
<a name="ln6542">exit_1:</a>
<a name="ln6543">  api_free_keydict_float_config(&amp;arg2);</a>
<a name="ln6544"> </a>
<a name="ln6545">exit_0:</a>
<a name="ln6546">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6547">    luaL_where(lstate, 1);</a>
<a name="ln6548">    if (err_param) {</a>
<a name="ln6549">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6550">      lua_pushstring(lstate, err_param);</a>
<a name="ln6551">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6552">    }</a>
<a name="ln6553">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6554">    api_clear_error(&amp;err);</a>
<a name="ln6555">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6556">    return lua_error(lstate);</a>
<a name="ln6557">  }</a>
<a name="ln6558"> </a>
<a name="ln6559">  return 0;</a>
<a name="ln6560">}</a>
<a name="ln6561"> </a>
<a name="ln6562">static int nlua_api_nvim_win_get_config(lua_State *lstate)</a>
<a name="ln6563">{</a>
<a name="ln6564">  Error err = ERROR_INIT;</a>
<a name="ln6565">  char *err_param = 0;</a>
<a name="ln6566">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6567">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6568">    goto exit_0;</a>
<a name="ln6569">  }</a>
<a name="ln6570">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6571">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_config&quot;);</a>
<a name="ln6572">  }</a>
<a name="ln6573">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6574">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln6575">  }</a>
<a name="ln6576"> </a>
<a name="ln6577">  const Dictionary ret = nvim_win_get_config(arg1, &amp;err);</a>
<a name="ln6578">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln6579">api_free_dictionary(ret);</a>
<a name="ln6580"> </a>
<a name="ln6581">  api_free_window(arg1);</a>
<a name="ln6582"> </a>
<a name="ln6583">exit_0:</a>
<a name="ln6584">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6585">    luaL_where(lstate, 1);</a>
<a name="ln6586">    if (err_param) {</a>
<a name="ln6587">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6588">      lua_pushstring(lstate, err_param);</a>
<a name="ln6589">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6590">    }</a>
<a name="ln6591">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6592">    api_clear_error(&amp;err);</a>
<a name="ln6593">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6594">    return lua_error(lstate);</a>
<a name="ln6595">  }</a>
<a name="ln6596"> </a>
<a name="ln6597">  return 1;</a>
<a name="ln6598">}</a>
<a name="ln6599"> </a>
<a name="ln6600">static int nlua_api_nvim_win_get_buf(lua_State *lstate)</a>
<a name="ln6601">{</a>
<a name="ln6602">  Error err = ERROR_INIT;</a>
<a name="ln6603">  char *err_param = 0;</a>
<a name="ln6604">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6605">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6606">    goto exit_0;</a>
<a name="ln6607">  }</a>
<a name="ln6608">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6609">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_buf&quot;);</a>
<a name="ln6610">  }</a>
<a name="ln6611">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6612">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln6613">  }</a>
<a name="ln6614"> </a>
<a name="ln6615">  const Buffer ret = nvim_win_get_buf(arg1, &amp;err);</a>
<a name="ln6616">  nlua_push_Buffer(lstate, ret, true);</a>
<a name="ln6617">api_free_buffer(ret);</a>
<a name="ln6618"> </a>
<a name="ln6619">  api_free_window(arg1);</a>
<a name="ln6620"> </a>
<a name="ln6621">exit_0:</a>
<a name="ln6622">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6623">    luaL_where(lstate, 1);</a>
<a name="ln6624">    if (err_param) {</a>
<a name="ln6625">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6626">      lua_pushstring(lstate, err_param);</a>
<a name="ln6627">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6628">    }</a>
<a name="ln6629">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6630">    api_clear_error(&amp;err);</a>
<a name="ln6631">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6632">    return lua_error(lstate);</a>
<a name="ln6633">  }</a>
<a name="ln6634"> </a>
<a name="ln6635">  return 1;</a>
<a name="ln6636">}</a>
<a name="ln6637"> </a>
<a name="ln6638">static int nlua_api_nvim_win_set_buf(lua_State *lstate)</a>
<a name="ln6639">{</a>
<a name="ln6640">  Error err = ERROR_INIT;</a>
<a name="ln6641">  char *err_param = 0;</a>
<a name="ln6642">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6643">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6644">    goto exit_0;</a>
<a name="ln6645">  }</a>
<a name="ln6646">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6647">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_buf&quot;);</a>
<a name="ln6648">  }</a>
<a name="ln6649">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln6650">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln6651">    goto exit_0;</a>
<a name="ln6652">  }</a>
<a name="ln6653">    const Buffer arg2 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln6654">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln6655">  }</a>
<a name="ln6656"> </a>
<a name="ln6657">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6658">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln6659">  }</a>
<a name="ln6660"> </a>
<a name="ln6661">  nvim_win_set_buf(arg1, arg2, &amp;err);</a>
<a name="ln6662"> </a>
<a name="ln6663">  api_free_window(arg1);</a>
<a name="ln6664">exit_1:</a>
<a name="ln6665">  api_free_buffer(arg2);</a>
<a name="ln6666"> </a>
<a name="ln6667">exit_0:</a>
<a name="ln6668">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6669">    luaL_where(lstate, 1);</a>
<a name="ln6670">    if (err_param) {</a>
<a name="ln6671">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6672">      lua_pushstring(lstate, err_param);</a>
<a name="ln6673">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6674">    }</a>
<a name="ln6675">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6676">    api_clear_error(&amp;err);</a>
<a name="ln6677">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6678">    return lua_error(lstate);</a>
<a name="ln6679">  }</a>
<a name="ln6680"> </a>
<a name="ln6681">  return 0;</a>
<a name="ln6682">}</a>
<a name="ln6683"> </a>
<a name="ln6684">static int nlua_api_nvim_win_get_cursor(lua_State *lstate)</a>
<a name="ln6685">{</a>
<a name="ln6686">  Error err = ERROR_INIT;</a>
<a name="ln6687">  char *err_param = 0;</a>
<a name="ln6688">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6689">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6690">    goto exit_0;</a>
<a name="ln6691">  }</a>
<a name="ln6692">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6693">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_cursor&quot;);</a>
<a name="ln6694">  }</a>
<a name="ln6695">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6696">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln6697">  }</a>
<a name="ln6698"> </a>
<a name="ln6699">  const ArrayOf(Integer, 2) ret = nvim_win_get_cursor(arg1, &amp;err);</a>
<a name="ln6700">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln6701">api_free_array(ret);</a>
<a name="ln6702"> </a>
<a name="ln6703">  api_free_window(arg1);</a>
<a name="ln6704"> </a>
<a name="ln6705">exit_0:</a>
<a name="ln6706">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6707">    luaL_where(lstate, 1);</a>
<a name="ln6708">    if (err_param) {</a>
<a name="ln6709">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6710">      lua_pushstring(lstate, err_param);</a>
<a name="ln6711">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6712">    }</a>
<a name="ln6713">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6714">    api_clear_error(&amp;err);</a>
<a name="ln6715">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6716">    return lua_error(lstate);</a>
<a name="ln6717">  }</a>
<a name="ln6718"> </a>
<a name="ln6719">  return 1;</a>
<a name="ln6720">}</a>
<a name="ln6721"> </a>
<a name="ln6722">static int nlua_api_nvim_win_set_cursor(lua_State *lstate)</a>
<a name="ln6723">{</a>
<a name="ln6724">  Error err = ERROR_INIT;</a>
<a name="ln6725">  char *err_param = 0;</a>
<a name="ln6726">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6727">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6728">    goto exit_0;</a>
<a name="ln6729">  }</a>
<a name="ln6730">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6731">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_cursor&quot;);</a>
<a name="ln6732">  }</a>
<a name="ln6733">    const ArrayOf(Integer, 2) arg2 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln6734">  if (ERROR_SET(&amp;err)) {      err_param = &quot;pos&quot;;      goto exit_0;</a>
<a name="ln6735">  }</a>
<a name="ln6736"> </a>
<a name="ln6737">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6738">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln6739">  }</a>
<a name="ln6740"> </a>
<a name="ln6741">  nvim_win_set_cursor(arg1, arg2, &amp;err);</a>
<a name="ln6742"> </a>
<a name="ln6743">  api_free_window(arg1);</a>
<a name="ln6744">exit_1:</a>
<a name="ln6745">  api_free_array(arg2);</a>
<a name="ln6746"> </a>
<a name="ln6747">exit_0:</a>
<a name="ln6748">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6749">    luaL_where(lstate, 1);</a>
<a name="ln6750">    if (err_param) {</a>
<a name="ln6751">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6752">      lua_pushstring(lstate, err_param);</a>
<a name="ln6753">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6754">    }</a>
<a name="ln6755">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6756">    api_clear_error(&amp;err);</a>
<a name="ln6757">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6758">    return lua_error(lstate);</a>
<a name="ln6759">  }</a>
<a name="ln6760"> </a>
<a name="ln6761">  return 0;</a>
<a name="ln6762">}</a>
<a name="ln6763"> </a>
<a name="ln6764">static int nlua_api_nvim_win_get_height(lua_State *lstate)</a>
<a name="ln6765">{</a>
<a name="ln6766">  Error err = ERROR_INIT;</a>
<a name="ln6767">  char *err_param = 0;</a>
<a name="ln6768">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6769">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6770">    goto exit_0;</a>
<a name="ln6771">  }</a>
<a name="ln6772">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6773">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_height&quot;);</a>
<a name="ln6774">  }</a>
<a name="ln6775">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6776">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln6777">  }</a>
<a name="ln6778"> </a>
<a name="ln6779">  const Integer ret = nvim_win_get_height(arg1, &amp;err);</a>
<a name="ln6780">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln6781">api_free_integer(ret);</a>
<a name="ln6782"> </a>
<a name="ln6783">  api_free_window(arg1);</a>
<a name="ln6784"> </a>
<a name="ln6785">exit_0:</a>
<a name="ln6786">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6787">    luaL_where(lstate, 1);</a>
<a name="ln6788">    if (err_param) {</a>
<a name="ln6789">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6790">      lua_pushstring(lstate, err_param);</a>
<a name="ln6791">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6792">    }</a>
<a name="ln6793">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6794">    api_clear_error(&amp;err);</a>
<a name="ln6795">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6796">    return lua_error(lstate);</a>
<a name="ln6797">  }</a>
<a name="ln6798"> </a>
<a name="ln6799">  return 1;</a>
<a name="ln6800">}</a>
<a name="ln6801"> </a>
<a name="ln6802">static int nlua_api_nvim_win_set_height(lua_State *lstate)</a>
<a name="ln6803">{</a>
<a name="ln6804">  Error err = ERROR_INIT;</a>
<a name="ln6805">  char *err_param = 0;</a>
<a name="ln6806">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6807">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6808">    goto exit_0;</a>
<a name="ln6809">  }</a>
<a name="ln6810">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6811">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_height&quot;);</a>
<a name="ln6812">  }</a>
<a name="ln6813">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln6814">  if (ERROR_SET(&amp;err)) {      err_param = &quot;height&quot;;      goto exit_0;</a>
<a name="ln6815">  }</a>
<a name="ln6816"> </a>
<a name="ln6817">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6818">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln6819">  }</a>
<a name="ln6820"> </a>
<a name="ln6821">  nvim_win_set_height(arg1, arg2, &amp;err);</a>
<a name="ln6822"> </a>
<a name="ln6823">  api_free_window(arg1);</a>
<a name="ln6824">exit_1:</a>
<a name="ln6825">  api_free_integer(arg2);</a>
<a name="ln6826"> </a>
<a name="ln6827">exit_0:</a>
<a name="ln6828">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6829">    luaL_where(lstate, 1);</a>
<a name="ln6830">    if (err_param) {</a>
<a name="ln6831">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6832">      lua_pushstring(lstate, err_param);</a>
<a name="ln6833">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6834">    }</a>
<a name="ln6835">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6836">    api_clear_error(&amp;err);</a>
<a name="ln6837">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6838">    return lua_error(lstate);</a>
<a name="ln6839">  }</a>
<a name="ln6840"> </a>
<a name="ln6841">  return 0;</a>
<a name="ln6842">}</a>
<a name="ln6843"> </a>
<a name="ln6844">static int nlua_api_nvim_win_get_width(lua_State *lstate)</a>
<a name="ln6845">{</a>
<a name="ln6846">  Error err = ERROR_INIT;</a>
<a name="ln6847">  char *err_param = 0;</a>
<a name="ln6848">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6849">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6850">    goto exit_0;</a>
<a name="ln6851">  }</a>
<a name="ln6852">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6853">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_width&quot;);</a>
<a name="ln6854">  }</a>
<a name="ln6855">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6856">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln6857">  }</a>
<a name="ln6858"> </a>
<a name="ln6859">  const Integer ret = nvim_win_get_width(arg1, &amp;err);</a>
<a name="ln6860">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln6861">api_free_integer(ret);</a>
<a name="ln6862"> </a>
<a name="ln6863">  api_free_window(arg1);</a>
<a name="ln6864"> </a>
<a name="ln6865">exit_0:</a>
<a name="ln6866">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6867">    luaL_where(lstate, 1);</a>
<a name="ln6868">    if (err_param) {</a>
<a name="ln6869">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6870">      lua_pushstring(lstate, err_param);</a>
<a name="ln6871">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6872">    }</a>
<a name="ln6873">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6874">    api_clear_error(&amp;err);</a>
<a name="ln6875">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6876">    return lua_error(lstate);</a>
<a name="ln6877">  }</a>
<a name="ln6878"> </a>
<a name="ln6879">  return 1;</a>
<a name="ln6880">}</a>
<a name="ln6881"> </a>
<a name="ln6882">static int nlua_api_nvim_win_set_width(lua_State *lstate)</a>
<a name="ln6883">{</a>
<a name="ln6884">  Error err = ERROR_INIT;</a>
<a name="ln6885">  char *err_param = 0;</a>
<a name="ln6886">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6887">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6888">    goto exit_0;</a>
<a name="ln6889">  }</a>
<a name="ln6890">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6891">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_width&quot;);</a>
<a name="ln6892">  }</a>
<a name="ln6893">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln6894">  if (ERROR_SET(&amp;err)) {      err_param = &quot;width&quot;;      goto exit_0;</a>
<a name="ln6895">  }</a>
<a name="ln6896"> </a>
<a name="ln6897">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6898">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln6899">  }</a>
<a name="ln6900"> </a>
<a name="ln6901">  nvim_win_set_width(arg1, arg2, &amp;err);</a>
<a name="ln6902"> </a>
<a name="ln6903">  api_free_window(arg1);</a>
<a name="ln6904">exit_1:</a>
<a name="ln6905">  api_free_integer(arg2);</a>
<a name="ln6906"> </a>
<a name="ln6907">exit_0:</a>
<a name="ln6908">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6909">    luaL_where(lstate, 1);</a>
<a name="ln6910">    if (err_param) {</a>
<a name="ln6911">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6912">      lua_pushstring(lstate, err_param);</a>
<a name="ln6913">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6914">    }</a>
<a name="ln6915">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6916">    api_clear_error(&amp;err);</a>
<a name="ln6917">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6918">    return lua_error(lstate);</a>
<a name="ln6919">  }</a>
<a name="ln6920"> </a>
<a name="ln6921">  return 0;</a>
<a name="ln6922">}</a>
<a name="ln6923"> </a>
<a name="ln6924">static int nlua_api_nvim_win_get_var(lua_State *lstate)</a>
<a name="ln6925">{</a>
<a name="ln6926">  Error err = ERROR_INIT;</a>
<a name="ln6927">  char *err_param = 0;</a>
<a name="ln6928">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6929">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6930">    goto exit_0;</a>
<a name="ln6931">  }</a>
<a name="ln6932">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6933">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_var&quot;);</a>
<a name="ln6934">  }</a>
<a name="ln6935">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6936">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln6937">  }</a>
<a name="ln6938"> </a>
<a name="ln6939">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6940">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln6941">  }</a>
<a name="ln6942"> </a>
<a name="ln6943">  const Object ret = nvim_win_get_var(arg1, arg2, &amp;err);</a>
<a name="ln6944">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln6945">api_free_object(ret);</a>
<a name="ln6946"> </a>
<a name="ln6947">  api_free_window(arg1);</a>
<a name="ln6948">exit_1:</a>
<a name="ln6949">  api_free_string(arg2);</a>
<a name="ln6950"> </a>
<a name="ln6951">exit_0:</a>
<a name="ln6952">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6953">    luaL_where(lstate, 1);</a>
<a name="ln6954">    if (err_param) {</a>
<a name="ln6955">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6956">      lua_pushstring(lstate, err_param);</a>
<a name="ln6957">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6958">    }</a>
<a name="ln6959">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6960">    api_clear_error(&amp;err);</a>
<a name="ln6961">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6962">    return lua_error(lstate);</a>
<a name="ln6963">  }</a>
<a name="ln6964"> </a>
<a name="ln6965">  return 1;</a>
<a name="ln6966">}</a>
<a name="ln6967"> </a>
<a name="ln6968">static int nlua_api_nvim_win_set_var(lua_State *lstate)</a>
<a name="ln6969">{</a>
<a name="ln6970">  Error err = ERROR_INIT;</a>
<a name="ln6971">  char *err_param = 0;</a>
<a name="ln6972">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln6973">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln6974">    goto exit_0;</a>
<a name="ln6975">  }</a>
<a name="ln6976">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6977">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_var&quot;);</a>
<a name="ln6978">  }</a>
<a name="ln6979">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln6980">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln6981">  }</a>
<a name="ln6982"> </a>
<a name="ln6983">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6984">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln6985">  }</a>
<a name="ln6986"> </a>
<a name="ln6987">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6988">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_2;</a>
<a name="ln6989">  }</a>
<a name="ln6990"> </a>
<a name="ln6991">  nvim_win_set_var(arg1, arg2, arg3, &amp;err);</a>
<a name="ln6992"> </a>
<a name="ln6993">  api_free_window(arg1);</a>
<a name="ln6994">exit_2:</a>
<a name="ln6995">  api_free_string(arg2);</a>
<a name="ln6996">exit_1:</a>
<a name="ln6997">  api_free_object(arg3);</a>
<a name="ln6998"> </a>
<a name="ln6999">exit_0:</a>
<a name="ln7000">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7001">    luaL_where(lstate, 1);</a>
<a name="ln7002">    if (err_param) {</a>
<a name="ln7003">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7004">      lua_pushstring(lstate, err_param);</a>
<a name="ln7005">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7006">    }</a>
<a name="ln7007">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7008">    api_clear_error(&amp;err);</a>
<a name="ln7009">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7010">    return lua_error(lstate);</a>
<a name="ln7011">  }</a>
<a name="ln7012"> </a>
<a name="ln7013">  return 0;</a>
<a name="ln7014">}</a>
<a name="ln7015"> </a>
<a name="ln7016">static int nlua_api_nvim_win_del_var(lua_State *lstate)</a>
<a name="ln7017">{</a>
<a name="ln7018">  Error err = ERROR_INIT;</a>
<a name="ln7019">  char *err_param = 0;</a>
<a name="ln7020">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln7021">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln7022">    goto exit_0;</a>
<a name="ln7023">  }</a>
<a name="ln7024">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7025">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_del_var&quot;);</a>
<a name="ln7026">  }</a>
<a name="ln7027">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln7028">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln7029">  }</a>
<a name="ln7030"> </a>
<a name="ln7031">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7032">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln7033">  }</a>
<a name="ln7034"> </a>
<a name="ln7035">  nvim_win_del_var(arg1, arg2, &amp;err);</a>
<a name="ln7036"> </a>
<a name="ln7037">  api_free_window(arg1);</a>
<a name="ln7038">exit_1:</a>
<a name="ln7039">  api_free_string(arg2);</a>
<a name="ln7040"> </a>
<a name="ln7041">exit_0:</a>
<a name="ln7042">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7043">    luaL_where(lstate, 1);</a>
<a name="ln7044">    if (err_param) {</a>
<a name="ln7045">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7046">      lua_pushstring(lstate, err_param);</a>
<a name="ln7047">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7048">    }</a>
<a name="ln7049">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7050">    api_clear_error(&amp;err);</a>
<a name="ln7051">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7052">    return lua_error(lstate);</a>
<a name="ln7053">  }</a>
<a name="ln7054"> </a>
<a name="ln7055">  return 0;</a>
<a name="ln7056">}</a>
<a name="ln7057"> </a>
<a name="ln7058">static int nlua_api_nvim_win_get_position(lua_State *lstate)</a>
<a name="ln7059">{</a>
<a name="ln7060">  Error err = ERROR_INIT;</a>
<a name="ln7061">  char *err_param = 0;</a>
<a name="ln7062">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln7063">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln7064">    goto exit_0;</a>
<a name="ln7065">  }</a>
<a name="ln7066">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7067">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_position&quot;);</a>
<a name="ln7068">  }</a>
<a name="ln7069">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7070">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln7071">  }</a>
<a name="ln7072"> </a>
<a name="ln7073">  const ArrayOf(Integer, 2) ret = nvim_win_get_position(arg1, &amp;err);</a>
<a name="ln7074">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln7075">api_free_array(ret);</a>
<a name="ln7076"> </a>
<a name="ln7077">  api_free_window(arg1);</a>
<a name="ln7078"> </a>
<a name="ln7079">exit_0:</a>
<a name="ln7080">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7081">    luaL_where(lstate, 1);</a>
<a name="ln7082">    if (err_param) {</a>
<a name="ln7083">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7084">      lua_pushstring(lstate, err_param);</a>
<a name="ln7085">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7086">    }</a>
<a name="ln7087">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7088">    api_clear_error(&amp;err);</a>
<a name="ln7089">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7090">    return lua_error(lstate);</a>
<a name="ln7091">  }</a>
<a name="ln7092"> </a>
<a name="ln7093">  return 1;</a>
<a name="ln7094">}</a>
<a name="ln7095"> </a>
<a name="ln7096">static int nlua_api_nvim_win_get_tabpage(lua_State *lstate)</a>
<a name="ln7097">{</a>
<a name="ln7098">  Error err = ERROR_INIT;</a>
<a name="ln7099">  char *err_param = 0;</a>
<a name="ln7100">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln7101">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln7102">    goto exit_0;</a>
<a name="ln7103">  }</a>
<a name="ln7104">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7105">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_tabpage&quot;);</a>
<a name="ln7106">  }</a>
<a name="ln7107">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7108">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln7109">  }</a>
<a name="ln7110"> </a>
<a name="ln7111">  const Tabpage ret = nvim_win_get_tabpage(arg1, &amp;err);</a>
<a name="ln7112">  nlua_push_Tabpage(lstate, ret, true);</a>
<a name="ln7113">api_free_tabpage(ret);</a>
<a name="ln7114"> </a>
<a name="ln7115">  api_free_window(arg1);</a>
<a name="ln7116"> </a>
<a name="ln7117">exit_0:</a>
<a name="ln7118">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7119">    luaL_where(lstate, 1);</a>
<a name="ln7120">    if (err_param) {</a>
<a name="ln7121">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7122">      lua_pushstring(lstate, err_param);</a>
<a name="ln7123">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7124">    }</a>
<a name="ln7125">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7126">    api_clear_error(&amp;err);</a>
<a name="ln7127">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7128">    return lua_error(lstate);</a>
<a name="ln7129">  }</a>
<a name="ln7130"> </a>
<a name="ln7131">  return 1;</a>
<a name="ln7132">}</a>
<a name="ln7133"> </a>
<a name="ln7134">static int nlua_api_nvim_win_get_number(lua_State *lstate)</a>
<a name="ln7135">{</a>
<a name="ln7136">  Error err = ERROR_INIT;</a>
<a name="ln7137">  char *err_param = 0;</a>
<a name="ln7138">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln7139">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln7140">    goto exit_0;</a>
<a name="ln7141">  }</a>
<a name="ln7142">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7143">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_number&quot;);</a>
<a name="ln7144">  }</a>
<a name="ln7145">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7146">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln7147">  }</a>
<a name="ln7148"> </a>
<a name="ln7149">  const Integer ret = nvim_win_get_number(arg1, &amp;err);</a>
<a name="ln7150">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln7151">api_free_integer(ret);</a>
<a name="ln7152"> </a>
<a name="ln7153">  api_free_window(arg1);</a>
<a name="ln7154"> </a>
<a name="ln7155">exit_0:</a>
<a name="ln7156">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7157">    luaL_where(lstate, 1);</a>
<a name="ln7158">    if (err_param) {</a>
<a name="ln7159">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7160">      lua_pushstring(lstate, err_param);</a>
<a name="ln7161">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7162">    }</a>
<a name="ln7163">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7164">    api_clear_error(&amp;err);</a>
<a name="ln7165">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7166">    return lua_error(lstate);</a>
<a name="ln7167">  }</a>
<a name="ln7168"> </a>
<a name="ln7169">  return 1;</a>
<a name="ln7170">}</a>
<a name="ln7171"> </a>
<a name="ln7172">static int nlua_api_nvim_win_is_valid(lua_State *lstate)</a>
<a name="ln7173">{</a>
<a name="ln7174">  Error err = ERROR_INIT;</a>
<a name="ln7175">  char *err_param = 0;</a>
<a name="ln7176">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln7177">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln7178">    goto exit_0;</a>
<a name="ln7179">  }</a>
<a name="ln7180">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7181">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_is_valid&quot;);</a>
<a name="ln7182">  }</a>
<a name="ln7183">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7184">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln7185">  }</a>
<a name="ln7186"> </a>
<a name="ln7187">  const Boolean ret = nvim_win_is_valid(arg1);</a>
<a name="ln7188">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln7189">api_free_boolean(ret);</a>
<a name="ln7190"> </a>
<a name="ln7191">  api_free_window(arg1);</a>
<a name="ln7192"> </a>
<a name="ln7193">exit_0:</a>
<a name="ln7194">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7195">    luaL_where(lstate, 1);</a>
<a name="ln7196">    if (err_param) {</a>
<a name="ln7197">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7198">      lua_pushstring(lstate, err_param);</a>
<a name="ln7199">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7200">    }</a>
<a name="ln7201">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7202">    api_clear_error(&amp;err);</a>
<a name="ln7203">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7204">    return lua_error(lstate);</a>
<a name="ln7205">  }</a>
<a name="ln7206"> </a>
<a name="ln7207">  return 1;</a>
<a name="ln7208">}</a>
<a name="ln7209"> </a>
<a name="ln7210">static int nlua_api_nvim_win_hide(lua_State *lstate)</a>
<a name="ln7211">{</a>
<a name="ln7212">  Error err = ERROR_INIT;</a>
<a name="ln7213">  char *err_param = 0;</a>
<a name="ln7214">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln7215">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln7216">    goto exit_0;</a>
<a name="ln7217">  }</a>
<a name="ln7218">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7219">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_hide&quot;);</a>
<a name="ln7220">  }</a>
<a name="ln7221">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln7222">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln7223">    goto exit_0;</a>
<a name="ln7224">  }</a>
<a name="ln7225">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7226">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln7227">  }</a>
<a name="ln7228"> </a>
<a name="ln7229">  nvim_win_hide(arg1, &amp;err);</a>
<a name="ln7230"> </a>
<a name="ln7231">  api_free_window(arg1);</a>
<a name="ln7232"> </a>
<a name="ln7233">exit_0:</a>
<a name="ln7234">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7235">    luaL_where(lstate, 1);</a>
<a name="ln7236">    if (err_param) {</a>
<a name="ln7237">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7238">      lua_pushstring(lstate, err_param);</a>
<a name="ln7239">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7240">    }</a>
<a name="ln7241">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7242">    api_clear_error(&amp;err);</a>
<a name="ln7243">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7244">    return lua_error(lstate);</a>
<a name="ln7245">  }</a>
<a name="ln7246"> </a>
<a name="ln7247">  return 0;</a>
<a name="ln7248">}</a>
<a name="ln7249"> </a>
<a name="ln7250">static int nlua_api_nvim_win_close(lua_State *lstate)</a>
<a name="ln7251">{</a>
<a name="ln7252">  Error err = ERROR_INIT;</a>
<a name="ln7253">  char *err_param = 0;</a>
<a name="ln7254">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln7255">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln7256">    goto exit_0;</a>
<a name="ln7257">  }</a>
<a name="ln7258">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7259">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_close&quot;);</a>
<a name="ln7260">  }</a>
<a name="ln7261">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln7262">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln7263">    goto exit_0;</a>
<a name="ln7264">  }</a>
<a name="ln7265">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln7266">  if (ERROR_SET(&amp;err)) {      err_param = &quot;force&quot;;      goto exit_0;</a>
<a name="ln7267">  }</a>
<a name="ln7268"> </a>
<a name="ln7269">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7270">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln7271">  }</a>
<a name="ln7272"> </a>
<a name="ln7273">  nvim_win_close(arg1, arg2, &amp;err);</a>
<a name="ln7274"> </a>
<a name="ln7275">  api_free_window(arg1);</a>
<a name="ln7276">exit_1:</a>
<a name="ln7277">  api_free_boolean(arg2);</a>
<a name="ln7278"> </a>
<a name="ln7279">exit_0:</a>
<a name="ln7280">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7281">    luaL_where(lstate, 1);</a>
<a name="ln7282">    if (err_param) {</a>
<a name="ln7283">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7284">      lua_pushstring(lstate, err_param);</a>
<a name="ln7285">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7286">    }</a>
<a name="ln7287">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7288">    api_clear_error(&amp;err);</a>
<a name="ln7289">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7290">    return lua_error(lstate);</a>
<a name="ln7291">  }</a>
<a name="ln7292"> </a>
<a name="ln7293">  return 0;</a>
<a name="ln7294">}</a>
<a name="ln7295"> </a>
<a name="ln7296">static int nlua_api_nvim_win_call(lua_State *lstate)</a>
<a name="ln7297">{</a>
<a name="ln7298">  Error err = ERROR_INIT;</a>
<a name="ln7299">  char *err_param = 0;</a>
<a name="ln7300">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln7301">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln7302">    goto exit_0;</a>
<a name="ln7303">  }</a>
<a name="ln7304">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7305">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_call&quot;);</a>
<a name="ln7306">  }</a>
<a name="ln7307">    const LuaRef arg2 = nlua_pop_LuaRef(lstate, &amp;err);</a>
<a name="ln7308">  if (ERROR_SET(&amp;err)) {      err_param = &quot;fun&quot;;      goto exit_0;</a>
<a name="ln7309">  }</a>
<a name="ln7310"> </a>
<a name="ln7311">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7312">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln7313">  }</a>
<a name="ln7314"> </a>
<a name="ln7315">  const Object ret = nvim_win_call(arg1, arg2, &amp;err);</a>
<a name="ln7316">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln7317">api_free_object(ret);</a>
<a name="ln7318"> </a>
<a name="ln7319">  api_free_window(arg1);</a>
<a name="ln7320">exit_1:</a>
<a name="ln7321">  api_free_luaref(arg2);</a>
<a name="ln7322"> </a>
<a name="ln7323">exit_0:</a>
<a name="ln7324">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7325">    luaL_where(lstate, 1);</a>
<a name="ln7326">    if (err_param) {</a>
<a name="ln7327">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7328">      lua_pushstring(lstate, err_param);</a>
<a name="ln7329">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7330">    }</a>
<a name="ln7331">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7332">    api_clear_error(&amp;err);</a>
<a name="ln7333">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7334">    return lua_error(lstate);</a>
<a name="ln7335">  }</a>
<a name="ln7336"> </a>
<a name="ln7337">  return 1;</a>
<a name="ln7338">}</a>
<a name="ln7339"> </a>
<a name="ln7340">static int nlua_api_nvim_win_set_hl_ns(lua_State *lstate)</a>
<a name="ln7341">{</a>
<a name="ln7342">  Error err = ERROR_INIT;</a>
<a name="ln7343">  char *err_param = 0;</a>
<a name="ln7344">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln7345">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln7346">    goto exit_0;</a>
<a name="ln7347">  }</a>
<a name="ln7348">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7349">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_hl_ns&quot;);</a>
<a name="ln7350">  }</a>
<a name="ln7351">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln7352">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_0;</a>
<a name="ln7353">  }</a>
<a name="ln7354"> </a>
<a name="ln7355">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7356">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln7357">  }</a>
<a name="ln7358"> </a>
<a name="ln7359">  nvim_win_set_hl_ns(arg1, arg2, &amp;err);</a>
<a name="ln7360"> </a>
<a name="ln7361">  api_free_window(arg1);</a>
<a name="ln7362">exit_1:</a>
<a name="ln7363">  api_free_integer(arg2);</a>
<a name="ln7364"> </a>
<a name="ln7365">exit_0:</a>
<a name="ln7366">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7367">    luaL_where(lstate, 1);</a>
<a name="ln7368">    if (err_param) {</a>
<a name="ln7369">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7370">      lua_pushstring(lstate, err_param);</a>
<a name="ln7371">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7372">    }</a>
<a name="ln7373">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7374">    api_clear_error(&amp;err);</a>
<a name="ln7375">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7376">    return lua_error(lstate);</a>
<a name="ln7377">  }</a>
<a name="ln7378"> </a>
<a name="ln7379">  return 0;</a>
<a name="ln7380">}</a>
<a name="ln7381"> </a>
<a name="ln7382">static int nlua_api_nvim_win_text_height(lua_State *lstate)</a>
<a name="ln7383">{</a>
<a name="ln7384">  Error err = ERROR_INIT;</a>
<a name="ln7385">  char *err_param = 0;</a>
<a name="ln7386">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln7387">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln7388">    goto exit_0;</a>
<a name="ln7389">  }</a>
<a name="ln7390">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7391">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_text_height&quot;);</a>
<a name="ln7392">  }</a>
<a name="ln7393">    KeyDict_win_text_height arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_win_text_height_get_field, &amp;err_param, &amp;err);</a>
<a name="ln7394">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln7395">  }</a>
<a name="ln7396"> </a>
<a name="ln7397">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7398">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln7399">  }</a>
<a name="ln7400"> </a>
<a name="ln7401">  Arena arena = ARENA_EMPTY;</a>
<a name="ln7402">  const Dictionary ret = nvim_win_text_height(arg1, &amp;arg2, &amp;arena, &amp;err);</a>
<a name="ln7403">  nlua_push_Dictionary(lstate, ret, false);</a>
<a name="ln7404">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln7405"> </a>
<a name="ln7406">  api_free_window(arg1);</a>
<a name="ln7407">exit_1:</a>
<a name="ln7408">  api_free_keydict_win_text_height(&amp;arg2);</a>
<a name="ln7409"> </a>
<a name="ln7410">exit_0:</a>
<a name="ln7411">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7412">    luaL_where(lstate, 1);</a>
<a name="ln7413">    if (err_param) {</a>
<a name="ln7414">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7415">      lua_pushstring(lstate, err_param);</a>
<a name="ln7416">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7417">    }</a>
<a name="ln7418">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7419">    api_clear_error(&amp;err);</a>
<a name="ln7420">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7421">    return lua_error(lstate);</a>
<a name="ln7422">  }</a>
<a name="ln7423"> </a>
<a name="ln7424">  return 1;</a>
<a name="ln7425">}</a>
<a name="ln7426">void nlua_add_api_functions(lua_State *lstate);  // silence -Wmissing-prototypes</a>
<a name="ln7427">void nlua_add_api_functions(lua_State *lstate)</a>
<a name="ln7428">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7429">{</a>
<a name="ln7430">  lua_createtable(lstate, 0, 173);</a>
<a name="ln7431"> </a>
<a name="ln7432">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_autocmds);</a>
<a name="ln7433">  lua_setfield(lstate, -2, &quot;nvim_get_autocmds&quot;);</a>
<a name="ln7434">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_create_autocmd);</a>
<a name="ln7435">  lua_setfield(lstate, -2, &quot;nvim_create_autocmd&quot;);</a>
<a name="ln7436">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_autocmd);</a>
<a name="ln7437">  lua_setfield(lstate, -2, &quot;nvim_del_autocmd&quot;);</a>
<a name="ln7438">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_clear_autocmds);</a>
<a name="ln7439">  lua_setfield(lstate, -2, &quot;nvim_clear_autocmds&quot;);</a>
<a name="ln7440">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_create_augroup);</a>
<a name="ln7441">  lua_setfield(lstate, -2, &quot;nvim_create_augroup&quot;);</a>
<a name="ln7442">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_augroup_by_id);</a>
<a name="ln7443">  lua_setfield(lstate, -2, &quot;nvim_del_augroup_by_id&quot;);</a>
<a name="ln7444">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_augroup_by_name);</a>
<a name="ln7445">  lua_setfield(lstate, -2, &quot;nvim_del_augroup_by_name&quot;);</a>
<a name="ln7446">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_exec_autocmds);</a>
<a name="ln7447">  lua_setfield(lstate, -2, &quot;nvim_exec_autocmds&quot;);</a>
<a name="ln7448">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_line_count);</a>
<a name="ln7449">  lua_setfield(lstate, -2, &quot;nvim_buf_line_count&quot;);</a>
<a name="ln7450">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_attach);</a>
<a name="ln7451">  lua_setfield(lstate, -2, &quot;nvim_buf_attach&quot;);</a>
<a name="ln7452">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__buf_redraw_range);</a>
<a name="ln7453">  lua_setfield(lstate, -2, &quot;nvim__buf_redraw_range&quot;);</a>
<a name="ln7454">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_lines);</a>
<a name="ln7455">  lua_setfield(lstate, -2, &quot;nvim_buf_get_lines&quot;);</a>
<a name="ln7456">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_lines);</a>
<a name="ln7457">  lua_setfield(lstate, -2, &quot;nvim_buf_set_lines&quot;);</a>
<a name="ln7458">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_text);</a>
<a name="ln7459">  lua_setfield(lstate, -2, &quot;nvim_buf_set_text&quot;);</a>
<a name="ln7460">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_text);</a>
<a name="ln7461">  lua_setfield(lstate, -2, &quot;nvim_buf_get_text&quot;);</a>
<a name="ln7462">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_offset);</a>
<a name="ln7463">  lua_setfield(lstate, -2, &quot;nvim_buf_get_offset&quot;);</a>
<a name="ln7464">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_var);</a>
<a name="ln7465">  lua_setfield(lstate, -2, &quot;nvim_buf_get_var&quot;);</a>
<a name="ln7466">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_changedtick);</a>
<a name="ln7467">  lua_setfield(lstate, -2, &quot;nvim_buf_get_changedtick&quot;);</a>
<a name="ln7468">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_keymap);</a>
<a name="ln7469">  lua_setfield(lstate, -2, &quot;nvim_buf_get_keymap&quot;);</a>
<a name="ln7470">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_keymap);</a>
<a name="ln7471">  lua_setfield(lstate, -2, &quot;nvim_buf_set_keymap&quot;);</a>
<a name="ln7472">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_del_keymap);</a>
<a name="ln7473">  lua_setfield(lstate, -2, &quot;nvim_buf_del_keymap&quot;);</a>
<a name="ln7474">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_var);</a>
<a name="ln7475">  lua_setfield(lstate, -2, &quot;nvim_buf_set_var&quot;);</a>
<a name="ln7476">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_del_var);</a>
<a name="ln7477">  lua_setfield(lstate, -2, &quot;nvim_buf_del_var&quot;);</a>
<a name="ln7478">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_name);</a>
<a name="ln7479">  lua_setfield(lstate, -2, &quot;nvim_buf_get_name&quot;);</a>
<a name="ln7480">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_name);</a>
<a name="ln7481">  lua_setfield(lstate, -2, &quot;nvim_buf_set_name&quot;);</a>
<a name="ln7482">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_is_loaded);</a>
<a name="ln7483">  lua_setfield(lstate, -2, &quot;nvim_buf_is_loaded&quot;);</a>
<a name="ln7484">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_delete);</a>
<a name="ln7485">  lua_setfield(lstate, -2, &quot;nvim_buf_delete&quot;);</a>
<a name="ln7486">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_is_valid);</a>
<a name="ln7487">  lua_setfield(lstate, -2, &quot;nvim_buf_is_valid&quot;);</a>
<a name="ln7488">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_del_mark);</a>
<a name="ln7489">  lua_setfield(lstate, -2, &quot;nvim_buf_del_mark&quot;);</a>
<a name="ln7490">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_mark);</a>
<a name="ln7491">  lua_setfield(lstate, -2, &quot;nvim_buf_set_mark&quot;);</a>
<a name="ln7492">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_mark);</a>
<a name="ln7493">  lua_setfield(lstate, -2, &quot;nvim_buf_get_mark&quot;);</a>
<a name="ln7494">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_call);</a>
<a name="ln7495">  lua_setfield(lstate, -2, &quot;nvim_buf_call&quot;);</a>
<a name="ln7496">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__buf_stats);</a>
<a name="ln7497">  lua_setfield(lstate, -2, &quot;nvim__buf_stats&quot;);</a>
<a name="ln7498">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_parse_cmd);</a>
<a name="ln7499">  lua_setfield(lstate, -2, &quot;nvim_parse_cmd&quot;);</a>
<a name="ln7500">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_cmd);</a>
<a name="ln7501">  lua_setfield(lstate, -2, &quot;nvim_cmd&quot;);</a>
<a name="ln7502">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_create_user_command);</a>
<a name="ln7503">  lua_setfield(lstate, -2, &quot;nvim_create_user_command&quot;);</a>
<a name="ln7504">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_user_command);</a>
<a name="ln7505">  lua_setfield(lstate, -2, &quot;nvim_del_user_command&quot;);</a>
<a name="ln7506">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_create_user_command);</a>
<a name="ln7507">  lua_setfield(lstate, -2, &quot;nvim_buf_create_user_command&quot;);</a>
<a name="ln7508">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_del_user_command);</a>
<a name="ln7509">  lua_setfield(lstate, -2, &quot;nvim_buf_del_user_command&quot;);</a>
<a name="ln7510">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_commands);</a>
<a name="ln7511">  lua_setfield(lstate, -2, &quot;nvim_get_commands&quot;);</a>
<a name="ln7512">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_commands);</a>
<a name="ln7513">  lua_setfield(lstate, -2, &quot;nvim_buf_get_commands&quot;);</a>
<a name="ln7514">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_exec);</a>
<a name="ln7515">  lua_setfield(lstate, -2, &quot;nvim_exec&quot;);</a>
<a name="ln7516">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_command_output);</a>
<a name="ln7517">  lua_setfield(lstate, -2, &quot;nvim_command_output&quot;);</a>
<a name="ln7518">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_number);</a>
<a name="ln7519">  lua_setfield(lstate, -2, &quot;nvim_buf_get_number&quot;);</a>
<a name="ln7520">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_clear_highlight);</a>
<a name="ln7521">  lua_setfield(lstate, -2, &quot;nvim_buf_clear_highlight&quot;);</a>
<a name="ln7522">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_virtual_text);</a>
<a name="ln7523">  lua_setfield(lstate, -2, &quot;nvim_buf_set_virtual_text&quot;);</a>
<a name="ln7524">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_hl_by_id);</a>
<a name="ln7525">  lua_setfield(lstate, -2, &quot;nvim_get_hl_by_id&quot;);</a>
<a name="ln7526">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_hl_by_name);</a>
<a name="ln7527">  lua_setfield(lstate, -2, &quot;nvim_get_hl_by_name&quot;);</a>
<a name="ln7528">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_option_info);</a>
<a name="ln7529">  lua_setfield(lstate, -2, &quot;nvim_get_option_info&quot;);</a>
<a name="ln7530">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_option);</a>
<a name="ln7531">  lua_setfield(lstate, -2, &quot;nvim_set_option&quot;);</a>
<a name="ln7532">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_option);</a>
<a name="ln7533">  lua_setfield(lstate, -2, &quot;nvim_get_option&quot;);</a>
<a name="ln7534">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_option);</a>
<a name="ln7535">  lua_setfield(lstate, -2, &quot;nvim_buf_get_option&quot;);</a>
<a name="ln7536">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_option);</a>
<a name="ln7537">  lua_setfield(lstate, -2, &quot;nvim_buf_set_option&quot;);</a>
<a name="ln7538">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_option);</a>
<a name="ln7539">  lua_setfield(lstate, -2, &quot;nvim_win_get_option&quot;);</a>
<a name="ln7540">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_option);</a>
<a name="ln7541">  lua_setfield(lstate, -2, &quot;nvim_win_set_option&quot;);</a>
<a name="ln7542">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_create_namespace);</a>
<a name="ln7543">  lua_setfield(lstate, -2, &quot;nvim_create_namespace&quot;);</a>
<a name="ln7544">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_namespaces);</a>
<a name="ln7545">  lua_setfield(lstate, -2, &quot;nvim_get_namespaces&quot;);</a>
<a name="ln7546">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_extmark_by_id);</a>
<a name="ln7547">  lua_setfield(lstate, -2, &quot;nvim_buf_get_extmark_by_id&quot;);</a>
<a name="ln7548">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_extmarks);</a>
<a name="ln7549">  lua_setfield(lstate, -2, &quot;nvim_buf_get_extmarks&quot;);</a>
<a name="ln7550">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_extmark);</a>
<a name="ln7551">  lua_setfield(lstate, -2, &quot;nvim_buf_set_extmark&quot;);</a>
<a name="ln7552">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_del_extmark);</a>
<a name="ln7553">  lua_setfield(lstate, -2, &quot;nvim_buf_del_extmark&quot;);</a>
<a name="ln7554">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_add_highlight);</a>
<a name="ln7555">  lua_setfield(lstate, -2, &quot;nvim_buf_add_highlight&quot;);</a>
<a name="ln7556">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_clear_namespace);</a>
<a name="ln7557">  lua_setfield(lstate, -2, &quot;nvim_buf_clear_namespace&quot;);</a>
<a name="ln7558">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_decoration_provider);</a>
<a name="ln7559">  lua_setfield(lstate, -2, &quot;nvim_set_decoration_provider&quot;);</a>
<a name="ln7560">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__buf_debug_extmarks);</a>
<a name="ln7561">  lua_setfield(lstate, -2, &quot;nvim__buf_debug_extmarks&quot;);</a>
<a name="ln7562">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_option_value);</a>
<a name="ln7563">  lua_setfield(lstate, -2, &quot;nvim_get_option_value&quot;);</a>
<a name="ln7564">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_option_value);</a>
<a name="ln7565">  lua_setfield(lstate, -2, &quot;nvim_set_option_value&quot;);</a>
<a name="ln7566">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_all_options_info);</a>
<a name="ln7567">  lua_setfield(lstate, -2, &quot;nvim_get_all_options_info&quot;);</a>
<a name="ln7568">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_option_info2);</a>
<a name="ln7569">  lua_setfield(lstate, -2, &quot;nvim_get_option_info2&quot;);</a>
<a name="ln7570">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_list_wins);</a>
<a name="ln7571">  lua_setfield(lstate, -2, &quot;nvim_tabpage_list_wins&quot;);</a>
<a name="ln7572">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_get_var);</a>
<a name="ln7573">  lua_setfield(lstate, -2, &quot;nvim_tabpage_get_var&quot;);</a>
<a name="ln7574">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_set_var);</a>
<a name="ln7575">  lua_setfield(lstate, -2, &quot;nvim_tabpage_set_var&quot;);</a>
<a name="ln7576">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_del_var);</a>
<a name="ln7577">  lua_setfield(lstate, -2, &quot;nvim_tabpage_del_var&quot;);</a>
<a name="ln7578">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_get_win);</a>
<a name="ln7579">  lua_setfield(lstate, -2, &quot;nvim_tabpage_get_win&quot;);</a>
<a name="ln7580">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_get_number);</a>
<a name="ln7581">  lua_setfield(lstate, -2, &quot;nvim_tabpage_get_number&quot;);</a>
<a name="ln7582">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_is_valid);</a>
<a name="ln7583">  lua_setfield(lstate, -2, &quot;nvim_tabpage_is_valid&quot;);</a>
<a name="ln7584">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_hl_id_by_name);</a>
<a name="ln7585">  lua_setfield(lstate, -2, &quot;nvim_get_hl_id_by_name&quot;);</a>
<a name="ln7586">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_hl);</a>
<a name="ln7587">  lua_setfield(lstate, -2, &quot;nvim_get_hl&quot;);</a>
<a name="ln7588">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_hl);</a>
<a name="ln7589">  lua_setfield(lstate, -2, &quot;nvim_set_hl&quot;);</a>
<a name="ln7590">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_hl_ns);</a>
<a name="ln7591">  lua_setfield(lstate, -2, &quot;nvim_set_hl_ns&quot;);</a>
<a name="ln7592">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_hl_ns_fast);</a>
<a name="ln7593">  lua_setfield(lstate, -2, &quot;nvim_set_hl_ns_fast&quot;);</a>
<a name="ln7594">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_feedkeys);</a>
<a name="ln7595">  lua_setfield(lstate, -2, &quot;nvim_feedkeys&quot;);</a>
<a name="ln7596">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_input);</a>
<a name="ln7597">  lua_setfield(lstate, -2, &quot;nvim_input&quot;);</a>
<a name="ln7598">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_input_mouse);</a>
<a name="ln7599">  lua_setfield(lstate, -2, &quot;nvim_input_mouse&quot;);</a>
<a name="ln7600">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_replace_termcodes);</a>
<a name="ln7601">  lua_setfield(lstate, -2, &quot;nvim_replace_termcodes&quot;);</a>
<a name="ln7602">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_notify);</a>
<a name="ln7603">  lua_setfield(lstate, -2, &quot;nvim_notify&quot;);</a>
<a name="ln7604">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_strwidth);</a>
<a name="ln7605">  lua_setfield(lstate, -2, &quot;nvim_strwidth&quot;);</a>
<a name="ln7606">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_list_runtime_paths);</a>
<a name="ln7607">  lua_setfield(lstate, -2, &quot;nvim_list_runtime_paths&quot;);</a>
<a name="ln7608">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__runtime_inspect);</a>
<a name="ln7609">  lua_setfield(lstate, -2, &quot;nvim__runtime_inspect&quot;);</a>
<a name="ln7610">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_runtime_file);</a>
<a name="ln7611">  lua_setfield(lstate, -2, &quot;nvim_get_runtime_file&quot;);</a>
<a name="ln7612">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__get_lib_dir);</a>
<a name="ln7613">  lua_setfield(lstate, -2, &quot;nvim__get_lib_dir&quot;);</a>
<a name="ln7614">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__get_runtime);</a>
<a name="ln7615">  lua_setfield(lstate, -2, &quot;nvim__get_runtime&quot;);</a>
<a name="ln7616">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_current_dir);</a>
<a name="ln7617">  lua_setfield(lstate, -2, &quot;nvim_set_current_dir&quot;);</a>
<a name="ln7618">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_current_line);</a>
<a name="ln7619">  lua_setfield(lstate, -2, &quot;nvim_get_current_line&quot;);</a>
<a name="ln7620">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_current_line);</a>
<a name="ln7621">  lua_setfield(lstate, -2, &quot;nvim_set_current_line&quot;);</a>
<a name="ln7622">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_current_line);</a>
<a name="ln7623">  lua_setfield(lstate, -2, &quot;nvim_del_current_line&quot;);</a>
<a name="ln7624">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_var);</a>
<a name="ln7625">  lua_setfield(lstate, -2, &quot;nvim_get_var&quot;);</a>
<a name="ln7626">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_var);</a>
<a name="ln7627">  lua_setfield(lstate, -2, &quot;nvim_set_var&quot;);</a>
<a name="ln7628">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_var);</a>
<a name="ln7629">  lua_setfield(lstate, -2, &quot;nvim_del_var&quot;);</a>
<a name="ln7630">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_vvar);</a>
<a name="ln7631">  lua_setfield(lstate, -2, &quot;nvim_get_vvar&quot;);</a>
<a name="ln7632">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_vvar);</a>
<a name="ln7633">  lua_setfield(lstate, -2, &quot;nvim_set_vvar&quot;);</a>
<a name="ln7634">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_echo);</a>
<a name="ln7635">  lua_setfield(lstate, -2, &quot;nvim_echo&quot;);</a>
<a name="ln7636">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_out_write);</a>
<a name="ln7637">  lua_setfield(lstate, -2, &quot;nvim_out_write&quot;);</a>
<a name="ln7638">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_err_write);</a>
<a name="ln7639">  lua_setfield(lstate, -2, &quot;nvim_err_write&quot;);</a>
<a name="ln7640">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_err_writeln);</a>
<a name="ln7641">  lua_setfield(lstate, -2, &quot;nvim_err_writeln&quot;);</a>
<a name="ln7642">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_list_bufs);</a>
<a name="ln7643">  lua_setfield(lstate, -2, &quot;nvim_list_bufs&quot;);</a>
<a name="ln7644">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_current_buf);</a>
<a name="ln7645">  lua_setfield(lstate, -2, &quot;nvim_get_current_buf&quot;);</a>
<a name="ln7646">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_current_buf);</a>
<a name="ln7647">  lua_setfield(lstate, -2, &quot;nvim_set_current_buf&quot;);</a>
<a name="ln7648">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_list_wins);</a>
<a name="ln7649">  lua_setfield(lstate, -2, &quot;nvim_list_wins&quot;);</a>
<a name="ln7650">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_current_win);</a>
<a name="ln7651">  lua_setfield(lstate, -2, &quot;nvim_get_current_win&quot;);</a>
<a name="ln7652">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_current_win);</a>
<a name="ln7653">  lua_setfield(lstate, -2, &quot;nvim_set_current_win&quot;);</a>
<a name="ln7654">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_create_buf);</a>
<a name="ln7655">  lua_setfield(lstate, -2, &quot;nvim_create_buf&quot;);</a>
<a name="ln7656">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_open_term);</a>
<a name="ln7657">  lua_setfield(lstate, -2, &quot;nvim_open_term&quot;);</a>
<a name="ln7658">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_chan_send);</a>
<a name="ln7659">  lua_setfield(lstate, -2, &quot;nvim_chan_send&quot;);</a>
<a name="ln7660">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_list_tabpages);</a>
<a name="ln7661">  lua_setfield(lstate, -2, &quot;nvim_list_tabpages&quot;);</a>
<a name="ln7662">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_current_tabpage);</a>
<a name="ln7663">  lua_setfield(lstate, -2, &quot;nvim_get_current_tabpage&quot;);</a>
<a name="ln7664">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_current_tabpage);</a>
<a name="ln7665">  lua_setfield(lstate, -2, &quot;nvim_set_current_tabpage&quot;);</a>
<a name="ln7666">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_paste);</a>
<a name="ln7667">  lua_setfield(lstate, -2, &quot;nvim_paste&quot;);</a>
<a name="ln7668">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_put);</a>
<a name="ln7669">  lua_setfield(lstate, -2, &quot;nvim_put&quot;);</a>
<a name="ln7670">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_color_by_name);</a>
<a name="ln7671">  lua_setfield(lstate, -2, &quot;nvim_get_color_by_name&quot;);</a>
<a name="ln7672">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_color_map);</a>
<a name="ln7673">  lua_setfield(lstate, -2, &quot;nvim_get_color_map&quot;);</a>
<a name="ln7674">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_context);</a>
<a name="ln7675">  lua_setfield(lstate, -2, &quot;nvim_get_context&quot;);</a>
<a name="ln7676">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_load_context);</a>
<a name="ln7677">  lua_setfield(lstate, -2, &quot;nvim_load_context&quot;);</a>
<a name="ln7678">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_mode);</a>
<a name="ln7679">  lua_setfield(lstate, -2, &quot;nvim_get_mode&quot;);</a>
<a name="ln7680">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_keymap);</a>
<a name="ln7681">  lua_setfield(lstate, -2, &quot;nvim_get_keymap&quot;);</a>
<a name="ln7682">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_keymap);</a>
<a name="ln7683">  lua_setfield(lstate, -2, &quot;nvim_set_keymap&quot;);</a>
<a name="ln7684">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_keymap);</a>
<a name="ln7685">  lua_setfield(lstate, -2, &quot;nvim_del_keymap&quot;);</a>
<a name="ln7686">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_chan_info);</a>
<a name="ln7687">  lua_setfield(lstate, -2, &quot;nvim_get_chan_info&quot;);</a>
<a name="ln7688">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_list_chans);</a>
<a name="ln7689">  lua_setfield(lstate, -2, &quot;nvim_list_chans&quot;);</a>
<a name="ln7690">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__id);</a>
<a name="ln7691">  lua_setfield(lstate, -2, &quot;nvim__id&quot;);</a>
<a name="ln7692">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__id_array);</a>
<a name="ln7693">  lua_setfield(lstate, -2, &quot;nvim__id_array&quot;);</a>
<a name="ln7694">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__id_dictionary);</a>
<a name="ln7695">  lua_setfield(lstate, -2, &quot;nvim__id_dictionary&quot;);</a>
<a name="ln7696">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__id_float);</a>
<a name="ln7697">  lua_setfield(lstate, -2, &quot;nvim__id_float&quot;);</a>
<a name="ln7698">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__stats);</a>
<a name="ln7699">  lua_setfield(lstate, -2, &quot;nvim__stats&quot;);</a>
<a name="ln7700">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_list_uis);</a>
<a name="ln7701">  lua_setfield(lstate, -2, &quot;nvim_list_uis&quot;);</a>
<a name="ln7702">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_proc_children);</a>
<a name="ln7703">  lua_setfield(lstate, -2, &quot;nvim_get_proc_children&quot;);</a>
<a name="ln7704">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_proc);</a>
<a name="ln7705">  lua_setfield(lstate, -2, &quot;nvim_get_proc&quot;);</a>
<a name="ln7706">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_select_popupmenu_item);</a>
<a name="ln7707">  lua_setfield(lstate, -2, &quot;nvim_select_popupmenu_item&quot;);</a>
<a name="ln7708">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__inspect_cell);</a>
<a name="ln7709">  lua_setfield(lstate, -2, &quot;nvim__inspect_cell&quot;);</a>
<a name="ln7710">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__screenshot);</a>
<a name="ln7711">  lua_setfield(lstate, -2, &quot;nvim__screenshot&quot;);</a>
<a name="ln7712">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__unpack);</a>
<a name="ln7713">  lua_setfield(lstate, -2, &quot;nvim__unpack&quot;);</a>
<a name="ln7714">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_mark);</a>
<a name="ln7715">  lua_setfield(lstate, -2, &quot;nvim_del_mark&quot;);</a>
<a name="ln7716">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_mark);</a>
<a name="ln7717">  lua_setfield(lstate, -2, &quot;nvim_get_mark&quot;);</a>
<a name="ln7718">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_eval_statusline);</a>
<a name="ln7719">  lua_setfield(lstate, -2, &quot;nvim_eval_statusline&quot;);</a>
<a name="ln7720">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_exec2);</a>
<a name="ln7721">  lua_setfield(lstate, -2, &quot;nvim_exec2&quot;);</a>
<a name="ln7722">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_command);</a>
<a name="ln7723">  lua_setfield(lstate, -2, &quot;nvim_command&quot;);</a>
<a name="ln7724">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_eval);</a>
<a name="ln7725">  lua_setfield(lstate, -2, &quot;nvim_eval&quot;);</a>
<a name="ln7726">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_call_function);</a>
<a name="ln7727">  lua_setfield(lstate, -2, &quot;nvim_call_function&quot;);</a>
<a name="ln7728">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_call_dict_function);</a>
<a name="ln7729">  lua_setfield(lstate, -2, &quot;nvim_call_dict_function&quot;);</a>
<a name="ln7730">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_parse_expression);</a>
<a name="ln7731">  lua_setfield(lstate, -2, &quot;nvim_parse_expression&quot;);</a>
<a name="ln7732">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_open_win);</a>
<a name="ln7733">  lua_setfield(lstate, -2, &quot;nvim_open_win&quot;);</a>
<a name="ln7734">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_config);</a>
<a name="ln7735">  lua_setfield(lstate, -2, &quot;nvim_win_set_config&quot;);</a>
<a name="ln7736">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_config);</a>
<a name="ln7737">  lua_setfield(lstate, -2, &quot;nvim_win_get_config&quot;);</a>
<a name="ln7738">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_buf);</a>
<a name="ln7739">  lua_setfield(lstate, -2, &quot;nvim_win_get_buf&quot;);</a>
<a name="ln7740">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_buf);</a>
<a name="ln7741">  lua_setfield(lstate, -2, &quot;nvim_win_set_buf&quot;);</a>
<a name="ln7742">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_cursor);</a>
<a name="ln7743">  lua_setfield(lstate, -2, &quot;nvim_win_get_cursor&quot;);</a>
<a name="ln7744">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_cursor);</a>
<a name="ln7745">  lua_setfield(lstate, -2, &quot;nvim_win_set_cursor&quot;);</a>
<a name="ln7746">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_height);</a>
<a name="ln7747">  lua_setfield(lstate, -2, &quot;nvim_win_get_height&quot;);</a>
<a name="ln7748">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_height);</a>
<a name="ln7749">  lua_setfield(lstate, -2, &quot;nvim_win_set_height&quot;);</a>
<a name="ln7750">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_width);</a>
<a name="ln7751">  lua_setfield(lstate, -2, &quot;nvim_win_get_width&quot;);</a>
<a name="ln7752">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_width);</a>
<a name="ln7753">  lua_setfield(lstate, -2, &quot;nvim_win_set_width&quot;);</a>
<a name="ln7754">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_var);</a>
<a name="ln7755">  lua_setfield(lstate, -2, &quot;nvim_win_get_var&quot;);</a>
<a name="ln7756">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_var);</a>
<a name="ln7757">  lua_setfield(lstate, -2, &quot;nvim_win_set_var&quot;);</a>
<a name="ln7758">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_del_var);</a>
<a name="ln7759">  lua_setfield(lstate, -2, &quot;nvim_win_del_var&quot;);</a>
<a name="ln7760">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_position);</a>
<a name="ln7761">  lua_setfield(lstate, -2, &quot;nvim_win_get_position&quot;);</a>
<a name="ln7762">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_tabpage);</a>
<a name="ln7763">  lua_setfield(lstate, -2, &quot;nvim_win_get_tabpage&quot;);</a>
<a name="ln7764">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_number);</a>
<a name="ln7765">  lua_setfield(lstate, -2, &quot;nvim_win_get_number&quot;);</a>
<a name="ln7766">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_is_valid);</a>
<a name="ln7767">  lua_setfield(lstate, -2, &quot;nvim_win_is_valid&quot;);</a>
<a name="ln7768">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_hide);</a>
<a name="ln7769">  lua_setfield(lstate, -2, &quot;nvim_win_hide&quot;);</a>
<a name="ln7770">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_close);</a>
<a name="ln7771">  lua_setfield(lstate, -2, &quot;nvim_win_close&quot;);</a>
<a name="ln7772">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_call);</a>
<a name="ln7773">  lua_setfield(lstate, -2, &quot;nvim_win_call&quot;);</a>
<a name="ln7774">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_hl_ns);</a>
<a name="ln7775">  lua_setfield(lstate, -2, &quot;nvim_win_set_hl_ns&quot;);</a>
<a name="ln7776">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_text_height);</a>
<a name="ln7777">  lua_setfield(lstate, -2, &quot;nvim_win_text_height&quot;);</a>
<a name="ln7778">  lua_setfield(lstate, -2, &quot;api&quot;);</a>
<a name="ln7779">}</a>
</code></pre>
<div class="balloon" rel="2584"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="2591"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="3153"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="3160"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4006"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4013"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4039"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4046"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4113"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4120"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4229"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4236"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4304"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4311"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4689"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4696"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4722"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4729"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4795"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4802"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4828"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4835"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5035"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5042"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5068"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5075"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5291"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5298"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5398"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5405"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5603"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5610"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5788"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5795"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5821"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5828"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>