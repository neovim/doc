["src/nvim/buffer.c", [" */", "int ", "open_buffer ("], "whitespace/end_of_line"]
["src/nvim/buffer.c", ["int ", "open_buffer (", "    int read_stdin,                     /* read file from stdin */"], "whitespace/parens"]
["src/nvim/buffer.c", ["      && (curbuf->b_flags & BF_NEVERLOADED))", "    curbuf->b_p_ro = TRUE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["     */", "    close_buffer(NULL, curbuf, 0, FALSE);", ""], "readability/bool"]
["src/nvim/buffer.c", ["  old_curbuf = curbuf;", "  modified_was_set = FALSE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["     */", "    curbuf->b_p_bin = TRUE;", "    retval = readfile(NULL, NULL, (linenr_T)0,"], "readability/bool"]
["src/nvim/buffer.c", ["        while (--line_count >= 0)", "          ml_delete((linenr_T)1, FALSE);", "      } else {"], "readability/bool"]
["src/nvim/buffer.c", ["        while (curbuf->b_ml.ml_line_count > line_count)", "          ml_delete(line_count, FALSE);", "      }"], "readability/bool"]
["src/nvim/buffer.c", ["      else if (retval != FAIL)", "        unchanged(curbuf, FALSE);", "      apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,"], "readability/bool"]
["src/nvim/buffer.c", ["        unchanged(curbuf, FALSE);", "      apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,", "          curbuf, &retval);"], "readability/bool"]
["src/nvim/buffer.c", ["  if (curbuf->b_flags & BF_NEVERLOADED) {", "    (void)buf_init_chartab(curbuf, FALSE);", "    parse_cino(curbuf);"], "readability/bool"]
["src/nvim/buffer.c", ["  else if (retval != FAIL && !read_stdin)", "    unchanged(curbuf, FALSE);", "  save_file_ff(curbuf);                 /* keep this fileformat */"], "readability/bool"]
["src/nvim/buffer.c", ["  }", "  apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf, &retval);", ""], "readability/bool"]
["src/nvim/buffer.c", ["", "    apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,", "        &retval);"], "readability/bool"]
["src/nvim/buffer.c", ["    if (bp == buf) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/buffer.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/buffer.c", [" */", "void ", "close_buffer ("], "whitespace/end_of_line"]
["src/nvim/buffer.c", ["void ", "close_buffer (", "    win_T *win,               /* if not NULL, set b_last_cursor */"], "whitespace/parens"]
["src/nvim/buffer.c", ["      wipe_buf = true;", "    } else if (buf->b_p_bh[0] == 'u')    // 'bufhidden' == \"unload\"", "      unload_buf = true;"], "readability/braces"]
["src/nvim/buffer.c", ["        win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,", "        win->w_cursor.col, TRUE);", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["    apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,", "        FALSE, buf);", "    if (!buf_valid(buf)) {"], "readability/bool"]
["src/nvim/buffer.c", ["      apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname,", "          FALSE, buf);", "      if (!buf_valid(buf)) {"], "readability/bool"]
["src/nvim/buffer.c", ["    terminal_close(buf->terminal, NULL);", "  } ", ""], "whitespace/end_of_line"]
["src/nvim/buffer.c", ["  if (buf->b_ffname == NULL)", "    del_buf = TRUE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["       * \":bdel\" compatible with Vim 5.7. */", "      free_buffer_stuff(buf, TRUE);", ""], "readability/bool"]
["src/nvim/buffer.c", ["    if (del_buf)", "      buf->b_p_bl = FALSE;", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["  buf->b_ml.ml_line_count = 1;", "  unchanged(buf, TRUE);", "  buf->b_p_eol = TRUE;"], "readability/bool"]
["src/nvim/buffer.c", ["  unchanged(buf, TRUE);", "  buf->b_p_eol = TRUE;", "  buf->b_start_eol = TRUE;"], "readability/bool"]
["src/nvim/buffer.c", ["  buf->b_p_eol = TRUE;", "  buf->b_start_eol = TRUE;", "  buf->b_p_bomb = FALSE;"], "readability/bool"]
["src/nvim/buffer.c", ["  buf->b_start_eol = TRUE;", "  buf->b_p_bomb = FALSE;", "  buf->b_start_bomb = FALSE;"], "readability/bool"]
["src/nvim/buffer.c", ["  buf->b_p_bomb = FALSE;", "  buf->b_start_bomb = FALSE;", "  buf->b_ml.ml_mfp = NULL;"], "readability/bool"]
["src/nvim/buffer.c", ["  buf->b_closing = true;", "  apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname, FALSE, buf);", "  if (!buf_valid(buf))              /* autocommands may delete the buffer */"], "readability/bool"]
["src/nvim/buffer.c", ["  if ((flags & BFA_DEL) && buf->b_p_bl) {", "    apply_autocmds(EVENT_BUFDELETE, buf->b_fname, buf->b_fname, FALSE, buf);", "    if (!buf_valid(buf))            /* autocommands may delete the buffer */"], "readability/bool"]
["src/nvim/buffer.c", ["    apply_autocmds(EVENT_BUFWIPEOUT, buf->b_fname, buf->b_fname,", "        FALSE, buf);", "    if (!buf_valid(buf))            /* autocommands may delete the buffer */"], "readability/bool"]
["src/nvim/buffer.c", ["", "  ml_close(buf, TRUE);              /* close and delete the memline/memfile */", "  buf->b_ml.ml_line_count = 0;      /* no lines in buffer */"], "readability/bool"]
["src/nvim/buffer.c", ["  handle_unregister_buffer(buf);", "  free_buffer_stuff(buf, TRUE);", "  unref_var_dict(buf->b_vars);"], "readability/bool"]
["src/nvim/buffer.c", [" */", "static void ", "free_buffer_stuff ("], "whitespace/end_of_line"]
["src/nvim/buffer.c", ["static void ", "free_buffer_stuff (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/buffer.c", ["    clear_wininfo(buf);                 /* including window-local options */", "    free_buf_options(buf, TRUE);", "    ga_clear(&buf->b_s.b_langp);"], "readability/bool"]
["src/nvim/buffer.c", ["  buf_delete_signs(buf);                /* delete any signs */", "  map_clear_int(buf, MAP_ALL_MODES, TRUE, FALSE);    /* clear local mappings */", "  map_clear_int(buf, MAP_ALL_MODES, TRUE, TRUE);     /* clear local abbrevs */"], "readability/bool"]
["src/nvim/buffer.c", ["  map_clear_int(buf, MAP_ALL_MODES, TRUE, FALSE);    /* clear local mappings */", "  map_clear_int(buf, MAP_ALL_MODES, TRUE, TRUE);     /* clear local abbrevs */", "  xfree(buf->b_start_fenc);"], "readability/bool"]
["src/nvim/buffer.c", ["    /* Quitting means closing the split window, nothing else. */", "    win_close(curwin, TRUE);", "    swap_exists_action = SEA_NONE;"], "readability/bool"]
["src/nvim/buffer.c", ["    swap_exists_action = SEA_NONE;", "    swap_exists_did_quit = TRUE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["    swap_exists_action = SEA_NONE;      /* don't want it again */", "    swap_exists_did_quit = TRUE;", "    close_buffer(curwin, curbuf, DOBUF_UNLOAD, FALSE);"], "readability/bool"]
["src/nvim/buffer.c", ["    swap_exists_did_quit = TRUE;", "    close_buffer(curwin, curbuf, DOBUF_UNLOAD, FALSE);", "    if (!buf_valid(old_curbuf) || old_curbuf == curbuf)"], "readability/bool"]
["src/nvim/buffer.c", ["    /* User selected Recover at ATTENTION prompt. */", "    msg_scroll = TRUE;", "    ml_recover();"], "readability/bool"]
["src/nvim/buffer.c", ["char_u *", "do_bufdel (", "    int command,"], "whitespace/parens"]
["src/nvim/buffer.c", ["      bnr = start_bnr;", "    } else      /* addr_count == 1 */", "      bnr = end_bnr;"], "readability/braces"]
["src/nvim/buffer.c", ["          bnr = buflist_findpat(arg, p, command == DOBUF_WIPE,", "              FALSE, FALSE);", "          if (bnr < 0)                      /* failed */"], "readability/bool"]
["src/nvim/buffer.c", ["          arg = p;", "        } else", "          bnr = getdigits_int(&arg);"], "readability/braces"]
["src/nvim/buffer.c", ["    /* Close any other windows on this buffer, then make it empty. */", "    close_windows(buf, TRUE);", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["  if (buf != curbuf && buf_valid(buf) && buf->b_nwindows == 0)", "    close_buffer(NULL, buf, action, FALSE);", "  if (!close_others)"], "readability/bool"]
["src/nvim/buffer.c", ["  if (!close_others)", "    need_fileinfo = FALSE;", "  return retval;"], "readability/bool"]
["src/nvim/buffer.c", [" */", "int ", "do_buffer ("], "whitespace/end_of_line"]
["src/nvim/buffer.c", ["int ", "do_buffer (", "    int action,"], "whitespace/parens"]
["src/nvim/buffer.c", ["        EMSGN(_(\"E86: Buffer %\" PRId64 \" does not exist\"), count);", "    } else if (dir == FORWARD)", "      EMSG(_(\"E87: Cannot go beyond last buffer\"));"], "readability/braces"]
["src/nvim/buffer.c", ["      if ((p_confirm || cmdmod.confirm) && p_write && !buf->terminal) {", "        dialog_changed(buf, FALSE);", "        if (!buf_valid(buf))"], "readability/bool"]
["src/nvim/buffer.c", ["    if (bp == NULL && buf == curbuf)", "      return empty_curbuf(TRUE, forceit, action);", ""], "readability/bool"]
["src/nvim/buffer.c", ["           && (firstwin != lastwin || first_tabpage->tp_next != NULL)) {", "      if (win_close(curwin, FALSE) == FAIL)", "        break;"], "readability/bool"]
["src/nvim/buffer.c", ["    if (buf != curbuf) {", "      close_windows(buf, FALSE);", "      if (buf != curbuf && buf_valid(buf) && buf->b_nwindows <= 0)"], "readability/bool"]
["src/nvim/buffer.c", ["      if (buf != curbuf && buf_valid(buf) && buf->b_nwindows <= 0)", "        close_buffer(NULL, buf, action, FALSE);", "      return OK;"], "readability/bool"]
["src/nvim/buffer.c", ["    if (buf == NULL) {          /* No previous buffer, Try 2'nd approach */", "      forward = TRUE;", "      buf = curbuf->b_next;"], "readability/bool"]
["src/nvim/buffer.c", ["          buf = curbuf->b_prev;", "          forward = FALSE;", "          continue;"], "readability/bool"]
["src/nvim/buffer.c", ["     * now is to make the current buffer empty. */", "    return empty_curbuf(FALSE, forceit, action);", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["    if ((p_confirm || cmdmod.confirm) && p_write) {", "      dialog_changed(curbuf, FALSE);", "      if (!buf_valid(buf))"], "readability/bool"]
["src/nvim/buffer.c", ["  /* Don't restart Select mode after switching to another buffer. */", "  VIsual_reselect = FALSE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["", "  apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "  if (buf_valid(prevbuf) && !aborting()) {"], "readability/bool"]
["src/nvim/buffer.c", ["    if (unload)", "      close_windows(prevbuf, FALSE);", "    if (buf_valid(prevbuf) && !aborting()) {"], "readability/bool"]
["src/nvim/buffer.c", ["      if (prevbuf == curbuf)", "        u_sync(FALSE);", "      close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf,"], "readability/bool"]
["src/nvim/buffer.c", ["                             && !bufIsChanged(", "                                 prevbuf)) ? DOBUF_UNLOAD : 0, FALSE);", "      if (curwin != previouswin && win_valid(previouswin))"], "readability/bool"]
["src/nvim/buffer.c", ["       && !aborting()", "       ) || curwin->w_buffer == NULL", "      ) {"], "whitespace/parens"]
["src/nvim/buffer.c", ["  curwin->w_cursor.coladd = 0;", "  curwin->w_set_curswant = TRUE;", "  curwin->w_topline_was_set = FALSE;"], "readability/bool"]
["src/nvim/buffer.c", ["  curwin->w_set_curswant = TRUE;", "  curwin->w_topline_was_set = FALSE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["    if (*curbuf->b_p_ft == NUL)", "      did_filetype = FALSE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["", "    open_buffer(FALSE, NULL, 0);", "  } else {"], "readability/bool"]
["src/nvim/buffer.c", ["    if (!msg_silent)", "      need_fileinfo = TRUE;             /* display file info after redraw */", "    (void)buf_check_timestamp(curbuf, FALSE);     /* check if file changed */"], "readability/bool"]
["src/nvim/buffer.c", ["      need_fileinfo = TRUE;             /* display file info after redraw */", "    (void)buf_check_timestamp(curbuf, FALSE);     /* check if file changed */", "    curwin->w_topline = 1;"], "readability/bool"]
["src/nvim/buffer.c", ["    curwin->w_topfill = 0;", "    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);", "    apply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);"], "readability/bool"]
["src/nvim/buffer.c", ["    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);", "    apply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["  if (curwin->w_topline == 1 && !curwin->w_topline_was_set)", "    scroll_cursor_halfway(FALSE);       /* redisplay at correct position */", ""], "readability/bool"]
["src/nvim/buffer.c", ["    if (curbuf->b_ffname != NULL && vim_chdirfile(curbuf->b_ffname) == OK) {", "      shorten_fnames(TRUE);", "    }"], "readability/bool"]
["src/nvim/buffer.c", ["buf_T *", "buflist_new (", "    char_u *ffname,            /* full path of fname or relative */"], "whitespace/parens"]
["src/nvim/buffer.c", ["    if (lnum != 0)", "      buflist_setfpos(buf, curwin, lnum, (colnr_T)0, FALSE);", "    /* copy the options now, if 'cpo' doesn't have 's' and not done"], "readability/bool"]
["src/nvim/buffer.c", ["    if ((flags & BLN_LISTED) && !buf->b_p_bl) {", "      buf->b_p_bl = TRUE;", "      if (!(flags & BLN_DUMMY)) {"], "readability/bool"]
["src/nvim/buffer.c", ["      if (!(flags & BLN_DUMMY)) {", "        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf);", "        if (!buf_valid(buf)) {"], "readability/bool"]
["src/nvim/buffer.c", ["    if (curbuf->b_p_bl)", "      apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);", "    if (buf == curbuf)"], "readability/bool"]
["src/nvim/buffer.c", ["    if (buf == curbuf)", "      apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);", "    if (aborting())             /* autocmds may abort script processing */"], "readability/bool"]
["src/nvim/buffer.c", ["    /* buf->b_nwindows = 0; why was this here? */", "    free_buffer_stuff(buf, FALSE);      /* delete local variables et al. */", ""], "readability/bool"]
["src/nvim/buffer.c", ["  fmarks_check_names(buf);              /* check file marks for this file */", "  buf->b_p_bl = (flags & BLN_LISTED) ? TRUE : FALSE;    /* init 'buflisted' */", "  if (!(flags & BLN_DUMMY)) {"], "readability/bool"]
["src/nvim/buffer.c", ["  if (!(flags & BLN_DUMMY)) {", "    apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, buf);", "    if (!buf_valid(buf)) {"], "readability/bool"]
["src/nvim/buffer.c", ["    if (flags & BLN_LISTED) {", "      apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf);", "      if (!buf_valid(buf)) {"], "readability/bool"]
["src/nvim/buffer.c", ["    col = fpos->col;", "  } else", "    col = 0;"], "readability/braces"]
["src/nvim/buffer.c", ["      curwin->w_cursor.coladd = 0;", "      curwin->w_set_curswant = TRUE;", "    }"], "readability/bool"]
["src/nvim/buffer.c", ["    curwin->w_cursor.col = 0;", "  else {", "    curwin->w_cursor.col = fpos->col;"], "readability/braces"]
["src/nvim/buffer.c", ["    curwin->w_cursor.coladd = 0;", "    curwin->w_set_curswant = TRUE;", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["#ifdef UNIX", "      TRUE                  /* force expansion, get rid of symbolic links */", "#else"], "readability/bool"]
["src/nvim/buffer.c", ["#else", "      FALSE", "#endif"], "readability/bool"]
["src/nvim/buffer.c", ["#endif", "      );", "  if (ffname != NULL) {"], "whitespace/parens"]
["src/nvim/buffer.c", [" */", "int ", "buflist_findpat ("], "whitespace/end_of_line"]
["src/nvim/buffer.c", ["int ", "buflist_findpat (", "    char_u *pattern,"], "whitespace/parens"]
["src/nvim/buffer.c", ["   */", "  else {", "    pat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);"], "whitespace/newline"]
["src/nvim/buffer.c", ["   */", "  else {", "    pat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);"], "readability/braces"]
["src/nvim/buffer.c", ["  else {", "    pat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);", "    if (pat == NULL)"], "readability/bool"]
["src/nvim/buffer.c", ["     * is TRUE, try finding an unlisted buffer. */", "    find_listed = TRUE;", "    for (;; ) {"], "readability/bool"]
["src/nvim/buffer.c", ["        break;", "      find_listed = FALSE;", "    }"], "readability/bool"]
["src/nvim/buffer.c", ["    STRCPY(patc + 11, pat + 1);", "  } else", "    patc = pat;"], "readability/braces"]
["src/nvim/buffer.c", ["            ++count;", "          else {", "            if (options & WILD_HOME_REPLACE)"], "readability/braces"]
["src/nvim/buffer.c", ["      match = name;", "    else {", "      /* Replace $(HOME) with '~' and try matching again. */"], "readability/braces"]
["src/nvim/buffer.c", ["char_u *", "buflist_nr2name (", "    int n,"], "whitespace/parens"]
["src/nvim/buffer.c", ["          break;", "    } else", "      wip = buf->b_wininfo;"], "readability/braces"]
["src/nvim/buffer.c", ["", "  wip = find_wininfo(buf, TRUE);", "  if (wip != NULL && wip->wi_optset) {"], "readability/bool"]
["src/nvim/buffer.c", ["    cloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);", "  } else", "    copy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);"], "readability/braces"]
["src/nvim/buffer.c", ["", "  wininfo_T *wip = find_wininfo(buf, FALSE);", "  return (wip == NULL) ? &no_position : &(wip->wi_fpos);"], "readability/bool"]
["src/nvim/buffer.c", ["    else", "      home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);", ""], "readability/bool"]
["src/nvim/buffer.c", [" */", "int ", "setfname ("], "whitespace/end_of_line"]
["src/nvim/buffer.c", ["int ", "setfname (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/buffer.c", ["      /* delete from the list */", "      close_buffer(NULL, obuf, DOBUF_WIPE, FALSE);", "    }"], "readability/bool"]
["src/nvim/buffer.c", ["char_u *", "getaltfname (", "    int errmsg                     /* give error message */"], "whitespace/parens"]
["src/nvim/buffer.c", ["{", "  buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);", "}"], "readability/bool"]
["src/nvim/buffer.c", ["  if (ffname == NULL || *ffname == NUL || buf->b_ffname == NULL) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["  if (fnamecmp(ffname, buf->b_ffname) == 0) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["      // file_id not valid, assume files are different.", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/buffer.c", ["      if (buf_same_file_id(buf, file_id_p))", "        return FALSE;", "    }"], "readability/bool"]
["src/nvim/buffer.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/buffer.c", [" */", "void ", "fileinfo ("], "whitespace/end_of_line"]
["src/nvim/buffer.c", ["void ", "fileinfo (", "    int fullname,               /* when non-zero print full path */"], "whitespace/parens"]
["src/nvim/buffer.c", ["    p = buffer + STRLEN(buffer);", "  } else", "    p = buffer;"], "readability/braces"]
["src/nvim/buffer.c", ["    STRLCPY(p, buf_spname(curbuf), IOSIZE - (p - buffer));", "  else {", "    if (!fullname && curbuf->b_fname != NULL)"], "readability/braces"]
["src/nvim/buffer.c", ["    home_replace(shorthelp ? curbuf : NULL, name, p,", "        (int)(IOSIZE - (p - buffer)), TRUE);", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["    n = msg_scroll;", "    msg_scroll = TRUE;", "    msg(buffer);"], "readability/bool"]
["src/nvim/buffer.c", ["  } else {", "    p = msg_trunc_attr(buffer, FALSE, 0);", "    if (restart_edit != 0 || (msg_scrolled && !need_wait_return))"], "readability/bool"]
["src/nvim/buffer.c", ["    /* Postpone updating the title when 'lazyredraw' is set. */", "    need_maketitle = TRUE;", "    return;"], "readability/bool"]
["src/nvim/buffer.c", ["", "  need_maketitle = FALSE;", "  if (!p_title && !p_icon && lasttitle == NULL && lasticon == NULL)"], "readability/bool"]
["src/nvim/buffer.c", ["      if (stl_syntax & STL_IN_TITLE) {", "        int use_sandbox = FALSE;", "        int save_called_emsg = called_emsg;"], "readability/bool"]
["src/nvim/buffer.c", ["        use_sandbox = was_set_insecurely((char_u *)\"titlestring\", 0);", "        called_emsg = FALSE;", "        build_stl_str_hl(curwin, t_str, sizeof(buf),"], "readability/bool"]
["src/nvim/buffer.c", ["        called_emsg |= save_called_emsg;", "      } else", "        t_str = p_titlestring;"], "readability/braces"]
["src/nvim/buffer.c", ["        STRLCPY(buf, _(\"[No Name]\"), SPACE_FOR_FNAME + 1);", "      else {", "        p = transstr(path_tail(curbuf->b_fname));"], "readability/braces"]
["src/nvim/buffer.c", ["        home_replace(curbuf, curbuf->b_ffname,", "            buf + off, SPACE_FOR_DIR - off, TRUE);", "#ifdef BACKSLASH_IN_FILENAME"], "readability/bool"]
["src/nvim/buffer.c", ["", "      append_arg_number(curwin, buf, SPACE_FOR_ARGNR, FALSE);", ""], "readability/bool"]
["src/nvim/buffer.c", ["      if (stl_syntax & STL_IN_ICON) {", "        int use_sandbox = FALSE;", "        int save_called_emsg = called_emsg;"], "readability/bool"]
["src/nvim/buffer.c", ["        use_sandbox = was_set_insecurely((char_u *)\"iconstring\", 0);", "        called_emsg = FALSE;", "        build_stl_str_hl(curwin, i_str, sizeof(buf),"], "readability/bool"]
["src/nvim/buffer.c", ["        called_emsg |= save_called_emsg;", "      } else", "        i_str = p_iconstring;"], "readability/braces"]
["src/nvim/buffer.c", ["      *last = vim_strsave(str);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/buffer.c", ["            }", "        } else", "          /* close nrs are stored as negative values */"], "readability/braces"]
["src/nvim/buffer.c", ["      if (wp->w_p_list && lcs_tab1 == NUL) {", "        wp->w_p_list = FALSE;", "        getvcol(wp, &wp->w_cursor, NULL, &virtcol, NULL);"], "readability/bool"]
["src/nvim/buffer.c", ["        getvcol(wp, &wp->w_cursor, NULL, &virtcol, NULL);", "        wp->w_p_list = TRUE;", "      }"], "readability/bool"]
["src/nvim/buffer.c", ["  return width;", "}", ""], "readability/fn_size"]
["src/nvim/buffer.c", [" */", "static int ", "append_arg_number ("], "whitespace/end_of_line"]
["src/nvim/buffer.c", ["static int ", "append_arg_number (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/buffer.c", ["  if (ARGCOUNT <= 1)            /* nothing to do */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["  if (p - buf + 35 >= buflen)   /* getting too long */", "    return FALSE;", "  *p++ = ' ';"], "readability/bool"]
["src/nvim/buffer.c", ["      : \"%d of %d)\", wp->w_arg_idx + 1, ARGCOUNT);", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/buffer.c", [" */", "void ", "do_arg_all ("], "whitespace/end_of_line"]
["src/nvim/buffer.c", ["void ", "do_arg_all (", "    int count,"], "whitespace/parens"]
["src/nvim/buffer.c", ["  int i;", "  char_u      *opened;          /* Array of weight for which args are open:", "                                 *  0: not opened"], "readability/multiline_comment"]
["src/nvim/buffer.c", ["  char_u      *opened;          /* Array of weight for which args are open:", "                                 *  0: not opened", "                                 *  1: opened in other tab"], "readability/alt_tokens"]
["src/nvim/buffer.c", ["                                 *  2: opened in curtab", "                                 *  3: opened in curtab and curwin", "                                 */"], "readability/alt_tokens"]
["src/nvim/buffer.c", ["  int opened_len;               /* length of opened[] */", "  int use_firstwin = FALSE;             /* use first window for arglist */", "  int split_ret = OK;"], "readability/bool"]
["src/nvim/buffer.c", ["  if (had_tab > 0)", "    goto_tabpage_tp(first_tabpage, TRUE, TRUE);", "  for (;; ) {"], "readability/bool"]
["src/nvim/buffer.c", ["        i = opened_len;", "      else {", "        /* check if the buffer in this window is in the arglist */"], "readability/braces"]
["src/nvim/buffer.c", ["                  || path_full_compare(alist_name(&AARGLIST(alist)[i]),", "                      buf->b_ffname, TRUE) & kEqualFiles)) {", "            int weight = 1;"], "readability/bool"]
["src/nvim/buffer.c", ["              }", "            } else if (keep_tabs)", "              i = opened_len;"], "readability/braces"]
["src/nvim/buffer.c", ["              && bufIsChanged(buf)) {", "            (void)autowrite(buf, FALSE);", "            /* check if autocommands removed the window */"], "readability/bool"]
["src/nvim/buffer.c", ["              && (first_tabpage->tp_next == NULL || !had_tab))", "            use_firstwin = TRUE;", "          else {"], "readability/bool"]
["src/nvim/buffer.c", ["            use_firstwin = TRUE;", "          else {", "            win_close(wp, !P_HID(buf) && !bufIsChanged(buf));"], "readability/braces"]
["src/nvim/buffer.c", ["      tpnext = first_tabpage;           /* start all over...*/", "    goto_tabpage_tp(tpnext, TRUE, TRUE);", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["      && curbuf->b_ffname == NULL && !curbuf->b_changed)", "    use_firstwin = TRUE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["    if (alist == &global_alist && i == global_alist.al_ga.ga_len - 1)", "      arg_had_last = TRUE;", "    if (opened[i] > 0) {"], "readability/bool"]
["src/nvim/buffer.c", ["          continue;", "      } else        /* first window: do autocmd for leaving this buffer */", "        --autocmd_no_leave;"], "readability/braces"]
["src/nvim/buffer.c", ["        ++autocmd_no_leave;", "      use_firstwin = FALSE;", "    }"], "readability/bool"]
["src/nvim/buffer.c", ["    if (valid_tabpage(last_curtab))", "      goto_tabpage_tp(last_curtab, TRUE, TRUE);", "    if (win_valid(last_curwin))"], "readability/bool"]
["src/nvim/buffer.c", ["  if (valid_tabpage(new_curtab))", "    goto_tabpage_tp(new_curtab, TRUE, TRUE);", "  if (win_valid(new_curwin))"], "readability/bool"]
["src/nvim/buffer.c", ["  if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide)", "    all = FALSE;", "  else"], "readability/bool"]
["src/nvim/buffer.c", ["  else", "    all = TRUE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["  if (had_tab > 0)", "    goto_tabpage_tp(first_tabpage, TRUE, TRUE);", "  for (;; ) {"], "readability/bool"]
["src/nvim/buffer.c", ["           || (had_tab > 0 && wp != firstwin)", "           ) && firstwin != lastwin", "          && !(wp->w_closing || wp->w_buffer->b_closing)"], "whitespace/parens"]
["src/nvim/buffer.c", ["          ) {", "        win_close(wp, FALSE);", "        wpnext = firstwin;              /* just in case an autocommand does"], "readability/bool"]
["src/nvim/buffer.c", ["        win_close(wp, FALSE);", "        wpnext = firstwin;              /* just in case an autocommand does", "                                           something strange with windows */"], "readability/multiline_comment"]
["src/nvim/buffer.c", ["        open_wins = 0;", "      } else", "        ++open_wins;"], "readability/braces"]
["src/nvim/buffer.c", ["      break;", "    goto_tabpage_tp(tpnext, TRUE, TRUE);", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["        /* User selected Quit at ATTENTION prompt; close this window. */", "        win_close(curwin, TRUE);", "        --open_wins;"], "readability/bool"]
["src/nvim/buffer.c", ["        swap_exists_action = SEA_NONE;", "        swap_exists_did_quit = TRUE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["        leave_cleanup(&cs);", "      } else", "        handle_swap_exists(NULL);"], "readability/braces"]
["src/nvim/buffer.c", ["    r = (P_HID(wp->w_buffer) || !bufIsChanged(wp->w_buffer)", "         || autowrite(wp->w_buffer, FALSE) == OK);", "    if (!win_valid(wp)) {"], "readability/bool"]
["src/nvim/buffer.c", [" */", "static int ", "chk_modeline ("], "whitespace/end_of_line"]
["src/nvim/buffer.c", ["static int ", "chk_modeline (", "    linenr_T lnum,"], "whitespace/parens"]
["src/nvim/buffer.c", ["    ++s;", "  while (s[-1] != ':');", ""], "whitespace/empty_loop_body"]
["src/nvim/buffer.c", ["", "  end = FALSE;", "  while (end == FALSE) {"], "readability/bool"]
["src/nvim/buffer.c", ["  end = FALSE;", "  while (end == FALSE) {", "    s = skipwhite(s);"], "readability/bool"]
["src/nvim/buffer.c", ["    if (*e == NUL)", "      end = TRUE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["        break;", "      end = TRUE;", "      s = vim_strchr(s, ' ') + 1;"], "readability/bool"]
["src/nvim/buffer.c", ["    }", "    else {", "        prev->next = newsign;"], "whitespace/newline"]
["src/nvim/buffer.c", ["    }", "    else {", "        prev->next = newsign;"], "readability/braces"]
["src/nvim/buffer.c", ["        } else if ((lnum == sign->lnum && id != sign->id)", "                   || (id < 0 && lnum < sign->lnum)) {  // attempt to keep signs sorted by lnum", "            insert_sign(buf, prev, sign, id, lnum, typenr);"], "whitespace/line_length"]
["src/nvim/buffer.c", ["{", "    signlist_T\t*sign;\t\t/* a sign in a b_signlist */", ""], "whitespace/tab"]
["src/nvim/buffer.c", ["                    || (type == SIGN_LINEHL", "                        && sign_get_attr(sign->typenr, TRUE) != 0))) {", "            return sign->typenr;"], "readability/bool"]
["src/nvim/buffer.c", ["    // sign column. Not when curwin is NULL (this means we're exiting).", "    if (buf->b_signlist != NULL && curwin != NULL){", "      redraw_buf_later(buf, NOT_VALID);"], "whitespace/braces"]
["src/nvim/buffer.c", ["        for (p = buf->b_signlist; p != NULL && !got_int; p = p->next) {", "            vim_snprintf(lbuf, BUFSIZ, _(\"    line=%\" PRId64 \"  id=%d  name=%s\"),", "                    (int64_t)p->lnum, p->id, sign_typenr2name(p->typenr));"], "whitespace/line_length"]
["src/nvim/buffer.c", [" */", "void sign_mark_adjust(linenr_T line1, linenr_T line2, long amount, long amount_after)", "{"], "whitespace/line_length"]
["src/nvim/buffer.c", ["        }", "        else if (sign->lnum > line2)", "            sign->lnum += amount_after;"], "whitespace/newline"]
["src/nvim/buffer.c", ["    if (on)", "      apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);", "    else"], "readability/bool"]
["src/nvim/buffer.c", ["    else", "      apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/buffer.c", ["  buf_T       *newbuf;", "  int differ = TRUE;", "  linenr_T lnum;"], "readability/bool"]
["src/nvim/buffer.c", ["  if (newbuf == NULL)", "    return TRUE;", ""], "readability/bool"]
["src/nvim/buffer.c", ["    if (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count) {", "      differ = FALSE;", "      for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)"], "readability/bool"]
["src/nvim/buffer.c", ["      for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)", "        if (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0) {", "          differ = TRUE;"], "readability/bool"]
["src/nvim/buffer.c", ["        if (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0) {", "          differ = TRUE;", "          break;"], "readability/bool"]
["src/nvim/buffer.c", ["  if (curbuf != newbuf)         /* safety check */", "    wipe_buffer(newbuf, FALSE);", ""], "readability/bool"]
["src/nvim/buffer.c", [" */", "void ", "wipe_buffer ("], "whitespace/end_of_line"]
["src/nvim/buffer.c", ["void ", "wipe_buffer (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/buffer.c", ["    block_autocmds();", "  close_buffer(NULL, buf, DOBUF_WIPE, FALSE);", "  if (!aucmd)"], "readability/bool"]
["src/nvim/charset.c", ["", "static int chartab_initialized = FALSE;", ""], "readability/bool"]
["src/nvim/charset.c", ["{", "  return buf_init_chartab(curbuf, TRUE);", "}"], "readability/bool"]
["src/nvim/charset.c", ["    while (*p) {", "      tilde = FALSE;", "      do_isalpha = FALSE;"], "readability/bool"]
["src/nvim/charset.c", ["      tilde = FALSE;", "      do_isalpha = FALSE;", ""], "readability/bool"]
["src/nvim/charset.c", ["      if ((*p == '^') && (p[1] != NUL)) {", "        tilde = TRUE;", "        ++p;"], "readability/bool"]
["src/nvim/charset.c", ["        if (c == '@') {", "          do_isalpha = TRUE;", "          c = 1;"], "readability/bool"]
["src/nvim/charset.c", ["  }", "  chartab_initialized = TRUE;", "  return OK;"], "readability/bool"]
["src/nvim/charset.c", ["  if ((enc_dbcs != 0) && (c < 0x100) && (MB_BYTE2LEN(c) > 1)) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/charset.c", ["///", "/// @param line ", "/// @param s"], "whitespace/end_of_line"]
["src/nvim/charset.c", ["/// @return The number of characters taken up on the screen.", "int win_lbr_chartabsize(win_T *wp, char_u *line, char_u *s, colnr_T col, int *headp)", "{"], "whitespace/line_length"]
["src/nvim/charset.c", ["    // there is no border", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/charset.c", ["  if ((int)vcol < width1 - 1) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/charset.c", ["  if ((int)vcol == width1 - 1) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/charset.c", ["  if (width2 <= 0) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/charset.c", ["  char_u *ptr;    // points to current char", "  char_u *posptr; // points to char at pos->col", "  char_u *line;   // start of the line"], "whitespace/comments"]
["src/nvim/charset.c", ["  vcol = 0;", "  line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);", ""], "readability/bool"]
["src/nvim/charset.c", ["", "  curwin->w_p_list = FALSE;", "  getvcol(curwin, posp, NULL, &vcol, NULL);"], "readability/bool"]
["src/nvim/charset.c", ["    // Cannot put the cursor on part of a wide character.", "    ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);", ""], "readability/bool"]
["src/nvim/charset.c", ["  if (c <= '@') {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/charset.c", ["      // islower() can't handle these chars and may crash", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/charset.c", ["  if (c <= '@') {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/charset.c", ["      // islower() can't handle these chars and may crash", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/charset.c", ["  char_u *ptr = start;", "  int hex = 0; // default is decimal", "  int negative = FALSE;"], "whitespace/comments"]
["src/nvim/charset.c", ["  int hex = 0; // default is decimal", "  int negative = FALSE;", "  unsigned long un = 0;"], "readability/bool"]
["src/nvim/charset.c", ["  if (ptr[0] == '-') {", "    negative = TRUE;", "    ++ptr;"], "readability/bool"]
["src/nvim/diff.c", ["", "static int diff_busy = FALSE;    // ex_diffgetput() is busy", ""], "readability/bool"]
["src/nvim/diff.c", ["      tp->tp_diffbuf[i] = NULL;", "      tp->tp_diff_invalid = TRUE;", ""], "readability/bool"]
["src/nvim/diff.c", ["      if (tp == curtab) {", "        diff_redraw(TRUE);", "      }"], "readability/bool"]
["src/nvim/diff.c", ["{", "", "  if (!win->w_p_diff) {"], "whitespace/blank_line"]
["src/nvim/diff.c", ["        curtab->tp_diffbuf[i] = NULL;", "        curtab->tp_diff_invalid = TRUE;", "        diff_redraw(TRUE);"], "readability/bool"]
["src/nvim/diff.c", ["        curtab->tp_diff_invalid = TRUE;", "        diff_redraw(TRUE);", "      }"], "readability/bool"]
["src/nvim/diff.c", ["      curtab->tp_diffbuf[i] = buf;", "      curtab->tp_diff_invalid = TRUE;", "      diff_redraw(TRUE);"], "readability/bool"]
["src/nvim/diff.c", ["      curtab->tp_diff_invalid = TRUE;", "      diff_redraw(TRUE);", "      return;"], "readability/bool"]
["src/nvim/diff.c", ["    if (i != DB_COUNT) {", "      tp->tp_diff_invalid = TRUE;", "      if (tp == curtab) {"], "readability/bool"]
["src/nvim/diff.c", ["      if (tp == curtab) {", "        diff_redraw(TRUE);", "      }"], "readability/bool"]
["src/nvim/diff.c", ["  linenr_T last;", "  linenr_T lnum_deleted = line1; // lnum of remaining deletion", "  int n;"], "whitespace/comments"]
["src/nvim/diff.c", ["    // Check for these situations:", "    //\t  1  2\t3", "    //\t  1  2\t3"], "whitespace/tab"]
["src/nvim/diff.c", ["    // Check for these situations:", "    //\t  1  2\t3", "    //\t  1  2\t3"], "whitespace/comments"]
["src/nvim/diff.c", ["    //\t  1  2\t3", "    //\t  1  2\t3", "    // line1     2\t3  4  5"], "whitespace/tab"]
["src/nvim/diff.c", ["    //\t  1  2\t3", "    //\t  1  2\t3", "    // line1     2\t3  4  5"], "whitespace/comments"]
["src/nvim/diff.c", ["    //\t  1  2\t3", "    // line1     2\t3  4  5", "    //\t     2\t3  4  5"], "whitespace/tab"]
["src/nvim/diff.c", ["    // line1     2\t3  4  5", "    //\t     2\t3  4  5", "    //\t     2\t3  4  5"], "whitespace/tab"]
["src/nvim/diff.c", ["    // line1     2\t3  4  5", "    //\t     2\t3  4  5", "    //\t     2\t3  4  5"], "whitespace/comments"]
["src/nvim/diff.c", ["    //\t     2\t3  4  5", "    //\t     2\t3  4  5", "    // line2     2\t3  4  5"], "whitespace/tab"]
["src/nvim/diff.c", ["    //\t     2\t3  4  5", "    //\t     2\t3  4  5", "    // line2     2\t3  4  5"], "whitespace/comments"]
["src/nvim/diff.c", ["    //\t     2\t3  4  5", "    // line2     2\t3  4  5", "    //\t\t3     5  6"], "whitespace/tab"]
["src/nvim/diff.c", ["    // line2     2\t3  4  5", "    //\t\t3     5  6", "    //\t\t3     5  6"], "whitespace/tab"]
["src/nvim/diff.c", ["    // line2     2\t3  4  5", "    //\t\t3     5  6", "    //\t\t3     5  6"], "whitespace/comments"]
["src/nvim/diff.c", ["    //\t\t3     5  6", "    //\t\t3     5  6", ""], "whitespace/tab"]
["src/nvim/diff.c", ["    //\t\t3     5  6", "    //\t\t3     5  6", ""], "whitespace/comments"]
["src/nvim/diff.c", ["      } else {", "        int check_unchanged = FALSE;", ""], "readability/bool"]
["src/nvim/diff.c", ["              dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1;", "              check_unchanged = TRUE;", "            }"], "readability/bool"]
["src/nvim/diff.c", ["              }", "              check_unchanged = TRUE;", "            } else {"], "readability/bool"]
["src/nvim/diff.c", ["            dp->df_count[idx] += inserted;", "            check_unchanged = TRUE;", "          } else {"], "readability/bool"]
["src/nvim/diff.c", ["          //", "          // TODO: also check for equal lines in the middle and perhaps split", "          // the block."], "readability/todo"]
["src/nvim/diff.c", ["  if (tp == curtab) {", "    diff_redraw(TRUE);", ""], "readability/bool"]
["src/nvim/diff.c", ["    // making many changes, postpone until redrawing.", "    diff_need_scrollbind = TRUE;", "  }"], "readability/bool"]
["src/nvim/diff.c", ["                                                dp->df_lnum[i_org] + off_org,", "                                                FALSE));", ""], "readability/bool"]
["src/nvim/diff.c", ["                                          dp->df_lnum[i_new] + off_new,", "                                          FALSE)) != 0) {", "          break;"], "readability/bool"]
["src/nvim/diff.c", ["      }", "      check_topfill(wp, FALSE);", "    }"], "readability/bool"]
["src/nvim/diff.c", ["  int r = buf_write(buf, fname, NULL, (linenr_T)1, buf->b_ml.ml_line_count,", "                    NULL, FALSE, FALSE, FALSE, TRUE);", "  free_string_option(buf->b_p_ff);"], "readability/bool"]
["src/nvim/diff.c", ["  diff_clear(curtab);", "  curtab->tp_diff_invalid = FALSE;", ""], "readability/bool"]
["src/nvim/diff.c", ["  // May try twice, first with \"-a\" and then without.", "  int io_error = FALSE;", "  int ok = FALSE;"], "readability/bool"]
["src/nvim/diff.c", ["  int io_error = FALSE;", "  int ok = FALSE;", "  for (;;) {"], "readability/bool"]
["src/nvim/diff.c", ["  for (;;) {", "    ok = FALSE;", "    FILE *fd = mch_fopen((char *)tmp_orig, \"w\");"], "readability/bool"]
["src/nvim/diff.c", ["    if (fd == NULL) {", "      io_error = TRUE;", "    } else {"], "readability/bool"]
["src/nvim/diff.c", ["      if (fwrite(\"line1\\n\", (size_t)6, (size_t)1, fd) != 1) {", "        io_error = TRUE;", "      }"], "readability/bool"]
["src/nvim/diff.c", ["      if (fd == NULL) {", "        io_error = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/diff.c", ["        if (fwrite(\"line2\\n\", (size_t)6, (size_t)1, fd) != 1) {", "          io_error = TRUE;", "        }"], "readability/bool"]
["src/nvim/diff.c", ["        if (fd == NULL) {", "          io_error = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/diff.c", ["            if (STRNCMP(linebuf, \"1c1\", 3) == 0) {", "              ok = TRUE;", "            }"], "readability/bool"]
["src/nvim/diff.c", ["      if (buf_valid(buf)) {", "        buf_check_timestamp(buf, FALSE);", "      }"], "readability/bool"]
["src/nvim/diff.c", ["", "  diff_redraw(TRUE);", ""], "readability/bool"]
["src/nvim/diff.c", ["    vim_snprintf((char *)cmd, len, \"diff %s%s%s%s%s %s\",", "                 diff_a_works == FALSE ? \"\" : \"-a \",", "                 \"\","], "readability/bool"]
["src/nvim/diff.c", ["        NULL", "        );", "    unblock_autocmds();"], "whitespace/parens"]
["src/nvim/diff.c", ["  win_T *old_curwin = curwin;", "  char_u *newname = NULL; // name of patched file buffer", ""], "whitespace/comments"]
["src/nvim/diff.c", ["                (linenr_T)1, curbuf->b_ml.ml_line_count,", "                NULL, FALSE, FALSE, FALSE, TRUE) == FAIL) {", "    goto theend;"], "readability/bool"]
["src/nvim/diff.c", ["  // Get the absolute path of the patchfile, changing directory below.", "  fullname = (char_u *)FullName_save((char *)eap->arg, FALSE);", "#endif  // ifdef UNIX"], "readability/bool"]
["src/nvim/diff.c", ["    os_chdir(tempdir);", "    shorten_fnames(TRUE);", "  }"], "readability/bool"]
["src/nvim/diff.c", ["    }", "    shorten_fnames(TRUE);", "  }"], "readability/bool"]
["src/nvim/diff.c", ["        // Set 'diff', 'scrollbind' on and 'wrap' off.", "        diff_win_options(curwin, TRUE);", "        diff_win_options(old_curwin, TRUE);"], "readability/bool"]
["src/nvim/diff.c", ["        diff_win_options(curwin, TRUE);", "        diff_win_options(old_curwin, TRUE);", ""], "readability/bool"]
["src/nvim/diff.c", ["    eap->cmdidx = CMD_split;", "    curwin->w_p_diff = TRUE;", "    do_exedit(eap, old_curwin);"], "readability/bool"]
["src/nvim/diff.c", ["      // Set 'diff', 'scrollbind' on and 'wrap' off.", "      diff_win_options(curwin, TRUE);", "      diff_win_options(old_curwin, TRUE);"], "readability/bool"]
["src/nvim/diff.c", ["      diff_win_options(curwin, TRUE);", "      diff_win_options(old_curwin, TRUE);", "    }"], "readability/bool"]
["src/nvim/diff.c", ["  // Set 'diff', 'scrollbind' on and 'wrap' off.", "  diff_win_options(curwin, TRUE);", "}"], "readability/bool"]
["src/nvim/diff.c", ["", "  wp->w_p_diff = TRUE;", ""], "readability/bool"]
["src/nvim/diff.c", ["  }", "  wp->w_p_scb = TRUE;", ""], "readability/bool"]
["src/nvim/diff.c", ["  }", "  wp->w_p_crb = TRUE;", ""], "readability/bool"]
["src/nvim/diff.c", ["  }", "  wp->w_p_wrap = FALSE;", "  curwin = wp;"], "readability/bool"]
["src/nvim/diff.c", ["  wp->w_p_fdc = diff_foldcolumn;", "  wp->w_p_fen = TRUE;", "  wp->w_p_fdl = 0;"], "readability/bool"]
["src/nvim/diff.c", ["  // Saved the current values, to be restored in ex_diffoff().", "  wp->w_p_diff_saved = TRUE;", ""], "readability/bool"]
["src/nvim/diff.c", ["  win_T *old_curwin = curwin;", "  int diffwin = FALSE;", ""], "readability/bool"]
["src/nvim/diff.c", ["      // were saved in diff_win_options() restore them.", "      wp->w_p_diff = FALSE;", ""], "readability/bool"]
["src/nvim/diff.c", ["      if (wp->w_p_scb) {", "        wp->w_p_scb = wp->w_p_diff_saved ? wp->w_p_scb_save : FALSE;", "      }"], "readability/bool"]
["src/nvim/diff.c", ["      if (wp->w_p_crb) {", "        wp->w_p_crb = wp->w_p_diff_saved ? wp->w_p_crb_save : FALSE;", "      }"], "readability/bool"]
["src/nvim/diff.c", ["      if (!wp->w_p_wrap) {", "        wp->w_p_wrap = wp->w_p_diff_saved ? wp->w_p_wrap_save : TRUE;", "      }"], "readability/bool"]
["src/nvim/diff.c", ["        if (foldmethodIsManual(wp) || !wp->w_p_diff_saved) {", "          wp->w_p_fen = FALSE;", "        } else {"], "readability/bool"]
["src/nvim/diff.c", ["", "      wp->w_p_diff_saved = FALSE;", "    }"], "readability/bool"]
["src/nvim/diff.c", ["  long f1, l1, f2, l2;", "  char_u linebuf[LBUFLEN]; // only need to hold the diff line", "  int difftype;"], "whitespace/comments"]
["src/nvim/diff.c", ["  long count_orig, count_new;", "  int notset = TRUE; // block \"*dp\" not set yet", ""], "whitespace/comments"]
["src/nvim/diff.c", ["  long count_orig, count_new;", "  int notset = TRUE; // block \"*dp\" not set yet", ""], "readability/bool"]
["src/nvim/diff.c", ["      dp = dp->df_next;", "      notset = TRUE;", "    }"], "readability/bool"]
["src/nvim/diff.c", ["    }", "    notset = FALSE; // \"*dp\" has been set", "  }"], "whitespace/comments"]
["src/nvim/diff.c", ["    }", "    notset = FALSE; // \"*dp\" has been set", "  }"], "readability/bool"]
["src/nvim/diff.c", ["    dp = dp->df_next;", "    notset = TRUE;", "  }"], "readability/bool"]
["src/nvim/diff.c", ["{", "  int idx; // index in tp_diffbuf[] for this buffer", "  diff_T *dp;"], "whitespace/comments"]
["src/nvim/diff.c", ["  // A closed fold never has filler lines.", "  if (hasFoldingWin(wp, lnum, NULL, NULL, TRUE, NULL)) {", "    return 0;"], "readability/bool"]
["src/nvim/diff.c", ["  if (lnum < dp->df_lnum[idx] + dp->df_count[idx]) {", "    int zero = FALSE;", ""], "readability/bool"]
["src/nvim/diff.c", ["    // count, check if the lines are identical.", "    cmp = FALSE;", ""], "readability/bool"]
["src/nvim/diff.c", ["        if (dp->df_count[i] == 0) {", "          zero = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/diff.c", ["          }", "          cmp = TRUE;", "        }"], "readability/bool"]
["src/nvim/diff.c", ["    // Other windows might still show the change though.", "    if (zero == FALSE) {", "      return 0;"], "readability/bool"]
["src/nvim/diff.c", ["  if (dp->df_count[idx1] != dp->df_count[idx2]) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/diff.c", ["  if (diff_check_sanity(curtab, dp) == FAIL) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/diff.c", ["    char_u *line = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx1],", "                                          dp->df_lnum[idx1] + i, FALSE));", ""], "readability/bool"]
["src/nvim/diff.c", ["    int cmp = diff_cmp(line, ml_get_buf(curtab->tp_diffbuf[idx2],", "                                        dp->df_lnum[idx2] + i, FALSE));", "    xfree(line);"], "readability/bool"]
["src/nvim/diff.c", ["    if (cmp != 0) {", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/diff.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/diff.c", ["  (void)hasFoldingWin(towin, towin->w_topline, &towin->w_topline,", "                      NULL, TRUE, NULL);", "}"], "readability/bool"]
["src/nvim/diff.c", ["    FOR_ALL_TABS(tp) {", "      tp->tp_diff_invalid = TRUE;", "    }"], "readability/bool"]
["src/nvim/diff.c", ["", "  diff_redraw(TRUE);", ""], "readability/bool"]
["src/nvim/diff.c", ["  int ei_new;", "  int added = TRUE;", ""], "readability/bool"]
["src/nvim/diff.c", ["  // Make a copy of the line, the next ml_get() will invalidate it.", "  char_u *line_org = vim_strsave(ml_get_buf(wp->w_buffer, lnum, FALSE));", ""], "readability/bool"]
["src/nvim/diff.c", ["    xfree(line_org);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/diff.c", ["    xfree(line_org);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/diff.c", ["      }", "      added = FALSE;", "      line_new = ml_get_buf(curtab->tp_diffbuf[i],"], "readability/bool"]
["src/nvim/diff.c", ["      line_new = ml_get_buf(curtab->tp_diffbuf[i],", "                            dp->df_lnum[i] + off, FALSE);", ""], "readability/bool"]
["src/nvim/diff.c", ["{", "  int other = FALSE;", "  diff_T *dp;"], "readability/bool"]
["src/nvim/diff.c", ["  if (!wp->w_p_diff) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/diff.c", ["    } else if (curtab->tp_diffbuf[i] != NULL) {", "      other = TRUE;", "    }"], "readability/bool"]
["src/nvim/diff.c", ["  if ((idx == -1) || !other) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/diff.c", ["  if (curtab->tp_first_diff == NULL) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/diff.c", ["    if (dp->df_lnum[idx] + dp->df_count[idx] + diff_context > lnum) {", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/diff.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/diff.c", ["  } else {", "    vim_snprintf(buf, 30, \"%zu\", count);", "    ea.arg = (char_u *)buf;"], "runtime/printf"]
["src/nvim/diff.c", ["  int buf_empty;", "  int found_not_ma = FALSE;", "  int idx_other;"], "readability/bool"]
["src/nvim/diff.c", ["        }", "        found_not_ma = TRUE;", "      }"], "readability/bool"]
["src/nvim/diff.c", ["    } else {", "      i = buflist_findpat(eap->arg, p, FALSE, TRUE, FALSE);", ""], "readability/bool"]
["src/nvim/diff.c", ["", "  diff_busy = TRUE;", ""], "readability/bool"]
["src/nvim/diff.c", ["        buf_empty = curbuf->b_ml.ml_line_count == 1;", "        ml_delete(lnum, FALSE);", "        added--;"], "readability/bool"]
["src/nvim/diff.c", ["        }", "        p = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from], nr, FALSE));", "        ml_append(lnum + i - 1, p, 0, FALSE);"], "readability/bool"]
["src/nvim/diff.c", ["        p = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from], nr, FALSE));", "        ml_append(lnum + i - 1, p, 0, FALSE);", "        xfree(p);"], "readability/bool"]
["src/nvim/diff.c", ["          // delete the dummy empty line.", "          buf_empty = FALSE;", "          ml_delete((linenr_T)2, FALSE);"], "readability/bool"]
["src/nvim/diff.c", ["          buf_empty = FALSE;", "          ml_delete((linenr_T)2, FALSE);", "        }"], "readability/bool"]
["src/nvim/diff.c", ["    if (KeyTyped) {", "      u_sync(FALSE);", "    }"], "readability/bool"]
["src/nvim/diff.c", ["", "  diff_busy = FALSE;", ""], "readability/bool"]
["src/nvim/diff.c", ["  // Also need to redraw the other buffers.", "  diff_redraw(FALSE);", "}"], "readability/bool"]
["src/nvim/digraph.c", ["{", "  { 'N', 'U', 0x0a }, // LF for NUL", "  { 'S', 'H', 0x01 },"], "whitespace/comments"]
["src/nvim/digraph.c", ["  { 'W', '=', 0x20a9 },", "  { '=', 'e', 0x20ac }, // euro", "  { 'E', 'u', 0x20ac }, // euro"], "whitespace/comments"]
["src/nvim/digraph.c", ["  { '=', 'e', 0x20ac }, // euro", "  { 'E', 'u', 0x20ac }, // euro", "  { '=', 'R', 0x20bd }, // rouble"], "whitespace/comments"]
["src/nvim/digraph.c", ["  { 'E', 'u', 0x20ac }, // euro", "  { '=', 'R', 0x20bd }, // rouble", "  { '=', 'P', 0x20bd }, // rouble"], "whitespace/comments"]
["src/nvim/digraph.c", ["  { '=', 'R', 0x20bd }, // rouble", "  { '=', 'P', 0x20bd }, // rouble", "  { 'o', 'C', 0x2103 },"], "whitespace/comments"]
["src/nvim/digraph.c", ["  { 'O', '~', 213 },  // \ufffd", "  { '/', '\\\\', 215 }, // \ufffd - multiplication symbol in ISO 8859-1", "  { 'U', '`', 217 },  // \ufffd"], "whitespace/comments"]
["src/nvim/digraph.c", ["{", "  static int backspaced; // character before K_BS", "  static int lastchar;   // last typed character"], "whitespace/comments"]
["src/nvim/digraph.c", ["    if (backspaced >= 0) {", "      c = getdigraph(backspaced, c, FALSE);", "    }"], "readability/bool"]
["src/nvim/digraph.c", ["      if ((char2cells(c) == 1) && (cmdline_star == 0)) {", "        putcmdline(c, TRUE);", "      }"], "readability/bool"]
["src/nvim/digraph.c", ["      // ESC cancels CTRL-K", "      return getdigraph(c, cc, TRUE);", "    }"], "readability/bool"]
["src/nvim/digraph.c", ["    tmp.char2 = dp->char2;", "    tmp.result = getexactdigraph(tmp.char1, tmp.char2, FALSE);", ""], "readability/bool"]
["src/nvim/digraph.c", ["    assert(p >= buf);", "    vim_snprintf((char *)p, sizeof(buf) - (size_t)(p - buf), \" %3d\", dp->result);", "    msg_outtrans(buf);"], "whitespace/line_length"]
["src/nvim/digraph.c", ["", "    if (source_runtime((char_u *)buf, FALSE) == FAIL) {", "      // try finding \"keymap/'keymap'.vim\" in 'runtimepath'"], "readability/bool"]
["src/nvim/digraph.c", ["", "      if (source_runtime((char_u *)buf, FALSE) == FAIL) {", "        xfree(buf);"], "readability/bool"]
["src/nvim/digraph.c", ["                 ((kmap_T *)curbuf->b_kmap_ga.ga_data)[i].to);", "    (void)do_map(2, buf, LANGMAP, FALSE);", "  }"], "readability/bool"]
["src/nvim/digraph.c", ["    vim_snprintf((char *)buf, sizeof(buf), \"<buffer> %s\", kp[i].from);", "    (void)do_map(1, buf, LANGMAP, FALSE);", "    xfree(kp[i].from);"], "readability/bool"]
["src/nvim/digraph.c", ["  // Vim 5.x compatible digraphs that don't conflict with the above", "  { '~', '!', 161 },  // \ufffd", "  { 'c', '|', 162 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { '~', '!', 161 },  // \ufffd", "  { 'c', '|', 162 },  // \ufffd", "  { '$', '$', 163 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'c', '|', 162 },  // \ufffd", "  { '$', '$', 163 },  // \ufffd", "  { 'o', 'x', 164 },  // \ufffd - currency symbol in ISO 8859-1"], "readability/utf8"]
["src/nvim/digraph.c", ["  { '$', '$', 163 },  // \ufffd", "  { 'o', 'x', 164 },  // \ufffd - currency symbol in ISO 8859-1", "  { 'Y', '-', 165 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'o', 'x', 164 },  // \ufffd - currency symbol in ISO 8859-1", "  { 'Y', '-', 165 },  // \ufffd", "  { '|', '|', 166 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'Y', '-', 165 },  // \ufffd", "  { '|', '|', 166 },  // \ufffd", "  { 'c', 'O', 169 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { '|', '|', 166 },  // \ufffd", "  { 'c', 'O', 169 },  // \ufffd", "  { '-', ',', 172 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'c', 'O', 169 },  // \ufffd", "  { '-', ',', 172 },  // \ufffd", "  { '-', '=', 175 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { '-', ',', 172 },  // \ufffd", "  { '-', '=', 175 },  // \ufffd", "  { '~', 'o', 176 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { '-', '=', 175 },  // \ufffd", "  { '~', 'o', 176 },  // \ufffd", "  { '2', '2', 178 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { '~', 'o', 176 },  // \ufffd", "  { '2', '2', 178 },  // \ufffd", "  { '3', '3', 179 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { '2', '2', 178 },  // \ufffd", "  { '3', '3', 179 },  // \ufffd", "  { 'p', 'p', 182 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { '3', '3', 179 },  // \ufffd", "  { 'p', 'p', 182 },  // \ufffd", "  { '~', '.', 183 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'p', 'p', 182 },  // \ufffd", "  { '~', '.', 183 },  // \ufffd", "  { '1', '1', 185 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { '~', '.', 183 },  // \ufffd", "  { '1', '1', 185 },  // \ufffd", "  { '~', '?', 191 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { '1', '1', 185 },  // \ufffd", "  { '~', '?', 191 },  // \ufffd", "  { 'A', '`', 192 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { '~', '?', 191 },  // \ufffd", "  { 'A', '`', 192 },  // \ufffd", "  { 'A', '^', 194 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'A', '`', 192 },  // \ufffd", "  { 'A', '^', 194 },  // \ufffd", "  { 'A', '~', 195 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'A', '^', 194 },  // \ufffd", "  { 'A', '~', 195 },  // \ufffd", "  { 'A', '\"', 196 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'A', '~', 195 },  // \ufffd", "  { 'A', '\"', 196 },  // \ufffd", "  { 'A', '@', 197 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'A', '\"', 196 },  // \ufffd", "  { 'A', '@', 197 },  // \ufffd", "  { 'E', '`', 200 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'A', '@', 197 },  // \ufffd", "  { 'E', '`', 200 },  // \ufffd", "  { 'E', '^', 202 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'E', '`', 200 },  // \ufffd", "  { 'E', '^', 202 },  // \ufffd", "  { 'E', '\"', 203 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'E', '^', 202 },  // \ufffd", "  { 'E', '\"', 203 },  // \ufffd", "  { 'I', '`', 204 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'E', '\"', 203 },  // \ufffd", "  { 'I', '`', 204 },  // \ufffd", "  { 'I', '^', 206 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'I', '`', 204 },  // \ufffd", "  { 'I', '^', 206 },  // \ufffd", "  { 'I', '\"', 207 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'I', '^', 206 },  // \ufffd", "  { 'I', '\"', 207 },  // \ufffd", "  { 'N', '~', 209 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'I', '\"', 207 },  // \ufffd", "  { 'N', '~', 209 },  // \ufffd", "  { 'O', '`', 210 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'N', '~', 209 },  // \ufffd", "  { 'O', '`', 210 },  // \ufffd", "  { 'O', '^', 212 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'O', '`', 210 },  // \ufffd", "  { 'O', '^', 212 },  // \ufffd", "  { 'O', '~', 213 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'O', '^', 212 },  // \ufffd", "  { 'O', '~', 213 },  // \ufffd", "  { '/', '\\\\', 215 }, // \ufffd - multiplication symbol in ISO 8859-1"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'O', '~', 213 },  // \ufffd", "  { '/', '\\\\', 215 }, // \ufffd - multiplication symbol in ISO 8859-1", "  { 'U', '`', 217 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { '/', '\\\\', 215 }, // \ufffd - multiplication symbol in ISO 8859-1", "  { 'U', '`', 217 },  // \ufffd", "  { 'U', '^', 219 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'U', '`', 217 },  // \ufffd", "  { 'U', '^', 219 },  // \ufffd", "  { 'I', 'p', 222 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'U', '^', 219 },  // \ufffd", "  { 'I', 'p', 222 },  // \ufffd", "  { 'a', '`', 224 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'I', 'p', 222 },  // \ufffd", "  { 'a', '`', 224 },  // \ufffd", "  { 'a', '^', 226 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'a', '`', 224 },  // \ufffd", "  { 'a', '^', 226 },  // \ufffd", "  { 'a', '~', 227 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'a', '^', 226 },  // \ufffd", "  { 'a', '~', 227 },  // \ufffd", "  { 'a', '\"', 228 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'a', '~', 227 },  // \ufffd", "  { 'a', '\"', 228 },  // \ufffd", "  { 'a', '@', 229 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'a', '\"', 228 },  // \ufffd", "  { 'a', '@', 229 },  // \ufffd", "  { 'e', '`', 232 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'a', '@', 229 },  // \ufffd", "  { 'e', '`', 232 },  // \ufffd", "  { 'e', '^', 234 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'e', '`', 232 },  // \ufffd", "  { 'e', '^', 234 },  // \ufffd", "  { 'e', '\"', 235 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'e', '^', 234 },  // \ufffd", "  { 'e', '\"', 235 },  // \ufffd", "  { 'i', '`', 236 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'e', '\"', 235 },  // \ufffd", "  { 'i', '`', 236 },  // \ufffd", "  { 'i', '^', 238 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'i', '`', 236 },  // \ufffd", "  { 'i', '^', 238 },  // \ufffd", "  { 'n', '~', 241 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'i', '^', 238 },  // \ufffd", "  { 'n', '~', 241 },  // \ufffd", "  { 'o', '`', 242 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'n', '~', 241 },  // \ufffd", "  { 'o', '`', 242 },  // \ufffd", "  { 'o', '^', 244 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'o', '`', 242 },  // \ufffd", "  { 'o', '^', 244 },  // \ufffd", "  { 'o', '~', 245 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'o', '^', 244 },  // \ufffd", "  { 'o', '~', 245 },  // \ufffd", "  { 'u', '`', 249 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'o', '~', 245 },  // \ufffd", "  { 'u', '`', 249 },  // \ufffd", "  { 'u', '^', 251 },  // \ufffd"], "readability/utf8"]
["src/nvim/digraph.c", ["  { 'u', '`', 249 },  // \ufffd", "  { 'u', '^', 251 },  // \ufffd", "  { 'y', '\"', 255 },  // x XX"], "readability/utf8"]
["src/nvim/edit.c", ["  char_u      *(cp_text[CPT_COUNT]);    /* text for the menu */", "  char_u      *cp_fname;        /* file containing the match, allocated when", "                                 * cp_flags has FREE_FNAME */"], "readability/multiline_comment"]
["src/nvim/edit.c", [" * otherwise it inserts a line break. */", "static int compl_enter_selects = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "static int compl_get_longest = FALSE;           /* put longest common string", "                                                   in compl_leader */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_get_longest = FALSE;           /* put longest common string", "                                                   in compl_leader */"], "readability/bool"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/bool"]
["src/nvim/edit.c", ["static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert"], "readability/bool"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/bool"]
["src/nvim/edit.c", ["static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */", ""], "readability/bool"]
["src/nvim/edit.c", ["", "static int compl_used_match;            /* Selected one of the matches.  When", "                                           FALSE the match was edited or using"], "readability/multiline_comment"]
["src/nvim/edit.c", ["static int compl_used_match;            /* Selected one of the matches.  When", "                                           FALSE the match was edited or using", "                                           the longest common string. */"], "readability/alt_tokens"]
["src/nvim/edit.c", ["static int compl_used_match;            /* Selected one of the matches.  When", "                                           FALSE the match was edited or using", "                                           the longest common string. */"], "readability/bool"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/bool"]
["src/nvim/edit.c", ["", "static int compl_restarting = FALSE;            /* don't insert match */", ""], "readability/bool"]
["src/nvim/edit.c", [" * FALSE the word to be completed must be located. */", "static int compl_started = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", [" * which is not allowed. */", "static int compl_busy = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["static pos_T compl_startpos;", "static colnr_T compl_col = 0;               /* column where the text starts", "                                             * that is being completed */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["                                             * that is being completed */", "static char_u     *compl_orig_text = NULL;  /* text as it was before", "                                             * completion started */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_opt_refresh_always = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "static char_u   *last_insert = NULL;    /* the text of the previous insert,", "                                           K_SPECIAL and CSI are escaped */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int ins_need_undo;               /* call u_save() before inserting a", "                                           char.  Set when edit() is called."], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int did_add_space = FALSE;       /* auto_format() added an extra space", "                                           under the cursor */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int did_add_space = FALSE;       /* auto_format() added an extra space", "                                           under the cursor */"], "readability/bool"]
["src/nvim/edit.c", ["int", "edit (", "    int cmdchar,"], "whitespace/parens"]
["src/nvim/edit.c", ["static void", "ins_redraw (", "    int ready                   /* not busy with something */"], "whitespace/parens"]
["src/nvim/edit.c", ["  linenr_T conceal_new_cursor_line = 0;", "  int conceal_update_lines = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["    if (has_cursormovedI())", "      apply_autocmds(EVENT_CURSORMOVEDI, NULL, NULL, FALSE, curbuf);", "    if (curwin->w_p_cole > 0) {"], "readability/bool"]
["src/nvim/edit.c", ["      conceal_new_cursor_line = curwin->w_cursor.lnum;", "      conceal_update_lines = TRUE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["    if (last_changedtick_buf == curbuf)", "      apply_autocmds(EVENT_TEXTCHANGEDI, NULL, NULL, FALSE, curbuf);", "    last_changedtick_buf = curbuf;"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  showruler(FALSE);", "  setcursor();"], "readability/bool"]
["src/nvim/edit.c", ["  setcursor();", "  emsg_on_display = FALSE;      /* may remove error message now */", "}"], "readability/bool"]
["src/nvim/edit.c", ["  int c;", "  int did_putchar = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["  /* may need to redraw when no more chars available now */", "  ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["  if (redrawing() && !char_avail()) {", "    edit_putchar('^', TRUE);", "    did_putchar = TRUE;"], "readability/bool"]
["src/nvim/edit.c", ["    edit_putchar('^', TRUE);", "    did_putchar = TRUE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  clear_showcmd();", "  insert_special(c, FALSE, TRUE);", "  revins_chars++;"], "readability/bool"]
["src/nvim/edit.c", ["    if (pc_status == PC_STATUS_RIGHT || pc_status == PC_STATUS_LEFT)", "      redrawWinline(curwin->w_cursor.lnum, FALSE);", "    else"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  curs_columns(FALSE);              /* recompute w_wrow and w_wcol */", "  if (curwin->w_wcol < curwin->w_width) {"], "readability/bool"]
["src/nvim/edit.c", ["  if (curwin->w_wcol < curwin->w_width) {", "    edit_putchar('$', FALSE);", "    dollar_vcol = curwin->w_virtcol;"], "readability/bool"]
["src/nvim/edit.c", ["    dollar_vcol = -1;", "    redrawWinline(curwin->w_cursor.lnum, FALSE);", "  }"], "readability/bool"]
["src/nvim/edit.c", ["void", "change_indent (", "    int type,"], "whitespace/parens"]
["src/nvim/edit.c", ["    int round,", "    int replaced,                   /* replaced character, put on replace stack */", "    int call_changed_bytes                 /* call changed_bytes() */"], "whitespace/line_length"]
["src/nvim/edit.c", ["  save_p_list = curwin->w_p_list;", "  curwin->w_p_list = FALSE;", "  vc = getvcol_nolist(&curwin->w_cursor);"], "readability/bool"]
["src/nvim/edit.c", ["    (void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);", "  else {", "    int save_State = State;"], "readability/braces"]
["src/nvim/edit.c", ["    new_cursor_col += curwin->w_cursor.col;", "  } else if (!(State & INSERT))", "    new_cursor_col = curwin->w_cursor.col;"], "readability/braces"]
["src/nvim/edit.c", ["    new_cursor_col = curwin->w_cursor.col;", "  else {", "    /*"], "readability/braces"]
["src/nvim/edit.c", ["    curwin->w_cursor.col = (colnr_T)new_cursor_col;", "  curwin->w_set_curswant = TRUE;", "  changed_cline_bef_curs();"], "readability/bool"]
["src/nvim/edit.c", ["    /* Put back original line */", "    ml_replace(curwin->w_cursor.lnum, orig_line, FALSE);", "    curwin->w_cursor.col = orig_col;"], "readability/bool"]
["src/nvim/edit.c", ["    if (*get_cursor_pos_ptr() == NUL || curwin->w_cursor.col == ecol)", "      return FALSE;", "    del_bytes((long)((int)ecol - curwin->w_cursor.col), FALSE, TRUE);"], "readability/bool"]
["src/nvim/edit.c", ["      return FALSE;", "    del_bytes((long)((int)ecol - curwin->w_cursor.col), FALSE, TRUE);", "  } else"], "readability/bool"]
["src/nvim/edit.c", ["    del_bytes((long)((int)ecol - curwin->w_cursor.col), FALSE, TRUE);", "  } else", "    (void)del_char(FALSE);"], "readability/braces"]
["src/nvim/edit.c", ["  } else", "    (void)del_char(FALSE);", "  return TRUE;"], "readability/bool"]
["src/nvim/edit.c", ["    (void)del_char(FALSE);", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/edit.c", ["    }", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/edit.c", ["  if (c == Ctrl_R)", "    return TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["  if (ins_compl_pum_key(c))", "    return TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["  EMSG(_(e_internal));", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/edit.c", [" */", "int ins_compl_add_infercase(char_u *str, int len, int icase, char_u *fname, int dir, int flags)", "{"], "whitespace/line_length"]
["src/nvim/edit.c", ["  int         *wca;                     /* Wide character array. */", "  int has_lower = FALSE;", "  int was_letter = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  int has_lower = FALSE;", "  int was_letter = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["      }", "    } else", "      actual_len = len;"], "readability/braces"]
["src/nvim/edit.c", ["      }", "    } else", "      actual_compl_length = compl_length;"], "readability/braces"]
["src/nvim/edit.c", ["      if (vim_islower(c)) {", "        has_lower = TRUE;", "        if (vim_isupper(wca[i])) {"], "readability/bool"]
["src/nvim/edit.c", ["    return ins_compl_add(IObuff, len, icase, fname, NULL, dir,", "        flags, FALSE);", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  return ins_compl_add(str, len, icase, fname, NULL, dir, flags, FALSE);", "}"], "readability/bool"]
["src/nvim/edit.c", ["static int", "ins_compl_add (", "    char_u *str,"], "whitespace/parens"]
["src/nvim/edit.c", ["    flags |= FREE_FNAME;", "  } else", "    match->cp_fname = NULL;"], "readability/braces"]
["src/nvim/edit.c", ["    ins_bytes(compl_leader + ins_compl_len());", "    ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["      ins_compl_delete();", "    compl_used_match = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/edit.c", ["      ins_bytes(compl_leader + ins_compl_len());", "      ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "    compl_used_match = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["    if ((add_r = ins_compl_add(matches[i], -1, icase,", "             NULL, NULL, dir, 0, FALSE)) == OK)", "      /* if dir was BACKWARD then honor it just once */"], "readability/bool"]
["src/nvim/edit.c", ["  if (ins_compl_add(compl_orig_text, -1, p_ic, NULL, NULL, 0,", "                    ORIGINAL_TEXT, FALSE) != OK) {", "    return;"], "readability/bool"]
["src/nvim/edit.c", ["  compl_matches = ins_compl_make_cyclic();", "  compl_started = TRUE;", "  compl_used_match = TRUE;"], "readability/bool"]
["src/nvim/edit.c", ["  compl_started = TRUE;", "  compl_used_match = TRUE;", "  compl_cont_status = 0;"], "readability/bool"]
["src/nvim/edit.c", ["  if (vim_strchr(p_cot, 'm') == NULL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["      )", "    return FALSE;", "  return TRUE;"], "readability/bool"]
["src/nvim/edit.c", ["    return FALSE;", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/edit.c", ["   * one (ignoring the original text). */", "  compl = compl_first_match;", "  i = 0;"], "readability/alt_tokens"]
["src/nvim/edit.c", ["  do {", "    if (compl == NULL", "        || ((compl->cp_flags & ORIGINAL_TEXT) == 0 && ++i == 2))"], "readability/alt_tokens"]
["src/nvim/edit.c", ["      break;", "    compl = compl->cp_next;", "  } while (compl != compl_first_match);"], "readability/alt_tokens"]
["src/nvim/edit.c", ["    compl = compl->cp_next;", "  } while (compl != compl_first_match);", ""], "readability/alt_tokens"]
["src/nvim/edit.c", ["  compl_T     *shown_compl = NULL;", "  int did_find_shown_match = FALSE;", "  int shown_match_ok = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  int did_find_shown_match = FALSE;", "  int shown_match_ok = FALSE;", "  int i;"], "readability/bool"]
["src/nvim/edit.c", ["    compl_match_arraysize = 0;", "    compl = compl_first_match;", "    if (compl_leader != NULL)"], "readability/alt_tokens"]
["src/nvim/edit.c", ["        ++compl_match_arraysize;", "      compl = compl->cp_next;", "    } while (compl != NULL && compl != compl_first_match);"], "readability/alt_tokens"]
["src/nvim/edit.c", ["      compl = compl->cp_next;", "    } while (compl != NULL && compl != compl_first_match);", "    if (compl_match_arraysize == 0)"], "readability/alt_tokens"]
["src/nvim/edit.c", ["      compl = compl->cp_next;", "    } while (compl != NULL && compl != compl_first_match);", "    if (compl_match_arraysize == 0)"], "readability/alt_tokens"]
["src/nvim/edit.c", ["    if (compl_shown_match->cp_flags & ORIGINAL_TEXT)", "      shown_match_ok = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["    i = 0;", "    compl = compl_first_match;", "    do {"], "readability/alt_tokens"]
["src/nvim/edit.c", ["        if (!shown_match_ok) {", "          if (compl == compl_shown_match || did_find_shown_match) {", "            /* This item is the shown match or this is the"], "readability/alt_tokens"]
["src/nvim/edit.c", ["            compl_shown_match = compl;", "            did_find_shown_match = TRUE;", "            shown_match_ok = TRUE;"], "readability/bool"]
["src/nvim/edit.c", ["            did_find_shown_match = TRUE;", "            shown_match_ok = TRUE;", "          } else"], "readability/bool"]
["src/nvim/edit.c", ["            shown_match_ok = TRUE;", "          } else", "            /* Remember this displayed match for when the"], "readability/braces"]
["src/nvim/edit.c", ["", "      if (compl == compl_shown_match) {", "        did_find_shown_match = TRUE;"], "readability/alt_tokens"]
["src/nvim/edit.c", ["      if (compl == compl_shown_match) {", "        did_find_shown_match = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["        if (compl->cp_flags & ORIGINAL_TEXT)", "          shown_match_ok = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["          compl_shown_match = shown_compl;", "          shown_match_ok = TRUE;", "        }"], "readability/bool"]
["src/nvim/edit.c", ["      }", "      compl = compl->cp_next;", "    } while (compl != NULL && compl != compl_first_match);"], "readability/alt_tokens"]
["src/nvim/edit.c", ["      compl = compl->cp_next;", "    } while (compl != NULL && compl != compl_first_match);", ""], "readability/alt_tokens"]
["src/nvim/edit.c", ["      compl = compl->cp_next;", "    } while (compl != NULL && compl != compl_first_match);", ""], "readability/alt_tokens"]
["src/nvim/edit.c", ["static void", "ins_compl_dictionaries (", "    char_u *dict_start,"], "whitespace/parens"]
["src/nvim/edit.c", ["  if (curbuf->b_p_inf)", "    p_scs = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "static void ins_compl_files(int count, char_u **files, int thesaurus, int flags, regmatch_T *regmatch, char_u *buf, int *dir)", "{"], "whitespace/line_length"]
["src/nvim/edit.c", ["          _(\"Scanning dictionary: %s\"), (char *)files[i]);", "      (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));", "    }"], "readability/bool"]
["src/nvim/edit.c", ["              }", "            else", "              ptr = find_word_end(ptr);"], "whitespace/newline"]
["src/nvim/edit.c", ["      }", "  } else", "    while (vim_iswordc(*ptr))"], "readability/braces"]
["src/nvim/edit.c", ["  compl_cont_status = 0;", "  compl_started = FALSE;", "  compl_matches = 0;"], "readability/bool"]
["src/nvim/edit.c", ["  compl_orig_text = NULL;", "  compl_enter_selects = FALSE;", "  // clear v:completed_item"], "readability/bool"]
["src/nvim/edit.c", ["  ins_bytes(compl_leader + ins_compl_len());", "  compl_used_match = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["    ins_compl_set_original_text(compl_leader);", "  else {", "    spell_bad_len = 0;          /* need to redetect bad word */"], "readability/braces"]
["src/nvim/edit.c", ["    update_screen(0);", "    compl_restarting = TRUE;", "    if (ins_complete(Ctrl_N) == FAIL)"], "readability/bool"]
["src/nvim/edit.c", ["      compl_cont_status = 0;", "    compl_restarting = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  if (compl_match_array == NULL)", "    compl_enter_selects = FALSE;", "}"], "readability/bool"]
["src/nvim/edit.c", ["  ins_compl_free();", "  compl_started = FALSE;", "  compl_matches = 0;"], "readability/bool"]
["src/nvim/edit.c", ["        return;", "    } else", "      return;"], "readability/braces"]
["src/nvim/edit.c", ["  int want_cindent;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["    compl_get_longest = (strstr((char *)p_cot, \"longest\") != NULL);", "    compl_used_match = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["    compl_used_match = TRUE;", "", "  }"], "whitespace/blank_line"]
["src/nvim/edit.c", ["  if (strstr((char *)p_cot, \"noselect\") != NULL) {", "    compl_no_insert = FALSE;", "    compl_no_select = TRUE;"], "readability/bool"]
["src/nvim/edit.c", ["    compl_no_insert = FALSE;", "    compl_no_select = TRUE;", "  } else if (strstr((char *)p_cot, \"noinsert\") != NULL) {"], "readability/bool"]
["src/nvim/edit.c", ["  } else if (strstr((char *)p_cot, \"noinsert\") != NULL) {", "    compl_no_insert = TRUE;", "    compl_no_select = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["    compl_no_insert = TRUE;", "    compl_no_select = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/edit.c", ["  } else {", "    compl_no_insert = FALSE;", "    compl_no_select = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["    compl_no_insert = FALSE;", "    compl_no_select = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["          do_c_expr_indent();", "          want_cindent = FALSE;                 /* don't do it again */", "        }"], "readability/bool"]
["src/nvim/edit.c", ["          && pum_visible())", "        retval = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["          ins_bytes(compl_orig_text + ins_compl_len());", "        retval = TRUE;", "      }"], "readability/bool"]
["src/nvim/edit.c", ["", "      auto_format(FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/edit.c", ["      ins_compl_free();", "      compl_started = FALSE;", "      compl_matches = 0;"], "readability/bool"]
["src/nvim/edit.c", ["      ctrl_x_mode = 0;", "      compl_enter_selects = FALSE;", "      if (edit_submode != NULL) {"], "readability/bool"]
["src/nvim/edit.c", ["       * upon the completion. */", "      apply_autocmds(EVENT_COMPLETEDONE, NULL, NULL, FALSE, curbuf);", "    }"], "readability/bool"]
["src/nvim/edit.c", ["    }", "  } else if (ctrl_x_mode == CTRL_X_LOCAL_MSG)", "    /* Trigger the CompleteDone event to give scripts a chance to act"], "readability/braces"]
["src/nvim/edit.c", ["     * upon the (possibly failed) completion. */", "    apply_autocmds(EVENT_COMPLETEDONE, NULL, NULL, FALSE, curbuf);", ""], "readability/bool"]
["src/nvim/edit.c", ["    for (len = 0; p[len] != NUL && p[len] == ptr[len]; ++len)", "      ;", "    if (len > 0)"], "whitespace/semicolon"]
["src/nvim/edit.c", ["      AppendCharToRedobuff(K_BS);", "  } else", "    len = 0;"], "readability/braces"]
["src/nvim/edit.c", ["           && wp->w_buffer->b_scanned)", "      ;", "    buf = wp->w_buffer;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["    buf = wp->w_buffer;", "  } else", "    /* 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'"], "readability/braces"]
["src/nvim/edit.c", ["               || buf->b_scanned))", "      ;", "  return buf;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["static void", "expand_by_function (", "    int type,                   /* CTRL_X_OMNI or CTRL_X_FUNCTION */"], "whitespace/parens"]
["src/nvim/edit.c", ["  /* Call a function, which returns a list or dict. */", "  if (call_vim_function(funcname, 2, args, FALSE, FALSE, &rettv) == OK) {", "    switch (rettv.v_type) {"], "readability/bool"]
["src/nvim/edit.c", ["  /* Check for optional \"refresh\" item. */", "  compl_opt_refresh_always = FALSE;", "  di_refresh = dict_find(dict, (char_u *)\"refresh\", 7);"], "readability/bool"]
["src/nvim/edit.c", ["    if (v != NULL && STRCMP(v, (char_u *)\"always\") == 0)", "      compl_opt_refresh_always = TRUE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  char_u      *word;", "  int icase = FALSE;", "  int adup = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  int icase = FALSE;", "  int adup = FALSE;", "  int aempty = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  int adup = FALSE;", "  int aempty = FALSE;", "  char_u      *(cptext[CPT_COUNT]);"], "readability/bool"]
["src/nvim/edit.c", ["  if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL) {", "    word = get_dict_string(tv->vval.v_dict, (char_u *)\"word\", FALSE);", "    cptext[CPT_ABBR] = get_dict_string(tv->vval.v_dict,"], "readability/bool"]
["src/nvim/edit.c", ["    cptext[CPT_ABBR] = get_dict_string(tv->vval.v_dict,", "        (char_u *)\"abbr\", FALSE);", "    cptext[CPT_MENU] = get_dict_string(tv->vval.v_dict,"], "readability/bool"]
["src/nvim/edit.c", ["    cptext[CPT_MENU] = get_dict_string(tv->vval.v_dict,", "        (char_u *)\"menu\", FALSE);", "    cptext[CPT_KIND] = get_dict_string(tv->vval.v_dict,"], "readability/bool"]
["src/nvim/edit.c", ["    cptext[CPT_KIND] = get_dict_string(tv->vval.v_dict,", "        (char_u *)\"kind\", FALSE);", "    cptext[CPT_INFO] = get_dict_string(tv->vval.v_dict,"], "readability/bool"]
["src/nvim/edit.c", ["    cptext[CPT_INFO] = get_dict_string(tv->vval.v_dict,", "        (char_u *)\"info\", FALSE);", "    if (get_dict_string(tv->vval.v_dict, (char_u *)\"icase\", FALSE) != NULL)"], "readability/bool"]
["src/nvim/edit.c", ["        (char_u *)\"info\", FALSE);", "    if (get_dict_string(tv->vval.v_dict, (char_u *)\"icase\", FALSE) != NULL)", "      icase = get_dict_number(tv->vval.v_dict, (char_u *)\"icase\");"], "readability/bool"]
["src/nvim/edit.c", ["      icase = get_dict_number(tv->vval.v_dict, (char_u *)\"icase\");", "    if (get_dict_string(tv->vval.v_dict, (char_u *)\"dup\", FALSE) != NULL)", "      adup = get_dict_number(tv->vval.v_dict, (char_u *)\"dup\");"], "readability/bool"]
["src/nvim/edit.c", ["      adup = get_dict_number(tv->vval.v_dict, (char_u *)\"dup\");", "    if (get_dict_string(tv->vval.v_dict, (char_u *)\"empty\", FALSE) != NULL)", "      aempty = get_dict_number(tv->vval.v_dict, (char_u *)\"empty\");"], "readability/bool"]
["src/nvim/edit.c", ["  static char_u       *e_cpt = (char_u *)\"\";    /* curr. entry in 'complete' */", "  static int found_all = FALSE;                 /* Found all matches of a", "                                                   certain type. */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["  static char_u       *e_cpt = (char_u *)\"\";    /* curr. entry in 'complete' */", "  static int found_all = FALSE;                 /* Found all matches of a", "                                                   certain type. */"], "readability/bool"]
["src/nvim/edit.c", ["    }", "    found_all = FALSE;", "    ins_buf = curbuf;"], "readability/bool"]
["src/nvim/edit.c", ["    found_new_match = FAIL;", "    set_match_pos = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["        && (!compl_started || found_all)) {", "      found_all = FALSE;", "      while (*e_cpt == ',' || *e_cpt == ' ')"], "readability/bool"]
["src/nvim/edit.c", ["         * wrap and come back there a second time. */", "        set_match_pos = TRUE;", "      } else if (vim_strchr((char_u *)\"buwU\", *e_cpt) != NULL"], "readability/bool"]
["src/nvim/edit.c", ["        if (ins_buf->b_ml.ml_mfp != NULL) {         /* loaded buffer */", "          compl_started = TRUE;", "          first_match_pos.col = last_match_pos.col = 0;"], "readability/bool"]
["src/nvim/edit.c", ["        } else {      /* unloaded buffer, scan like dictionary */", "          found_all = TRUE;", "          if (ins_buf->b_fname == NULL)"], "readability/bool"]
["src/nvim/edit.c", ["            : ins_buf->b_sfname);", "        (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));", "      } else if (*e_cpt == NUL)"], "readability/bool"]
["src/nvim/edit.c", ["        (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));", "      } else if (*e_cpt == NUL)", "        break;"], "readability/braces"]
["src/nvim/edit.c", ["        break;", "      else {", "        if (CTRL_X_MODE_LINE_OR_EVAL(l_ctrl_x_mode)) {"], "readability/braces"]
["src/nvim/edit.c", ["          }", "        } else if (*e_cpt == 'i')", "          type = CTRL_X_PATH_PATTERNS;"], "readability/braces"]
["src/nvim/edit.c", ["          vim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning tags.\"));", "          (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));", "        } else"], "readability/bool"]
["src/nvim/edit.c", ["          (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));", "        } else", "          type = -1;"], "readability/braces"]
["src/nvim/edit.c", ["", "        found_all = TRUE;", "        if (type == -1)"], "readability/bool"]
["src/nvim/edit.c", ["      find_pattern_in_path(compl_pattern, compl_direction,", "                           STRLEN(compl_pattern), FALSE, FALSE,", "                           ((type == CTRL_X_PATH_DEFINES"], "readability/bool"]
["src/nvim/edit.c", ["              EW_FILE|EW_DIR|EW_ADDSLASH|EW_SILENT) == OK) {", "", "        /* May change home directory back to \"~\". */"], "whitespace/blank_line"]
["src/nvim/edit.c", ["              &num_matches, &matches) == EXPAND_OK)", "        ins_compl_add_matches(num_matches, matches, FALSE);", "      break;"], "readability/bool"]
["src/nvim/edit.c", ["      if (ins_buf->b_p_inf)", "        p_scs = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["              compl_direction, compl_pattern);", "        } else", "          found_new_match = searchit(NULL, ins_buf, pos,"], "readability/braces"]
["src/nvim/edit.c", ["          /* set \"compl_started\" even on fail */", "          compl_started = TRUE;", "          first_match_pos = *pos;"], "readability/bool"]
["src/nvim/edit.c", ["          last_match_pos = *pos;", "          set_match_pos = FALSE;", "        } else if (first_match_pos.lnum == last_match_pos.lnum"], "readability/bool"]
["src/nvim/edit.c", ["          set_match_pos = FALSE;", "        } else if (first_match_pos.lnum == last_match_pos.lnum", "                   && first_match_pos.col == last_match_pos.col)"], "readability/braces"]
["src/nvim/edit.c", ["          if (ins_buf == curbuf)", "            found_all = TRUE;", "          break;"], "readability/bool"]
["src/nvim/edit.c", ["          continue;", "        ptr = ml_get_buf(ins_buf, pos->lnum, FALSE) + pos->col;", "        if (CTRL_X_MODE_LINE_OR_EVAL(l_ctrl_x_mode)) {"], "readability/bool"]
["src/nvim/edit.c", ["              continue;", "            ptr = ml_get_buf(ins_buf, pos->lnum + 1, FALSE);", "            if (!p_paste)"], "readability/bool"]
["src/nvim/edit.c", ["              STRNCPY(IObuff, ptr, len);", "              ptr = ml_get_buf(ins_buf, pos->lnum + 1, FALSE);", "              tmp_ptr = ptr = skipwhite(ptr);"], "readability/bool"]
["src/nvim/edit.c", ["      }", "      compl_started = TRUE;", "    } else {"], "readability/bool"]
["src/nvim/edit.c", ["", "      compl_started = FALSE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  compl_started = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["  backspace_until_column(i);", "  // TODO: is this sufficient for redrawing?  Redrawing everything causes", "  // flicker, thus we can't do that."], "readability/todo"]
["src/nvim/edit.c", ["  if (compl_shown_match->cp_flags & ORIGINAL_TEXT)", "    compl_used_match = FALSE;", "  else"], "readability/bool"]
["src/nvim/edit.c", ["  else", "    compl_used_match = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["static int", "ins_compl_next (", "    int allow_get_expansion,"], "whitespace/parens"]
["src/nvim/edit.c", ["    int allow_get_expansion,", "    int count,                      /* repeat completion this many times; should", "                                   be at least 1 */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["  compl_T *found_compl = NULL;", "  int found_end = FALSE;", "  int advance;"], "readability/bool"]
["src/nvim/edit.c", ["  if (compl_restarting) {", "    advance = FALSE;", "    compl_restarting = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["    advance = FALSE;", "    compl_restarting = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["          ++compl_pending;", "        } else", "          break;"], "readability/braces"]
["src/nvim/edit.c", ["      }", "      found_end = FALSE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["    ins_bytes(compl_orig_text + ins_compl_len());", "    compl_used_match = FALSE;", "  } else if (insert_match) {"], "readability/bool"]
["src/nvim/edit.c", ["  } else {", "    compl_used_match = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  if (compl_no_insert && !started) {", "    compl_enter_selects = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/edit.c", ["    msg(IObuff);", "    redraw_cmdline = FALSE;         /* don't overwrite! */", "  }"], "readability/bool"]
["src/nvim/edit.c", ["      compl_shows_dir = ins_compl_key2dir(c);", "      (void)ins_compl_next(FALSE, ins_compl_key2count(c),", "          c != K_UP && c != K_DOWN);"], "readability/bool"]
["src/nvim/edit.c", ["        if (c != Ctrl_R && KeyTyped)", "          compl_interrupted = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["    compl_pending = 0;", "    (void)ins_compl_next(FALSE, todo, TRUE);", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  case K_S_UP:", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/edit.c", ["", "    did_ai = FALSE;", "    did_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["    did_ai = FALSE;", "    did_si = FALSE;", "    can_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["    did_si = FALSE;", "    can_si = FALSE;", "    can_si_back = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["    can_si = FALSE;", "    can_si_back = FALSE;", "    if (stop_arrow() == FAIL)"], "readability/bool"]
["src/nvim/edit.c", ["        compl_cont_status = CONT_ADDING | CONT_N_ADDS;", "      } else", "        compl_cont_status = 0;"], "readability/braces"]
["src/nvim/edit.c", ["        compl_cont_status = 0;", "    } else", "      compl_cont_status &= CONT_LOCAL;"], "readability/braces"]
["src/nvim/edit.c", ["          while (--startcol >= 0 && vim_isIDc(line[startcol]))", "            ;", "          compl_col += ++startcol;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["                  vim_iswordp(mb_prevptr(line, line + compl_col))", "                  )))", "          prefix = (char_u *)\"\";"], "whitespace/parens"]
["src/nvim/edit.c", ["          }", "        } else", "          while (--startcol >= 0 && vim_iswordc(line[startcol]))"], "readability/braces"]
["src/nvim/edit.c", ["          while (--startcol >= 0 && vim_iswordc(line[startcol]))", "            ;", "        compl_col += ++startcol;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["      curbuf_save = curbuf;", "      col = call_func_retnr(funcname, 2, args, FALSE);", "      if (curwin_save != curwin || curbuf_save != curbuf) {"], "readability/bool"]
["src/nvim/edit.c", ["       */", "      compl_opt_refresh_always = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["      }", "      else", "        compl_col = spell_word_start(startcol);"], "whitespace/newline"]
["src/nvim/edit.c", ["    if (ins_compl_add(compl_orig_text, -1, p_ic, NULL, NULL, 0,", "                      ORIGINAL_TEXT, FALSE) != OK) {", "      xfree(compl_pattern);"], "readability/bool"]
["src/nvim/edit.c", ["  save_w_wrow = curwin->w_wrow;", "  n = ins_compl_next(TRUE, ins_compl_key2count(c), ins_compl_use_match(c));", ""], "readability/bool"]
["src/nvim/edit.c", ["    (void)vgetc();", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["        if (dollar_vcol >= 0)", "          curs_columns(FALSE);", "      }"], "readability/bool"]
["src/nvim/edit.c", ["  compl_was_interrupted = compl_interrupted;", "  compl_interrupted = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["  int i;", "  int hex = FALSE;", "  int octal = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  int hex = FALSE;", "  int octal = FALSE;", "  int unicode = 0;"], "readability/bool"]
["src/nvim/edit.c", ["    if (nc == 'x' || nc == 'X')", "      hex = TRUE;", "    else if (nc == 'o' || nc == 'O')"], "readability/bool"]
["src/nvim/edit.c", ["    else if (nc == 'o' || nc == 'O')", "      octal = TRUE;", "    else if (nc == 'u' || nc == 'U')"], "readability/bool"]
["src/nvim/edit.c", ["      unicode = nc;", "    else {", "      if (hex"], "readability/braces"]
["src/nvim/edit.c", ["        break;", "    } else if (i >= 3)          /* decimal or octal: up to three chars */", "      break;"], "readability/braces"]
["src/nvim/edit.c", ["  if (enc_dbcs && (cc & 0xff) == 0)", "    cc = '?';           /* don't accept an illegal DBCS char, the NUL in the", "                           second byte will cause trouble! */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["    cc = '?';           /* don't accept an illegal DBCS char, the NUL in the", "                           second byte will cause trouble! */", ""], "whitespace/operators"]
["src/nvim/edit.c", ["    vungetc(nc);", "  got_int = FALSE;          /* CTRL-C typed after CTRL-V is not an interrupt */", "  return cc;"], "readability/bool"]
["src/nvim/edit.c", ["static void", "insert_special (", "    int c,"], "whitespace/parens"]
["src/nvim/edit.c", ["      AppendToRedobuffLit(p, -1);", "      ctrlv = FALSE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["void", "insertchar (", "    int c,                                  /* character to insert or NUL */"], "whitespace/parens"]
["src/nvim/edit.c", ["                          || Insstart_blank_vcol <= (colnr_T)textwidth", "                          )))))) {", "    /* Format with 'formatexpr' when it's set.  Use internal formatting"], "whitespace/parens"]
["src/nvim/edit.c", ["     * when 'formatexpr' isn't set or it returns non-zero. */", "    int do_internal = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["       * was called. */", "      ins_need_undo = TRUE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["     */", "    i = get_leader_len(line = get_cursor_line_ptr(), &p, FALSE, TRUE);", "    if (i > 0 && vim_strchr(p, COM_MIDDLE) != NULL) {   /* Just checking */"], "readability/bool"]
["src/nvim/edit.c", ["      while (--i >= 0 && ascii_iswhite(line[i]))", "        ;", "      i++;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["", "  did_ai = FALSE;", "  did_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  did_ai = FALSE;", "  did_si = FALSE;", "  can_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  did_si = FALSE;", "  can_si = FALSE;", "  can_si_back = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  can_si = FALSE;", "  can_si_back = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["      i = 1;", "    } else", "      i = 0;"], "readability/braces"]
["src/nvim/edit.c", ["static void", "internal_format (", "    int textwidth,"], "whitespace/parens"]
["src/nvim/edit.c", ["  int save_char = NUL;", "  int haveto_redraw = FALSE;", "  int fo_ins_blank = has_format_option(FO_INS_BLANK);"], "readability/bool"]
["src/nvim/edit.c", ["  int fo_white_par = has_format_option(FO_WHITE_PAR);", "  int first_line = TRUE;", "  colnr_T leader_len;"], "readability/bool"]
["src/nvim/edit.c", ["  colnr_T leader_len;", "  int no_leader = FALSE;", "  int do_comments = (flags & INSCHAR_DO_COM);"], "readability/bool"]
["src/nvim/edit.c", ["    if (no_leader)", "      do_comments = FALSE;", "    else if (!(flags & INSCHAR_FORMAT)"], "readability/bool"]
["src/nvim/edit.c", ["             && has_format_option(FO_WRAP_COMS))", "      do_comments = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["    if (do_comments)", "      leader_len = get_leader_len(get_cursor_line_ptr(), NULL, FALSE, TRUE);", "    else"], "readability/bool"]
["src/nvim/edit.c", ["    if (leader_len == 0)", "      no_leader = TRUE;", "    if (!(flags & INSCHAR_FORMAT)"], "readability/bool"]
["src/nvim/edit.c", ["            change_indent(INDENT_SET, second_indent,", "                FALSE, NUL, TRUE);", "          else if (leader_len > 0 && second_indent - leader_len > 0) {"], "readability/bool"]
["src/nvim/edit.c", ["      }", "      first_line = FALSE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["", "    haveto_redraw = TRUE;", "    can_cindent = TRUE;"], "readability/bool"]
["src/nvim/edit.c", ["    haveto_redraw = TRUE;", "    can_cindent = TRUE;", "    /* moved the cursor, don't autoindent or cindent now */"], "readability/bool"]
["src/nvim/edit.c", ["    /* moved the cursor, don't autoindent or cindent now */", "    did_ai = FALSE;", "    did_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["    did_ai = FALSE;", "    did_si = FALSE;", "    can_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["    did_si = FALSE;", "    can_si = FALSE;", "    can_si_back = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["    can_si = FALSE;", "    can_si_back = FALSE;", "    line_breakcheck();"], "readability/bool"]
["src/nvim/edit.c", ["void", "auto_format (", "    int trailblank,                 /* when TRUE also format with trailing blank */"], "whitespace/parens"]
["src/nvim/edit.c", ["auto_format (", "    int trailblank,                 /* when TRUE also format with trailing blank */", "    int prev_line                  /* may start in previous line */"], "whitespace/line_length"]
["src/nvim/edit.c", ["  /* may remove added space */", "  check_auto_format(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["  if (has_format_option(FO_WRAP_COMS) && !has_format_option(FO_WRAP)", "      && get_leader_len(old, NULL, FALSE, TRUE) == 0)", "    return;"], "readability/bool"]
["src/nvim/edit.c", ["  saved_cursor = pos;", "  format_lines((linenr_T)-1, FALSE);", "  curwin->w_cursor = saved_cursor;"], "readability/bool"]
["src/nvim/edit.c", ["    coladvance((colnr_T)MAXCOL);", "  } else", "    check_cursor_col();"], "readability/braces"]
["src/nvim/edit.c", ["      pnew[len + 1] = NUL;", "      ml_replace(curwin->w_cursor.lnum, pnew, FALSE);", "      /* remove the space later */"], "readability/bool"]
["src/nvim/edit.c", ["      /* remove the space later */", "      did_add_space = TRUE;", "    } else"], "readability/bool"]
["src/nvim/edit.c", ["      did_add_space = TRUE;", "    } else", "      /* may remove added space */"], "readability/braces"]
["src/nvim/edit.c", ["      /* may remove added space */", "      check_auto_format(FALSE);", "  }"], "readability/bool"]
["src/nvim/edit.c", ["static void", "check_auto_format (", "    int end_insert                     /* TRUE when ending Insert mode */"], "whitespace/parens"]
["src/nvim/edit.c", ["      /* Somehow the space was removed already. */", "      did_add_space = FALSE;", "    else {"], "readability/bool"]
["src/nvim/edit.c", ["      did_add_space = FALSE;", "    else {", "      if (!end_insert) {"], "readability/braces"]
["src/nvim/edit.c", ["        /* The space is no longer at the end of the line, delete it. */", "        del_char(FALSE);", "        did_add_space = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["        del_char(FALSE);", "        did_add_space = FALSE;", "      }"], "readability/bool"]
["src/nvim/edit.c", ["int", "comp_textwidth (", "    int ff                 /* force formatting (for \"gq\" command) */"], "whitespace/parens"]
["src/nvim/edit.c", ["    AppendToRedobuff(buf);", "  } else", "    AppendCharToRedobuff(c);"], "readability/braces"]
["src/nvim/edit.c", ["    AppendToRedobuff(ESC_STR);", "    stop_insert(end_insert_pos, FALSE, FALSE);", "    arrow_used = TRUE;          /* this means we stopped the current insert */"], "readability/bool"]
["src/nvim/edit.c", ["    stop_insert(end_insert_pos, FALSE, FALSE);", "    arrow_used = TRUE;          /* this means we stopped the current insert */", "  }"], "readability/bool"]
["src/nvim/edit.c", ["    spell_redraw_lnum = 0;", "    redrawWinline(lnum, FALSE);", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  pos_T tpos = curwin->w_cursor;", "  spell_bad_len = spell_move_to(curwin, BACKWARD, TRUE, TRUE, NULL);", "  if (curwin->w_cursor.col != tpos.col)"], "readability/bool"]
["src/nvim/edit.c", ["  if (arrow_used) {", "    Insstart = curwin->w_cursor;  //new insertion starts here", "    if (Insstart.col > Insstart_orig.col && !ins_need_undo) {"], "whitespace/comments"]
["src/nvim/edit.c", ["      // right, except when nothing was inserted yet.", "      update_Insstart_orig = FALSE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["    if (u_save_cursor() == OK) {", "      arrow_used = FALSE;", "      ins_need_undo = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["      arrow_used = FALSE;", "      ins_need_undo = FALSE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["    if (u_save_cursor() == OK)", "      ins_need_undo = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["static void", "stop_insert (", "    pos_T *end_insert_pos,"], "whitespace/parens"]
["src/nvim/edit.c", ["    last_insert_skip = new_insert_skip;", "  } else", "    xfree(ptr);"], "readability/braces"]
["src/nvim/edit.c", ["", "      auto_format(TRUE, FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["    /* If a space was inserted for auto-formatting, remove it now. */", "    check_auto_format(TRUE);", ""], "readability/bool"]
["src/nvim/edit.c", ["          break;", "        if (del_char(TRUE) == FAIL)", "          break;            /* should not happen */"], "readability/bool"]
["src/nvim/edit.c", ["        curwin->w_cursor = tpos;", "      else {", "        /* reset tpos, could have been invalidated in the loop above */"], "readability/braces"]
["src/nvim/edit.c", ["  }", "  did_ai = FALSE;", "  did_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  did_ai = FALSE;", "  did_si = FALSE;", "  can_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  did_si = FALSE;", "  can_si = FALSE;", "  can_si_back = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  can_si = FALSE;", "  can_si_back = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["      *s++ = KE_FILLER;", "    } else", "      *s++ = c;"], "readability/braces"]
["src/nvim/edit.c", ["    coladvance(curwin->w_curswant);", "  else {", "    curwin->w_cursor.col = 0;"], "readability/braces"]
["src/nvim/edit.c", ["    }", "    curwin->w_set_curswant = TRUE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["                                   (*mb_ptr2char)(ptr)", "                                   ))", "                              ? ptr2cells(ptr) : 1));"], "whitespace/parens"]
["src/nvim/edit.c", ["                              ? ptr2cells(ptr) : 1));", "    curwin->w_set_curswant = TRUE;", "    /* Return OK if the cursor moved, FAIL otherwise (at window edge). */"], "readability/bool"]
["src/nvim/edit.c", ["", "  curwin->w_set_curswant = TRUE;", "  return OK;"], "readability/bool"]
["src/nvim/edit.c", ["           && !has_mbyte", "           ) || getviscol() < v)", "        break;"], "whitespace/parens"]
["src/nvim/edit.c", ["              (*mb_ptr2char)(ptr)", "              ) && ptr2cells(ptr) > 1)", "        curwin->w_cursor.coladd = 0;"], "whitespace/parens"]
["src/nvim/edit.c", ["", "    curwin->w_set_curswant = TRUE;", "    return OK;"], "readability/bool"]
["src/nvim/edit.c", ["", "  curwin->w_set_curswant = TRUE;", "  --curwin->w_cursor.col;"], "readability/bool"]
["src/nvim/edit.c", ["int", "cursor_up (", "    long n,"], "whitespace/parens"]
["src/nvim/edit.c", ["        lnum = 1;", "    } else", "      lnum -= n;"], "readability/braces"]
["src/nvim/edit.c", ["int", "cursor_down (", "    long n,"], "whitespace/parens"]
["src/nvim/edit.c", ["        lnum = curbuf->b_ml.ml_line_count;", "    } else", "      lnum += n;"], "readability/braces"]
["src/nvim/edit.c", ["int", "stuff_inserted (", "    int c,                  /* Command character to be inserted */"], "whitespace/parens"]
["src/nvim/edit.c", ["  if (p_paste || no_abbr || arrow_used)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["static void", "replace_join (", "    int off                /* offset for which NUL to remove */"], "whitespace/parens"]
["src/nvim/edit.c", ["    ins_bytes_len(buf, n);", "  } else", "    ins_char(cc);"], "readability/braces"]
["src/nvim/edit.c", ["          ins_bytes_len(buf, n);", "        else {", "          /* Not a composing char, put it back. */"], "readability/braces"]
["src/nvim/edit.c", ["      while (vcol > orig_vcols && gchar_cursor() == ' ') {", "        del_char(FALSE);", "        ++orig_vcols;"], "readability/bool"]
["src/nvim/edit.c", ["    changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);", "  } else if (cc == 0)", "    (void)del_char_after_col(limit_col);"], "readability/braces"]
["src/nvim/edit.c", ["                      || *curbuf->b_p_inde != NUL", "                      );", "}"], "whitespace/parens"]
["src/nvim/edit.c", ["{", "  change_indent(INDENT_SET, get_the_indent(), FALSE, 0, TRUE);", "  if (linewhite(curwin->w_cursor.lnum))"], "readability/bool"]
["src/nvim/edit.c", ["  if (linewhite(curwin->w_cursor.lnum))", "    did_ai = TRUE;          /* delete the indent if the line stays empty */", "}"], "readability/bool"]
["src/nvim/edit.c", ["    /* Can happen with CTRL-Y and CTRL-E on a short line. */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["      if (!line_is_empty)", "        try_match = FALSE;", "      ++look;"], "readability/bool"]
["src/nvim/edit.c", ["      ++look;", "    } else", "      try_match_word = FALSE;"], "readability/braces"]
["src/nvim/edit.c", ["    } else", "      try_match_word = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["      if (try_match && keytyped == Ctrl_chr(look[1]))", "        return TRUE;", "      look += 2;"], "readability/bool"]
["src/nvim/edit.c", ["     */", "    else if (*look == 'o') {", "      if (try_match && keytyped == KEY_OPEN_FORW)"], "whitespace/newline"]
["src/nvim/edit.c", ["      if (try_match && keytyped == KEY_OPEN_FORW)", "        return TRUE;", "      ++look;"], "readability/bool"]
["src/nvim/edit.c", ["      if (try_match && keytyped == KEY_OPEN_BACK)", "        return TRUE;", "      ++look;"], "readability/bool"]
["src/nvim/edit.c", ["     */", "    else if (*look == 'e') {", "      if (try_match && keytyped == 'e' && curwin->w_cursor.col >= 4) {"], "whitespace/newline"]
["src/nvim/edit.c", ["            STRNCMP(p + curwin->w_cursor.col - 4, \"else\", 4) == 0)", "          return TRUE;", "      }"], "readability/bool"]
["src/nvim/edit.c", ["     */", "    else if (*look == ':') {", "      if (try_match && keytyped == ':') {"], "whitespace/newline"]
["src/nvim/edit.c", ["        p = get_cursor_line_ptr();", "        if (cin_iscase(p, FALSE) || cin_isscopedecl(p) || cin_islabel())", "          return TRUE;"], "readability/bool"]
["src/nvim/edit.c", ["        if (cin_iscase(p, FALSE) || cin_isscopedecl(p) || cin_islabel())", "          return TRUE;", "        /* Need to get the line again after cin_islabel(). */"], "readability/bool"]
["src/nvim/edit.c", ["          p[curwin->w_cursor.col - 1] = ' ';", "          i = (cin_iscase(p, FALSE) || cin_isscopedecl(p)", "               || cin_islabel());"], "readability/bool"]
["src/nvim/edit.c", ["          if (i)", "            return TRUE;", "        }"], "readability/bool"]
["src/nvim/edit.c", ["     */", "    else if (*look == '<') {", "      if (try_match) {"], "whitespace/newline"]
["src/nvim/edit.c", ["            && keytyped == look[1])", "          return TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["        if (keytyped == get_special_key_code(look + 1))", "          return TRUE;", "      }"], "readability/bool"]
["src/nvim/edit.c", ["     */", "    else if (*look == '=' && look[1] != ',' && look[1] != NUL) {", "      ++look;"], "whitespace/newline"]
["src/nvim/edit.c", ["      if (*look == '~') {", "        icase = TRUE;", "        ++look;"], "readability/bool"]
["src/nvim/edit.c", ["        ++look;", "      } else", "        icase = FALSE;"], "readability/braces"]
["src/nvim/edit.c", ["      } else", "        icase = FALSE;", "      p = vim_strchr(look, ',');"], "readability/bool"]
["src/nvim/edit.c", ["          && curwin->w_cursor.col >= (colnr_T)(p - look)) {", "        int match = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["            }", "          } else", "            for (s = line + curwin->w_cursor.col; s > line; --s)"], "readability/braces"]
["src/nvim/edit.c", ["                  : STRNCMP(s, look, p - look)) == 0)", "            match = TRUE;", "        } else"], "readability/bool"]
["src/nvim/edit.c", ["            match = TRUE;", "        } else", "        /* TODO: multi-byte */"], "readability/braces"]
["src/nvim/edit.c", ["              == 0)", "            match = TRUE;", "        }"], "readability/bool"]
["src/nvim/edit.c", ["              (int)(curwin->w_cursor.col - (p - look)))", "            match = FALSE;", "        }"], "readability/bool"]
["src/nvim/edit.c", ["        if (match)", "          return TRUE;", "      }"], "readability/bool"]
["src/nvim/edit.c", ["     */", "    else {", "      if (try_match && *look == keytyped)"], "whitespace/newline"]
["src/nvim/edit.c", ["     */", "    else {", "      if (try_match && *look == keytyped)"], "readability/braces"]
["src/nvim/edit.c", ["      if (try_match && *look == keytyped)", "        return TRUE;", "      ++look;"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/edit.c", ["  if (p_hkmapp) {   /* phonetic mapping, by Ilya Dogolazky */", "    enum {hALEF=0, BET, GIMEL, DALET, HEI, VAV, ZAIN, HET, TET, IUD,", "          KAFsofit, hKAF, LAMED, MEMsofit, MEM, NUNsofit, NUN, SAMEH, AIN,"], "whitespace/operators"]
["src/nvim/edit.c", ["    else if (c == 228)", "      return ' ';        /* \\\"a --> ' '      -- / --\t       */", "    else if (c == 252)"], "whitespace/tab"]
["src/nvim/edit.c", ["    else if (c == 252)", "      return ' ';        /* \\\"u --> ' '      -- / --\t       */", "    /* NOTE: islower() does not do the right thing for us on Linux so we"], "whitespace/tab"]
["src/nvim/edit.c", ["{", "  int need_redraw = FALSE;", "  int regname;"], "readability/bool"]
["src/nvim/edit.c", ["    /* may need to redraw when no more chars available now */", "    ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "    edit_putchar('\"', TRUE);", "    add_to_showcmd_c(Ctrl_R);"], "readability/bool"]
["src/nvim/edit.c", ["  regname = plain_vgetc();", "  LANGMAP_ADJUST(regname, TRUE);", "  if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P) {"], "readability/bool"]
["src/nvim/edit.c", ["    regname = plain_vgetc();", "    LANGMAP_ADJUST(regname, TRUE);", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  if (u_sync_once == 1)", "    ins_need_undo = TRUE;", "  u_sync_once = 0;"], "readability/bool"]
["src/nvim/edit.c", ["  case Ctrl_K:", "  case 'k': ins_up(TRUE);", "    break;"], "readability/bool"]
["src/nvim/edit.c", ["  case Ctrl_J:", "  case 'j': ins_down(TRUE);", "    break;"], "readability/bool"]
["src/nvim/edit.c", ["  /* CTRL-G u: start new undoable edit */", "  case 'u': u_sync(TRUE);", "    ins_need_undo = TRUE;"], "readability/bool"]
["src/nvim/edit.c", ["  case 'u': u_sync(TRUE);", "    ins_need_undo = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["{", "  if (map_to_exists_mode((char_u *)\"\", LANGMAP, FALSE)) {", "    /* \":lmap\" mappings exists, Toggle use of \":lmap\" mappings. */"], "readability/bool"]
["src/nvim/edit.c", ["static int", "ins_esc (", "    long *count,"], "whitespace/parens"]
["src/nvim/edit.c", ["  int temp;", "  static int disabled_redraw = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["    --RedrawingDisabled;", "    disabled_redraw = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["      ++RedrawingDisabled;", "      disabled_redraw = TRUE;", "      return FALSE;             /* repeat the insert */"], "readability/bool"]
["src/nvim/edit.c", ["      disabled_redraw = TRUE;", "      return FALSE;             /* repeat the insert */", "    }"], "readability/bool"]
["src/nvim/edit.c", ["    }", "    stop_insert(&curwin->w_cursor, TRUE, nomove);", "    undisplay_dollar();"], "readability/bool"]
["src/nvim/edit.c", ["  if (restart_edit == NUL && (colnr_T)temp == curwin->w_cursor.col)", "    curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["              && !VIsual_active", "              ))", "      && !revins_on"], "whitespace/parens"]
["src/nvim/edit.c", ["", "  return TRUE;              /* exit Insert mode */", "}"], "readability/bool"]
["src/nvim/edit.c", ["    undisplay_dollar();", "  } else", "    revins_scol = -1;"], "readability/braces"]
["src/nvim/edit.c", ["     */", "    arrow_used = TRUE;", "    (void)stop_arrow();"], "readability/bool"]
["src/nvim/edit.c", ["      State = INSERT;", "  } else", "    p_hkmap = curwin->w_p_rl ^ p_ri;        /* be consistent! */"], "readability/braces"]
["src/nvim/edit.c", ["  if (!km_startsel) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["    stuffcharReadbuff(c);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/edit.c", ["                 \"r\"), 1);", "  apply_autocmds(EVENT_INSERTCHANGE, NULL, NULL, FALSE, curbuf);", "  if (State & REPLACE_FLAG)"], "readability/bool"]
["src/nvim/edit.c", ["  if (virtual_active())", "    ins_at_eol = FALSE;         /* cursor always keeps its column */", "  else"], "readability/bool"]
["src/nvim/edit.c", ["    --curwin->w_cursor.col;", "    (void)del_char(FALSE);              /* delete the '^' or '0' */", "    /* In Replace mode, restore the characters that '^' or '0' replaced. */"], "readability/bool"]
["src/nvim/edit.c", ["      old_indent = get_indent();        /* remember curr. indent */", "    change_indent(INDENT_SET, 0, TRUE, 0, TRUE);", "  } else"], "readability/bool"]
["src/nvim/edit.c", ["    change_indent(INDENT_SET, 0, TRUE, 0, TRUE);", "  } else", "    change_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);"], "readability/braces"]
["src/nvim/edit.c", ["  } else", "    change_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);", ""], "readability/bool"]
["src/nvim/edit.c", ["  if (did_ai && *skipwhite(get_cursor_line_ptr()) != NUL)", "    did_ai = FALSE;", "  did_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["    did_ai = FALSE;", "  did_si = FALSE;", "  can_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  did_si = FALSE;", "  can_si = FALSE;", "  can_si_back = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  can_si = FALSE;", "  can_si_back = FALSE;", "  can_cindent = FALSE;          /* no cindenting after ^D or ^T */"], "readability/bool"]
["src/nvim/edit.c", ["  can_si_back = FALSE;", "  can_cindent = FALSE;          /* no cindenting after ^D or ^T */", "}"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  did_ai = FALSE;", "  did_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  did_ai = FALSE;", "  did_si = FALSE;", "  can_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  did_si = FALSE;", "  can_si = FALSE;", "  can_si_back = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  can_si = FALSE;", "  can_si_back = FALSE;", "  AppendCharToRedobuff(K_DEL);"], "readability/bool"]
["src/nvim/edit.c", ["      replace_do_bs(-1);", "  } else", "    (void)del_char(FALSE);"], "readability/braces"]
["src/nvim/edit.c", ["  } else", "    (void)del_char(FALSE);", "}"], "readability/bool"]
["src/nvim/edit.c", ["  colnr_T mincol;", "  int did_backspace = FALSE;", "  int in_indent;"], "readability/bool"]
["src/nvim/edit.c", ["  if (stop_arrow() == FAIL)", "    return FALSE;", "  in_indent = inindent(0);"], "readability/bool"]
["src/nvim/edit.c", ["  if (in_indent)", "    can_cindent = FALSE;", "  end_comment_pending = NUL;    /* After BS, don't auto-end comment */"], "readability/bool"]
["src/nvim/edit.c", ["      --curwin->w_cursor.coladd;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["      curwin->w_cursor.coladd = 0;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/edit.c", ["              (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL) {", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/edit.c", ["          char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,", "              TRUE);", "          int len;"], "readability/bool"]
["src/nvim/edit.c", ["", "        do_join(2, FALSE, FALSE, FALSE, false);", "        if (temp == NUL && gchar_cursor() != NUL)"], "readability/bool"]
["src/nvim/edit.c", ["          inc_cursor();", "      } else", "        dec_cursor();"], "readability/braces"]
["src/nvim/edit.c", ["    }", "    did_ai = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/edit.c", ["", "      *inserted_space_p = FALSE;", "      if (p_sta && in_indent)"], "readability/bool"]
["src/nvim/edit.c", ["          ins_char(' ');", "        else {", "          ins_str((char_u *)\" \");"], "readability/braces"]
["src/nvim/edit.c", ["     */", "    else do {", "        if (!revins_on)     /* put cursor on char to be deleted */"], "whitespace/newline"]
["src/nvim/edit.c", ["     */", "    else do {", "        if (!revins_on)     /* put cursor on char to be deleted */"], "whitespace/newline"]
["src/nvim/edit.c", ["        /* end of word? */", "        else if (mode == BACKSPACE_WORD_NOT_SPACE", "                 && (ascii_isspace(cc = gchar_cursor())"], "whitespace/newline"]
["src/nvim/edit.c", ["          replace_do_bs(-1);", "        else {", "          const bool l_enc_utf8 = enc_utf8;"], "readability/braces"]
["src/nvim/edit.c", ["            (void)utfc_ptr2char(get_cursor_pos_ptr(), cpc);", "          (void)del_char(FALSE);", "          /*"], "readability/bool"]
["src/nvim/edit.c", ["             || curwin->w_cursor.col != Insstart_orig.col)));", "    did_backspace = TRUE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  }", "  did_si = FALSE;", "  can_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  did_si = FALSE;", "  can_si = FALSE;", "  can_si_back = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  can_si = FALSE;", "  can_si_back = FALSE;", "  if (curwin->w_cursor.col <= 1)"], "readability/bool"]
["src/nvim/edit.c", ["  if (curwin->w_cursor.col <= 1)", "    did_ai = FALSE;", "  /*"], "readability/bool"]
["src/nvim/edit.c", ["    }", "    can_cindent = TRUE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["  win_T       *old_curwin = curwin;", "  int did_scroll = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["    }", "    did_scroll = TRUE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "  curwin->w_redr_status = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["    start_arrow(&tpos);", "    can_cindent = TRUE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["      oneright();", "    else {", "      if (has_mbyte)"], "readability/braces"]
["src/nvim/edit.c", ["   * cursor to the next line */", "  else if (vim_strchr(p_ww, ']') != NULL", "           && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {"], "whitespace/newline"]
["src/nvim/edit.c", ["    start_arrow(&curwin->w_cursor);", "    curwin->w_set_curswant = TRUE;", "    ++curwin->w_cursor.lnum;"], "readability/bool"]
["src/nvim/edit.c", ["static void", "ins_up (", "    int startcol                   /* when TRUE move to Insstart.col */"], "whitespace/parens"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (cursor_up(1L, TRUE) == OK) {", "    if (startcol)"], "readability/bool"]
["src/nvim/edit.c", ["static void", "ins_down (", "    int startcol                   /* when TRUE move to Insstart.col */"], "whitespace/parens"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (cursor_down(1L, TRUE) == OK) {", "    if (startcol)"], "readability/bool"]
["src/nvim/edit.c", ["  if (echeck_abbr(TAB + ABBR_OFF))", "    return FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["  if (ind)", "    can_cindent = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["      && get_sts_value() == 0)", "    return TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["  if (stop_arrow() == FAIL)", "    return TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "  did_ai = FALSE;", "  did_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  did_ai = FALSE;", "  did_si = FALSE;", "  can_si = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  did_si = FALSE;", "  can_si = FALSE;", "  can_si_back = FALSE;"], "readability/bool"]
["src/nvim/edit.c", ["  can_si = FALSE;", "  can_si_back = FALSE;", "  AppendToRedobuff((char_u *)\"\\t\");"], "readability/bool"]
["src/nvim/edit.c", ["      ins_char(' ');", "    else {", "      ins_str((char_u *)\" \");"], "readability/braces"]
["src/nvim/edit.c", ["    if (vim_strchr(p_cpo, CPO_LISTWM) == NULL)", "      curwin->w_p_list = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/edit.c", ["  if (echeck_abbr(c + ABBR_OFF))", "    return FALSE;", "  if (stop_arrow() == FAIL)"], "readability/bool"]
["src/nvim/edit.c", ["  if (stop_arrow() == FAIL)", "    return TRUE;", "  undisplay_dollar();"], "readability/bool"]
["src/nvim/edit.c", ["  old_indent = 0;", "  can_cindent = TRUE;", "  /* When inserting a line the cursor line must never be in a closed fold. */"], "readability/bool"]
["src/nvim/edit.c", ["  int cc;", "  int did_putchar = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["    /* may need to redraw when no more chars available now */", "    ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "    edit_putchar('?', TRUE);", "    did_putchar = TRUE;"], "readability/bool"]
["src/nvim/edit.c", ["    edit_putchar('?', TRUE);", "    did_putchar = TRUE;", "    add_to_showcmd_c(Ctrl_K);"], "readability/bool"]
["src/nvim/edit.c", ["    clear_showcmd();", "    insert_special(c, TRUE, FALSE);", "    return NUL;"], "readability/bool"]
["src/nvim/edit.c", ["  if (c != ESC) {", "    did_putchar = FALSE;", "    if (redrawing() && !char_avail()) {"], "readability/bool"]
["src/nvim/edit.c", ["      /* may need to redraw when no more chars available now */", "      ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["      if (char2cells(c) == 1) {", "        ins_redraw(FALSE);", "        edit_putchar(c, TRUE);"], "readability/bool"]
["src/nvim/edit.c", ["        ins_redraw(FALSE);", "        edit_putchar(c, TRUE);", "        did_putchar = TRUE;"], "readability/bool"]
["src/nvim/edit.c", ["        edit_putchar(c, TRUE);", "        did_putchar = TRUE;", "      }"], "readability/bool"]
["src/nvim/edit.c", ["      AppendToRedobuff((char_u *)CTRL_V_STR);", "      c = getdigraph(c, cc, TRUE);", "      clear_showcmd();"], "readability/bool"]
["src/nvim/edit.c", ["      curbuf->b_p_tw = -1;", "      insert_special(c, TRUE, FALSE);", "      curbuf->b_p_tw = tw_save;"], "readability/bool"]
["src/nvim/edit.c", ["      c = Ctrl_V;       /* pretend CTRL-V is last character */", "      auto_format(FALSE, TRUE);", "    }"], "readability/bool"]
["src/nvim/edit.c", ["        while (--i > 0 && ascii_iswhite(ptr[i]))", "          ;", "      curwin->w_cursor.lnum = pos->lnum;"], "whitespace/semicolon"]
["src/nvim/edit.c", ["      if (State & VREPLACE_FLAG)", "        change_indent(INDENT_SET, i, FALSE, NUL, TRUE);", "      else"], "readability/bool"]
["src/nvim/edit.c", ["       */", "      temp = TRUE;", "      if (c == '{' && can_si_back && curwin->w_cursor.lnum > 1) {"], "readability/bool"]
["src/nvim/edit.c", ["        if (get_indent() >= i)", "          temp = FALSE;", "        curwin->w_cursor = old_pos;"], "readability/bool"]
["src/nvim/edit.c", ["      if (temp)", "        shift_line(TRUE, FALSE, 1, TRUE);", "    }"], "readability/bool"]
["src/nvim/edit.c", ["    buf[(*mb_char2bytes)(c, buf)] = NUL;", "  else {", "    buf[0] = c;"], "readability/braces"]
["src/nvim/edit.c", ["  char_u *res = NULL;", "  if (apply_autocmds(EVENT_INSERTCHARPRE, NULL, NULL, FALSE, curbuf)) {", "    /* Get the value of v:char.  It may be empty or more than one"], "readability/bool"]
["src/nvim/eval.c", ["", "#define DO_NOT_FREE_CNT 99999   /* refcount for dict or list that should not", "                                   be freed. */"], "readability/multiline_comment"]
["src/nvim/eval.c", ["", "#define AUTOLOAD_CHAR '#'       /* Character used as separator in autoload ", "                                   function/variable names. */"], "readability/multiline_comment"]
["src/nvim/eval.c", ["", "#define AUTOLOAD_CHAR '#'       /* Character used as separator in autoload ", "                                   function/variable names. */"], "whitespace/end_of_line"]
["src/nvim/eval.c", ["  char_u      *ll_exp_name;     /* NULL or expanded name in allocated memory. */", "  typval_T    *ll_tv;           /* Typeval of item being used.  If \"newkey\"", "                                   isn't NULL it's the Dict to which to add"], "readability/multiline_comment"]
["src/nvim/eval.c", ["#define FNE_INCL_BR     1       /* find_name_end(): include [] in name */", "#define FNE_CHECK_START 2       /* find_name_end(): check name starts with", "                                   valid character */"], "readability/multiline_comment"]
["src/nvim/eval.c", ["static uint64_t current_job_id = 1;", "static PMap(uint64_t) *jobs = NULL; ", ""], "whitespace/end_of_line"]
["src/nvim/eval.c", ["  tvp->vval.v_string = val;", "  set_var(name, tvp, FALSE);", "  free_tv(tvp);"], "readability/bool"]
["src/nvim/eval.c", [" */", "int ", "var_redir_start ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["int ", "var_redir_start (", "    char_u *name,"], "whitespace/parens"]
["src/nvim/eval.c", ["  /* Parse the variable name (can be a dict or list entry). */", "  redir_endp = get_lval(redir_varname, NULL, redir_lval, FALSE, FALSE, 0,", "      FNE_CHECK_START);"], "readability/bool"]
["src/nvim/eval.c", ["  save_emsg = did_emsg;", "  did_emsg = FALSE;", "  tv.v_type = VAR_STRING;"], "readability/bool"]
["src/nvim/eval.c", ["  if (append)", "    set_var_lval(redir_lval, redir_endp, &tv, TRUE, (char_u *)\".\");", "  else"], "readability/bool"]
["src/nvim/eval.c", ["  else", "    set_var_lval(redir_lval, redir_endp, &tv, TRUE, (char_u *)\"=\");", "  clear_lval(redir_lval);"], "readability/bool"]
["src/nvim/eval.c", ["      redir_endp = get_lval(redir_varname, NULL, redir_lval,", "          FALSE, FALSE, 0, FNE_CHECK_START);", "      if (redir_endp != NULL && redir_lval->ll_name != NULL)"], "readability/bool"]
["src/nvim/eval.c", ["      if (redir_endp != NULL && redir_lval->ll_name != NULL)", "        set_var_lval(redir_lval, redir_endp, &tv, FALSE, (char_u *)\".\");", "      clear_lval(redir_lval);"], "readability/bool"]
["src/nvim/eval.c", ["", "int eval_charconvert(char_u *enc_from, char_u *enc_to, char_u *fname_from, char_u *fname_to)", "{"], "whitespace/line_length"]
["src/nvim/eval.c", ["{", "  int err = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  set_vim_var_string(VV_FNAME_OUT, fname_to, -1);", "  if (eval_to_bool(p_ccv, &err, NULL, FALSE))", "    err = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["  if (eval_to_bool(p_ccv, &err, NULL, FALSE))", "    err = TRUE;", "  set_vim_var_string(VV_CC_FROM, NULL, -1);"], "readability/bool"]
["src/nvim/eval.c", ["{", "  int err = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  set_vim_var_string(VV_CMDARG, args, -1);", "  if (eval_to_bool(p_pexpr, &err, NULL, FALSE))", "    err = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["  if (eval_to_bool(p_pexpr, &err, NULL, FALSE))", "    err = TRUE;", "  set_vim_var_string(VV_FNAME_IN, NULL, -1);"], "readability/bool"]
["src/nvim/eval.c", ["{", "  int err = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  set_vim_var_string(VV_FNAME_OUT, outfile, -1);", "  (void)eval_to_bool(p_dex, &err, NULL, FALSE);", "  set_vim_var_string(VV_FNAME_IN, NULL, -1);"], "readability/bool"]
["src/nvim/eval.c", ["  set_vim_var_string(VV_FNAME_OUT, outfile, -1);", "  (void)eval_to_bool(p_pex, &err, NULL, FALSE);", "  set_vim_var_string(VV_FNAME_IN, NULL, -1);"], "readability/bool"]
["src/nvim/eval.c", [" */", "int ", "eval_to_bool ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["int ", "eval_to_bool (", "    char_u *arg,"], "whitespace/parens"]
["src/nvim/eval.c", ["  typval_T tv;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  if (eval0(arg, &tv, nextcmd, !skip) == FAIL)", "    *error = TRUE;", "  else {"], "readability/bool"]
["src/nvim/eval.c", ["    *error = TRUE;", "  else {", "    *error = FALSE;"], "readability/braces"]
["src/nvim/eval.c", ["  else {", "    *error = FALSE;", "    if (!skip) {"], "readability/bool"]
["src/nvim/eval.c", ["char_u *", "eval_to_string_skip (", "    char_u *arg,"], "whitespace/parens"]
["src/nvim/eval.c", ["    retval = NULL;", "  else {", "    retval = vim_strsave(get_tv_string(&tv));"], "readability/braces"]
["src/nvim/eval.c", ["  *pp = skipwhite(*pp);", "  return eval1(pp, &rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "  if (eval0(arg, &tv, nextcmd, TRUE) == FAIL)", "    retval = NULL;"], "readability/bool"]
["src/nvim/eval.c", ["    retval = NULL;", "  else {", "    if (convert && tv.v_type == VAR_LIST) {"], "readability/braces"]
["src/nvim/eval.c", ["      retval = vim_strsave(numbuf);", "    } else", "      retval = vim_strsave(get_tv_string(&tv));"], "readability/braces"]
["src/nvim/eval.c", ["  ++textlock;", "  retval = eval_to_string(arg, nextcmd, FALSE);", "  if (use_sandbox)"], "readability/bool"]
["src/nvim/eval.c", ["", "  if (eval1(&p, &rettv, TRUE) == FAIL)", "    retval = -1;"], "readability/bool"]
["src/nvim/eval.c", ["    retval = -1;", "  else {", "    retval = get_tv_number_chk(&rettv, NULL);"], "readability/braces"]
["src/nvim/eval.c", ["", "  if (eval1(&p, &rettv, TRUE) == OK) {", "    if (rettv.v_type != VAR_LIST)"], "readability/bool"]
["src/nvim/eval.c", ["", "  if (eval0(arg, tv, nextcmd, TRUE) == FAIL) {", "    xfree(tv);"], "readability/bool"]
["src/nvim/eval.c", [" */", "int ", "call_vim_function ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["int ", "call_vim_function (", "    char_u *func,"], "whitespace/parens"]
["src/nvim/eval.c", ["      /* Recognize a number argument, the others must be strings. */", "      vim_str2nr(argv[i], NULL, &len, TRUE, TRUE, &n, NULL);", "    if (len != 0 && len == (int)STRLEN(argv[i])) {"], "readability/bool"]
["src/nvim/eval.c", ["      curwin->w_cursor.lnum, curwin->w_cursor.lnum,", "      &doesrange, TRUE, NULL);", "  if (safe) {"], "readability/bool"]
["src/nvim/eval.c", [" */", "long ", "call_func_retnr ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["long ", "call_func_retnr (", "    char_u *func,"], "whitespace/parens"]
["src/nvim/eval.c", ["  /* All arguments are passed as strings, no conversion to number. */", "  if (call_vim_function(func, argc, argv, safe, TRUE, &rettv) == FAIL)", "    return -1;"], "readability/bool"]
["src/nvim/eval.c", ["void *", "call_func_retstr (", "    char_u *func,"], "whitespace/parens"]
["src/nvim/eval.c", ["  /* All arguments are passed as strings, no conversion to number. */", "  if (call_vim_function(func, argc, argv, safe, TRUE, &rettv) == FAIL)", "    return NULL;"], "readability/bool"]
["src/nvim/eval.c", ["void *", "call_func_retlist (", "    char_u *func,"], "whitespace/parens"]
["src/nvim/eval.c", ["  /* All arguments are passed as strings, no conversion to number. */", "  if (call_vim_function(func, argc, argv, safe, TRUE, &rettv) == FAIL)", "    return NULL;"], "readability/bool"]
["src/nvim/eval.c", ["  *cp = NUL;", "  if (eval0(arg, &tv, NULL, TRUE) == FAIL)", "    retval = 0;"], "readability/bool"]
["src/nvim/eval.c", ["    retval = 0;", "  else {", "    /* If the result is a number, just return the number. */"], "readability/braces"]
["src/nvim/eval.c", ["      retval = 0;", "    else {", "      /* If the result is a string, check if there is a non-digit before"], "readability/braces"]
["src/nvim/eval.c", ["  char_u      *argend;", "  int first = TRUE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    } else if (i != FAIL) {", "      (void)ex_let_vars(eap->arg, &rettv, FALSE, semicolon, var_count,", "          op);"], "readability/bool"]
["src/nvim/eval.c", [" */", "static int ", "ex_let_vars ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "ex_let_vars (", "    char_u *arg_start,"], "whitespace/parens"]
["src/nvim/eval.c", ["    arg = skipwhite(arg + 1);", "    arg = ex_let_one(arg, &item->li_tv, TRUE, (char_u *)\",;]\", nextchars);", "    item = item->li_next;"], "readability/bool"]
["src/nvim/eval.c", ["", "      arg = ex_let_one(skipwhite(arg + 1), &ltv, FALSE,", "          (char_u *)\"]\", nextchars);"], "readability/bool"]
["src/nvim/eval.c", ["    return p + 1;", "  } else", "    return skip_var_one(arg);"], "readability/braces"]
["src/nvim/eval.c", [" */", "static void list_hashtable_vars(hashtab_T *ht, char_u *prefix, int empty, int *first)", "{"], "whitespace/line_length"]
["src/nvim/eval.c", ["{", "  list_hashtable_vars(&globvarht, (char_u *)\"\", TRUE, first);", "}"], "readability/bool"]
["src/nvim/eval.c", ["  list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)\"b:\",", "      TRUE, first);", ""], "readability/bool"]
["src/nvim/eval.c", ["", "  sprintf((char *)numbuf, \"%\" PRId64, (int64_t)curbuf->b_changedtick);", "  list_one_var_a((char_u *)\"b:\", (char_u *)\"changedtick\", VAR_NUMBER,"], "runtime/printf"]
["src/nvim/eval.c", ["  list_hashtable_vars(&curwin->w_vars->dv_hashtab,", "      (char_u *)\"w:\", TRUE, first);", "}"], "readability/bool"]
["src/nvim/eval.c", ["  list_hashtable_vars(&curtab->tp_vars->dv_hashtab,", "      (char_u *)\"t:\", TRUE, first);", "}"], "readability/bool"]
["src/nvim/eval.c", ["{", "  list_hashtable_vars(&vimvarht, (char_u *)\"v:\", FALSE, first);", "}"], "readability/bool"]
["src/nvim/eval.c", ["    list_hashtable_vars(&SCRIPT_VARS(current_SID),", "        (char_u *)\"s:\", FALSE, first);", "}"], "readability/bool"]
["src/nvim/eval.c", ["    list_hashtable_vars(&current_funccal->l_vars.dv_hashtab,", "        (char_u *)\"l:\", FALSE, first);", "}"], "readability/bool"]
["src/nvim/eval.c", ["{", "  int error = FALSE;", "  int len;"], "readability/bool"]
["src/nvim/eval.c", ["      if (!ascii_iswhite(*arg) && !ends_excmd(*arg)) {", "        emsg_severe = TRUE;", "        EMSG(_(e_trailing));"], "readability/bool"]
["src/nvim/eval.c", ["      name_start = name = arg;", "      len = get_name_len(&arg, &tofree, TRUE, TRUE);", "      if (len <= 0) {"], "readability/bool"]
["src/nvim/eval.c", ["        if (len < 0 && !aborting()) {", "          emsg_severe = TRUE;", "          EMSG2(_(e_invarg2), arg);"], "readability/bool"]
["src/nvim/eval.c", ["        }", "        error = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/eval.c", ["          name = tofree;", "        if (get_var_tv(name, len, &tv, TRUE, FALSE) == FAIL)", "          error = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["        if (get_var_tv(name, len, &tv, TRUE, FALSE) == FAIL)", "          error = TRUE;", "        else {"], "readability/bool"]
["src/nvim/eval.c", ["          error = TRUE;", "        else {", "          /* handle d.key, l[idx], f(expr) */"], "readability/braces"]
["src/nvim/eval.c", ["          arg_subsc = arg;", "          if (handle_subscript(&arg, &tv, TRUE, TRUE) == FAIL)", "            error = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["          if (handle_subscript(&arg, &tv, TRUE, TRUE) == FAIL)", "            error = TRUE;", "          else {"], "readability/bool"]
["src/nvim/eval.c", ["            error = TRUE;", "          else {", "            if (arg == arg_subsc && len == 2 && name[1] == ':') {"], "readability/braces"]
["src/nvim/eval.c", ["static char_u *", "ex_let_one (", "    char_u *arg,               /* points to variable name */"], "whitespace/parens"]
["src/nvim/eval.c", ["      EMSG2(_(e_invarg2), name - 1);", "    else {", "      if (op != NULL && (*op == '+' || *op == '-'))"], "readability/braces"]
["src/nvim/eval.c", ["          else if (didset_vim && STRICMP(name, \"VIM\") == 0)", "            didset_vim = FALSE;", "          else if (didset_vimruntime"], "readability/bool"]
["src/nvim/eval.c", ["                   && STRICMP(name, \"VIMRUNTIME\") == 0)", "            didset_vimruntime = FALSE;", "          arg_end = arg;"], "readability/bool"]
["src/nvim/eval.c", ["   */", "  else if (*arg == '&') {", "    /* Find the end of the name. */"], "whitespace/newline"]
["src/nvim/eval.c", ["      EMSG(_(e_letunexp));", "    else {", "      long n;"], "readability/braces"]
["src/nvim/eval.c", ["          EMSG2(_(e_letwrong), op);", "        else {", "          if (opt_type == 1) {          /* number */"], "readability/braces"]
["src/nvim/eval.c", ["   */", "  else if (*arg == '@') {", "    ++arg;"], "whitespace/newline"]
["src/nvim/eval.c", ["      EMSG(_(e_letunexp));", "    else {", "      char_u      *ptofree = NULL;"], "readability/braces"]
["src/nvim/eval.c", ["      if (p != NULL) {", "        write_reg_contents(*arg == '@' ? '\"' : *arg, p, -1, FALSE);", "        arg_end = arg + 1;"], "readability/bool"]
["src/nvim/eval.c", ["   */", "  else if (eval_isnamec1(*arg) || *arg == '{') {", "    lval_T lv;"], "whitespace/newline"]
["src/nvim/eval.c", ["", "    p = get_lval(arg, tv, &lv, FALSE, FALSE, 0, FNE_CHECK_START);", "    if (p != NULL && lv.ll_name != NULL) {"], "readability/bool"]
["src/nvim/eval.c", ["        EMSG(_(e_letunexp));", "      else {", "        set_var_lval(&lv, p, tv, copy, op);"], "readability/braces"]
["src/nvim/eval.c", ["    clear_lval(&lv);", "  } else", "    EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/eval.c", ["    EMSG2(_(e_readonlyvar), arg);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["static char_u *", "get_lval (", "    char_u *name,"], "whitespace/parens"]
["src/nvim/eval.c", ["  typval_T var2;", "  int empty1 = FALSE;", "  listitem_T  *ni;"], "readability/bool"]
["src/nvim/eval.c", ["      if (!aborting() && !quiet) {", "        emsg_severe = TRUE;", "        EMSG2(_(e_invarg2), name);"], "readability/bool"]
["src/nvim/eval.c", ["    lp->ll_name = lp->ll_exp_name;", "  } else", "    lp->ll_name = name;"], "readability/braces"]
["src/nvim/eval.c", ["      for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)", "        ;", "      if (len == 0) {"], "whitespace/semicolon"]
["src/nvim/eval.c", ["      if (*p == ':')", "        empty1 = TRUE;", "      else {"], "readability/bool"]
["src/nvim/eval.c", ["        empty1 = TRUE;", "      else {", "        empty1 = FALSE;"], "readability/braces"]
["src/nvim/eval.c", ["      else {", "        empty1 = FALSE;", "        if (eval1(&p, &var1, TRUE) == FAIL)             /* recursive! */"], "readability/bool"]
["src/nvim/eval.c", ["        empty1 = FALSE;", "        if (eval1(&p, &var1, TRUE) == FAIL)             /* recursive! */", "          return NULL;"], "readability/bool"]
["src/nvim/eval.c", ["        if (*p == ']')", "          lp->ll_empty2 = TRUE;", "        else {"], "readability/bool"]
["src/nvim/eval.c", ["          lp->ll_empty2 = TRUE;", "        else {", "          lp->ll_empty2 = FALSE;"], "readability/braces"]
["src/nvim/eval.c", ["        else {", "          lp->ll_empty2 = FALSE;", "          if (eval1(&p, &var2, TRUE) == FAIL) {         /* recursive! */"], "readability/bool"]
["src/nvim/eval.c", ["          lp->ll_empty2 = FALSE;", "          if (eval1(&p, &var2, TRUE) == FAIL) {         /* recursive! */", "            if (!empty1)"], "readability/bool"]
["src/nvim/eval.c", ["        }", "        lp->ll_range = TRUE;", "      } else"], "readability/bool"]
["src/nvim/eval.c", ["        lp->ll_range = TRUE;", "      } else", "        lp->ll_range = FALSE;"], "readability/braces"]
["src/nvim/eval.c", ["      } else", "        lp->ll_range = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["          key[len] = NUL;", "        } else", "          prevval = 0;           /* avoid compiler warning */"], "readability/braces"]
["src/nvim/eval.c", ["      /* existing variable, need to check if it can be changed */", "      else if (var_check_ro(lp->ll_di->di_flags, name))", "        return NULL;"], "whitespace/newline"]
["src/nvim/eval.c", ["        lp->ll_n1 = 0;", "      else {", "        lp->ll_n1 = get_tv_number(&var1);           /* is number or string */"], "readability/braces"]
["src/nvim/eval.c", [" */", "static void set_var_lval(lval_T *lp, char_u *endp, typval_T *rettv, int copy, char_u *op)", "{"], "whitespace/line_length"]
["src/nvim/eval.c", ["        if (get_var_tv(lp->ll_name, (int)STRLEN(lp->ll_name),", "                &tv, TRUE, FALSE) == OK) {", "          if (tv_op(&tv, rettv, op) == OK)"], "readability/bool"]
["src/nvim/eval.c", ["          if (tv_op(&tv, rettv, op) == OK)", "            set_var(lp->ll_name, &tv, FALSE);", "          clear_tv(&tv);"], "readability/bool"]
["src/nvim/eval.c", ["        }", "      } else", "        set_var(lp->ll_name, rettv, copy);"], "readability/braces"]
["src/nvim/eval.c", ["    }", "  } else if (tv_check_lock(lp->ll_newkey == NULL", "                 ? lp->ll_tv->v_lock"], "readability/braces"]
["src/nvim/eval.c", ["                 : lp->ll_tv->vval.v_dict->dv_lock, lp->ll_name))", "    ;", "  else if (lp->ll_range) {"], "whitespace/semicolon"]
["src/nvim/eval.c", ["    // Check whether any of the list items is locked", "    for (listitem_T *ri = rettv->vval.v_list->lv_first; ri != NULL && ll_li != NULL; ) {", "      if (tv_check_lock(ll_li->li_tv.v_lock, lp->ll_name)) {"], "whitespace/line_length"]
["src/nvim/eval.c", ["        tv_op(&lp->ll_li->li_tv, &ri->li_tv, op);", "      else {", "        clear_tv(&lp->ll_li->li_tv);"], "readability/braces"]
["src/nvim/eval.c", ["", "  *errp = TRUE;         /* default: there is an error */", ""], "readability/bool"]
["src/nvim/eval.c", ["  if (eval0(skipwhite(expr + 2), &tv, nextcmdp, !skip) == OK) {", "    *errp = FALSE;", "    if (!skip) {"], "readability/bool"]
["src/nvim/eval.c", ["  if (item == NULL)", "    result = FALSE;", "  else {"], "readability/bool"]
["src/nvim/eval.c", ["    result = FALSE;", "  else {", "    fi->fi_lw.lw_item = item->li_next;"], "readability/braces"]
["src/nvim/eval.c", ["    fi->fi_lw.lw_item = item->li_next;", "    result = (ex_let_vars(arg, &item->li_tv, TRUE,", "                  fi->fi_semicolon, fi->fi_varcount, NULL) == OK);"], "readability/bool"]
["src/nvim/eval.c", ["{", "  int got_eq = FALSE;", "  int c;"], "readability/bool"]
["src/nvim/eval.c", ["    }", "  } else", "    xp->xp_context = cmdidx == CMD_call ? EXPAND_FUNCTIONS"], "readability/braces"]
["src/nvim/eval.c", ["          xp->xp_pattern += 2;", "", "      }"], "whitespace/blank_line"]
["src/nvim/eval.c", ["    } else if (c == '=') {", "      got_eq = TRUE;", "      xp->xp_context = EXPAND_EXPRESSION;"], "readability/bool"]
["src/nvim/eval.c", ["        while ((c = *++xp->xp_pattern) != NUL && c != '\\'')", "          /* skip */;", "        xp->xp_context = EXPAND_NOTHING;"], "whitespace/semicolon"]
["src/nvim/eval.c", ["          xp->xp_context = EXPAND_EXPRESSION;", "        } else", "          xp->xp_context = EXPAND_COMMANDS;"], "readability/braces"]
["src/nvim/eval.c", ["          xp->xp_context = EXPAND_COMMANDS;", "      } else", "        xp->xp_context = EXPAND_EXPRESSION;"], "readability/braces"]
["src/nvim/eval.c", ["        xp->xp_context = EXPAND_EXPRESSION;", "    } else", "      /* Doesn't look like something valid, expand as an expression"], "readability/braces"]
["src/nvim/eval.c", ["      while ((c = *++arg) != NUL && (c == ' ' || c == '\\t'))", "        /* skip */;", "  }"], "whitespace/semicolon"]
["src/nvim/eval.c", ["  int doesrange;", "  int failed = FALSE;", "  funcdict_T fudi;"], "readability/bool"]
["src/nvim/eval.c", ["    ++emsg_skip;", "    if (eval0(eap->arg, &rettv, &eap->nextcmd, FALSE) != FAIL)", "      clear_tv(&rettv);"], "readability/bool"]
["src/nvim/eval.c", ["  len = (int)STRLEN(tofree);", "  name = deref_func_name(tofree, &len, FALSE);", ""], "readability/bool"]
["src/nvim/eval.c", ["    lnum = eap->line2;          /* do it once, also with an invalid range */", "  } else", "    lnum = eap->line1;"], "readability/braces"]
["src/nvim/eval.c", ["            !eap->skip, fudi.fd_dict) == FAIL) {", "      failed = TRUE;", "      break;"], "readability/bool"]
["src/nvim/eval.c", ["    /* Handle a function returning a Funcref, Dictionary or List. */", "    if (handle_subscript(&arg, &rettv, !eap->skip, TRUE) == FAIL) {", "      failed = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["    if (handle_subscript(&arg, &rettv, !eap->skip, TRUE) == FAIL) {", "      failed = TRUE;", "      break;"], "readability/bool"]
["src/nvim/eval.c", ["    if (!ends_excmd(*arg)) {", "      emsg_severe = TRUE;", "      EMSG(_(e_trailing));"], "readability/bool"]
["src/nvim/eval.c", ["      EMSG(_(e_trailing));", "    } else", "      eap->nextcmd = check_nextcmd(arg);"], "readability/braces"]
["src/nvim/eval.c", ["  char_u      *name_end;", "  int error = FALSE;", "  lval_T lv;"], "readability/bool"]
["src/nvim/eval.c", ["    /* Parse the name and find the end. */", "    name_end = get_lval(arg, NULL, &lv, TRUE, eap->skip || error, 0,", "        FNE_CHECK_START);"], "readability/bool"]
["src/nvim/eval.c", ["    if (lv.ll_name == NULL)", "      error = TRUE;                 /* error but continue parsing */", "    if (name_end == NULL || (!ascii_iswhite(*name_end)"], "readability/bool"]
["src/nvim/eval.c", ["      if (name_end != NULL) {", "        emsg_severe = TRUE;", "        EMSG(_(e_trailing));"], "readability/bool"]
["src/nvim/eval.c", ["        if (do_unlet_var(&lv, name_end, eap->forceit) == FAIL)", "          error = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/eval.c", ["                eap->cmdidx == CMD_lockvar) == FAIL)", "          error = TRUE;", "      }"], "readability/bool"]
["src/nvim/eval.c", ["    *name_end = cc;", "  } else if (tv_check_lock(lp->ll_tv->v_lock, lp->ll_name))", "    return FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["      ret = FAIL;", "    else {", "      di = find_var(lp->ll_name, NULL, TRUE);"], "readability/braces"]
["src/nvim/eval.c", ["    else {", "      di = find_var(lp->ll_name, NULL, TRUE);", "      if (di == NULL)"], "readability/bool"]
["src/nvim/eval.c", ["        ret = FAIL;", "      else {", "        if (lock)"], "readability/braces"]
["src/nvim/eval.c", ["    }", "  } else if (lp->ll_list != NULL)", "    /* (un)lock a List item. */"], "readability/braces"]
["src/nvim/eval.c", ["  if ((*arg)[0] == '?') {", "    result = FALSE;", "    if (evaluate) {"], "readability/bool"]
["src/nvim/eval.c", ["    if (evaluate) {", "      int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      if (get_tv_number_chk(rettv, &error) != 0)", "        result = TRUE;", "      clear_tv(rettv);"], "readability/bool"]
["src/nvim/eval.c", ["  int first;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["   */", "  first = TRUE;", "  result = FALSE;"], "readability/bool"]
["src/nvim/eval.c", ["  first = TRUE;", "  result = FALSE;", "  while ((*arg)[0] == '|' && (*arg)[1] == '|') {"], "readability/bool"]
["src/nvim/eval.c", ["      if (get_tv_number_chk(rettv, &error) != 0)", "        result = TRUE;", "      clear_tv(rettv);"], "readability/bool"]
["src/nvim/eval.c", ["        return FAIL;", "      first = FALSE;", "    }"], "readability/bool"]
["src/nvim/eval.c", ["      if (get_tv_number_chk(&var2, &error) != 0)", "        result = TRUE;", "      clear_tv(&var2);"], "readability/bool"]
["src/nvim/eval.c", ["  int first;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["   */", "  first = TRUE;", "  result = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["  first = TRUE;", "  result = TRUE;", "  while ((*arg)[0] == '&' && (*arg)[1] == '&') {"], "readability/bool"]
["src/nvim/eval.c", ["      if (get_tv_number_chk(rettv, &error) == 0)", "        result = FALSE;", "      clear_tv(rettv);"], "readability/bool"]
["src/nvim/eval.c", ["        return FAIL;", "      first = FALSE;", "    }"], "readability/bool"]
["src/nvim/eval.c", ["      if (get_tv_number_chk(&var2, &error) == 0)", "        result = FALSE;", "      clear_tv(&var2);"], "readability/bool"]
["src/nvim/eval.c", ["  exptype_T type = TYPE_UNKNOWN;", "  int type_is = FALSE;              /* TRUE for \"is\" and \"isnot\" */", "  int len = 2;"], "readability/bool"]
["src/nvim/eval.c", ["      len = 1;", "  } else", "      type = TYPE_GEQUAL;"], "readability/braces"]
["src/nvim/eval.c", ["      len = 1;", "  } else", "      type = TYPE_SEQUAL;"], "readability/braces"]
["src/nvim/eval.c", ["        type = len == 2 ? TYPE_EQUAL : TYPE_NEQUAL;", "        type_is = TRUE;", "      }"], "readability/bool"]
["src/nvim/eval.c", ["    if (p[len] == '?') {", "      ic = TRUE;", "      ++len;"], "readability/bool"]
["src/nvim/eval.c", ["    /* extra '#' appended: match case */", "    else if (p[len] == '#') {", "      ic = FALSE;"], "whitespace/newline"]
["src/nvim/eval.c", ["    else if (p[len] == '#') {", "      ic = FALSE;", "      ++len;"], "readability/bool"]
["src/nvim/eval.c", ["    /* nothing appended: use 'ignorecase' */", "    else", "      ic = p_ic;"], "whitespace/newline"]
["src/nvim/eval.c", ["          n1 = list_equal(rettv->vval.v_list, var2.vval.v_list,", "              ic, FALSE);", "          if (type == TYPE_NEQUAL)"], "readability/bool"]
["src/nvim/eval.c", ["          n1 = dict_equal(rettv->vval.v_dict, var2.vval.v_dict,", "              ic, FALSE);", "          if (type == TYPE_NEQUAL)"], "readability/bool"]
["src/nvim/eval.c", ["              || var2.vval.v_string == NULL)", "            n1 = FALSE;", "          else"], "readability/bool"]
["src/nvim/eval.c", ["       */", "      else if ((rettv->v_type == VAR_FLOAT || var2.v_type == VAR_FLOAT)", "               && type != TYPE_MATCH && type != TYPE_NOMATCH) {"], "whitespace/newline"]
["src/nvim/eval.c", ["          f2 = get_tv_number(&var2);", "        n1 = FALSE;", "        switch (type) {"], "readability/bool"]
["src/nvim/eval.c", ["       */", "      else if ((rettv->v_type == VAR_NUMBER || var2.v_type == VAR_NUMBER)", "               && type != TYPE_MATCH && type != TYPE_NOMATCH) {"], "whitespace/newline"]
["src/nvim/eval.c", ["          i = 0;", "        n1 = FALSE;", "        switch (type) {"], "readability/bool"]
["src/nvim/eval.c", ["   */", "  if (eval6(arg, rettv, evaluate, FALSE) == FAIL)", "    return FAIL;"], "readability/bool"]
["src/nvim/eval.c", ["      } else {", "        int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", [" */", "static int ", "eval6 ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "eval6 (", "    char_u **arg,"], "whitespace/parens"]
["src/nvim/eval.c", ["  long n1, n2;", "  int use_float = FALSE;", "  float_T f1 = 0, f2;"], "readability/bool"]
["src/nvim/eval.c", ["  float_T f1 = 0, f2;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["        f1 = rettv->vval.v_float;", "        use_float = TRUE;", "        n1 = 0;"], "readability/bool"]
["src/nvim/eval.c", ["        n1 = 0;", "      } else", "        n1 = get_tv_number_chk(rettv, &error);"], "readability/braces"]
["src/nvim/eval.c", ["        return FAIL;", "    } else", "      n1 = 0;"], "readability/braces"]
["src/nvim/eval.c", ["    *arg = skipwhite(*arg + 1);", "    if (eval7(arg, &var2, evaluate, FALSE) == FAIL)", "      return FAIL;"], "readability/bool"]
["src/nvim/eval.c", ["          f1 = n1;", "          use_float = TRUE;", "        }"], "readability/bool"]
["src/nvim/eval.c", ["              n1 = 0x7fffffffL;", "          } else", "            n1 = n1 / n2;"], "readability/braces"]
["src/nvim/eval.c", [" */", "static int ", "eval7 ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "eval7 (", "    char_u **arg,"], "whitespace/parens"]
["src/nvim/eval.c", ["    char_u *p = skipdigits(*arg + 1);", "    int get_float = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    if (!want_string && p[0] == '.' && ascii_isdigit(p[1])) {", "      get_float = TRUE;", "      p = skipdigits(p + 2);"], "readability/bool"]
["src/nvim/eval.c", ["        if (!ascii_isdigit(*p))", "          get_float = FALSE;", "        else"], "readability/bool"]
["src/nvim/eval.c", ["      if (ASCII_ISALPHA(*p) || *p == '.')", "        get_float = FALSE;", "    }"], "readability/bool"]
["src/nvim/eval.c", ["    } else {", "      vim_str2nr(*arg, NULL, &len, TRUE, TRUE, &n, NULL);", "      *arg += len;"], "readability/bool"]
["src/nvim/eval.c", ["    s = *arg;", "    len = get_name_len(arg, &alias, evaluate, TRUE);", "    if (alias != NULL)"], "readability/bool"]
["src/nvim/eval.c", ["      ret = FAIL;", "    else {", "      if (**arg == '(') {               /* recursive! */"], "readability/braces"]
["src/nvim/eval.c", ["        }", "      } else if (evaluate)", "        ret = get_var_tv(s, len, rettv, TRUE, FALSE);"], "readability/braces"]
["src/nvim/eval.c", ["      } else if (evaluate)", "        ret = get_var_tv(s, len, rettv, TRUE, FALSE);", "      else"], "readability/bool"]
["src/nvim/eval.c", ["  if (ret == OK)", "    ret = handle_subscript(arg, rettv, evaluate, TRUE);", ""], "readability/bool"]
["src/nvim/eval.c", ["  if (ret == OK && evaluate && end_leader > start_leader) {", "    int error = FALSE;", "    int val = 0;"], "readability/bool"]
["src/nvim/eval.c", [" */", "static int ", "eval_index ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "eval_index (", "    char_u **arg,"], "whitespace/parens"]
["src/nvim/eval.c", ["{", "  int empty1 = FALSE, empty2 = FALSE;", "  typval_T var1, var2;"], "readability/bool"]
["src/nvim/eval.c", ["  long len = -1;", "  int range = FALSE;", "  char_u      *s;"], "readability/bool"]
["src/nvim/eval.c", ["    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)", "      ;", "    if (len == 0)"], "whitespace/semicolon"]
["src/nvim/eval.c", ["    if (**arg == ':')", "      empty1 = TRUE;", "    else if (eval1(arg, &var1, evaluate) == FAIL)       /* recursive! */"], "readability/bool"]
["src/nvim/eval.c", ["    if (**arg == ':') {", "      range = TRUE;", "      *arg = skipwhite(*arg + 1);"], "readability/bool"]
["src/nvim/eval.c", ["      if (**arg == ']')", "        empty2 = TRUE;", "      else if (eval1(arg, &var2, evaluate) == FAIL) {           /* recursive! */"], "readability/bool"]
["src/nvim/eval.c", ["        n2 = -1;", "      else {", "        n2 = get_tv_number(&var2);"], "readability/braces"]
["src/nvim/eval.c", [" */", "static int ", "get_option_tv ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "get_option_tv (", "    char_u **arg,"], "whitespace/parens"]
["src/nvim/eval.c", ["    }", "  } else if (working && (opt_type == -2 || opt_type == -1))", "    ret = FAIL;"], "readability/braces"]
["src/nvim/eval.c", ["      /* Special key, e.g.: \"\\<C-W>\" */", "      case '<': extra = trans_special(&p, name, TRUE);", "        if (extra != 0) {"], "readability/bool"]
["src/nvim/eval.c", ["      }", "    } else", "      MB_COPY_CHAR(p, name);"], "readability/braces"]
["src/nvim/eval.c", ["      MB_COPY_CHAR(p, name);", "", "  }"], "whitespace/blank_line"]
["src/nvim/eval.c", ["    if (evaluate)", "      list_free(l, TRUE);", "    return FAIL;"], "readability/bool"]
["src/nvim/eval.c", ["  if (l != NULL && --l->lv_refcount <= 0)", "    list_free(l, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", [" */", "void ", "list_free ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["void ", "list_free (", "    list_T *l,"], "whitespace/parens"]
["src/nvim/eval.c", [" */", "static int ", "list_equal ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "list_equal (", "    list_T *l1,"], "whitespace/parens"]
["src/nvim/eval.c", ["  if (l1 == NULL || l2 == NULL)", "    return FALSE;", "  if (l1 == l2)"], "readability/bool"]
["src/nvim/eval.c", ["  if (l1 == l2)", "    return TRUE;", "  if (list_len(l1) != list_len(l2))"], "readability/bool"]
["src/nvim/eval.c", ["  if (list_len(l1) != list_len(l2))", "    return FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    if (!tv_equal(&item1->li_tv, &item2->li_tv, ic, recursive))", "      return FALSE;", "  return item1 == NULL && item2 == NULL;"], "readability/bool"]
["src/nvim/eval.c", [" */", "static int ", "dict_equal ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "dict_equal (", "    dict_T *d1,"], "whitespace/parens"]
["src/nvim/eval.c", ["  if (d1 == NULL || d2 == NULL)", "    return FALSE;", "  if (d1 == d2)"], "readability/bool"]
["src/nvim/eval.c", ["  if (d1 == d2)", "    return TRUE;", "  if (dict_len(d1) != dict_len(d2))"], "readability/bool"]
["src/nvim/eval.c", ["  if (dict_len(d1) != dict_len(d2))", "    return FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      if (item2 == NULL)", "        return FALSE;", "      if (!tv_equal(&HI2DI(hi)->di_tv, &item2->di_tv, ic, recursive))"], "readability/bool"]
["src/nvim/eval.c", ["      if (!tv_equal(&HI2DI(hi)->di_tv, &item2->di_tv, ic, recursive))", "        return FALSE;", "      --todo;"], "readability/bool"]
["src/nvim/eval.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/eval.c", [" */", "static int ", "tv_equal ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "tv_equal (", "    typval_T *tv1,"], "whitespace/parens"]
["src/nvim/eval.c", ["  if (tv1->v_type != tv2->v_type)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    --tv_equal_recurse_limit;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["    ++recursive_cnt;", "    r = list_equal(tv1->vval.v_list, tv2->vval.v_list, ic, TRUE);", "    --recursive_cnt;"], "readability/bool"]
["src/nvim/eval.c", ["    ++recursive_cnt;", "    r = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, TRUE);", "    --recursive_cnt;"], "readability/bool"]
["src/nvim/eval.c", ["  EMSG2(_(e_intern2), \"tv_equal()\");", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/eval.c", [" */", "static long ", "list_find_nr ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static long ", "list_find_nr (", "    list_T *l,"], "whitespace/parens"]
["src/nvim/eval.c", ["    if (errorp != NULL)", "      *errorp = TRUE;", "    return -1L;"], "readability/bool"]
["src/nvim/eval.c", ["    list_append(l, ni);", "  else {", "    /* Insert new item before existing item. */"], "readability/braces"]
["src/nvim/eval.c", ["      }", "    } else", "      copy_tv(&item->li_tv, &ni->li_tv);"], "readability/braces"]
["src/nvim/eval.c", ["      dict_T *dd_next = dd->dv_used_next;", "      dict_free(dd, FALSE);", "      did_free = true;"], "readability/bool"]
["src/nvim/eval.c", ["      list_T* ll_next = ll->lv_used_next;", "      list_free(ll, FALSE);", "      did_free = true;"], "readability/bool"]
["src/nvim/eval.c", ["  if (d != NULL && --d->dv_refcount <= 0)", "    dict_free(d, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", [" */", "void ", "dict_free ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["void ", "dict_free (", "    dict_T *d,"], "whitespace/parens"]
["src/nvim/eval.c", ["          }", "        } else", "          copy_tv(&HI2DI(hi)->di_tv, &di->di_tv);"], "readability/braces"]
["src/nvim/eval.c", ["  }", "  ", "  if (di->di_tv.v_type != VAR_FUNC && di->di_tv.v_type != VAR_STRING) {"], "whitespace/end_of_line"]
["src/nvim/eval.c", ["  if (*start != '}') {", "    if (eval1(&start, &tv, FALSE) == FAIL)      /* recursive! */", "      return FAIL;"], "readability/bool"]
["src/nvim/eval.c", ["    if (evaluate)", "      dict_free(d, TRUE);", "    return FAIL;"], "readability/bool"]
["src/nvim/eval.c", [" */", "static int ", "string2float ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "string2float (", "    char_u *text,"], "whitespace/parens"]
["src/nvim/eval.c", ["  {\"count\",           2, 4, f_count},", "  {\"cscope_connection\",0,3, f_cscope_connection},", "  {\"cursor\",          1, 3, f_cursor},"], "whitespace/comma"]
["src/nvim/eval.c", ["  {\"highlightID\",     1, 1, f_hlID},            /* obsolete */", "  {\"highlight_exists\",1, 1, f_hlexists},        /* obsolete */", "  {\"histadd\",         2, 2, f_histadd},"], "whitespace/comma"]
["src/nvim/eval.c", ["  {\"matchadd\",        2, 4, f_matchadd},", "  {\"matchaddpos\",     2, 4, f_matchaddpos}, ", "  {\"matcharg\",        1, 1, f_matcharg},"], "whitespace/end_of_line"]
["src/nvim/eval.c", [" */", "static int ", "find_internal_func ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "find_internal_func (", "    char_u *name              /* name of the function */"], "whitespace/parens"]
["src/nvim/eval.c", [" */", "static int ", "get_func_tv ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "get_func_tv (", "    char_u *name,              /* name of the function */"], "whitespace/parens"]
["src/nvim/eval.c", ["int", "call_func (", "    char_u *funcname,          /* name of the function */"], "whitespace/parens"]
["src/nvim/eval.c", ["    int argcount,                   /* number of \"argvars\" */", "    typval_T *argvars,           /* vars for arguments, must have \"argcount\"", "                                   PLUS ONE elements! */"], "readability/multiline_comment"]
["src/nvim/eval.c", ["    typval_T *argvars,           /* vars for arguments, must have \"argcount\"", "                                   PLUS ONE elements! */", "    linenr_T firstline,             /* first line of range */"], "whitespace/operators"]
["src/nvim/eval.c", ["        error = ERROR_SCRIPT;", "      else {", "        sprintf((char *)fname_buf + 3, \"%\" PRId64 \"_\", (int64_t)current_SID);"], "readability/braces"]
["src/nvim/eval.c", ["      else {", "        sprintf((char *)fname_buf + 3, \"%\" PRId64 \"_\", (int64_t)current_SID);", "        i = (int)STRLEN(fname_buf);"], "runtime/printf"]
["src/nvim/eval.c", ["    }", "  } else", "    fname = name;"], "readability/braces"]
["src/nvim/eval.c", ["", "  *doesrange = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      if (fp == NULL", "          && apply_autocmds(EVENT_FUNCUNDEFINED, rfname, rfname, TRUE, NULL)", "          && !aborting()) {"], "readability/bool"]
["src/nvim/eval.c", ["      /* Try loading a package. */", "      if (fp == NULL && script_autoload(rfname, TRUE) && !aborting()) {", "        /* loaded a package, search for the function again */"], "readability/bool"]
["src/nvim/eval.c", ["        if (fp->uf_flags & FC_RANGE)", "          *doesrange = TRUE;", "        if (argcount < fp->uf_args.ga_len)"], "readability/bool"]
["src/nvim/eval.c", ["          error = ERROR_DICT;", "        else {", "          // Call the user function."], "readability/braces"]
["src/nvim/eval.c", ["          error = ERROR_TOOMANY;", "        else {", "          argvars[argcount].v_type = VAR_UNKNOWN;"], "readability/braces"]
["src/nvim/eval.c", ["    varnumber_T n;", "    int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    }", "  } else", "    EMSG(_(e_listreq));"], "readability/braces"]
["src/nvim/eval.c", ["    u_sync_once = 1;     /* notify that u_sync() was called */", "    u_sync(TRUE);", "  }"], "readability/bool"]
["src/nvim/eval.c", ["      }", "      ml_append(lnum + added, line, (colnr_T)0, FALSE);", "      ++added;"], "readability/bool"]
["src/nvim/eval.c", ["      curwin->w_cursor.lnum += added;", "  } else", "    rettv->vval.v_number = 1;           /* Failed */"], "readability/braces"]
["src/nvim/eval.c", ["  save_magic = p_magic;", "  p_magic = TRUE;", "  save_cpo = p_cpo;"], "readability/bool"]
["src/nvim/eval.c", ["  buf = buflist_findnr(buflist_findpat(name, name + STRLEN(name),", "          TRUE, FALSE, curtab_only));", ""], "readability/bool"]
["src/nvim/eval.c", ["  ++emsg_off;", "  buf = get_buf_tv(&argvars[0], FALSE);", "  rettv->v_type = VAR_STRING;"], "readability/bool"]
["src/nvim/eval.c", ["  buf_T       *buf;", "  int error = FALSE;", "  char_u      *name;"], "readability/bool"]
["src/nvim/eval.c", ["  ++emsg_off;", "  buf = get_buf_tv(&argvars[0], FALSE);", "  --emsg_off;"], "readability/bool"]
["src/nvim/eval.c", ["", "  buf_T *buf = get_buf_tv(&argvars[0], TRUE);", "  int winnr = 0;"], "readability/bool"]
["src/nvim/eval.c", ["{", "  byteidx(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["{", "  byteidx(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["        curwin->w_cursor.lnum, curwin->w_cursor.lnum,", "        &dummy, TRUE, selfdict);", ""], "readability/bool"]
["src/nvim/eval.c", ["      rettv->vval.v_number = (*mb_ptr2char)(get_tv_string(&argvars[0]));", "  } else", "    rettv->vval.v_number = get_tv_string(&argvars[0])[0];"], "readability/braces"]
["src/nvim/eval.c", ["    curwin->w_cursor = pos;", "  } else", "    rettv->vval.v_number = -1;"], "readability/braces"]
["src/nvim/eval.c", ["", "  fp = var2fpos(&argvars[0], FALSE, &fnum);", "  if (fp != NULL && fnum == curbuf->b_fnum) {"], "readability/bool"]
["src/nvim/eval.c", ["  char_u      *typestr;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  if (message == NULL)", "    error = TRUE;", "  if (argvars[1].v_type != VAR_UNKNOWN) {"], "readability/bool"]
["src/nvim/eval.c", ["    if (buttons == NULL)", "      error = TRUE;", "    if (argvars[2].v_type != VAR_UNKNOWN) {"], "readability/bool"]
["src/nvim/eval.c", ["        if (typestr == NULL)", "          error = TRUE;", "        else {"], "readability/bool"]
["src/nvim/eval.c", ["          error = TRUE;", "        else {", "          switch (TOUPPER_ASC(*typestr)) {"], "readability/braces"]
["src/nvim/eval.c", ["    rettv->vval.v_number = do_dialog(type, NULL, message, buttons,", "        def, NULL, FALSE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["  long n = 0;", "  int ic = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      if (argvars[2].v_type != VAR_UNKNOWN) {", "        int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      for (; li != NULL; li = li->li_next)", "        if (tv_equal(&li->li_tv, &argvars[1], ic, FALSE))", "          ++n;"], "readability/bool"]
["src/nvim/eval.c", ["    if ((d = argvars[0].vval.v_dict) != NULL) {", "      int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["          --todo;", "          if (tv_equal(&HI2DI(hi)->di_tv, &argvars[1], ic, FALSE))", "            ++n;"], "readability/bool"]
["src/nvim/eval.c", ["    }", "  } else", "    EMSG2(_(e_listdictarg), \"count()\");"], "readability/braces"]
["src/nvim/eval.c", ["", "  curwin->w_set_curswant = TRUE;", "  rettv->vval.v_number = 0;"], "readability/bool"]
["src/nvim/eval.c", ["    EMSG(_(e_invarg));", "  else {", "    current_copyID += COPYID_INC;"], "readability/braces"]
["src/nvim/eval.c", ["          hlID = HLF_CHD;               /* changed line */", "      } else", "        hlID = HLF_ADD;         /* added line */"], "readability/braces"]
["src/nvim/eval.c", ["        hlID = HLF_ADD;         /* added line */", "    } else", "      hlID = (hlf_T)0;"], "readability/braces"]
["src/nvim/eval.c", ["  char_u *p = s;", "  if (s == NULL || eval1(&s, rettv, TRUE) == FAIL) {", "    if (p != NULL && !aborting()) {"], "readability/bool"]
["src/nvim/eval.c", ["    }", "    need_clr_eos = FALSE;", "    rettv->v_type = VAR_NUMBER;"], "readability/bool"]
["src/nvim/eval.c", ["  char_u      *name;", "  int n = FALSE;", "  int len = 0;"], "readability/bool"]
["src/nvim/eval.c", ["    if (os_getenv((char *)(p + 1)) != NULL)", "      n = TRUE;", "    else {"], "readability/bool"]
["src/nvim/eval.c", ["      n = TRUE;", "    else {", "      /* try expanding things like $VIM and ${HOME} */"], "readability/braces"]
["src/nvim/eval.c", ["      if (p != NULL && *p != '$')", "        n = TRUE;", "      xfree(p);"], "readability/bool"]
["src/nvim/eval.c", ["  } else if (*p == '&' || *p == '+') {                /* option */", "    n = (get_option_tv(&p, NULL, TRUE) == OK);", "    if (*skipwhite(p) != NUL)"], "readability/bool"]
["src/nvim/eval.c", ["    if (*skipwhite(p) != NUL)", "      n = FALSE;                        /* trailing garbage */", "  } else if (*p == '*') {             /* internal or user defined function */"], "readability/bool"]
["src/nvim/eval.c", ["    name = p;", "    len = get_name_len(&p, &tofree, TRUE, FALSE);", "    if (len > 0) {"], "readability/bool"]
["src/nvim/eval.c", ["        name = tofree;", "      n = (get_var_tv(name, len, &tv, FALSE, TRUE) == OK);", "      if (n) {"], "readability/bool"]
["src/nvim/eval.c", ["        /* handle d.key, l[idx], f(expr) */", "        n = (handle_subscript(&p, &tv, TRUE, FALSE) == OK);", "        if (n)"], "readability/bool"]
["src/nvim/eval.c", ["    if (*p != NUL)", "      n = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  expand_T xpc;", "  int error = FALSE;", "  char_u      *result;"], "readability/bool"]
["src/nvim/eval.c", ["      }", "    } else", "      rettv->vval.v_string = result;"], "readability/braces"]
["src/nvim/eval.c", ["            options, WILD_ALL);", "      else {", "        rettv_list_alloc(rettv);"], "readability/braces"]
["src/nvim/eval.c", ["      }", "    } else", "      rettv->vval.v_string = NULL;"], "readability/braces"]
["src/nvim/eval.c", ["    long before;", "    int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["          item = NULL;", "        else {", "          item = list_find(l1, before);"], "readability/braces"]
["src/nvim/eval.c", ["        }", "      } else", "        item = NULL;"], "readability/braces"]
["src/nvim/eval.c", ["        }", "      } else", "        action = (char_u *)\"force\";"], "readability/braces"]
["src/nvim/eval.c", ["    }", "  } else", "    EMSG2(_(e_listdictarg), \"extend()\");"], "readability/braces"]
["src/nvim/eval.c", ["    vim_feedkeys(cstr_as_string((char *)keys),", "\t\t    cstr_as_string((char *)flags), true);", "  }"], "whitespace/tab"]
["src/nvim/eval.c", ["  int count = 1;", "  int first = TRUE;", "  int error = FALSE;"], "readability/bool"]
["src/nvim/eval.c", ["  int first = TRUE;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    if (p == NULL)", "      error = TRUE;", "    else {"], "readability/bool"]
["src/nvim/eval.c", ["      error = TRUE;", "    else {", "      if (*p != NUL)"], "readability/braces"]
["src/nvim/eval.c", ["                                          : curbuf->b_p_sua));", "      first = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["        list_append_string(rettv->vval.v_list, fresult, -1);", "", "    } while ((rettv->v_type == VAR_LIST || --count > 0) && fresult != NULL);"], "whitespace/blank_line"]
["src/nvim/eval.c", ["    save_did_emsg = did_emsg;", "    did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  s = expr;", "  if (eval1(&s, &rettv, TRUE) == FAIL)", "    goto theend;"], "readability/bool"]
["src/nvim/eval.c", ["  } else {", "    int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["{", "  filter_map(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["  rettv->vval.v_string = vim_strsave_fnameescape(", "      get_tv_string(&argvars[0]), FALSE);", "  rettv->v_type = VAR_STRING;"], "readability/bool"]
["src/nvim/eval.c", ["    fname = NULL;", "  else {", "    len = STRLEN(fname);"], "readability/braces"]
["src/nvim/eval.c", ["  if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count) {", "    if (hasFoldingWin(curwin, lnum, &first, &last, FALSE, NULL)) {", "      if (end)"], "readability/bool"]
["src/nvim/eval.c", ["{", "  foldclosed_both(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["{", "  foldclosed_both(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["    r = xmalloc(STRLEN(txt)", "                + STRLEN(vimvars[VV_FOLDDASHES].vv_str) // for %s", "                + 20                                    // for %3ld"], "whitespace/comments"]
["src/nvim/eval.c", ["                + STRLEN(s));                           // concatenated", "    sprintf((char *)r, txt, vimvars[VV_FOLDDASHES].vv_str,", "        (long)((linenr_T)vimvars[VV_FOLDEND].vv_nr"], "runtime/printf"]
["src/nvim/eval.c", ["    EMSG2(_(\"E700: Unknown function: %s\"), s);", "  else {", "    if (STRNCMP(s, \"s:\", 2) == 0 || STRNCMP(s, \"<SID>\", 5) == 0) {"], "readability/braces"]
["src/nvim/eval.c", ["       * printable text. */", "      sprintf(sid_buf, \"<SNR>%\" PRId64 \"_\", (int64_t)current_SID);", "      rettv->vval.v_string = xmalloc(STRLEN(sid_buf) + STRLEN(s + off) + 1);"], "runtime/printf"]
["src/nvim/eval.c", ["      STRCAT(rettv->vval.v_string, s + off);", "    } else", "      rettv->vval.v_string = vim_strsave(s);"], "readability/braces"]
["src/nvim/eval.c", ["  * using Lists and Dicts internally.  E.g.: \":echo [garbagecollect()]\". */", "  want_garbage_collect = TRUE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  if (argvars[0].v_type != VAR_UNKNOWN && get_tv_number(&argvars[0]) == 1)", "    garbage_collect_at_exit = TRUE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["    if ((l = argvars[0].vval.v_list) != NULL) {", "      int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    }", "  } else", "    EMSG2(_(e_listdictarg), \"get()\");"], "readability/braces"]
["src/nvim/eval.c", ["      copy_tv(&argvars[2], rettv);", "  } else", "    copy_tv(tv, rettv);"], "readability/braces"]
["src/nvim/eval.c", [" */", "static void get_buffer_lines(buf_T *buf, linenr_T start, linenr_T end, int retlist, typval_T *rettv)", "{"], "whitespace/line_length"]
["src/nvim/eval.c", ["    if (start >= 1 && start <= buf->b_ml.ml_line_count)", "      p = ml_get_buf(buf, start, FALSE);", "    else"], "readability/bool"]
["src/nvim/eval.c", ["      list_append_string(", "        rettv->vval.v_list, ml_get_buf(buf, start++, FALSE), -1);", "    }"], "readability/bool"]
["src/nvim/eval.c", ["  ++emsg_off;", "  buf = get_buf_tv(&argvars[0], FALSE);", "  --emsg_off;"], "readability/bool"]
["src/nvim/eval.c", ["", "  get_buffer_lines(buf, lnum, end, TRUE, rettv);", "}"], "readability/bool"]
["src/nvim/eval.c", ["  dictitem_T  *v;", "  int done = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  ++emsg_off;", "  buf = get_buf_tv(&argvars[0], FALSE);", ""], "readability/bool"]
["src/nvim/eval.c", ["    if (*varname == '&') {      /* buffer-local-option */", "      if (get_option_tv(&varname, rettv, TRUE) == OK)", "        done = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["      if (get_option_tv(&varname, rettv, TRUE) == OK)", "        done = TRUE;", "    } else if (STRCMP(varname, \"changedtick\") == 0) {"], "readability/bool"]
["src/nvim/eval.c", ["      rettv->vval.v_number = curbuf->b_changedtick;", "      done = TRUE;", "    } else {"], "readability/bool"]
["src/nvim/eval.c", ["      v = find_var_in_ht(&curbuf->b_vars->dv_hashtab,", "          'b', varname, FALSE);", "      if (v != NULL) {"], "readability/bool"]
["src/nvim/eval.c", ["        copy_tv(&v->di_tv, rettv);", "        done = TRUE;", "      }"], "readability/bool"]
["src/nvim/eval.c", ["  varnumber_T n;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      temp[i++] = K_THIRD(n);", "    } else if (has_mbyte)", "      i += (*mb_char2bytes)(n, temp + i);"], "readability/braces"]
["src/nvim/eval.c", ["      rettv->vval.v_number = 0;", "    else {", "      rettv->vval.v_number = (varnumber_T)filesize;"], "readability/braces"]
["src/nvim/eval.c", ["    end = 0;", "    retlist = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/eval.c", ["    end = get_tv_lnum(&argvars[1]);", "    retlist = TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["    if (cur->match.regprog == NULL) {", "      // match added with matchaddpos() ", "      for (i = 0; i < MAXPOSMATCH; ++i) {"], "whitespace/end_of_line"]
["src/nvim/eval.c", ["        }", "        sprintf(buf, \"pos%d\", i + 1);", "        dict_add_list(dict, buf, l);"], "runtime/printf"]
["src/nvim/eval.c", ["    rettv->v_type = VAR_LIST;", "    rettv->vval.v_list = ", "      get_reg_contents(regname, (arg2 ? kGRegExprSrc : 0) | kGRegList);"], "whitespace/end_of_line"]
["src/nvim/eval.c", ["    }", "  } else", "    /* Default to v:register */"], "readability/braces"]
["src/nvim/eval.c", ["    buf[0] = Ctrl_V;", "    sprintf((char *)buf + 1, \"%\" PRId64, (int64_t)(reglen + 1));", "    break;"], "runtime/printf"]
["src/nvim/eval.c", ["     * first window in the tabpage, otherwise the window is not valid. */", "    if (switch_win(&oldcurwin, &oldtabpage, tp->tp_firstwin, tp, TRUE) == OK) {", "      // look up the variable"], "readability/bool"]
["src/nvim/eval.c", ["      // Let gettabvar({nr}, \"\") return the \"t:\" dictionary.", "      v = find_var_in_ht(&tp->tp_vars->dv_hashtab, 't', varname, FALSE);", "      if (v != NULL) {"], "readability/bool"]
["src/nvim/eval.c", ["    /* restore previous notion of curwin */", "    restore_win(oldcurwin, oldtabpage, TRUE);", "  }"], "readability/bool"]
["src/nvim/eval.c", ["static win_T *", "find_win_by_nr (", "    typval_T *vp,"], "whitespace/parens"]
["src/nvim/eval.c", [" */", "static void ", "getwinvar ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static void ", "getwinvar (", "    typval_T *argvars,"], "whitespace/parens"]
["src/nvim/eval.c", ["     * otherwise the window is not valid. */", "    if (switch_win(&oldcurwin, &oldtabpage, win, tp, TRUE) == OK) {", "      if (*varname == '&') {      /* window-local-option */"], "readability/bool"]
["src/nvim/eval.c", ["        // Let getwinvar({nr}, \"\") return the \"w:\" dictionary.", "        v = find_var_in_ht(&win->w_vars->dv_hashtab, 'w', varname, FALSE);", "        if (v != NULL) {"], "readability/bool"]
["src/nvim/eval.c", ["    /* restore previous notion of curwin */", "    restore_win(oldcurwin, oldtabpage, TRUE);", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  expand_T xpc;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["          NULL, options, WILD_ALL);", "    else {", "      rettv_list_alloc(rettv);"], "readability/braces"]
["src/nvim/eval.c", ["    }", "  } else", "    rettv->vval.v_string = NULL;"], "readability/braces"]
["src/nvim/eval.c", ["{", "    char_u\t*pat = get_tv_string_chk(&argvars[0]);", ""], "whitespace/tab"]
["src/nvim/eval.c", ["    rettv->v_type = VAR_STRING;", "    rettv->vval.v_string = file_pat_to_reg_pat(pat, NULL, NULL, FALSE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["  char_u      *name;", "  int n = FALSE;", "  static char *(has_list[]) ="], "readability/bool"]
["src/nvim/eval.c", ["    if (STRICMP(name, has_list[i]) == 0) {", "      n = TRUE;", "      break;"], "readability/bool"]
["src/nvim/eval.c", ["", "  if (n == FALSE) {", "    if (STRNICMP(name, \"patch\", 5) == 0) {"], "readability/bool"]
["src/nvim/eval.c", ["", "  if (n == FALSE && eval_has_provider((char *)name)) {", "    n = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["  if (n == FALSE && eval_has_provider((char *)name)) {", "    n = TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  char_u buf[NUMBUFLEN];", "  int abbr = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    mode = (char_u *)\"nvo\";", "  else {", "    mode = get_tv_string_buf(&argvars[1], buf);"], "readability/braces"]
["src/nvim/eval.c", ["  if (map_to_exists(name, mode, abbr))", "    rettv->vval.v_number = TRUE;", "  else"], "readability/bool"]
["src/nvim/eval.c", ["  else", "    rettv->vval.v_number = FALSE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "  rettv->vval.v_number = FALSE;", "  if (check_restricted() || check_secure())"], "readability/bool"]
["src/nvim/eval.c", ["      init_history();", "      add_to_history(histype, str, FALSE, NUL);", "      rettv->vval.v_number = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["      add_to_history(histype, str, FALSE, NUL);", "      rettv->vval.v_number = TRUE;", "      return;"], "readability/bool"]
["src/nvim/eval.c", ["    rettv->vval.v_string = NULL;", "  else {", "    type = get_histtype(str);"], "readability/braces"]
["src/nvim/eval.c", ["  long idx = 0;", "  int ic = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    if (argvars[2].v_type != VAR_UNKNOWN) {", "      int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    for (; item != NULL; item = item->li_next, ++idx)", "      if (tv_equal(&item->li_tv, &argvars[1], ic, FALSE)) {", "        rettv->vval.v_number = idx;"], "readability/bool"]
["src/nvim/eval.c", ["", "  cmd_silent = FALSE;           /* Want to see the prompt. */", "  if (prompt != NULL) {"], "readability/bool"]
["src/nvim/eval.c", ["      p = prompt;", "    else {", "      ++p;"], "readability/braces"]
["src/nvim/eval.c", ["      msg_puts_attr(prompt, echo_attr);", "      msg_didout = FALSE;", "      msg_starthere();"], "readability/bool"]
["src/nvim/eval.c", ["    /* since the user typed this, no need to wait for return */", "    need_wait_return = FALSE;", "    msg_didout = FALSE;"], "readability/bool"]
["src/nvim/eval.c", ["    need_wait_return = FALSE;", "    msg_didout = FALSE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["{", "  get_user_input(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["{", "  get_user_input(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["  lines_left = Rows;    /* avoid more prompt */", "  msg_scroll = TRUE;", "  msg_clr_eos();"], "readability/bool"]
["src/nvim/eval.c", ["  list_T      *l;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      item = NULL;", "    else {", "      item = list_find(l, before);"], "readability/braces"]
["src/nvim/eval.c", ["  rettv->vval.v_number = -1;", "  end = get_lval(get_tv_string(&argvars[0]), NULL, &lv, FALSE, FALSE,", "      GLV_NO_AUTOLOAD, FNE_CHECK_START);"], "readability/bool"]
["src/nvim/eval.c", ["      EMSG(_(e_trailing));", "    else {", "      if (lv.ll_tv == NULL) {"], "readability/braces"]
["src/nvim/eval.c", ["          rettv->vval.v_number = 1;                 /* always locked */", "        else {", "          di = find_var(lv.ll_name, NULL, TRUE);"], "readability/braces"]
["src/nvim/eval.c", ["        else {", "          di = find_var(lv.ll_name, NULL, TRUE);", "          if (di != NULL) {"], "readability/bool"]
["src/nvim/eval.c", ["        }", "      } else if (lv.ll_range)", "        EMSG(_(\"E786: Range not allowed\"));"], "readability/braces"]
["src/nvim/eval.c", ["  }", "  ", "  // Build the argument vector"], "whitespace/end_of_line"]
["src/nvim/eval.c", ["    rettv->vval.v_string = (char_u *)ga.ga_data;", "  } else", "    rettv->vval.v_string = NULL;"], "readability/braces"]
["src/nvim/eval.c", ["", "  fp = var2fpos(&argvars[0], TRUE, &fnum);", "  if (fp != NULL)"], "readability/bool"]
["src/nvim/eval.c", ["    curwin->w_cursor = pos;", "  } else", "    rettv->vval.v_number = -1;"], "readability/braces"]
["src/nvim/eval.c", ["  int mode;", "  int abbr = FALSE;", "  int get_dict = FALSE;"], "readability/bool"]
["src/nvim/eval.c", ["  int abbr = FALSE;", "  int get_dict = FALSE;", "  mapblock_T  *mp;"], "readability/bool"]
["src/nvim/eval.c", ["    }", "  } else", "    which = (char_u *)\"\";"], "readability/braces"]
["src/nvim/eval.c", ["", "  keys = replace_termcodes(keys, &keys_buf, TRUE, TRUE, FALSE);", "  rhs = check_map(keys, mode, exact, FALSE, abbr, &mp, &buffer_local);"], "readability/bool"]
["src/nvim/eval.c", ["  keys = replace_termcodes(keys, &keys_buf, TRUE, TRUE, FALSE);", "  rhs = check_map(keys, mode, exact, FALSE, abbr, &mp, &buffer_local);", "  xfree(keys_buf);"], "readability/bool"]
["src/nvim/eval.c", ["    if (rhs != NULL)", "      rettv->vval.v_string = str2special_save(rhs, FALSE);", ""], "readability/bool"]
["src/nvim/eval.c", ["      // Return a dictionary.", "      char_u      *lhs = str2special_save(mp->m_keys, TRUE);", "      char_u      *mapmode = map_mode_to_chars(mp->m_mode);"], "readability/bool"]
["src/nvim/eval.c", ["{", "  filter_map(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["{", "  get_maparg(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["{", "  get_maparg(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["  if (argvars[2].v_type != VAR_UNKNOWN) {", "    int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["        startcol = start;", "      else {", "        str += start;"], "readability/braces"]
["src/nvim/eval.c", ["        if (li == NULL) {", "          match = FALSE;", "          break;"], "readability/bool"]
["src/nvim/eval.c", ["        if (startcol > (colnr_T)len || str + startcol <= regmatch.startp[0]) {", "            match = FALSE;", "            break;"], "readability/bool"]
["src/nvim/eval.c", ["              (int)(regmatch.endp[0] - regmatch.startp[0]));", "      } else if (l != NULL)", "        rettv->vval.v_number = idx;"], "readability/braces"]
["src/nvim/eval.c", ["        rettv->vval.v_number = idx;", "      else {", "        if (type != 0)"], "readability/braces"]
["src/nvim/eval.c", ["  int id = -1;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  }", "  if (error == TRUE)", "    return;"], "readability/bool"]
["src/nvim/eval.c", ["", "static void f_matchaddpos(typval_T *argvars, typval_T *rettv) FUNC_ATTR_NONNULL_ALL", "{"], "whitespace/line_length"]
["src/nvim/eval.c", ["    rettv->vval.v_number = -1;", "    ", "    char_u buf[NUMBUFLEN];"], "whitespace/end_of_line"]
["src/nvim/eval.c", ["", "    // id == 3 is ok because matchaddpos() is supposed to substitute :3match ", "    if (id == 1 || id == 2) {"], "whitespace/end_of_line"]
["src/nvim/eval.c", ["  rettv->vval.v_number = match_delete(curwin,", "      (int)get_tv_number(&argvars[0]), TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["  long i;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    dict_T          *d;", "    int first = TRUE;", "    hashitem_T      *hi;"], "readability/bool"]
["src/nvim/eval.c", ["            n = i;", "            first = FALSE;", "          } else if (domax ? i > n : i < n)"], "readability/bool"]
["src/nvim/eval.c", ["            first = FALSE;", "          } else if (domax ? i > n : i < n)", "            n = i;"], "readability/braces"]
["src/nvim/eval.c", ["    }", "  } else", "    EMSG(_(e_listdictarg));"], "readability/braces"]
["src/nvim/eval.c", ["{", "  max_min(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["{", "  max_min(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["    rettv->vval.v_number = FAIL;", "  else {", "    if (*path_tail(dir) == NUL)"], "readability/braces"]
["src/nvim/eval.c", ["      buf[1] = '?';", "  } else if (State == EXTERNCMD)", "    buf[0] = '!';"], "readability/braces"]
["src/nvim/eval.c", ["      buf[1] = 'v';", "    } else if (State & REPLACE_FLAG)", "      buf[0] = 'R';"], "readability/braces"]
["src/nvim/eval.c", ["/// @param[out]  ret_len  Resulting buffer length.", "/// @param[out]  ret_buf  Allocated buffer with the result or NULL if ret_len is ", "///                       zero."], "whitespace/end_of_line"]
["src/nvim/eval.c", ["/// @param[out]  ret_len  Resulting buffer length.", "/// @param[out]  ret_buf  Allocated buffer with the result or NULL if ret_len is ", "///                       zero."], "whitespace/line_length"]
["src/nvim/eval.c", ["                                   size_t *const ret_len, char **const ret_buf)", "  FUNC_ATTR_NONNULL_ARG(2,3) FUNC_ATTR_WARN_UNUSED_RESULT", "{"], "whitespace/comma"]
["src/nvim/eval.c", ["    /* Get the required length, allocate the buffer and do it for real. */", "    did_emsg = FALSE;", "    fmt = (char *)get_tv_string_buf(&argvars[0], buf);"], "readability/bool"]
["src/nvim/eval.c", ["  long i;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    EMSG(_(\"E727: Start past end\"));", "  else {", "    rettv_list_alloc(rettv);"], "readability/braces"]
["src/nvim/eval.c", ["{", "  int binary = FALSE;", "  char_u      *fname;"], "readability/bool"]
["src/nvim/eval.c", ["    if (STRCMP(get_tv_string(&argvars[1]), \"b\") == 0)", "      binary = TRUE;", "    if (argvars[2].v_type != VAR_UNKNOWN)"], "readability/bool"]
["src/nvim/eval.c", ["          break;", "      } else if (*p == NUL)", "        *p = '\\n';"], "readability/braces"]
["src/nvim/eval.c", ["            start = p + 1;", "          else {", "            /* have to shuffle buf to close gap */"], "readability/braces"]
["src/nvim/eval.c", ["            if (dest < buf) {", "              adjust_prevlen = (int)(buf - dest);               /* must be 1 or 2 */", "              dest = buf;"], "whitespace/line_length"]
["src/nvim/eval.c", ["      if (p - start + prevlen >= prevsize) {", "", "        /* A common use case is ordinary text files and \"prev\" gets a"], "whitespace/blank_line"]
["src/nvim/eval.c", ["          prevsize = (long)(p - start);", "        else {", "          long grow50pc = (prevsize * 3) / 2;"], "readability/braces"]
["src/nvim/eval.c", ["  union {", "    struct { varnumber_T low, high; } split;", "    proftime_T prof;"], "whitespace/newline"]
["src/nvim/eval.c", ["  union {", "    struct { varnumber_T low, high; } split;", "    proftime_T prof;"], "whitespace/newline"]
["src/nvim/eval.c", ["          EMSG2(_(e_dictkey), key);", "        else {", "          *rettv = di->di_tv;"], "readability/braces"]
["src/nvim/eval.c", ["    }", "  } else if (argvars[0].v_type != VAR_LIST)", "    EMSG2(_(e_listdictarg), \"remove()\");"], "readability/braces"]
["src/nvim/eval.c", ["           && !tv_check_lock(l->lv_lock, (char_u *)_(arg_errmsg))) {", "    int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    if (error)", "      ;                 /* type error: do nothing, errmsg already given */", "    else if ((item = list_find(l, idx)) == NULL)"], "whitespace/semicolon"]
["src/nvim/eval.c", ["      EMSGN(_(e_listidx), idx);", "    else {", "      if (argvars[2].v_type == VAR_UNKNOWN) {"], "readability/braces"]
["src/nvim/eval.c", ["        if (error)", "          ;                     /* type error: do nothing */", "        else if ((item2 = list_find(l, end)) == NULL)"], "whitespace/semicolon"]
["src/nvim/eval.c", ["          EMSGN(_(e_listidx), end);", "        else {", "          int cnt = 0;"], "readability/braces"]
["src/nvim/eval.c", ["            EMSG(_(e_invrange));", "          else {", "            vim_list_remove(l, item, item2);"], "readability/braces"]
["src/nvim/eval.c", ["    char_u  *q;", "    int is_relative_to_current = FALSE;", "    int has_trailing_pathsep = FALSE;"], "readability/bool"]
["src/nvim/eval.c", ["    int is_relative_to_current = FALSE;", "    int has_trailing_pathsep = FALSE;", "    int limit = 100;"], "readability/bool"]
["src/nvim/eval.c", ["                        || (p[1] == '.' && (vim_ispathsep(p[2])))))", "      is_relative_to_current = TRUE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    if (len > 0 && after_pathsep((char *)p, (char *)p + len)) {", "      has_trailing_pathsep = TRUE;", "      p[len - 1] = NUL;       /* the trailing slash breaks readlink() */"], "readability/bool"]
["src/nvim/eval.c", ["        STRMOVE(remain, q - 1);", "      else {", "        xfree(remain);"], "readability/braces"]
["src/nvim/eval.c", ["          dir = 0;", "        } else", "          *flagsp |= mask;"], "readability/braces"]
["src/nvim/eval.c", ["  else", "    curwin->w_set_curswant = TRUE;", "theend:"], "readability/bool"]
["src/nvim/eval.c", ["    c = -1;", "  else {", "    off = LineOffset[row] + col;"], "readability/braces"]
["src/nvim/eval.c", ["  int thisblock = 0;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    skip = (char_u *)\"\";", "  else {", "    skip = get_tv_string_buf_chk(&argvars[4], nbuf3);"], "readability/braces"]
["src/nvim/eval.c", [" */", "long ", "do_searchpair ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["long ", "do_searchpair (", "    char_u *spat,          /* start pattern */"], "whitespace/parens"]
["src/nvim/eval.c", ["  pat3 = xmalloc(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 23);", "  sprintf((char *)pat2, \"\\\\(%s\\\\m\\\\)\\\\|\\\\(%s\\\\m\\\\)\", spat, epat);", "  if (*mpat == NUL)"], "runtime/printf"]
["src/nvim/eval.c", ["  else", "    sprintf((char *)pat3, \"\\\\(%s\\\\m\\\\)\\\\|\\\\(%s\\\\m\\\\)\\\\|\\\\(%s\\\\m\\\\)\",", "        spat, epat, mpat);"], "runtime/printf"]
["src/nvim/eval.c", ["      curwin->w_cursor = pos;", "      r = eval_to_bool(skip, &err, NULL, FALSE);", "      curwin->w_cursor = save_pos;"], "readability/bool"]
["src/nvim/eval.c", ["  varname = get_tv_string_chk(&argvars[1]);", "  buf = get_buf_tv(&argvars[0], FALSE);", "  varp = &argvars[2];"], "readability/bool"]
["src/nvim/eval.c", ["      char_u      *strval;", "      int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      STRCPY(bufvarname + 2, varname);", "      set_var(bufvarname, varp, TRUE);", "      xfree(bufvarname);"], "readability/bool"]
["src/nvim/eval.c", ["  if ((d = argvars[0].vval.v_dict) != NULL) {", "    csearch = get_dict_string(d, (char_u *)\"char\", FALSE);", "    if (csearch != NULL) {"], "readability/bool"]
["src/nvim/eval.c", ["      }", "      else", "        set_last_csearch(PTR2CHAR(csearch),"], "whitespace/newline"]
["src/nvim/eval.c", ["    li = l->lv_first;", "  } else", "    line = get_tv_string_chk(&argvars[1]);"], "readability/braces"]
["src/nvim/eval.c", ["      u_sync_once = 1;       /* notify that u_sync() was called */", "      u_sync(TRUE);", "    }"], "readability/bool"]
["src/nvim/eval.c", ["      /* existing line, replace it */", "      if (u_savesub(lnum) == OK && ml_replace(lnum, line, TRUE) == OK) {", "        changed_bytes(lnum, 0);"], "readability/bool"]
["src/nvim/eval.c", ["      ++added;", "      if (ml_append(lnum - 1, line, (colnr_T)0, FALSE) == OK)", "        rettv->vval.v_number = 0;               /* OK */"], "readability/bool"]
["src/nvim/eval.c", [" */", "static void set_qf_ll_list(win_T *wp, typval_T *list_arg, typval_T *action_arg, typval_T *rettv)", "{"], "whitespace/line_length"]
["src/nvim/eval.c", ["    EMSG(_(e_listreq));", "  else {", "    list_T  *l = list_arg->vval.v_list;"], "readability/braces"]
["src/nvim/eval.c", ["  if ((l = argvars[0].vval.v_list) != NULL) {", "", "    /* To some extent make sure that we are dealing with a list from"], "whitespace/blank_line"]
["src/nvim/eval.c", ["      d = li->li_tv.vval.v_dict;", "      match_add(curwin, get_dict_string(d, (char_u *)\"group\", FALSE),", "          get_dict_string(d, (char_u *)\"pattern\", FALSE),"], "readability/bool"]
["src/nvim/eval.c", ["      match_add(curwin, get_dict_string(d, (char_u *)\"group\", FALSE),", "          get_dict_string(d, (char_u *)\"pattern\", FALSE),", "          (int)get_dict_number(d, (char_u *)\"priority\"),"], "readability/bool"]
["src/nvim/eval.c", ["          rettv->vval.v_number = 0;", "        } else", "          EMSG(_(e_invarg));"], "readability/braces"]
["src/nvim/eval.c", ["          rettv->vval.v_number = 0;", "      } else", "        EMSG(_(e_invarg));"], "readability/braces"]
["src/nvim/eval.c", ["    save_curtab = curtab;", "    goto_tabpage_tp(tp, FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/eval.c", ["    STRCPY(tabvarname + 2, varname);", "    set_var(tabvarname, varp, TRUE);", "    xfree(tabvarname);"], "readability/bool"]
["src/nvim/eval.c", ["    if (valid_tabpage(save_curtab))", "      goto_tabpage_tp(save_curtab, FALSE, FALSE);", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  if (win != NULL && varname != NULL && varp != NULL", "      && switch_win(&save_curwin, &save_curtab, win, tp, TRUE) == OK) {", "    if (*varname == '&') {"], "readability/bool"]
["src/nvim/eval.c", ["      char_u      *strval;", "      int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      STRCPY(winvarname + 2, varname);", "      set_var(winvarname, varp, TRUE);", "      xfree(winvarname);"], "readability/bool"]
["src/nvim/eval.c", ["    }", "    restore_win(save_curwin, save_curtab, TRUE);", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  res = call_func(item_compare_func, (int)STRLEN(item_compare_func),", "      &rettv, 2, argv, 0L, 0L, &dummy, TRUE,", "      item_compare_selfdict);"], "readability/bool"]
["src/nvim/eval.c", ["", "    item_compare_ic = FALSE;", "    item_compare_numeric = false;"], "readability/bool"]
["src/nvim/eval.c", ["      } else {", "        int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["        if (i == 1)", "          item_compare_ic = TRUE;", "        else"], "readability/bool"]
["src/nvim/eval.c", ["            item_compare_func = NULL;", "            item_compare_ic = TRUE;", "          }"], "readability/bool"]
["src/nvim/eval.c", ["", "      item_compare_func_err = FALSE;", "      // Test the compare function."], "readability/bool"]
["src/nvim/eval.c", ["      // f_uniq(): ptrs will be a stack of items to remove.", "      item_compare_func_err = FALSE;", "      item_compare_func_ptr = item_compare_func ? item_compare2_keeping_zero :"], "readability/bool"]
["src/nvim/eval.c", ["", "      for (li = l->lv_first; li != NULL && li->li_next != NULL; li = li->li_next) {", "        if (item_compare_func_ptr(&li, &li->li_next) == 0) {"], "whitespace/line_length"]
["src/nvim/eval.c", ["    /* Find the start and length of the badly spelled word. */", "    len = spell_move_to(curwin, FORWARD, TRUE, TRUE, &attr);", "    if (len != 0)"], "readability/bool"]
["src/nvim/eval.c", ["  char_u      *str;", "  int typeerr = FALSE;", "  int maxcount;"], "readability/bool"]
["src/nvim/eval.c", ["      }", "    } else", "      maxcount = 25;"], "readability/braces"]
["src/nvim/eval.c", ["  colnr_T col = 0;", "  int keepempty = FALSE;", "  int typeerr = FALSE;"], "readability/bool"]
["src/nvim/eval.c", ["  int keepempty = FALSE;", "  int typeerr = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    if (pat == NULL)", "      typeerr = TRUE;", "    if (argvars[2].v_type != VAR_UNKNOWN)"], "readability/bool"]
["src/nvim/eval.c", ["  if (regmatch.regprog != NULL) {", "    regmatch.rm_ic = FALSE;", "    while (*str != NUL || keepempty) {"], "readability/bool"]
["src/nvim/eval.c", ["      if (*str == NUL)", "        match = FALSE;          /* empty item at the end */", "      else"], "readability/bool"]
["src/nvim/eval.c", ["        col = 0;", "      else {", "        /* Don't get stuck at the same match. */"], "readability/braces"]
["src/nvim/eval.c", ["    rettv->vval.v_string = vim_strsave((char_u *)_(\"(Invalid)\"));", "  else {", "    vimconv_T conv;"], "readability/braces"]
["src/nvim/eval.c", ["  if (argvars[2].v_type != VAR_UNKNOWN) {", "    int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  int slen;", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    n = 0;", "  } else if (n > slen)", "    n = slen;"], "readability/braces"]
["src/nvim/eval.c", ["      return;           /* can never find a match */", "  } else", "    end_idx = haystack_len;"], "readability/braces"]
["src/nvim/eval.c", ["{", "  int error = FALSE;", "  int no = (int)get_tv_number_chk(&argvars[0], &error);"], "readability/bool"]
["src/nvim/eval.c", ["  int trans;", "  int transerr = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      && col >= 0 && col < (long)STRLEN(ml_get(lnum)))", "    id = syn_get_id(curwin, lnum, (colnr_T)col, trans, NULL, FALSE);", ""], "readability/bool"]
["src/nvim/eval.c", ["      && col <= (long)STRLEN(ml_get(lnum)) && curwin->w_p_cole > 0) {", "    (void)syn_get_id(curwin, lnum, col, FALSE, NULL, FALSE);", "    syntax_flags = get_syntax_info(&matchid);"], "readability/bool"]
["src/nvim/eval.c", ["    rettv_list_alloc(rettv);", "    (void)syn_get_id(curwin, lnum, (colnr_T)col, FALSE, NULL, TRUE);", ""], "readability/bool"]
["src/nvim/eval.c", ["", "static void get_system_output_as_rettv(typval_T *argvars, typval_T *rettv, ", "                                       bool retlist)"], "whitespace/end_of_line"]
["src/nvim/eval.c", ["    wp = firstwin;", "  else {", "    tp = find_tabpage((int)get_tv_number(&argvars[0]));"], "readability/braces"]
["src/nvim/eval.c", ["    }", "  } else", "    nr = tabpage_index(curtab);"], "readability/braces"]
["src/nvim/eval.c", ["", "  int first = TRUE;", "  while (get_tagfname(&tn, first, fname) == OK) {"], "readability/bool"]
["src/nvim/eval.c", ["    list_append_string(rettv->vval.v_list, fname, -1);", "    first = FALSE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["", "  rettv->vval.v_number = FALSE;", "  if (*tag_pattern == NUL)"], "readability/bool"]
["src/nvim/eval.c", ["      p += l;", "    } else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)", "      p += l;                 /* skip multi-byte character */"], "readability/braces"]
["src/nvim/eval.c", ["      p += l;                 /* skip multi-byte character */", "    else {", "      *p = TOLOWER_LOC(*p);         /* note that tolower() can be a macro */"], "readability/braces"]
["src/nvim/eval.c", ["  int cplen;", "  int first = TRUE;", "  char_u buf[NUMBUFLEN];"], "readability/bool"]
["src/nvim/eval.c", ["         * of in_str doesn't appear in fromstr. */", "        first = FALSE;", "        for (p = tostr; *p != NUL; p += tolen) {"], "readability/bool"]
["src/nvim/eval.c", ["", "  fp = var2fpos(&argvars[0], FALSE, &fnum);", "  if (fp != NULL && fp->lnum <= curbuf->b_ml.ml_line_count"], "readability/bool"]
["src/nvim/eval.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    sprintf((char *)buf, \"%dresize %d|\", winnr, wp->w_height);", "    ga_concat(&ga, buf);"], "runtime/printf"]
["src/nvim/eval.c", ["    ga_concat(&ga, buf);", "    sprintf((char *)buf, \"vert %dresize %d|\", winnr, wp->w_width);", "    ga_concat(&ga, buf);"], "runtime/printf"]
["src/nvim/eval.c", ["    EMSG(_(e_invarg));", "  else {", "    if (dict_find(dict, (char_u *)\"lnum\", -1) != NULL) {"], "readability/braces"]
["src/nvim/eval.c", ["      curwin->w_curswant = get_dict_number(dict, (char_u *)\"curswant\");", "      curwin->w_set_curswant = FALSE;", "    }"], "readability/bool"]
["src/nvim/eval.c", ["static pos_T *", "var2fpos (", "    typval_T *varp,"], "whitespace/parens"]
["src/nvim/eval.c", ["    int len;", "    int error = FALSE;", "    listitem_T      *li;"], "readability/bool"]
["src/nvim/eval.c", ["  if (name[0] == '\\'') {                        /* mark */", "    pp = getmark_buf_fnum(curbuf, name[1], FALSE, fnum);", "    if (pp == NULL || pp == (pos_T *)-1 || pp->lnum <= 0)"], "readability/bool"]
["src/nvim/eval.c", ["  for (p = *arg; vim_isIDc(*p); ++p)", "    ;", "  if (p == *arg)            /* no name found */"], "whitespace/semicolon"]
["src/nvim/eval.c", ["  for (p = *arg; eval_isnamec(*p); ++p)", "    ;", "  if (p == *arg)            /* no name found */"], "whitespace/semicolon"]
["src/nvim/eval.c", [" */", "static char_u *find_name_end(char_u *arg, char_u **expr_start, char_u **expr_end, int flags)", "{"], "whitespace/line_length"]
["src/nvim/eval.c", ["      for (p = p + 1; *p != NUL && *p != '\\''; mb_ptr_adv(p))", "        ;", "      if (*p == NUL)"], "whitespace/semicolon"]
["src/nvim/eval.c", [" */", "static char_u *make_expanded_name(char_u *in_start, char_u *expr_start, char_u *expr_end, char_u *in_end)", "{"], "whitespace/line_length"]
["src/nvim/eval.c", ["", "  temp_result = eval_to_string(expr_start + 1, &nextcmd, FALSE);", "  if (temp_result != NULL && nextcmd == NULL) {"], "readability/bool"]
["src/nvim/eval.c", ["    buf[(*mb_char2bytes)(c, buf)] = NUL;", "  else {", "    buf[0] = c;"], "readability/braces"]
["src/nvim/eval.c", [" */", "void set_vim_var_string (", "    int idx,"], "whitespace/parens"]
["src/nvim/eval.c", ["  if (eap->force_bin == FORCE_BIN)", "    sprintf((char *)newval, \" ++bin\");", "  else if (eap->force_bin == FORCE_NOBIN)"], "runtime/printf"]
["src/nvim/eval.c", ["  else if (eap->force_bin == FORCE_NOBIN)", "    sprintf((char *)newval, \" ++nobin\");", "  else"], "runtime/printf"]
["src/nvim/eval.c", ["  if (eap->force_ff != 0)", "    sprintf((char *)newval + STRLEN(newval), \" ++ff=%s\",", "        eap->cmd + eap->force_ff);"], "runtime/printf"]
["src/nvim/eval.c", ["  if (eap->force_enc != 0)", "    sprintf((char *)newval + STRLEN(newval), \" ++enc=%s\",", "        eap->cmd + eap->force_enc);"], "runtime/printf"]
["src/nvim/eval.c", ["  else if (eap->bad_char != 0)", "    sprintf((char *)newval + STRLEN(newval), \" ++bad=%c\", eap->bad_char);", "  vimvars[VV_CMDARG].vv_str = newval;"], "runtime/printf"]
["src/nvim/eval.c", [" */", "static int ", "get_var_tv ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "get_var_tv (", "    char_u *name,"], "whitespace/parens"]
["src/nvim/eval.c", ["   */", "  else {", "    v = find_var(name, NULL, no_autoload);"], "whitespace/newline"]
["src/nvim/eval.c", ["   */", "  else {", "    v = find_var(name, NULL, no_autoload);"], "readability/braces"]
["src/nvim/eval.c", ["    ret = FAIL;", "  } else if (rettv != NULL)", "    copy_tv(tv, rettv);"], "readability/braces"]
["src/nvim/eval.c", [" */", "static int ", "handle_subscript ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "handle_subscript (", "    char_u **arg,"], "whitespace/parens"]
["src/nvim/eval.c", ["        s = functv.vval.v_string;", "      } else", "        s = (char_u *)\"\";"], "readability/braces"]
["src/nvim/eval.c", ["          ++selfdict->dv_refcount;", "      } else", "        selfdict = NULL;"], "readability/braces"]
["src/nvim/eval.c", ["{", "  int error = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      vim_str2nr(varp->vval.v_string, NULL, NULL,", "          TRUE, TRUE, &n, NULL);", "    return n;"], "readability/bool"]
["src/nvim/eval.c", ["  else", "    *denote = TRUE;", "  return n;"], "readability/bool"]
["src/nvim/eval.c", ["  case VAR_NUMBER:", "    sprintf((char *)buf, \"%\" PRId64, (int64_t)varp->vval.v_number);", "    return buf;"], "runtime/printf"]
["src/nvim/eval.c", [" */", "static dictitem_T *find_var_in_ht(hashtab_T *ht, int htname, char_u *varname, int no_autoload)", "{"], "whitespace/line_length"]
["src/nvim/eval.c", ["       * be obtained again or not used. */", "      if (!script_autoload(varname, FALSE) || aborting())", "        return NULL;"], "readability/bool"]
["src/nvim/eval.c", ["", "  v = find_var(name, NULL, FALSE);", "  if (v == NULL)"], "readability/bool"]
["src/nvim/eval.c", ["{", "  vars_clear_ext(ht, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "static void ", "list_one_var_a ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static void ", "list_one_var_a (", "    char_u *prefix,"], "whitespace/parens"]
["src/nvim/eval.c", ["      ++string;", "  } else", "    msg_putchar(' ');"], "readability/braces"]
["src/nvim/eval.c", ["    msg_clr_eos();", "    *first = FALSE;", "  }"], "readability/bool"]
["src/nvim/eval.c", [" */", "static void ", "set_var ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static void ", "set_var (", "    char_u *name,"], "whitespace/parens"]
["src/nvim/eval.c", ["  }", "  v = find_var_in_ht(ht, 0, varname, TRUE);", ""], "readability/bool"]
["src/nvim/eval.c", ["          v->di_tv.vval.v_string = vim_strsave(get_tv_string(tv));", "        else {", "          /* Take over the string to avoid an extra alloc/free. */"], "readability/braces"]
["src/nvim/eval.c", ["        }", "      } else if (v->di_tv.v_type != VAR_NUMBER)", "        EMSG2(_(e_intern2), \"set_var()\");"], "readability/braces"]
["src/nvim/eval.c", ["        EMSG2(_(e_intern2), \"set_var()\");", "      else {", "        v->di_tv.vval.v_number = get_tv_number(tv);"], "readability/braces"]
["src/nvim/eval.c", ["    EMSG2(_(e_readonlyvar), name);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["    EMSG2(_(e_readonlysbx), name);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["    EMSG2(_(\"E795: Cannot delete variable %s\"), name);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/eval.c", [" */", "static int ", "var_check_func_name ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "var_check_func_name (", "    char_u *name,        /* points to start of variable name */"], "whitespace/parens"]
["src/nvim/eval.c", ["    EMSG2(_(\"E704: Funcref variable name must start with a capital: %s\"), name);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["        name);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["      EMSG2(_(e_illvar), varname);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/eval.c", ["    }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["        name == NULL ? (char_u *)_(\"Unknown\") : name);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["        name == NULL ? (char_u *)_(\"Unknown\") : name);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["      to->vval.v_string = NULL;", "    else {", "      to->vval.v_string = vim_strsave(from->vval.v_string);"], "readability/braces"]
["src/nvim/eval.c", ["      to->vval.v_list = NULL;", "    else {", "      to->vval.v_list = from->vval.v_list;"], "readability/braces"]
["src/nvim/eval.c", ["      to->vval.v_dict = NULL;", "    else {", "      to->vval.v_dict = from->vval.v_dict;"], "readability/braces"]
["src/nvim/eval.c", ["        EMSG2(_(e_invexpr2), p);", "      need_clr_eos = FALSE;", "      break;"], "readability/bool"]
["src/nvim/eval.c", ["    }", "    need_clr_eos = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["        }", "      } else if (eap->cmdidx == CMD_echo)", "        msg_puts_attr((char_u *)\" \", echo_attr);"], "readability/braces"]
["src/nvim/eval.c", ["              p += i - 1;", "            } else", "              (void)msg_outtrans_len_attr(p, 1, echo_attr);"], "readability/braces"]
["src/nvim/eval.c", ["    --emsg_skip;", "  else {", "    /* remove text that may still be there from the command */"], "readability/braces"]
["src/nvim/eval.c", ["        did_emsg = save_did_emsg;", "    } else if (eap->cmdidx == CMD_execute)", "      do_cmdline((char_u *)ga.ga_data,"], "readability/braces"]
["src/nvim/eval.c", ["    p += 2;", "  } else", "    *opt_flags = 0;"], "readability/braces"]
["src/nvim/eval.c", ["  garray_T newlines;", "  int varargs = FALSE;", "  int mustend = FALSE;"], "readability/bool"]
["src/nvim/eval.c", ["  int varargs = FALSE;", "  int mustend = FALSE;", "  int flags = 0;"], "readability/bool"]
["src/nvim/eval.c", ["          if (!isdigit(*fp->uf_name))", "            list_func_head(fp, FALSE);", "        }"], "readability/bool"]
["src/nvim/eval.c", ["  if (*eap->arg == '/') {", "    p = skip_regexp(eap->arg + 1, '/', TRUE, NULL);", "    if (!eap->skip) {"], "readability/bool"]
["src/nvim/eval.c", ["                && vim_regexec(&regmatch, fp->uf_name, 0))", "              list_func_head(fp, FALSE);", "          }"], "readability/bool"]
["src/nvim/eval.c", ["      return;", "    } else", "      eap->skip = TRUE;"], "readability/braces"]
["src/nvim/eval.c", ["    } else", "      eap->skip = TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  saved_did_emsg = did_emsg;", "  did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      if (fp != NULL) {", "        list_func_head(fp, TRUE);", "        for (int j = 0; j < fp->uf_lines.ga_len && !got_int; ++j) {"], "readability/bool"]
["src/nvim/eval.c", ["            msg_putchar(' ');", "          msg_prt_line(FUNCLINE(fp, j), FALSE);", "          ui_flush();                  /* show a line at a time */"], "readability/bool"]
["src/nvim/eval.c", ["        }", "      } else", "        emsg_funcname(N_(\"E123: Undefined function: %s\"), name);"], "readability/braces"]
["src/nvim/eval.c", ["    if (p[0] == '.' && p[1] == '.' && p[2] == '.') {", "      varargs = TRUE;", "      p += 3;"], "readability/bool"]
["src/nvim/eval.c", ["      p += 3;", "      mustend = TRUE;", "    } else {"], "readability/bool"]
["src/nvim/eval.c", ["      else", "        mustend = TRUE;", "    }"], "readability/bool"]
["src/nvim/eval.c", ["      p += 5;", "    } else", "      break;"], "readability/braces"]
["src/nvim/eval.c", ["    if (KeyTyped) {", "      msg_scroll = TRUE;", "      saved_wait_return = FALSE;"], "readability/bool"]
["src/nvim/eval.c", ["      msg_scroll = TRUE;", "      saved_wait_return = FALSE;", "    }"], "readability/bool"]
["src/nvim/eval.c", ["    }", "    need_wait_return = FALSE;", "    sourcing_lnum_off = sourcing_lnum;"], "readability/bool"]
["src/nvim/eval.c", ["        line_arg += STRLEN(line_arg);", "      else {", "        *p = NUL;"], "readability/braces"]
["src/nvim/eval.c", ["      }", "    } else if (eap->getline == NULL)", "      theline = getcmdline(':', 0L, indent);"], "readability/braces"]
["src/nvim/eval.c", ["      for (p = theline; ascii_iswhite(*p) || *p == ':'; ++p)", "        ;", ""], "whitespace/semicolon"]
["src/nvim/eval.c", ["        p += eval_fname_script(p);", "        xfree(trans_function_name(&p, TRUE, 0, NULL));", "        if (*skipwhite(p) == '(') {"], "readability/bool"]
["src/nvim/eval.c", ["                  && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))", "              )) {", "        /* \":python <<\" continues until a dot, like \":append\" */"], "whitespace/parens"]
["src/nvim/eval.c", ["  if (fudi.fd_dict == NULL) {", "    v = find_var(name, &ht, FALSE);", "    if (v != NULL && v->di_tv.v_type == VAR_FUNC) {"], "readability/bool"]
["src/nvim/eval.c", ["    /* Can't change an existing function if it is locked */", "    else if (tv_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg))", "      goto erret;"], "whitespace/newline"]
["src/nvim/eval.c", ["    xfree(name);", "    sprintf(numbuf, \"%d\", ++func_nr);", "    name = vim_strsave((char_u *)numbuf);"], "runtime/printf"]
["src/nvim/eval.c", ["        }", "      } else", "        /* overwrite existing dict entry */"], "readability/braces"]
["src/nvim/eval.c", ["  fp->uf_tml_self = NULL;", "  fp->uf_profiling = FALSE;", "  if (prof_def_func())"], "readability/bool"]
["src/nvim/eval.c", ["static char_u *", "trans_function_name (", "    char_u **pp,"], "whitespace/parens"]
["src/nvim/eval.c", ["  /* Note that TFN_ flags use the same values as GLV_ flags. */", "  end = get_lval(start, NULL, &lv, FALSE, skip, flags,", "      lead > 2 ? 0 : FNE_CHECK_START);"], "readability/bool"]
["src/nvim/eval.c", ["        EMSG2(_(e_invarg2), start);", "    } else", "      *pp = find_name_end(start, NULL, NULL, FNE_INCL_BR);"], "readability/braces"]
["src/nvim/eval.c", ["      }", "      sprintf((char *)sid_buf, \"%\" PRId64 \"_\", (int64_t)current_SID);", "      lead += (int)STRLEN(sid_buf);"], "runtime/printf"]
["src/nvim/eval.c", ["  name = xmalloc(len + lead + 1);", "  if (lead > 0){", "    name[0] = K_SPECIAL;"], "whitespace/braces"]
["src/nvim/eval.c", ["    msg_puts(fp->uf_name + 3);", "  } else", "    msg_puts(fp->uf_name);"], "readability/braces"]
["src/nvim/eval.c", ["  char_u  *p;", "  int n = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["", "  p = trans_function_name(&nm, FALSE, TFN_INT|TFN_QUIET|TFN_NO_AUTOLOAD,", "      NULL);"], "readability/bool"]
["src/nvim/eval.c", ["  if (!ASCII_ISLOWER(name[0])) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["", "  fp->uf_profiling = TRUE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["          prof_func_line(fd, fp->uf_tml_count[i],", "              &fp->uf_tml_total[i], &fp->uf_tml_self[i], TRUE);", "          fprintf(fd, \"%s\\n\", FUNCLINE(fp, i));"], "readability/bool"]
["src/nvim/eval.c", ["        prof_total_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"TOTAL\", FALSE);", "    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),"], "readability/bool"]
["src/nvim/eval.c", ["        prof_self_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"SELF\", TRUE);", "  }"], "readability/bool"]
["src/nvim/eval.c", ["", "static void ", "prof_sort_list ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static void ", "prof_sort_list (", "    FILE *fd,"], "whitespace/parens"]
["src/nvim/eval.c", ["      fprintf(fd, \"%s \", profile_msg(*self));", "  } else", "    fprintf(fd, \"                            \");"], "readability/braces"]
["src/nvim/eval.c", [" */", "static int ", "script_autoload ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static int ", "script_autoload (", "    char_u *name,"], "whitespace/parens"]
["src/nvim/eval.c", ["  char_u      *scriptname, *tofree;", "  int ret = FALSE;", "  int i;"], "readability/bool"]
["src/nvim/eval.c", ["  if (p == NULL || p == name)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  if (!reload && i < ga_loaded.ga_len)", "    ret = FALSE;            /* was loaded already */", "  else {"], "readability/bool"]
["src/nvim/eval.c", ["    ret = FALSE;            /* was loaded already */", "  else {", "    /* Remember the name if it wasn't loaded already. */"], "readability/braces"]
["src/nvim/eval.c", ["    /* Try loading the package from $VIMRUNTIME/autoload/<name>.vim */", "    if (source_runtime(scriptname, FALSE) == OK)", "      ret = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["    if (source_runtime(scriptname, FALSE) == OK)", "      ret = TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["    STRCAT(buf, fp->uf_name + 3);", "  } else", "    STRCPY(buf, fp->uf_name);"], "readability/braces"]
["src/nvim/eval.c", ["      dictitem_remove(fudi.fd_dict, fudi.fd_di);", "    } else", "      func_free(fp);"], "readability/braces"]
["src/nvim/eval.c", [" */", "static void ", "call_user_func ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static void ", "call_user_func (", "    ufunc_T *fp,                /* pointer to function */"], "whitespace/parens"]
["src/nvim/eval.c", ["  fc->linenr = 0;", "  fc->returned = FALSE;", "  fc->level = ex_nesting_level;"], "readability/bool"]
["src/nvim/eval.c", ["  /* Check if this function has a breakpoint. */", "  fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);", "  fc->dbg_tick = debug_tick;"], "readability/bool"]
["src/nvim/eval.c", ["      name = FUNCARG(fp, i);", "    else {", "      /* \"...\" argument a:1, a:2, etc. */"], "readability/braces"]
["src/nvim/eval.c", ["      /* \"...\" argument a:1, a:2, etc. */", "      sprintf((char *)numbuf, \"%d\", ai + 1);", "      name = numbuf;"], "runtime/printf"]
["src/nvim/eval.c", ["  sourcing_lnum = 1;", "  sourcing_name = xmalloc((save_sourcing_name == NULL ? 0 : STRLEN(save_sourcing_name))", "                          + STRLEN(fp->uf_name) + 13);"], "whitespace/line_length"]
["src/nvim/eval.c", ["        && STRNCMP(save_sourcing_name, \"function \", 9) == 0)", "      sprintf((char *)sourcing_name, \"%s..\", save_sourcing_name);", "    else"], "runtime/printf"]
["src/nvim/eval.c", ["    do_profiling == PROF_YES", "    && !fp->uf_profiling && has_profiling(FALSE, fp->uf_name, NULL);", ""], "readability/bool"]
["src/nvim/eval.c", ["  save_did_emsg = did_emsg;", "  did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["           sourcing_name, (int64_t)fc->rettv->vval.v_number);", "    else {", "      char_u buf[MSG_BUF_LEN];"], "readability/braces"]
["src/nvim/eval.c", ["      && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT) {", "    free_funccal(fc, FALSE);", "  } else {"], "readability/bool"]
["src/nvim/eval.c", [" */", "static void ", "free_funccal ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["static void ", "free_funccal (", "    funccall_T *fc,"], "whitespace/parens"]
["src/nvim/eval.c", ["  typval_T rettv;", "  int returning = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["    if (!eap->skip)", "      returning = do_return(eap, FALSE, TRUE, &rettv);", "    else"], "readability/bool"]
["src/nvim/eval.c", ["  /* It's safer to return also on error. */", "  else if (!eap->skip) {", "    /*"], "whitespace/newline"]
["src/nvim/eval.c", ["    if (!aborting())", "      returning = do_return(eap, FALSE, TRUE, NULL);", "  }"], "readability/bool"]
["src/nvim/eval.c", ["    /* Undo the return. */", "    current_funccal->returned = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["   */", "  idx = cleanup_conditionals(eap->cstack, 0, TRUE);", "  if (idx >= 0) {"], "readability/bool"]
["src/nvim/eval.c", ["      cstack->cs_rettv[idx] = rettv;", "    else {", "      /* When undoing a return in order to make it pending, get the stored"], "readability/braces"]
["src/nvim/eval.c", ["        *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;", "      } else", "        cstack->cs_rettv[idx] = NULL;"], "readability/braces"]
["src/nvim/eval.c", ["  } else {", "    current_funccal->returned = TRUE;", ""], "readability/bool"]
["src/nvim/eval.c", ["  if (fcp->dbg_tick != debug_tick) {", "    fcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,", "        sourcing_lnum);"], "readability/bool"]
["src/nvim/eval.c", ["    retval = NULL;", "  else {", "    /* Skip NULL lines (continuation lines). */"], "readability/braces"]
["src/nvim/eval.c", ["      retval = NULL;", "    else {", "      retval = vim_strsave(((char_u **)(gap->ga_data))[fcp->linenr++]);"], "readability/braces"]
["src/nvim/eval.c", ["    /* Find next breakpoint. */", "    fcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,", "        sourcing_lnum);"], "readability/bool"]
["src/nvim/eval.c", ["      --fp->uf_tml_idx;", "    fp->uf_tml_execed = FALSE;", "    fp->uf_tml_start = profile_start();"], "readability/bool"]
["src/nvim/eval.c", ["  if (fp->uf_profiling && fp->uf_tml_idx >= 0)", "    fp->uf_tml_execed = TRUE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["    msg((char_u *)_(\"No old files\"));", "  else {", "    msg_start();"], "readability/braces"]
["src/nvim/eval.c", ["    msg_start();", "    msg_scroll = TRUE;", "    for (li = l->lv_first; li != NULL && !got_int; li = li->li_next) {"], "readability/bool"]
["src/nvim/eval.c", ["    /* Assume \"got_int\" was set to truncate the listing. */", "    got_int = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", [" */", "int ", "modify_fname ("], "whitespace/end_of_line"]
["src/nvim/eval.c", ["int ", "modify_fname (", "    char_u *src,               /* string with modifiers */"], "whitespace/parens"]
["src/nvim/eval.c", ["      else", "        p = pbuf = (char_u *)FullName_save((char *)*fnamep, FALSE);", "    } else"], "readability/bool"]
["src/nvim/eval.c", ["        p = pbuf = (char_u *)FullName_save((char *)*fnamep, FALSE);", "    } else", "      p = *fnamep;"], "readability/braces"]
["src/nvim/eval.c", ["      } else {", "        home_replace(NULL, p, dirname, MAXPATHL, TRUE);", "        /* Only replace it when it starts with '~' */"], "readability/bool"]
["src/nvim/eval.c", ["        *fnamep = s + 1;", "      } else if (*fnamep <= tail)", "        *fnamelen = 0;"], "readability/braces"]
["src/nvim/eval.c", ["    char_u      *flags;", "    int didit = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["          *bufp = s;", "          didit = TRUE;", "          xfree(sub);"], "readability/bool"]
["src/nvim/eval.c", ["       */", "      sublen = vim_regsub(&regmatch, sub, tail, FALSE, TRUE, FALSE);", "      ga_grow(&ga, (int)((end - tail) + sublen -"], "readability/bool"]
["src/nvim/eval.c", ["      (void)vim_regsub(&regmatch, sub, (char_u *)ga.ga_data", "          + ga.ga_len + i, TRUE, TRUE, FALSE);", "      ga.ga_len += i + sublen - 1;"], "readability/bool"]
["src/nvim/eval.c", ["  provider_call_nesting--;", "  ", "  return rettv;"], "whitespace/end_of_line"]
["src/nvim/eval.c", ["{", "", "#define check_provider(name)                                              \\"], "whitespace/blank_line"]
["src/nvim/ex_cmds2.c", ["", "static int debug_greedy = FALSE;        /* batch mode debugging: don't save", "                                           and restore typeahead. */"], "readability/multiline_comment"]
["src/nvim/ex_cmds2.c", ["", "static int debug_greedy = FALSE;        /* batch mode debugging: don't save", "                                           and restore typeahead. */"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  tasave_T typeaheadbuf;", "  int typeahead_saved = FALSE;", "  int save_ignore_script = 0;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  ++no_wait_return;             /* don't wait for return */", "  did_emsg = FALSE;             /* don't use error from debugged stuff */", "  cmd_silent = FALSE;           /* display commands */"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  did_emsg = FALSE;             /* don't use error from debugged stuff */", "  cmd_silent = FALSE;           /* display commands */", "  msg_silent = FALSE;           /* display messages */"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  cmd_silent = FALSE;           /* display commands */", "  msg_silent = FALSE;           /* display messages */", "  emsg_silent = FALSE;          /* display error messages */"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  msg_silent = FALSE;           /* display messages */", "  emsg_silent = FALSE;          /* display error messages */", "  redir_off = TRUE;             /* don't redirect debug commands */"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  emsg_silent = FALSE;          /* display error messages */", "  redir_off = TRUE;             /* don't redirect debug commands */", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  for (;; ) {", "    msg_scroll = TRUE;", "    need_wait_return = FALSE;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    msg_scroll = TRUE;", "    need_wait_return = FALSE;", "    /* Save the current typeahead buffer and replace it with an empty one."], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      save_typeahead(&typeaheadbuf);", "      typeahead_saved = TRUE;", "      save_ignore_script = ignore_script;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      save_ignore_script = ignore_script;", "      ignore_script = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["        case CMD_QUIT:", "          got_int = TRUE;", "          debug_break_level = -1;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["        case CMD_INTERRUPT:", "          got_int = TRUE;", "          debug_break_level = 9999;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  redraw_all_later(NOT_VALID);", "  need_wait_return = FALSE;", "  msg_scroll = save_msg_scroll;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["   * here. */", "  debug_did_msg = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["", "  debug_skipped = FALSE;", "  if (debug_breakpoint_name != NULL) {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    } else {", "      debug_skipped = TRUE;", "      debug_skipped_name = debug_breakpoint_name;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      do_debug(eap->cmd);", "    else {", "      debug_skipped = TRUE;"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["    else {", "      debug_skipped = TRUE;", "      debug_skipped_name = NULL;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    prev_got_int = got_int;", "    got_int = FALSE;", "    debug_breakpoint_name = debug_skipped_name;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    /* eap->skip is TRUE */", "    eap->skip = FALSE;", "    dbg_check_breakpoint(eap);"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    dbg_check_breakpoint(eap);", "    eap->skip = TRUE;", "    got_int |= prev_got_int;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    got_int |= prev_got_int;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds2.c", [" */", "static int ", "dbg_parsearg ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds2.c", ["static int ", "dbg_parsearg (", "    char_u *arg,"], "whitespace/parens"]
["src/nvim/ex_cmds2.c", ["  struct debuggy *bp;", "  int here = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    bp->dbg_type = DBG_FILE;", "    here = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    p = skipwhite(p);", "  } else", "    bp->dbg_lnum = 0;"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["    bp->dbg_name = vim_strsave(curbuf->b_ffname);", "  else {", "    /* Expand the file name in the same way as do_source().  This means"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["      xfree(p);", "    } else", "      bp->dbg_name = p;"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["", "    pat = file_pat_to_reg_pat(bp->dbg_name, NULL, NULL, FALSE);", "    if (pat != NULL) {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      xfree(bp->dbg_name);", "    else {", "      if (bp->dbg_lnum == 0)            /* default line number is 1 */"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["  if (eap->addr_count == 0 || eap->line2 != 0)", "    debug_greedy = TRUE;", "  else"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  else", "    debug_greedy = FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  int todel = -1;", "  int del_all = FALSE;", "  linenr_T best_lnum = 0;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    todel = 0;", "    del_all = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    EMSG2(_(\"E161: Breakpoint not found: %s\"), eap->arg);", "  else {", "    while (!GA_EMPTY(gap)) {"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["      if (bp->dbg_type == DBG_FILE)", "        home_replace(NULL, bp->dbg_name, NameBuff, MAXPATHL, TRUE);", "      smsg(_(\"%3d  %s %s  line %\" PRId64),"], "readability/bool"]
["src/nvim/ex_cmds2.c", [" */", "linenr_T ", "dbg_find_breakpoint ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds2.c", ["linenr_T ", "dbg_find_breakpoint (", "    int file,                   /* TRUE for a file, FALSE for a function */"], "whitespace/parens"]
["src/nvim/ex_cmds2.c", [" */", "int ", "has_profiling ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds2.c", ["int ", "has_profiling (", "    int file,                   /* TRUE for a file, FALSE for a function */"], "whitespace/parens"]
["src/nvim/ex_cmds2.c", [" */", "static linenr_T ", "debuggy_find ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds2.c", ["static linenr_T ", "debuggy_find (", "    int file,                   /* TRUE for a file, FALSE for a function */"], "whitespace/parens"]
["src/nvim/ex_cmds2.c", ["      prev_got_int = got_int;", "      got_int = FALSE;", "      if (vim_regexec_prog(&bp->dbg_prog, false, name, (colnr_T)0)) {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      EMSG2(_(e_notopen), profile_fname);", "    else {", "      script_dump_profile(fd);"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["  si->sn_prl_idx = -1;", "  si->sn_prof_on = TRUE;", "  si->sn_pr_nest = 0;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["        fprintf(fd, \"Cannot open file!\\n\");", "      else {", "        for (int i = 0; i < si->sn_prl_ga.ga_len; ++i) {"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["            fprintf(fd, \"%s \", profile_msg(pp->sn_prl_self));", "          } else", "            fprintf(fd, \"                            \");"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["    return SCRIPT_ITEM(current_SID).sn_pr_force;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    if (bufIsChanged(buf) && !buf->b_p_ro) {", "      (void)buf_write_all(buf, FALSE);", "      /* an autocommand may have deleted the buffer */"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["        /* Autocommand deleted buffer, oops!  It's not changed now. */", "        return FALSE;", "      dialog_changed(buf, count > 1);"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["        /* Autocommand deleted buffer, oops!  It's not changed now. */", "        return FALSE;", "      return bufIsChanged(buf);"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      EMSG(_(e_nowrtmsg_nobang));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds2.c", [" */", "void ", "dialog_changed ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds2.c", ["void ", "dialog_changed (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/ex_cmds2.c", ["   * function. */", "  ea.append = ea.forceit = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    if (buf->b_fname != NULL && check_overwrite(&ea, buf,", "            buf->b_fname, buf->b_ffname, FALSE) == OK)", "      /* didn't hit Cancel */"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      /* didn't hit Cancel */", "      (void)buf_write_all(buf, FALSE);", "  } else if (ret == VIM_NO) {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  } else if (ret == VIM_NO) {", "    unchanged(buf, TRUE);", "  } else if (ret == VIM_ALL) {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["        if (buf2->b_fname != NULL && check_overwrite(&ea, buf2,", "                buf2->b_fname, buf2->b_ffname, FALSE) == OK)", "          /* didn't hit Cancel */"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["          /* didn't hit Cancel */", "          (void)buf_write_all(buf2, FALSE);", "        /* an autocommand may have deleted the buffer */"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    FOR_ALL_BUFFERS(buf2) {", "      unchanged(buf2, TRUE);", "    }"], "readability/bool"]
["src/nvim/ex_cmds2.c", [" */", "int ", "check_changed_any ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds2.c", ["int ", "check_changed_any (", "    int hidden                     /* Only check hidden buffers */"], "whitespace/parens"]
["src/nvim/ex_cmds2.c", ["{", "  int ret = FALSE;", "  int save;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  if (bufcount == 0)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["", "  ret = TRUE;", "  exiting = FALSE;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  ret = TRUE;", "  exiting = FALSE;", "  /*"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      msg_col = 0;", "      msg_didout = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      save = no_wait_return;", "      no_wait_return = FALSE;", "      wait_return(FALSE);"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      no_wait_return = FALSE;", "      wait_return(FALSE);", "      no_wait_return = save;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["                (linenr_T)1, buf->b_ml.ml_line_count, NULL,", "                FALSE, forceit, TRUE, FALSE));", "  if (curbuf != old_curbuf) {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["", "  inbacktick = FALSE;", "  for (p = str; *str; ++str) {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      if (*str == '`')", "        inbacktick ^= TRUE;", "      *p++ = *str;"], "readability/bool"]
["src/nvim/ex_cmds2.c", [" */", "static int ", "do_arglist ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds2.c", ["static int ", "do_arglist (", "    char_u *str,"], "whitespace/parens"]
["src/nvim/ex_cmds2.c", ["      p = ((char_u **)new_ga.ga_data)[i];", "      p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);", "      if (p == NULL)"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["", "      didone = FALSE;", "      for (match = 0; match < ARGCOUNT; ++match)"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["                (colnr_T)0)) {", "          didone = TRUE;", "          xfree(ARGLIST[match].ae_fname);"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      xfree(exp_files);", "    } else   /* what == AL_SET */", "      alist_set(ALIST(curwin), exp_count, exp_files, FALSE, NULL, 0);"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["    } else   /* what == AL_SET */", "      alist_set(ALIST(curwin), exp_count, exp_files, FALSE, NULL, 0);", "  }"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["                            alist_name(&WARGLIST(win)[win->w_arg_idx]),", "                            win->w_buffer->b_ffname, TRUE) & kEqualFiles))));", "}"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["     * Set \"arg_had_last\" if we are editing the last one. */", "    win->w_arg_idx_invalid = TRUE;", "    if (win->w_arg_idx != WARGCOUNT(win) - 1"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    if (win->w_arg_idx != WARGCOUNT(win) - 1", "        && arg_had_last == FALSE", "        && ALIST(win) == &global_alist"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["                && (path_full_compare(alist_name(&GARGLIST[GARGCOUNT - 1]),", "                        win->w_buffer->b_ffname, TRUE) & kEqualFiles))))", "      arg_had_last = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["                        win->w_buffer->b_ffname, TRUE) & kEqualFiles))))", "      arg_had_last = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["     * Set \"arg_had_last\" if it's also the last one */", "    win->w_arg_idx_invalid = FALSE;", "    if (win->w_arg_idx == WARGCOUNT(win) - 1"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["        )", "      arg_had_last = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["       * required and no wait_return(). */", "      gotocmdline(TRUE);", "      for (int i = 0; i < ARGCOUNT; ++i) {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["       */", "      other = TRUE;", "      if (P_HID(curbuf)) {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["        )", "      arg_had_last = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      i = 0;", "    } else", "      i = curwin->w_arg_idx + (int)eap->line2;"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["      EMSG(_(e_invarg));", "    else {", "      for (int i = eap->line1; i <= eap->line2; ++i)"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["    }", "  } else if (*eap->arg == NUL)", "    EMSG(_(e_argreq));"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["    }", "    listcmd_busy = TRUE;            /* avoids setting pcmark below */", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["        assert(tp);", "        goto_tabpage_tp(tp, TRUE, TRUE);", "        tp = tp->tp_next;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["        if (curwin->w_p_scb)", "          do_check_scrollbind(TRUE);", "      }"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    }", "    listcmd_busy = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    apply_autocmds(EVENT_SYNTAX, curbuf->b_p_syn,", "        curbuf->b_fname, TRUE, curbuf);", "  }"], "readability/bool"]
["src/nvim/ex_cmds2.c", [" */", "static int ", "alist_add_list ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds2.c", ["static int ", "alist_add_list (", "    int count,"], "whitespace/parens"]
["src/nvim/ex_cmds2.c", ["    }", "    do_unlet((char_u *)\"g:current_compiler\", TRUE);", "    do_unlet((char_u *)\"b:current_compiler\", TRUE);"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    do_unlet((char_u *)\"g:current_compiler\", TRUE);", "    do_unlet((char_u *)\"b:current_compiler\", TRUE);", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["", "    sprintf((char *)buf, \"compiler/%s.vim\", eap->arg);", "    if (source_runtime(buf, TRUE) == FAIL)"], "runtime/printf"]
["src/nvim/ex_cmds2.c", ["    sprintf((char *)buf, \"compiler/%s.vim\", eap->arg);", "    if (source_runtime(buf, TRUE) == FAIL)", "      EMSG2(_(\"E666: compiler not supported: %s\"), eap->arg);"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["        xfree(old_cur_comp);", "      } else", "        do_unlet((char_u *)\"g:current_compiler\", TRUE);"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["      } else", "        do_unlet((char_u *)\"g:current_compiler\", TRUE);", "    }"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["{", "  (void)do_source(fname, FALSE, DOSO_NONE);", "}"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  int i;", "  int did_one = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["              (*callback)(files[i], cookie);", "              did_one = TRUE;", "              if (!all)"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["        || eap->cstack->cs_idx >= 0", "        );", ""], "whitespace/parens"]
["src/nvim/ex_cmds2.c", ["  /* \":source\" read ex commands */", "  else if (do_source(fname, FALSE, DOSO_NONE) == FAIL)", "    EMSG2(_(e_notopen), fname);"], "readability/bool"]
["src/nvim/ex_cmds2.c", [" */", "int ", "do_source ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds2.c", ["int ", "do_source (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/ex_cmds2.c", ["      && apply_autocmds(EVENT_SOURCECMD, fname_exp, fname_exp,", "          FALSE, curbuf)) {", "    retval = aborting() ? FAIL : OK;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  /* Apply SourcePre autocommands, they may get the file. */", "  apply_autocmds(EVENT_SOURCEPRE, fname_exp, fname_exp, FALSE, curbuf);", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    cookie.fileformat = EOL_UNKNOWN;", "  cookie.error = FALSE;", "#endif"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  cookie.nextline = NULL;", "  cookie.finished = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["   */", "  cookie.breakpoint = dbg_find_breakpoint(TRUE, fname_exp, (linenr_T)0);", "  cookie.fname = fname_exp;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      SCRIPT_ITEM(script_items.ga_len).sn_name = NULL;", "      SCRIPT_ITEM(script_items.ga_len).sn_prof_on = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      home_replace(NULL, SCRIPT_ITEM(i).sn_name,", "          NameBuff, MAXPATHL, TRUE);", "      smsg(\"%3d: %s\", i, NameBuff);"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  if (sp->dbg_tick < debug_tick) {", "    sp->breakpoint = dbg_find_breakpoint(TRUE, sp->fname, sourcing_lnum);", "    sp->dbg_tick = debug_tick;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    line = get_one_sourceline(sp);", "  else {", "    line = sp->nextline;"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["    /* Find next breakpoint. */", "    sp->breakpoint = dbg_find_breakpoint(TRUE, sp->fname, sourcing_lnum);", "    sp->dbg_tick = debug_tick;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["#endif", "  int have_read = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["", "    have_read = TRUE;", "    ga.ga_len = len;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["          }", "          sp->error = TRUE;", "          sp->fileformat = EOL_UNIX;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--)", "        ;", "      if ((len & 1) != (c & 1)) {       /* escaped NL, read more */"], "whitespace/semicolon"]
["src/nvim/ex_cmds2.c", ["    }", "    si->sn_prl_execed = FALSE;", "    si->sn_prl_start = profile_start();"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  if (si->sn_prof_on && si->sn_prl_idx >= 0)", "    si->sn_prl_execed = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    name = enc_canonize(eap->arg);", "  } else", "    name = eap->arg;"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["  if (getline_equal(eap->getline, eap->cookie, getsourceline))", "    do_finish(eap, FALSE);", "  else"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    ((struct source_cookie *)getline_cookie(eap->getline,", "         eap->cookie))->finished = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["   */", "  idx = cleanup_conditionals(eap->cstack, 0, TRUE);", "  if (idx >= 0) {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    report_make_pending(CSTP_FINISH, NULL);", "  } else", "    ((struct source_cookie *)getline_cookie(eap->getline,"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["    ((struct source_cookie *)getline_cookie(eap->getline,", "         eap->cookie))->finished = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  if (eap->addr_count == 0)     /* default is all buffers */", "    check_timestamps(FALSE);", "  else {"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    check_timestamps(FALSE);", "  else {", "    buf = buflist_findnr((int)eap->line2);"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["    if (buf != NULL)            /* cannot happen? */", "      (void)buf_check_timestamp(buf, FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["      EMSG2(_(\"E197: Cannot set language to \\\"%s\\\"\"), name);", "    else {", "#ifdef HAVE_NL_MSG_CAT_CNTR"], "readability/braces"]
["src/nvim/ex_cmds2.c", ["static char_u   **locales = NULL;       /* Array of all available locales */", "static int did_init_locales = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds2.c", ["  if (!did_init_locales) {", "    did_init_locales = TRUE;", "    locales = find_locales();"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["   * into an array of locale strings. */", "  loc = (char_u *)strtok((char *)locale_a, \"\\n\");", ""], "runtime/threadsafe_fn"]
["src/nvim/ex_cmds2.c", ["    GA_APPEND(char_u *, &locales_ga, loc);", "    loc = (char_u *)strtok(NULL, \"\\n\");", "  }"], "runtime/threadsafe_fn"]
["src/nvim/ex_cmds2.c", ["{", "    int                split = FALSE;", "    buf_T      *buf;"], "readability/bool"]
["src/nvim/ex_cmds2.c", ["    }", "    else", "    {"], "whitespace/newline"]
["src/nvim/ex_cmds2.c", ["       }", "       else", "           eap->cmdidx = CMD_first;"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["                                   || c > '~'", "                                   )) {", "      transchar_nonprint(buf3, c);"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["      vim_snprintf(buf1, sizeof(buf1), \"  <%s>\", (char *)buf3);", "    } else", "      buf1[0] = NUL;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      new_indent = indent;", "    else {", "      has_tab = FALSE;          /* avoid uninit warnings */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    else {", "      has_tab = FALSE;          /* avoid uninit warnings */", "      len = linelen(eap->cmdidx == CMD_right ? &has_tab"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        new_indent = (width - len) / 2;", "      else {", "        new_indent = width - len;               /* right align */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["                (void)set_indent(++new_indent, 0);", "              while (linelen(NULL) <= width);", "              --new_indent;"], "whitespace/empty_loop_body"]
["src/nvim/ex_cmds.c", ["       last > first && ascii_iswhite(last[-1]); --last)", "    ;", "  save = *last;"], "whitespace/semicolon"]
["src/nvim/ex_cmds.c", ["static int sort_nr;                     /* sort on number */", "static int sort_rx;                     /* sort on regex instead of skipping it */", ""], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["", "static int sort_abort;                  /* flag to indicate if sorting has been interrupted */", ""], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["  if (got_int)", "    sort_abort = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["             : l1.start_col_nr > l2.start_col_nr ? 1 : -1;", "  else {", "    /* We need to copy one line into \"sortbuf1\", because there is no"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  char_u c;                             /* temporary character storage */", "  int unique = FALSE;", "  long deleted;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    if (ascii_iswhite(*p))", "      ;", "    else if (*p == 'i')"], "whitespace/semicolon"]
["src/nvim/ex_cmds.c", ["    else if (*p == 'i')", "      sort_ic = TRUE;", "    else if (*p == 'r')"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    else if (*p == 'r')", "      sort_rx = TRUE;", "    else if (*p == 'n')"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    else if (*p == 'u')", "      unique = TRUE;", "    else if (*p == '\"')         /* comment start */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    } else if (!ASCII_ISALPHA(*p) && regmatch.regprog == NULL) {", "      s = skip_regexp(p + 1, *p, TRUE, NULL);", "      if (*s != *p) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        regmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);", "      } else", "        regmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        end_col = (colnr_T)(regmatch.endp[0] - s);", "      } else", "        start_col = (colnr_T)(regmatch.endp[0] - s);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        start_col = (colnr_T)(regmatch.endp[0] - s);", "    } else if (regmatch.regprog != NULL)", "      end_col = 0;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        || (sort_ic ? STRICMP(s, sortbuf1) : STRCMP(s, sortbuf1)) != 0) {", "      if (ml_append(lnum++, s, (colnr_T)0, FALSE) == FAIL)", "        break;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    for (i = 0; i < count; ++i)", "      ml_delete(eap->line1, FALSE);", "  else"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  linenr_T lnum;", "  int got_tab = FALSE;", "  long num_spaces = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    vcol = 0;", "    did_undo = FALSE;", "    for (;; ) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        else", "          got_tab = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              (num_spaces + num_tabs < len)) {", "            if (did_undo == FALSE) {", "              did_undo = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["            if (did_undo == FALSE) {", "              did_undo = TRUE;", "              if (u_save((linenr_T)(lnum - 1),"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              ptr[col] = (col < num_tabs) ? '\\t' : ' ';", "            ml_replace(lnum, new_line, FALSE);", "            if (first_line == 0)"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        }", "        got_tab = FALSE;", "        num_spaces = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    str = vim_strsave(ml_get(l + extra));", "    ml_append(dest + l - line1, str, (colnr_T)0, FALSE);", "    xfree(str);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  for (l = line1; l <= line2; l++)", "    ml_delete(line1 + extra, TRUE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["    changed_lines(line1, 0, dest, 0L);", "  } else", "    changed_lines(dest + 1, 0, line1 + num_lines, 0L);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    p = vim_strsave(ml_get(line1));", "    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);", "    xfree(p);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  char_u              *newcmd = NULL;           /* the new command */", "  int free_newcmd = FALSE;                      /* need to free() newcmd */", "  int ins_prevcmd;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (addr_count == 0) {                /* :! */", "    msg_scroll = FALSE;             /* don't scroll here */", "    autowrite_all();"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          STRMOVE(p - 1, p);", "        else {", "          trailarg = p;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          *trailarg++ = NUL;", "          ins_prevcmd = TRUE;", "          break;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    AppendToRedobuff((char_u *)\"\\n\");", "    bangredo = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    STRCAT(newcmd, p_shq);", "    free_newcmd = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    do_filter(line1, line2, eap, newcmd, do_in, do_out);", "    apply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", [" */", "static void ", "do_filter ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds.c", ["static void ", "do_filter (", "    linenr_T line1,"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["  if (itmp != NULL && buf_write(curbuf, itmp, NULL, line1, line2, eap,", "          FALSE, FALSE, FALSE, TRUE) == FAIL) {", "    msg_putchar('\\n');                  /* keep message from buf_write() */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        NULL", "        )) {", "    redraw_later_clear();"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["    redraw_later_clear();", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  did_check_timestamps = FALSE;", "  need_check_timestamps = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  did_check_timestamps = FALSE;", "  need_check_timestamps = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["  os_breakcheck();", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["          mark_adjust(line1, line2, linecount, 0L);", "        else {", "          /* move marks from old lines to new lines, delete marks"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      curwin->w_cursor.lnum = line1;", "      del_lines(linecount, TRUE);", "      curbuf->b_op_start.lnum -= linecount;             /* adjust '[ */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      curbuf->b_op_end.lnum -= linecount;               /* adjust '] */", "      write_lnum_adjust(-linecount);                    /* adjust last line", "                                                           for next write */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["          set_keep_msg(msg_buf, 0);", "      } else", "        msgmore((long)linecount);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    --no_wait_return;", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", [" */", "void ", "do_shell ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds.c", ["void ", "do_shell (", "    char_u *cmd,"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["", "  // This ui_cursor_goto is required for when the '\\n' resulted in a \"delete line", "  // 1\" command to the terminal."], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["        redraw_later_clear();", "      need_wait_return = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, FALSE, curbuf);", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  size_t len = STRLEN(cmd) + 1;  // At least enough space for cmd + NULL.", "  ", "  len += is_fish_shell ?  sizeof(\"begin; \"\"; end\") - 1"], "whitespace/end_of_line"]
["src/nvim/ex_cmds.c", ["        (char *)opt, (char *)fname);", "  } else", "    vim_snprintf((char *)end, (size_t)(buflen - (end - buf)),"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  msg_start();", "  silent_mode = FALSE;", "  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  silent_mode = FALSE;", "  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */", "  print_line_no_prefix(lnum, use_number, list);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  }", "  info_message = FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  buf = curbuf;", "  apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);", "  /* buffer changed, don't change name now */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curbuf->b_sfname = NULL;", "  if (setfname(curbuf, new_fname, NULL, TRUE) == FAIL) {", "    curbuf->b_ffname = fname;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  xfree(sfname);", "  apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);", "  /* Change directories when the 'acd' option is set. */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  /* print full file name if :cd used */", "  fileinfo(FALSE, FALSE, eap->forceit);", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (eap->usefilter)           /* input lines to shell command */", "    do_bang(1, eap, FALSE, TRUE, FALSE);", "  else"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    }", "    other = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          goto theend;", "        eap->forceit = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);", "      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);", "      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);", "      if (curbuf != was_curbuf || aborting()) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      buf_name_changed(curbuf);", "      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);", "      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);", "      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);", "      if (!alt_buf->b_p_bl) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (!alt_buf->b_p_bl) {", "        alt_buf->b_p_bl = TRUE;", "        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        alt_buf->b_p_bl = TRUE;", "        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          (void)do_doautocmd((char_u *)\"filetypedetect BufRead\",", "              TRUE);", "        do_modelines(0);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    retval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2,", "        eap, eap->append, eap->forceit, TRUE, FALSE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (retval == OK) {", "        curbuf->b_p_ro = FALSE;", "        redraw_tabline = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        curbuf->b_p_ro = FALSE;", "        redraw_tabline = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", [" */", "int ", "check_overwrite ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds.c", ["int ", "check_overwrite (", "    exarg_T *eap,"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["    buf_T *buf,", "    char_u *fname,         /* file name to be used (can differ from", "                               buf->ffname) */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["    buf_T *buf,", "    char_u *fname,         /* file name to be used (can differ from", "                               buf->ffname) */"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["          return FAIL;", "        eap->forceit = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          }", "          eap->forceit = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (eap->cmdidx == CMD_xall || eap->cmdidx == CMD_wqall)", "    exiting = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["               || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,", "                   FALSE) == FAIL) {", "      ++error;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (p_write)", "    return FALSE;", "  EMSG(_(\"E142: File not written: Writing is disabled by 'write' option\"));"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  EMSG(_(\"E142: File not written: Writing is disabled by 'write' option\"));", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["            _(", "                \"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),", "            buf->b_fname);"], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["            _(", "                \"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),", "            buf->b_fname);"], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["        /* Set forceit, to force the writing of a readonly file */", "        *forceit = TRUE;", "        return FALSE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        *forceit = TRUE;", "        return FALSE;", "      } else"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        return FALSE;", "      } else", "        return TRUE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      } else", "        return TRUE;", "    } else if (buf->b_p_ro)"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        return TRUE;", "    } else if (buf->b_p_ro)", "      EMSG(_(e_readonly));"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          buf->b_fname);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", [" */", "int getfile(int fnum, char_u *ffname, char_u *sfname, int setpm, linenr_T lnum, int forceit)", "{"], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["    free_me = ffname;                   /* has been allocated, free() later */", "  } else", "    other = (fnum != curbuf->b_fnum);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (p_confirm && p_write)", "      dialog_changed(curbuf, FALSE);", "    if (curbufIsChanged()) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    retval = 0;         /* it's in the same file */", "  } else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,", "                 (P_HID(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0),"], "readability/braces"]
["src/nvim/ex_cmds.c", [" */", "int ", "do_ecmd ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds.c", ["int ", "do_ecmd (", "    int fnum,"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["  int oldbuf;                           /* TRUE if using existing buffer */", "  int auto_buf = FALSE;                 /* TRUE if autocommands brought us", "                                           into the buffer unexpectedly */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["  int oldbuf;                           /* TRUE if using existing buffer */", "  int auto_buf = FALSE;                 /* TRUE if autocommands brought us", "                                           into the buffer unexpectedly */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  char_u      *new_name = NULL;", "  int did_set_swapcommand = FALSE;", "  buf_T       *buf;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  char_u      *command = NULL;", "  int did_get_winopts = FALSE;", "  int readfile_flags = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      return OK;                        /* nothing to do */", "    other_file = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    if (ffname == NULL)", "      other_file = TRUE;", "    /* there is no file name */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    else if (*ffname == NUL && curbuf->b_ffname == NULL)", "      other_file = FALSE;", "    else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      other_file = FALSE;", "    else {", "      if (*ffname == NUL) {                 /* re-edit with same file name */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      }", "      free_fname = (char_u *)fix_fname((char *)ffname);       /* may expand to full path name */", "      if (free_fname != NULL)"], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["    set_vim_var_string(VV_SWAPCOMMAND, p, -1);", "    did_set_swapcommand = TRUE;", "    xfree(p);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      buf = buflist_findnr(fnum);", "    else {", "      if (flags & ECMD_ADDBUF) {"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    if (buf->b_ml.ml_mfp == NULL) {             /* no memfile yet */", "      oldbuf = FALSE;", "      buf->b_nwindows = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    } else {                                  /* existing memfile */", "      oldbuf = TRUE;", "      (void)buf_check_timestamp(buf, FALSE);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      oldbuf = TRUE;", "      (void)buf_check_timestamp(buf, FALSE);", "      /* Check if autocommands made buffer invalid or changed the current"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      au_new_curbuf = buf;", "      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      if (!buf_valid(buf)) {            /* new buffer has been deleted */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (buf == curbuf)                /* already in new buffer */", "        auto_buf = TRUE;", "      else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        auto_buf = TRUE;", "      else {", "        if (curbuf == old_curbuf)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        /* close the link to the current buffer */", "        u_sync(FALSE);", "        close_buffer(oldwin, curbuf,"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        close_buffer(oldwin, curbuf,", "            (flags & ECMD_HIDE) || curbuf->terminal ? 0 : DOBUF_UNLOAD, FALSE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["          if (oldwin->w_buffer == NULL) {", "            win_close(oldwin, FALSE);", "          }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        if (buf == curbuf)                      /* already in new buffer */", "          auto_buf = TRUE;", "        else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          auto_buf = TRUE;", "        else {", "          /*"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          if (!oldbuf && eap != NULL) {", "            set_file_options(TRUE, eap);", "            set_forced_fenc(eap);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        get_winopts(curbuf);", "        did_get_winopts = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["        did_get_winopts = TRUE;", "", "      }"], "whitespace/blank_line"]
["src/nvim/ex_cmds.c", ["      au_new_curbuf = NULL;", "    } else", "      ++curbuf->b_nwindows;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    // CTRL-O to go back to a help file.", "    set_buflisted(TRUE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["   * highlighting to work in the other file. */", "  did_filetype = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["       * Sync first so that this is a separate undo-able action. */", "      u_sync(FALSE);", "      if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      u_sync(FALSE);", "      if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)", "          == FAIL)"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      readfile_flags = READ_KEEP_UNDO;", "    } else", "      buf_freeall(curbuf, 0);         /* free all things for buffer */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["       */", "      if (should_abort(open_buffer(FALSE, eap, readfile_flags)))", "        retval = FAIL;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "      apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,", "          &retval);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          &retval);", "      apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,", "          &retval);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        curwin->w_cursor.coladd = 0;", "        curwin->w_set_curswant = TRUE;", "      } else"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        curwin->w_set_curswant = TRUE;", "      } else", "        beginline(BL_SOL | BL_FIX);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  /* Check if cursors in other windows on the same buffer are still valid */", "  check_lnums(FALSE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["    if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)", "      msg_scroll = FALSE;", "    if (!msg_scroll)            /* wait a bit when overwriting an error msg */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    if (!msg_scroll)            /* wait a bit when overwriting an error msg */", "      check_for_delay(FALSE);", "    msg_start();"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    msg_scroll = msg_scroll_save;", "    msg_scrolled_ign = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "    fileinfo(FALSE, TRUE, FALSE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "    msg_scrolled_ign = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (p_im)", "    need_start_insertmode = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["  char_u      *theline;", "  int did_undo = FALSE;", "  linenr_T lnum = eap->line2;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  for (;; ) {", "    msg_scroll = TRUE;", "    need_wait_return = FALSE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    msg_scroll = TRUE;", "    need_wait_return = FALSE;", "    if (curbuf->b_p_ai) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        append_indent = -1;", "      } else if (lnum > 0)", "        indent = get_indent_lnum(lnum);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    }", "    ex_keep_indent = FALSE;", "    if (eap->getline == NULL) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "    did_undo = TRUE;", "    ml_append(lnum, theline, (colnr_T)0, FALSE);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    did_undo = TRUE;", "    ml_append(lnum, theline, (colnr_T)0, FALSE);", "    appended_lines_mark(lnum, 1L);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    if (empty) {", "      ml_delete(2L, FALSE);", "      empty = FALSE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      ml_delete(2L, FALSE);", "      empty = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  need_wait_return = FALSE;     /* don't use wait_return() now */", "  ex_no_reprint = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  need_wait_return = FALSE;     /* don't use wait_return() now */", "  ex_no_reprint = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      break;", "    ml_delete(eap->line1, FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    for (x = kind + 1; *x == *kind; ++x)", "      ;", ""], "whitespace/semicolon"]
["src/nvim/ex_cmds.c", ["  curwin->w_cursor.lnum = curs;", "  ex_no_reprint = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    EMSG(_(\"E145: Shell commands not allowed in restricted mode\"));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    EMSG(_(e_curdir));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    EMSG(_(e_sandbox));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  regmmatch_T regmatch;", "  static int do_all = FALSE;            /* do multiple substitutions per line */", "  static int do_ask = FALSE;            /* ask for confirmation */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  static int do_all = FALSE;            /* do multiple substitutions per line */", "  static int do_ask = FALSE;            /* ask for confirmation */", "  static bool do_count = false;         /* count only */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  static bool do_count = false;         /* count only */", "  static int do_error = TRUE;           /* if false, ignore errors */", "  static int do_print = FALSE;          /* print last line with subs. */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  static int do_error = TRUE;           /* if false, ignore errors */", "  static int do_print = FALSE;          /* print last line with subs. */", "  static int do_list = FALSE;           /* list last line with subs. */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  static int do_print = FALSE;          /* print last line with subs. */", "  static int do_list = FALSE;           /* list last line with subs. */", "  static int do_number = FALSE;         /* list last line with line nr*/"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  static int do_list = FALSE;           /* list last line with subs. */", "  static int do_number = FALSE;         /* list last line with line nr*/", "  static int do_ic = 0;                 /* ignore case flag */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  int sublen;", "  int got_quit = FALSE;", "  int got_match = FALSE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  int got_quit = FALSE;", "  int got_match = FALSE;", "  int temp;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  linenr_T first_line = 0;              /* first changed line */", "  linenr_T last_line= 0;                /* below last changed line AFTER the", "                                         * change */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["  char_u      *sub_firstline;           /* allocated copy of first sub line */", "  int endcolumn = FALSE;                /* cursor in last column when done */", "  pos_T old_cursor = curwin->w_cursor;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  // more efficient.", "  // TODO: find a generic solution to make line-joining operations more", "  // efficient, avoid allocating a string that grows in size."], "readability/todo"]
["src/nvim/ex_cmds.c", ["    if (joined_lines_count > 1) {", "      do_join(joined_lines_count, FALSE, TRUE, FALSE, true);", "      sub_nsubs = joined_lines_count - 1;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    }", "    add_to_history(HIST_SEARCH, pat, TRUE, NUL);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["    // default is global on", "    do_all = p_gd ? TRUE : FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "    do_ask = FALSE;", "    do_error = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    do_ask = FALSE;", "    do_error = TRUE;", "    do_print = FALSE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    do_error = TRUE;", "    do_print = FALSE;", "    do_count = false;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    do_count = false;", "    do_number = FALSE;", "    do_ic = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    else if (*cmd == 'p')", "      do_print = TRUE;", "    else if (*cmd == '#') {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    else if (*cmd == '#') {", "      do_print = TRUE;", "      do_number = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      do_print = TRUE;", "      do_number = TRUE;", "    } else if (*cmd == 'l') {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    } else if (*cmd == 'l') {", "      do_print = TRUE;", "      do_list = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      do_print = TRUE;", "      do_list = TRUE;", "    } else if (*cmd == 'i')         /* ignore case */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      do_list = TRUE;", "    } else if (*cmd == 'i')         /* ignore case */", "      do_ic = 'i';"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (do_count)", "    do_ask = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (do_ic == 'i')", "    regmatch.rmm_ic = TRUE;", "  else if (do_ic == 'I')"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  else if (do_ic == 'I')", "    regmatch.rmm_ic = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["                                             || aborting()", "                                             ); ++lnum) {", "    nmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["      char_u      *p1;", "      int did_sub = FALSE;", "      int lastone;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      int do_again;                     /* do it again after joining lines */", "      int skip_match = FALSE;", "      linenr_T sub_firstlnum;           /* nr of first sub line */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        setpcmark();", "        got_match = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        curwin->w_cursor.lnum = lnum;", "        do_again = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["             * for a match in this line again. */", "            skip_match = TRUE;", "          else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["            skip_match = TRUE;", "          else {", "            /* search for a match at next column */"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            nmatch = 1;", "            skip_match = TRUE;", "          }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          sub_nsubs++;", "          did_sub = TRUE;", "          /* Skip the substitution, unless an expression is used,"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "              curwin->w_p_fen = FALSE;", "              /* Invert the matched string."], "readability/bool"]
["src/nvim/ex_cmds.c", ["                orig_line = vim_strsave(ml_get(lnum));", "                char_u *new_line = concat_str(new_start, sub_firstline + copycol);", ""], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["                curwin->w_cursor.col += len_change;", "                ml_replace(lnum, new_line, FALSE);", "              }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["                                    + len_change;", "              highlight_match = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["              update_screen(SOME_VALID);", "              highlight_match = FALSE;", "              redraw_later(SOME_VALID);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              if (msg_row == Rows - 1)", "                msg_didout = FALSE;                     /* avoid a scroll-up */", "              msg_starthere();"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              i = msg_scroll;", "              msg_scroll = 0;                           /* truncate msg when", "                                                           needed */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["                                                           needed */", "              msg_no_more = TRUE;", "              /* write message same highlighting as for"], "readability/bool"]
["src/nvim/ex_cmds.c", ["                        _(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);", "              msg_no_more = FALSE;", "              msg_scroll = i;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              msg_scroll = i;", "              showruler(TRUE);", "              ui_cursor_goto(msg_row, msg_col);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              /* clear the question */", "              msg_didout = FALSE;               /* don't scroll up */", "              msg_col = 0;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              msg_col = 0;", "              gotocmdline(TRUE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["              if (orig_line != NULL)", "                ml_replace(lnum, orig_line, FALSE);", "            }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "            need_wait_return = FALSE;             /* no hit-return prompt */", "            if (typed == 'q' || typed == ESC || typed == Ctrl_C"], "readability/bool"]
["src/nvim/ex_cmds.c", ["                ) {", "              got_quit = TRUE;", "              break;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              /* last: replace and then stop */", "              do_all = FALSE;", "              line2 = lnum;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["            if (typed == 'a') {", "              do_ask = FALSE;", "              break;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              matchcol = (colnr_T)STRLEN(sub_firstline);", "              skip_match = TRUE;", "            }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          save_ma = curbuf->b_p_ma;", "          curbuf->b_p_ma = FALSE;", "          sandbox++;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["            sub_firstlnum - regmatch.startpos[0].lnum,", "            sub, sub_firstline, FALSE, p_magic, TRUE);", "        if (do_count) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;", "          skip_match = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          p1 = sub_firstline;", "        else {", "          p1 = ml_get(sub_firstlnum + nmatch - 1);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            sub_firstlnum - regmatch.startpos[0].lnum,", "            sub, new_end, TRUE, p_magic, TRUE);", "        sub_nsubs++;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        sub_nsubs++;", "        did_sub = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["          if (sub_firstlnum <= line2)", "            do_again = TRUE;", "          else"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          else", "            do_all = FALSE;", "        }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              ml_append(lnum - 1, new_start,", "                  (colnr_T)(p1 - new_start + 1), FALSE);", "              mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["                appended_lines(lnum - 1, 1L);", "              else {", "                if (first_line == 0)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["            }", "          } else if (has_mbyte)", "            p1 += (*mb_ptr2len)(p1) - 1;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["              break;", "            ml_replace(lnum, new_start, TRUE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["              for (i = 0; i < nmatch_tl; ++i)", "                ml_delete(lnum, (int)FALSE);", "              mark_adjust(lnum, lnum + nmatch_tl - 1,"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              changed_bytes(lnum, 0);", "            else {", "              if (first_line == 0)"], "readability/braces"]
["src/nvim/ex_cmds.c", ["        MSG(\"\");", "    } else", "      global_need_beginline = TRUE;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    } else", "      global_need_beginline = TRUE;", "    if (do_print)"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  vim_regfree(regmatch.regprog);", "}", ""], "readability/fn_size"]
["src/nvim/ex_cmds.c", ["bool", "do_sub_msg (", "    bool count_only                /* used 'n' flag for \":s\" */"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["  if (global_busy) {", "    EMSG(_(\"E147: Cannot do :global recursive\"));       /* will increment global_busy */", "    return;"], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["  if (p_altkeymap && curwin->w_p_rl)", "    lrFswap(pat,0);", ""], "whitespace/comma"]
["src/nvim/ex_cmds.c", ["  /* When the command writes a message, don't overwrite the command. */", "  msg_didout = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["  sub_nlines = 0;", "  global_need_beginline = FALSE;", "  global_busy = 1;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (msg_col == 0 && msg_scrolled == 0)", "    msg_didout = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["bool", "prepare_tagpreview (", "    bool undo_sync                  /* sync undo when leaving the window */"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["        return false;", "      curwin->w_p_pvw = TRUE;", "      curwin->w_p_wfh = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_pvw = TRUE;", "      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'", "                                               and 'cursorbind' */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["                                               and 'cursorbind' */", "      curwin->w_p_diff = FALSE;             /* no 'diff' */", "      curwin->w_p_fdc = 0;                  /* no 'foldcolumn' */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      return;", "  } else", "    arg = (char_u *)\"\";"], "readability/braces"]
["src/nvim/ex_cmds.c", ["      win_enter(wp, true);", "    else {", "      /*"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          NULL                  /* buffer is still open, don't store info */", "          );", "      if (!cmdmod.keepalt)"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["", "  do_tag(tag, DT_HELP, 1, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["    if (buf != NULL && buf->b_nwindows == 0)", "      wipe_buffer(buf, TRUE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", [" */", "int ", "help_heuristic ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds.c", ["int ", "help_heuristic (", "    char_u *matched_string,"], "whitespace/parens"]
["src/nvim/ex_cmds.c", [" */", "int find_help_tags(char_u *arg, int *num_matches, char_u ***matches, int keep_lang)", "{"], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["              *d++ = '\\\\';              /* double a backslash */", "          } else", "            *d++ = *++s;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["          continue;", "        } else if (*s == '^')           /* \"^\" or \"CTRL-^\" or \"^_\" */", "          *d++ = '\\\\';"], "readability/braces"]
["src/nvim/ex_cmds.c", ["    check_buf_options(curbuf);", "    (void)buf_init_chartab(curbuf, FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curbuf->b_p_ts = 8;         // 'tabstop' is 8.", "  curwin->w_p_list = FALSE;   // No list mode.", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  curbuf->b_p_ma = FALSE;     // Not modifiable.", "  curbuf->b_p_bin = FALSE;    // Reset 'bin' before reading file."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curbuf->b_p_ma = FALSE;     // Not modifiable.", "  curbuf->b_p_bin = FALSE;    // Reset 'bin' before reading file.", "  curwin->w_p_nu = 0;         // No line numbers."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  RESET_BINDING(curwin);      // No scroll or cursor binding.", "  curwin->w_p_arab = FALSE;   // No arabic mode.", "  curwin->w_p_rl  = FALSE;    // Help window is left-to-right."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_arab = FALSE;   // No arabic mode.", "  curwin->w_p_rl  = FALSE;    // Help window is left-to-right.", "  curwin->w_p_fen = FALSE;    // No folding in the help window."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_rl  = FALSE;    // Help window is left-to-right.", "  curwin->w_p_fen = FALSE;    // No folding in the help window.", "  curwin->w_p_diff = FALSE;   // No 'diff'."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_fen = FALSE;    // No folding in the help window.", "  curwin->w_p_diff = FALSE;   // No 'diff'.", "  curwin->w_p_spell = FALSE;  // No spell checking."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_diff = FALSE;   // No 'diff'.", "  curwin->w_p_spell = FALSE;  // No spell checking.", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  set_buflisted(FALSE);", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  char_u      *line;", "  int in_example = FALSE;", "  int len;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum) {", "      line = ml_get_buf(curbuf, lnum, FALSE);", "      len = (int)STRLEN(line);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          /* blank-out a '<' in the first column */", "          line = ml_get_buf(curbuf, lnum, TRUE);", "          line[0] = ' ';"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        }", "        in_example = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          /* blank-out a '>' in the last column (start of example) */", "          line = ml_get_buf(curbuf, lnum, TRUE);", "          line[len - 1] = ' ';"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          line[len - 1] = ' ';", "          in_example = TRUE;", "        } else if (line[len - 1] == '~') {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          /* blank-out a '~' at the end of line (header marker) */", "          line = ml_get_buf(curbuf, lnum, TRUE);", "          line[len - 1] = ' ';"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    for (lnum = 1; lnum < curbuf->b_ml.ml_line_count; ++lnum) {", "      line = ml_get_buf(curbuf, lnum, FALSE);", "      if (strstr((char *)line, \"*local-additions*\") == NULL)"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        rt = (char_u *)vim_getenv(\"VIMRUNTIME\");", "        if (path_full_compare(rt, NameBuff, FALSE) != kEqualFiles) {", "          int fcount;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "          // Note: We cannot just do `&NameBuff` because it is a statically sized array", "          //       so `NameBuff == &NameBuff` according to C semantics."], "whitespace/line_length"]
["src/nvim/ex_cmds.c", ["                   */", "                  if (*s >= 0x80 && this_utf != FALSE) {", "                    int l;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "                    this_utf = TRUE;", "                    l = utf_ptr2len(s);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["                    if (l == 1)", "                      this_utf = FALSE;", "                    s += l - 1;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["                convert_setup(&vc, (char_u *)(", "                      this_utf == TRUE ? \"utf-8\"", "                      : \"latin1\"), p_enc);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["                  cp = IObuff;", "                else {", "                  /* Do the conversion.  If it fails"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "                ml_append(lnum, cp, (colnr_T)0, FALSE);", "                if (cp != IObuff)"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  char_u      **files;", "  int add_help_tags = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (STRNCMP(eap->arg, \"++t\", 3) == 0 && ascii_iswhite(eap->arg[3])) {", "    add_help_tags = TRUE;", "    eap->arg = skipwhite(eap->arg + 3);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      lang[1] = TOLOWER_ASC(files[i][len - 2]);", "    } else", "      continue;"], "readability/braces"]
["src/nvim/ex_cmds.c", ["", "static void ", "helptags_one ("], "whitespace/end_of_line"]
["src/nvim/ex_cmds.c", ["static void ", "helptags_one (", "    char_u *dir,               /* doc directory */"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["  int firstline;", "  int mix = FALSE;              /* detected mixed encodings */", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (add_help_tags || path_full_compare((char_u *)\"$VIMRUNTIME/doc\",", "          dir, FALSE) == kEqualFiles) {", "    s = xmalloc(18 + STRLEN(tagfname));"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    s = xmalloc(18 + STRLEN(tagfname));", "    sprintf((char *)s, \"help-tags\\t%s\\t1\\n\", tagfname);", "    GA_APPEND(char_u *, &ga, s);"], "runtime/printf"]
["src/nvim/ex_cmds.c", ["", "    firstline = TRUE;", "    while (!vim_fgets(IObuff, IOSIZE, fd) && !got_int) {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "            this_utf8 = TRUE;", "            l = utf_ptr2len(s);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["              /* Illegal UTF-8 byte sequence. */", "              this_utf8 = FALSE;", "              break;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        if (this_utf8 == MAYBE)             /* only ASCII characters found */", "          this_utf8 = FALSE;", "        if (utf8 == MAYBE)                  /* first file */"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          mix = !got_int;", "          got_int = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        }", "        firstline = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["            GA_APPEND(char_u *, &ga, s);", "            sprintf((char *)s, \"%s\\t%s\", p1, fname);", ""], "runtime/printf"]
["src/nvim/ex_cmds.c", ["", "    if (utf8 == TRUE)", "      fprintf(fd_tags, \"!_TAG_FILE_ENCODING\\tutf-8\\t//\\n\");"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        fputs((char *)s, fd_tags);", "      else {", "        fprintf(fd_tags, \"%s\\t/*\", s);"], "readability/braces"]
["src/nvim/ex_cmds.c", ["  if (mix)", "    got_int = FALSE;        /* continue with other languages */", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["    if (win->w_buffer->b_help) {", "      win_close(win, FALSE);", "      return;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["static char *cmds[] = {", "\t\t\t\"define\",", "#define SIGNCMD_DEFINE\t0"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\"define\",", "#define SIGNCMD_DEFINE\t0", "\t\t\t\"undefine\","], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["#define SIGNCMD_DEFINE\t0", "\t\t\t\"undefine\",", "#define SIGNCMD_UNDEFINE 1"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["#define SIGNCMD_UNDEFINE 1", "\t\t\t\"list\",", "#define SIGNCMD_LIST\t2"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\"list\",", "#define SIGNCMD_LIST\t2", "\t\t\t\"place\","], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["#define SIGNCMD_LIST\t2", "\t\t\t\"place\",", "#define SIGNCMD_PLACE\t3"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\"place\",", "#define SIGNCMD_PLACE\t3", "\t\t\t\"unplace\","], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["#define SIGNCMD_PLACE\t3", "\t\t\t\"unplace\",", "#define SIGNCMD_UNPLACE\t4"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\"unplace\",", "#define SIGNCMD_UNPLACE\t4", "\t\t\t\"jump\","], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["#define SIGNCMD_UNPLACE\t4", "\t\t\t\"jump\",", "#define SIGNCMD_JUMP\t5"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\"jump\",", "#define SIGNCMD_JUMP\t5", "\t\t\tNULL"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["#define SIGNCMD_JUMP\t5", "\t\t\tNULL", "#define SIGNCMD_LAST\t6"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tNULL", "#define SIGNCMD_LAST\t6", "};"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["{", "    char_u\t*arg = eap->arg;", "    char_u\t*p;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    char_u\t*arg = eap->arg;", "    char_u\t*p;", "    int\t\tidx;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    char_u\t*p;", "    int\t\tidx;", "    sign_T\t*sp;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    int\t\tidx;", "    sign_T\t*sp;", "    sign_T\t*sp_prev;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    sign_T\t*sp;", "    sign_T\t*sp_prev;", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    {", "\tEMSG2(_(\"E160: Unknown sign command: %s\"), arg);", "\treturn;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tEMSG2(_(\"E160: Unknown sign command: %s\"), arg);", "\treturn;", "    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t */", "\tif (idx == SIGNCMD_LIST && *arg == NUL)", "\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tif (idx == SIGNCMD_LIST && *arg == NUL)", "\t{", "\t    /* \":sign list\": list all defined signs */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tif (idx == SIGNCMD_LIST && *arg == NUL)", "\t{", "\t    /* \":sign list\": list all defined signs */"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    /* \":sign list\": list all defined signs */", "\t    for (sp = first_sign; sp != NULL && !got_int; sp = sp->sn_next)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    /* \":sign list\": list all defined signs */", "\t    for (sp = first_sign; sp != NULL && !got_int; sp = sp->sn_next)", "\t\tsign_list_defined(sp);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    for (sp = first_sign; sp != NULL && !got_int; sp = sp->sn_next)", "\t\tsign_list_defined(sp);", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tsign_list_defined(sp);", "\t}", "\telse if (*arg == NUL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t}", "\telse if (*arg == NUL)", "\t    EMSG(_(\"E156: Missing sign name\"));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t}", "\telse if (*arg == NUL)", "\t    EMSG(_(\"E156: Missing sign name\"));"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\telse if (*arg == NUL)", "\t    EMSG(_(\"E156: Missing sign name\"));", "\telse"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    EMSG(_(\"E156: Missing sign name\"));", "\telse", "\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\telse", "\t{", "\t    /* Isolate the sign name.  If it's a number skip leading zeroes,"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\telse", "\t{", "\t    /* Isolate the sign name.  If it's a number skip leading zeroes,"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t     * so that \"099\" and \"99\" are the same sign.  But keep \"0\". */", "\t    p = skiptowhite(arg);", "\t    if (*p != NUL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    p = skiptowhite(arg);", "\t    if (*p != NUL)", "\t\t*p++ = NUL;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    if (*p != NUL)", "\t\t*p++ = NUL;", "\t    while (arg[0] == '0' && arg[1] != NUL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t*p++ = NUL;", "\t    while (arg[0] == '0' && arg[1] != NUL)", "\t\t++arg;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    while (arg[0] == '0' && arg[1] != NUL)", "\t\t++arg;", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t    sp_prev = NULL;", "\t    for (sp = first_sign; sp != NULL; sp = sp->sn_next)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    sp_prev = NULL;", "\t    for (sp = first_sign; sp != NULL; sp = sp->sn_next)", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    for (sp = first_sign; sp != NULL; sp = sp->sn_next)", "\t    {", "\t\tif (STRCMP(sp->sn_name, arg) == 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\tif (STRCMP(sp->sn_name, arg) == 0)", "\t\t    break;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (STRCMP(sp->sn_name, arg) == 0)", "\t\t    break;", "\t\tsp_prev = sp;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    break;", "\t\tsp_prev = sp;", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tsp_prev = sp;", "\t    }", "\t    if (idx == SIGNCMD_DEFINE)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    if (idx == SIGNCMD_DEFINE)", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    if (idx == SIGNCMD_DEFINE)", "\t    {", "\t\t/* \":sign define {name} ...\": define a sign */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\t/* \":sign define {name} ...\": define a sign */", "\t\tif (sp == NULL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t/* \":sign define {name} ...\": define a sign */", "\t\tif (sp == NULL)", "\t\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (sp == NULL)", "\t\t{", "\t\t    sign_T\t*lp;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (sp == NULL)", "\t\t{", "\t\t    sign_T\t*lp;"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t\t{", "\t\t    sign_T\t*lp;", "\t\t    int\t\tstart = next_sign_typenr;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    sign_T\t*lp;", "\t\t    int\t\tstart = next_sign_typenr;", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t\t    /* Allocate a new sign. */", "\t\t    sp = xcalloc(1, sizeof(sign_T));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    /* Allocate a new sign. */", "\t\t    sp = xcalloc(1, sizeof(sign_T));", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t     * another one got deleted and we can use its number. */", "\t\t    for (lp = first_sign; lp != NULL; )", "\t\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    for (lp = first_sign; lp != NULL; )", "\t\t    {", "\t\t\tif (lp->sn_typenr == next_sign_typenr)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    {", "\t\t\tif (lp->sn_typenr == next_sign_typenr)", "\t\t\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tif (lp->sn_typenr == next_sign_typenr)", "\t\t\t{", "\t\t\t    ++next_sign_typenr;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tif (lp->sn_typenr == next_sign_typenr)", "\t\t\t{", "\t\t\t    ++next_sign_typenr;"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t\t\t{", "\t\t\t    ++next_sign_typenr;", "\t\t\t    if (next_sign_typenr == MAX_TYPENR)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    ++next_sign_typenr;", "\t\t\t    if (next_sign_typenr == MAX_TYPENR)", "\t\t\t\tnext_sign_typenr = 1;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    if (next_sign_typenr == MAX_TYPENR)", "\t\t\t\tnext_sign_typenr = 1;", "\t\t\t    if (next_sign_typenr == start)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\tnext_sign_typenr = 1;", "\t\t\t    if (next_sign_typenr == start)", "\t\t\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    if (next_sign_typenr == start)", "\t\t\t    {", "\t\t\t\txfree(sp);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    {", "\t\t\t\txfree(sp);", "\t\t\t\tEMSG(_(\"E612: Too many signs defined\"));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\txfree(sp);", "\t\t\t\tEMSG(_(\"E612: Too many signs defined\"));", "\t\t\t\treturn;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\tEMSG(_(\"E612: Too many signs defined\"));", "\t\t\t\treturn;", "\t\t\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\treturn;", "\t\t\t    }", "\t\t\t    lp = first_sign;  /* start all over */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    }", "\t\t\t    lp = first_sign;  /* start all over */", "\t\t\t    continue;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    lp = first_sign;  /* start all over */", "\t\t\t    continue;", "\t\t\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    continue;", "\t\t\t}", "\t\t\tlp = lp->sn_next;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t}", "\t\t\tlp = lp->sn_next;", "\t\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tlp = lp->sn_next;", "\t\t    }", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t\t    sp->sn_typenr = next_sign_typenr;", "\t\t    if (++next_sign_typenr == MAX_TYPENR)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    sp->sn_typenr = next_sign_typenr;", "\t\t    if (++next_sign_typenr == MAX_TYPENR)", "\t\t\tnext_sign_typenr = 1; /* wrap around */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    if (++next_sign_typenr == MAX_TYPENR)", "\t\t\tnext_sign_typenr = 1; /* wrap around */", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t\t    sp->sn_name = vim_strsave(arg);", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t\t    /* add the new sign to the list of signs */", "\t\t    if (sp_prev == NULL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    /* add the new sign to the list of signs */", "\t\t    if (sp_prev == NULL)", "\t\t\tfirst_sign = sp;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    if (sp_prev == NULL)", "\t\t\tfirst_sign = sp;", "\t\t    else"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tfirst_sign = sp;", "\t\t    else", "\t\t\tsp_prev->sn_next = sp;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    else", "\t\t\tsp_prev->sn_next = sp;", "\t\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tsp_prev->sn_next = sp;", "\t\t}", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t\t/* set values for a defined sign. */", "\t\tfor (;;)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t/* set values for a defined sign. */", "\t\tfor (;;)", "\t\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tfor (;;)", "\t\t{", "\t\t    arg = skipwhite(p);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tfor (;;)", "\t\t{", "\t\t    arg = skipwhite(p);"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t\t{", "\t\t    arg = skipwhite(p);", "\t\t    if (*arg == NUL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    arg = skipwhite(p);", "\t\t    if (*arg == NUL)", "\t\t\tbreak;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    if (*arg == NUL)", "\t\t\tbreak;", "\t\t    p = skiptowhite_esc(arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tbreak;", "\t\t    p = skiptowhite_esc(arg);", "\t\t    if (STRNCMP(arg, \"icon=\", 5) == 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    p = skiptowhite_esc(arg);", "\t\t    if (STRNCMP(arg, \"icon=\", 5) == 0)", "\t\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    if (STRNCMP(arg, \"icon=\", 5) == 0)", "\t\t    {", "\t\t\targ += 5;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    {", "\t\t\targ += 5;", "\t\t\txfree(sp->sn_icon);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\targ += 5;", "\t\t\txfree(sp->sn_icon);", "\t\t\tsp->sn_icon = vim_strnsave(arg, (int)(p - arg));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\txfree(sp->sn_icon);", "\t\t\tsp->sn_icon = vim_strnsave(arg, (int)(p - arg));", "\t\t\tbackslash_halve(sp->sn_icon);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tsp->sn_icon = vim_strnsave(arg, (int)(p - arg));", "\t\t\tbackslash_halve(sp->sn_icon);", "\t\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tbackslash_halve(sp->sn_icon);", "\t\t    }", "\t\t    else if (STRNCMP(arg, \"text=\", 5) == 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    }", "\t\t    else if (STRNCMP(arg, \"text=\", 5) == 0)", "\t\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    }", "\t\t    else if (STRNCMP(arg, \"text=\", 5) == 0)", "\t\t    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t\t    else if (STRNCMP(arg, \"text=\", 5) == 0)", "\t\t    {", "\t\t\tchar_u\t*s;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    {", "\t\t\tchar_u\t*s;", "\t\t\tint\tcells;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tchar_u\t*s;", "\t\t\tint\tcells;", "\t\t\tint\tlen;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tint\tcells;", "\t\t\tint\tlen;", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t\t\targ += 5;", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t\t\t/* Count cells and check for non-printable chars */", "\t\t\tif (has_mbyte)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t/* Count cells and check for non-printable chars */", "\t\t\tif (has_mbyte)", "\t\t\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tif (has_mbyte)", "\t\t\t{", "\t\t\t    cells = 0;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tif (has_mbyte)", "\t\t\t{", "\t\t\t    cells = 0;"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t\t\t{", "\t\t\t    cells = 0;", "\t\t\t    for (s = arg; s < p; s += (*mb_ptr2len)(s))"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    cells = 0;", "\t\t\t    for (s = arg; s < p; s += (*mb_ptr2len)(s))", "\t\t\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    for (s = arg; s < p; s += (*mb_ptr2len)(s))", "\t\t\t    {", "\t\t\t\tif (!vim_isprintc((*mb_ptr2char)(s)))"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    {", "\t\t\t\tif (!vim_isprintc((*mb_ptr2char)(s)))", "\t\t\t\t    break;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\tif (!vim_isprintc((*mb_ptr2char)(s)))", "\t\t\t\t    break;", "\t\t\t\tcells += (*mb_ptr2cells)(s);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\t    break;", "\t\t\t\tcells += (*mb_ptr2cells)(s);", "\t\t\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\tcells += (*mb_ptr2cells)(s);", "\t\t\t    }", "\t\t\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    }", "\t\t\t}", "\t\t\telse"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t}", "\t\t\telse", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t}", "\t\t\telse", ""], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["", "\t\t\t{", "\t\t\t    for (s = arg; s < p; ++s)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t\t\t{", "\t\t\t    for (s = arg; s < p; ++s)"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t\t\t{", "\t\t\t    for (s = arg; s < p; ++s)", "\t\t\t\tif (!vim_isprintc(*s))"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    for (s = arg; s < p; ++s)", "\t\t\t\tif (!vim_isprintc(*s))", "\t\t\t\t    break;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\tif (!vim_isprintc(*s))", "\t\t\t\t    break;", "\t\t\t    cells = (int)(s - arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t\t    break;", "\t\t\t    cells = (int)(s - arg);", "\t\t\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    cells = (int)(s - arg);", "\t\t\t}", "\t\t\t/* Currently must be one or two display cells */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t}", "\t\t\t/* Currently must be one or two display cells */", "\t\t\tif (s != p || cells < 1 || cells > 2)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t/* Currently must be one or two display cells */", "\t\t\tif (s != p || cells < 1 || cells > 2)", "\t\t\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tif (s != p || cells < 1 || cells > 2)", "\t\t\t{", "\t\t\t    *p = NUL;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tif (s != p || cells < 1 || cells > 2)", "\t\t\t{", "\t\t\t    *p = NUL;"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t\t\t{", "\t\t\t    *p = NUL;", "\t\t\t    EMSG2(_(\"E239: Invalid sign text: %s\"), arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    *p = NUL;", "\t\t\t    EMSG2(_(\"E239: Invalid sign text: %s\"), arg);", "\t\t\t    return;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    EMSG2(_(\"E239: Invalid sign text: %s\"), arg);", "\t\t\t    return;", "\t\t\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    return;", "\t\t\t}", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t\t\txfree(sp->sn_text);", "\t\t\t/* Allocate one byte more if we need to pad up"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t * with a space. */", "\t\t\tlen = (int)(p - arg + ((cells == 1) ? 1 : 0));", "\t\t\tsp->sn_text = vim_strnsave(arg, len);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tlen = (int)(p - arg + ((cells == 1) ? 1 : 0));", "\t\t\tsp->sn_text = vim_strnsave(arg, len);", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t\t\tif (cells == 1)", "\t\t\t    STRCPY(sp->sn_text + len - 1, \" \");"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tif (cells == 1)", "\t\t\t    STRCPY(sp->sn_text + len - 1, \" \");", "\t\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\t    STRCPY(sp->sn_text + len - 1, \" \");", "\t\t    }", "\t\t    else if (STRNCMP(arg, \"linehl=\", 7) == 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    }", "\t\t    else if (STRNCMP(arg, \"linehl=\", 7) == 0)", "\t\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    }", "\t\t    else if (STRNCMP(arg, \"linehl=\", 7) == 0)", "\t\t    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t\t    else if (STRNCMP(arg, \"linehl=\", 7) == 0)", "\t\t    {", "\t\t\targ += 7;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    {", "\t\t\targ += 7;", "\t\t\tsp->sn_line_hl = syn_check_group(arg, (int)(p - arg));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\targ += 7;", "\t\t\tsp->sn_line_hl = syn_check_group(arg, (int)(p - arg));", "\t\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tsp->sn_line_hl = syn_check_group(arg, (int)(p - arg));", "\t\t    }", "\t\t    else if (STRNCMP(arg, \"texthl=\", 7) == 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    }", "\t\t    else if (STRNCMP(arg, \"texthl=\", 7) == 0)", "\t\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    }", "\t\t    else if (STRNCMP(arg, \"texthl=\", 7) == 0)", "\t\t    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t\t    else if (STRNCMP(arg, \"texthl=\", 7) == 0)", "\t\t    {", "\t\t\targ += 7;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    {", "\t\t\targ += 7;", "\t\t\tsp->sn_text_hl = syn_check_group(arg, (int)(p - arg));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\targ += 7;", "\t\t\tsp->sn_text_hl = syn_check_group(arg, (int)(p - arg));", "\t\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tsp->sn_text_hl = syn_check_group(arg, (int)(p - arg));", "\t\t    }", "\t\t    else"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    }", "\t\t    else", "\t\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    }", "\t\t    else", "\t\t    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t\t    else", "\t\t    {", "\t\t\tEMSG2(_(e_invarg2), arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    {", "\t\t\tEMSG2(_(e_invarg2), arg);", "\t\t\treturn;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\tEMSG2(_(e_invarg2), arg);", "\t\t\treturn;", "\t\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\treturn;", "\t\t    }", "\t\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    }", "\t\t}", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t}", "\t    }", "\t    else if (sp == NULL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else if (sp == NULL)", "\t\tEMSG2(_(\"E155: Unknown sign: %s\"), arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else if (sp == NULL)", "\t\tEMSG2(_(\"E155: Unknown sign: %s\"), arg);"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t    else if (sp == NULL)", "\t\tEMSG2(_(\"E155: Unknown sign: %s\"), arg);", "\t    else if (idx == SIGNCMD_LIST)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tEMSG2(_(\"E155: Unknown sign: %s\"), arg);", "\t    else if (idx == SIGNCMD_LIST)", "\t\t/* \":sign list {name}\" */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    else if (idx == SIGNCMD_LIST)", "\t\t/* \":sign list {name}\" */", "\t\tsign_list_defined(sp);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t/* \":sign list {name}\" */", "\t\tsign_list_defined(sp);", "\t    else"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tsign_list_defined(sp);", "\t    else", "\t\t/* \":sign undefine {name}\" */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    else", "\t\t/* \":sign undefine {name}\" */", "\t\tsign_undefine(sp, sp_prev);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t/* \":sign undefine {name}\" */", "\t\tsign_undefine(sp, sp_prev);", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tsign_undefine(sp, sp_prev);", "\t}", "    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    }", "    else", "    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["    {", "\tint\t\tid = -1;", "\tlinenr_T\tlnum = -1;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tint\t\tid = -1;", "\tlinenr_T\tlnum = -1;", "\tchar_u\t\t*sign_name = NULL;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tlinenr_T\tlnum = -1;", "\tchar_u\t\t*sign_name = NULL;", "\tchar_u\t\t*arg1;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tchar_u\t\t*sign_name = NULL;", "\tchar_u\t\t*arg1;", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\tif (*arg == NUL)", "\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tif (*arg == NUL)", "\t{", "\t    if (idx == SIGNCMD_PLACE)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tif (*arg == NUL)", "\t{", "\t    if (idx == SIGNCMD_PLACE)"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    if (idx == SIGNCMD_PLACE)", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    if (idx == SIGNCMD_PLACE)", "\t    {", "\t\t/* \":sign place\": list placed signs in all buffers */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\t/* \":sign place\": list placed signs in all buffers */", "\t\tsign_list_placed(NULL);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t/* \":sign place\": list placed signs in all buffers */", "\t\tsign_list_placed(NULL);", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tsign_list_placed(NULL);", "\t    }", "\t    else if (idx == SIGNCMD_UNPLACE)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else if (idx == SIGNCMD_UNPLACE)", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else if (idx == SIGNCMD_UNPLACE)", "\t    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t    else if (idx == SIGNCMD_UNPLACE)", "\t    {", "\t\t/* \":sign unplace\": remove placed sign at cursor */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\t/* \":sign unplace\": remove placed sign at cursor */", "\t\tid = buf_findsign_id(curwin->w_buffer, curwin->w_cursor.lnum);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t/* \":sign unplace\": remove placed sign at cursor */", "\t\tid = buf_findsign_id(curwin->w_buffer, curwin->w_cursor.lnum);", "\t\tif (id > 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tid = buf_findsign_id(curwin->w_buffer, curwin->w_cursor.lnum);", "\t\tif (id > 0)", "\t\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (id > 0)", "\t\t{", "\t\t    buf_delsign(curwin->w_buffer, id);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (id > 0)", "\t\t{", "\t\t    buf_delsign(curwin->w_buffer, id);"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t\t{", "\t\t    buf_delsign(curwin->w_buffer, id);", "\t\t    update_debug_sign(curwin->w_buffer, curwin->w_cursor.lnum);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    buf_delsign(curwin->w_buffer, id);", "\t\t    update_debug_sign(curwin->w_buffer, curwin->w_cursor.lnum);", "\t\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    update_debug_sign(curwin->w_buffer, curwin->w_cursor.lnum);", "\t\t}", "\t\telse"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t}", "\t\telse", "\t\t    EMSG(_(\"E159: Missing sign number\"));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t}", "\t\telse", "\t\t    EMSG(_(\"E159: Missing sign number\"));"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t\telse", "\t\t    EMSG(_(\"E159: Missing sign number\"));", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    EMSG(_(\"E159: Missing sign number\"));", "\t    }", "\t    else"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else", "\t\tEMSG(_(e_argreq));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else", "\t\tEMSG(_(e_argreq));"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t    else", "\t\tEMSG(_(e_argreq));", "\t    return;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tEMSG(_(e_argreq));", "\t    return;", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    return;", "\t}", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\tif (idx == SIGNCMD_UNPLACE && arg[0] == '*' && arg[1] == NUL)", "\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tif (idx == SIGNCMD_UNPLACE && arg[0] == '*' && arg[1] == NUL)", "\t{", "\t    /* \":sign unplace *\": remove all placed signs */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tif (idx == SIGNCMD_UNPLACE && arg[0] == '*' && arg[1] == NUL)", "\t{", "\t    /* \":sign unplace *\": remove all placed signs */"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    /* \":sign unplace *\": remove all placed signs */", "\t    buf_delete_all_signs();"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    /* \":sign unplace *\": remove all placed signs */", "\t    buf_delete_all_signs();", "\t    return;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    buf_delete_all_signs();", "\t    return;", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    return;", "\t}", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t/* first arg could be placed sign id */", "\targ1 = arg;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t/* first arg could be placed sign id */", "\targ1 = arg;", "\tif (ascii_isdigit(*arg))"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\targ1 = arg;", "\tif (ascii_isdigit(*arg))", "\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tif (ascii_isdigit(*arg))", "\t{", "\t    id = getdigits_int(&arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tif (ascii_isdigit(*arg))", "\t{", "\t    id = getdigits_int(&arg);"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    id = getdigits_int(&arg);", "\t    if (!ascii_iswhite(*arg) && *arg != NUL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    id = getdigits_int(&arg);", "\t    if (!ascii_iswhite(*arg) && *arg != NUL)", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    if (!ascii_iswhite(*arg) && *arg != NUL)", "\t    {", "\t\tid = -1;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\tid = -1;", "\t\targ = arg1;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tid = -1;", "\t\targ = arg1;", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\targ = arg1;", "\t    }", "\t    else"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else", "\t    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t    else", "\t    {", "\t\targ = skipwhite(arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\targ = skipwhite(arg);", "\t\tif (idx == SIGNCMD_UNPLACE && *arg == NUL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\targ = skipwhite(arg);", "\t\tif (idx == SIGNCMD_UNPLACE && *arg == NUL)", "\t\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (idx == SIGNCMD_UNPLACE && *arg == NUL)", "\t\t{", "\t\t  // \":sign unplace {id}\": remove placed sign by number"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (idx == SIGNCMD_UNPLACE && *arg == NUL)", "\t\t{", "\t\t  // \":sign unplace {id}\": remove placed sign by number"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t\t{", "\t\t  // \":sign unplace {id}\": remove placed sign by number", "\t\t  FOR_ALL_BUFFERS(buf) {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t  // \":sign unplace {id}\": remove placed sign by number", "\t\t  FOR_ALL_BUFFERS(buf) {", "\t\t    if ((lnum = buf_delsign(buf, id)) != 0) {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t  FOR_ALL_BUFFERS(buf) {", "\t\t    if ((lnum = buf_delsign(buf, id)) != 0) {", "\t\t      update_debug_sign(buf, lnum);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    if ((lnum = buf_delsign(buf, id)) != 0) {", "\t\t      update_debug_sign(buf, lnum);", "                    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["                    }", "\t\t  }", "\t\t  return;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t  }", "\t\t  return;", "\t\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t  return;", "\t\t}", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t}", "\t    }", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t}", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["        buf_T *buf = NULL;", "\tfor (;;)", "\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tfor (;;)", "\t{", "\t    if (STRNCMP(arg, \"line=\", 5) == 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tfor (;;)", "\t{", "\t    if (STRNCMP(arg, \"line=\", 5) == 0)"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    if (STRNCMP(arg, \"line=\", 5) == 0)", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    if (STRNCMP(arg, \"line=\", 5) == 0)", "\t    {", "\t\targ += 5;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\targ += 5;", "\t\tlnum = atoi((char *)arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\targ += 5;", "\t\tlnum = atoi((char *)arg);", "\t\targ = skiptowhite(arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tlnum = atoi((char *)arg);", "\t\targ = skiptowhite(arg);", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\targ = skiptowhite(arg);", "\t    }", "\t    else if (STRNCMP(arg, \"*\", 1) == 0 && idx == SIGNCMD_UNPLACE)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else if (STRNCMP(arg, \"*\", 1) == 0 && idx == SIGNCMD_UNPLACE)", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else if (STRNCMP(arg, \"*\", 1) == 0 && idx == SIGNCMD_UNPLACE)", "\t    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t    else if (STRNCMP(arg, \"*\", 1) == 0 && idx == SIGNCMD_UNPLACE)", "\t    {", "\t\tif (id != -1)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\tif (id != -1)", "\t\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (id != -1)", "\t\t{", "\t\t    EMSG(_(e_invarg));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (id != -1)", "\t\t{", "\t\t    EMSG(_(e_invarg));"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t\t{", "\t\t    EMSG(_(e_invarg));", "\t\t    return;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    EMSG(_(e_invarg));", "\t\t    return;", "\t\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    return;", "\t\t}", "\t\tid = -2;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t}", "\t\tid = -2;", "\t\targ = skiptowhite(arg + 1);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tid = -2;", "\t\targ = skiptowhite(arg + 1);", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\targ = skiptowhite(arg + 1);", "\t    }", "\t    else if (STRNCMP(arg, \"name=\", 5) == 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else if (STRNCMP(arg, \"name=\", 5) == 0)", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else if (STRNCMP(arg, \"name=\", 5) == 0)", "\t    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t    else if (STRNCMP(arg, \"name=\", 5) == 0)", "\t    {", "\t\targ += 5;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\targ += 5;", "\t\tsign_name = arg;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\targ += 5;", "\t\tsign_name = arg;", "\t\targ = skiptowhite(arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tsign_name = arg;", "\t\targ = skiptowhite(arg);", "\t\tif (*arg != NUL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\targ = skiptowhite(arg);", "\t\tif (*arg != NUL)", "\t\t    *arg++ = NUL;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (*arg != NUL)", "\t\t    *arg++ = NUL;", "\t\twhile (sign_name[0] == '0' && sign_name[1] != NUL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    *arg++ = NUL;", "\t\twhile (sign_name[0] == '0' && sign_name[1] != NUL)", "\t\t    ++sign_name;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\twhile (sign_name[0] == '0' && sign_name[1] != NUL)", "\t\t    ++sign_name;", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    ++sign_name;", "\t    }", "\t    else if (STRNCMP(arg, \"file=\", 5) == 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else if (STRNCMP(arg, \"file=\", 5) == 0)", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else if (STRNCMP(arg, \"file=\", 5) == 0)", "\t    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t    else if (STRNCMP(arg, \"file=\", 5) == 0)", "\t    {", "\t\targ += 5;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\targ += 5;", "\t\tbuf = buflist_findname(arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\targ += 5;", "\t\tbuf = buflist_findname(arg);", "\t\tbreak;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tbuf = buflist_findname(arg);", "\t\tbreak;", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tbreak;", "\t    }", "\t    else if (STRNCMP(arg, \"buffer=\", 7) == 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else if (STRNCMP(arg, \"buffer=\", 7) == 0)", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else if (STRNCMP(arg, \"buffer=\", 7) == 0)", "\t    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t    else if (STRNCMP(arg, \"buffer=\", 7) == 0)", "\t    {", "\t\targ += 7;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\targ += 7;", "\t\tbuf = buflist_findnr(getdigits_int(&arg));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\targ += 7;", "\t\tbuf = buflist_findnr(getdigits_int(&arg));", "\t\tif (*skipwhite(arg) != NUL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tbuf = buflist_findnr(getdigits_int(&arg));", "\t\tif (*skipwhite(arg) != NUL)", "\t\t    EMSG(_(e_trailing));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (*skipwhite(arg) != NUL)", "\t\t    EMSG(_(e_trailing));", "\t\tbreak;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    EMSG(_(e_trailing));", "\t\tbreak;", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tbreak;", "\t    }", "\t    else"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else", "\t    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t    else", "\t    {", "\t\tEMSG(_(e_invarg));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\tEMSG(_(e_invarg));", "\t\treturn;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tEMSG(_(e_invarg));", "\t\treturn;", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\treturn;", "\t    }", "\t    arg = skipwhite(arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    arg = skipwhite(arg);", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    arg = skipwhite(arg);", "\t}", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\tif (buf == NULL)", "\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tif (buf == NULL)", "\t{", "\t    EMSG2(_(\"E158: Invalid buffer name: %s\"), arg);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tif (buf == NULL)", "\t{", "\t    EMSG2(_(\"E158: Invalid buffer name: %s\"), arg);"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    EMSG2(_(\"E158: Invalid buffer name: %s\"), arg);", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    EMSG2(_(\"E158: Invalid buffer name: %s\"), arg);", "\t}", "\telse if (id <= 0 && !(idx == SIGNCMD_UNPLACE && id == -2))"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t}", "\telse if (id <= 0 && !(idx == SIGNCMD_UNPLACE && id == -2))", "\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t}", "\telse if (id <= 0 && !(idx == SIGNCMD_UNPLACE && id == -2))", "\t{"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\telse if (id <= 0 && !(idx == SIGNCMD_UNPLACE && id == -2))", "\t{", "\t    if (lnum >= 0 || sign_name != NULL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\telse if (id <= 0 && !(idx == SIGNCMD_UNPLACE && id == -2))", "\t{", "\t    if (lnum >= 0 || sign_name != NULL)"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    if (lnum >= 0 || sign_name != NULL)", "\t\tEMSG(_(e_invarg));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    if (lnum >= 0 || sign_name != NULL)", "\t\tEMSG(_(e_invarg));", "\t    else"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tEMSG(_(e_invarg));", "\t    else", "\t\t/* \":sign place file={fname}\": list placed signs in one file */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    else", "\t\t/* \":sign place file={fname}\": list placed signs in one file */", "\t\tsign_list_placed(buf);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t/* \":sign place file={fname}\": list placed signs in one file */", "\t\tsign_list_placed(buf);", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tsign_list_placed(buf);", "\t}", "\telse if (idx == SIGNCMD_JUMP)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t}", "\telse if (idx == SIGNCMD_JUMP)", "\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t}", "\telse if (idx == SIGNCMD_JUMP)", "\t{"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\telse if (idx == SIGNCMD_JUMP)", "\t{", "\t    /* \":sign jump {id} file={fname}\" */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\telse if (idx == SIGNCMD_JUMP)", "\t{", "\t    /* \":sign jump {id} file={fname}\" */"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    /* \":sign jump {id} file={fname}\" */", "\t    if (lnum >= 0 || sign_name != NULL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    /* \":sign jump {id} file={fname}\" */", "\t    if (lnum >= 0 || sign_name != NULL)", "\t\tEMSG(_(e_invarg));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    if (lnum >= 0 || sign_name != NULL)", "\t\tEMSG(_(e_invarg));", "\t    else if ((lnum = buf_findsign(buf, id)) > 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tEMSG(_(e_invarg));", "\t    else if ((lnum = buf_findsign(buf, id)) > 0)", "\t    {\t\t\t\t/* goto a sign ... */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    else if ((lnum = buf_findsign(buf, id)) > 0)", "\t    {\t\t\t\t/* goto a sign ... */", "\t\tif (buf_jump_open_win(buf) != NULL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {\t\t\t\t/* goto a sign ... */", "\t\tif (buf_jump_open_win(buf) != NULL)", "\t\t{\t\t\t/* ... in a current window */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (buf_jump_open_win(buf) != NULL)", "\t\t{\t\t\t/* ... in a current window */", "\t\t    curwin->w_cursor.lnum = lnum;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (buf_jump_open_win(buf) != NULL)", "\t\t{\t\t\t/* ... in a current window */", "\t\t    curwin->w_cursor.lnum = lnum;"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t\t{\t\t\t/* ... in a current window */", "\t\t    curwin->w_cursor.lnum = lnum;", "\t\t    check_cursor_lnum();"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    curwin->w_cursor.lnum = lnum;", "\t\t    check_cursor_lnum();", "\t\t    beginline(BL_WHITE);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    check_cursor_lnum();", "\t\t    beginline(BL_WHITE);", "\t\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    beginline(BL_WHITE);", "\t\t}", "\t\telse"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t}", "\t\telse", "\t\t{   // ... not currently in a window"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t}", "\t\telse", "\t\t{   // ... not currently in a window"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t\telse", "\t\t{   // ... not currently in a window", "\t\t    char *cmd = xmalloc(STRLEN(buf->b_fname) + 25);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\telse", "\t\t{   // ... not currently in a window", "\t\t    char *cmd = xmalloc(STRLEN(buf->b_fname) + 25);"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t\t{   // ... not currently in a window", "\t\t    char *cmd = xmalloc(STRLEN(buf->b_fname) + 25);", "\t\t    sprintf(cmd, \"e +%\" PRId64 \" %s\","], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    char *cmd = xmalloc(STRLEN(buf->b_fname) + 25);", "\t\t    sprintf(cmd, \"e +%\" PRId64 \" %s\",", "                    (int64_t)lnum, buf->b_fname);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    char *cmd = xmalloc(STRLEN(buf->b_fname) + 25);", "\t\t    sprintf(cmd, \"e +%\" PRId64 \" %s\",", "                    (int64_t)lnum, buf->b_fname);"], "runtime/printf"]
["src/nvim/ex_cmds.c", ["                    (int64_t)lnum, buf->b_fname);", "\t\t    do_cmdline_cmd(cmd);", "\t\t    xfree(cmd);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    do_cmdline_cmd(cmd);", "\t\t    xfree(cmd);", "\t\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    xfree(cmd);", "\t\t}", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["", "\t\tfoldOpenCursor();", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tfoldOpenCursor();", "\t    }", "\t    else"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else", "\t\tEMSGN(_(\"E157: Invalid sign ID: %\" PRId64), id);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else", "\t\tEMSGN(_(\"E157: Invalid sign ID: %\" PRId64), id);"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t    else", "\t\tEMSGN(_(\"E157: Invalid sign ID: %\" PRId64), id);", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tEMSGN(_(\"E157: Invalid sign ID: %\" PRId64), id);", "\t}", "\telse if (idx == SIGNCMD_UNPLACE)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t}", "\telse if (idx == SIGNCMD_UNPLACE)", "\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t}", "\telse if (idx == SIGNCMD_UNPLACE)", "\t{"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\telse if (idx == SIGNCMD_UNPLACE)", "\t{", "\t    if (lnum >= 0 || sign_name != NULL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\telse if (idx == SIGNCMD_UNPLACE)", "\t{", "\t    if (lnum >= 0 || sign_name != NULL)"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    if (lnum >= 0 || sign_name != NULL)", "\t\tEMSG(_(e_invarg));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    if (lnum >= 0 || sign_name != NULL)", "\t\tEMSG(_(e_invarg));", "\t    else if (id == -2)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tEMSG(_(e_invarg));", "\t    else if (id == -2)", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    else if (id == -2)", "\t    {", "\t\t/* \":sign unplace * file={fname}\" */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\t/* \":sign unplace * file={fname}\" */", "\t\tredraw_buf_later(buf, NOT_VALID);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t/* \":sign unplace * file={fname}\" */", "\t\tredraw_buf_later(buf, NOT_VALID);", "\t\tbuf_delete_signs(buf);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tredraw_buf_later(buf, NOT_VALID);", "\t\tbuf_delete_signs(buf);", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tbuf_delete_signs(buf);", "\t    }", "\t    else"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    else", "\t    {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\t    else", "\t    {", "\t\t/* \":sign unplace {id} file={fname}\" */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\t/* \":sign unplace {id} file={fname}\" */", "\t\tlnum = buf_delsign(buf, id);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t/* \":sign unplace {id} file={fname}\" */", "\t\tlnum = buf_delsign(buf, id);", "\t\tupdate_debug_sign(buf, lnum);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tlnum = buf_delsign(buf, id);", "\t\tupdate_debug_sign(buf, lnum);", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tupdate_debug_sign(buf, lnum);", "\t    }", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t}", "\t    /* idx == SIGNCMD_PLACE */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t}", "\t    /* idx == SIGNCMD_PLACE */", "\telse if (sign_name != NULL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    /* idx == SIGNCMD_PLACE */", "\telse if (sign_name != NULL)", "\t{"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    /* idx == SIGNCMD_PLACE */", "\telse if (sign_name != NULL)", "\t{"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\telse if (sign_name != NULL)", "\t{", "\t    for (sp = first_sign; sp != NULL; sp = sp->sn_next)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\telse if (sign_name != NULL)", "\t{", "\t    for (sp = first_sign; sp != NULL; sp = sp->sn_next)"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    for (sp = first_sign; sp != NULL; sp = sp->sn_next)", "\t\tif (STRCMP(sp->sn_name, sign_name) == 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    for (sp = first_sign; sp != NULL; sp = sp->sn_next)", "\t\tif (STRCMP(sp->sn_name, sign_name) == 0)", "\t\t    break;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tif (STRCMP(sp->sn_name, sign_name) == 0)", "\t\t    break;", "\t    if (sp == NULL)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t    break;", "\t    if (sp == NULL)", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    if (sp == NULL)", "\t    {", "\t\tEMSG2(_(\"E155: Unknown sign: %s\"), sign_name);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\tEMSG2(_(\"E155: Unknown sign: %s\"), sign_name);", "\t\treturn;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tEMSG2(_(\"E155: Unknown sign: %s\"), sign_name);", "\t\treturn;", "\t    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\treturn;", "\t    }", "\t    if (lnum > 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    }", "\t    if (lnum > 0)", "\t\t/* \":sign place {id} line={lnum} name={name} file={fname}\":"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t * place a sign */", "\t\tbuf_addsign(buf, id, lnum, sp->sn_typenr);", "\t    else"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\tbuf_addsign(buf, id, lnum, sp->sn_typenr);", "\t    else", "\t\t/* \":sign place {id} file={fname}\": change sign type */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    else", "\t\t/* \":sign place {id} file={fname}\": change sign type */", "\t\tlnum = buf_change_sign_type(buf, id, sp->sn_typenr);"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t/* \":sign place {id} file={fname}\": change sign type */", "\t\tlnum = buf_change_sign_type(buf, id, sp->sn_typenr);", "            if (lnum > 0)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["                EMSG2(_(\"E885: Not possible to change sign %s\"), sign_name);", "\t}", "\telse"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t}", "\telse", "\t    EMSG(_(e_invarg));"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t}", "\telse", "\t    EMSG(_(e_invarg));"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["\telse", "\t    EMSG(_(e_invarg));", "    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["{", "    EXP_SUBCMD,\t\t/* expand :sign sub-commands */", "    EXP_DEFINE,\t\t/* expand :sign define {name} args */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    EXP_SUBCMD,\t\t/* expand :sign sub-commands */", "    EXP_DEFINE,\t\t/* expand :sign define {name} args */", "    EXP_PLACE,\t\t/* expand :sign place {id} args */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    EXP_DEFINE,\t\t/* expand :sign define {name} args */", "    EXP_PLACE,\t\t/* expand :sign place {id} args */", "    EXP_UNPLACE,\t/* expand :sign unplace\" */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    EXP_PLACE,\t\t/* expand :sign place {id} args */", "    EXP_UNPLACE,\t/* expand :sign unplace\" */", "    EXP_SIGN_NAMES\t/* expand with name of placed signs */"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    EXP_UNPLACE,\t/* expand :sign unplace\" */", "    EXP_SIGN_NAMES\t/* expand with name of placed signs */", "} expand_what;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["{", "    sign_T\t*sp;", "    int\t\tcurrent_idx;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    sign_T\t*sp;", "    int\t\tcurrent_idx;", ""], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    case EXP_SUBCMD:", "\treturn (char_u *)cmds[idx];", "    case EXP_DEFINE:"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    case EXP_DEFINE:", "\t{", "\t    char *define_arg[] ="], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    case EXP_DEFINE:", "\t{", "\t    char *define_arg[] ="], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    char *define_arg[] =", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    char *define_arg[] =", "\t    {", "\t\t\"icon=\", \"linehl=\", \"text=\", \"texthl=\", NULL"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\t\"icon=\", \"linehl=\", \"text=\", \"texthl=\", NULL", "\t    };"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\"icon=\", \"linehl=\", \"text=\", \"texthl=\", NULL", "\t    };", "\t    return (char_u *)define_arg[idx];"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    };", "\t    return (char_u *)define_arg[idx];", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    return (char_u *)define_arg[idx];", "\t}", "    case EXP_PLACE:"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    case EXP_PLACE:", "\t{", "\t    char *place_arg[] ="], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    case EXP_PLACE:", "\t{", "\t    char *place_arg[] ="], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    char *place_arg[] =", "\t    {"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    char *place_arg[] =", "\t    {", "\t\t\"line=\", \"name=\", \"file=\", \"buffer=\", NULL"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    {", "\t\t\"line=\", \"name=\", \"file=\", \"buffer=\", NULL", "\t    };"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\t\"line=\", \"name=\", \"file=\", \"buffer=\", NULL", "\t    };", "\t    return (char_u *)place_arg[idx];"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    };", "\t    return (char_u *)place_arg[idx];", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    return (char_u *)place_arg[idx];", "\t}", "    case EXP_UNPLACE:"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    case EXP_UNPLACE:", "\t{", "\t    char *unplace_arg[] = { \"file=\", \"buffer=\", NULL };"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    case EXP_UNPLACE:", "\t{", "\t    char *unplace_arg[] = { \"file=\", \"buffer=\", NULL };"], "whitespace/braces"]
["src/nvim/ex_cmds.c", ["\t{", "\t    char *unplace_arg[] = { \"file=\", \"buffer=\", NULL };", "\t    return (char_u *)unplace_arg[idx];"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    char *unplace_arg[] = { \"file=\", \"buffer=\", NULL };", "\t    return (char_u *)unplace_arg[idx];", "\t}"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    return (char_u *)unplace_arg[idx];", "\t}", "    case EXP_SIGN_NAMES:"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    case EXP_SIGN_NAMES:", "\t/* Complete with name of signs already defined */", "\tcurrent_idx = 0;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t/* Complete with name of signs already defined */", "\tcurrent_idx = 0;", "\tfor (sp = first_sign; sp != NULL; sp = sp->sn_next)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tcurrent_idx = 0;", "\tfor (sp = first_sign; sp != NULL; sp = sp->sn_next)", "\t    if (current_idx++ == idx)"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\tfor (sp = first_sign; sp != NULL; sp = sp->sn_next)", "\t    if (current_idx++ == idx)", "\t\treturn sp->sn_name;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t    if (current_idx++ == idx)", "\t\treturn sp->sn_name;", "\treturn NULL;"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["\t\treturn sp->sn_name;", "\treturn NULL;", "    default:"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["    default:", "\treturn NULL;", "    }"], "whitespace/tab"]
["src/nvim/ex_cmds.c", ["  }", "  else", "  {"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["static int quitmore = 0;", "static int ex_pressedreturn = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  dsp->trylevel       = trylevel;             trylevel = 0;", "  dsp->force_abort    = force_abort;          force_abort = FALSE;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->trylevel       = trylevel;             trylevel = 0;", "  dsp->force_abort    = force_abort;          force_abort = FALSE;", "  dsp->caught_stack   = caught_stack;         caught_stack = NULL;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  dsp->force_abort    = force_abort;          force_abort = FALSE;", "  dsp->caught_stack   = caught_stack;         caught_stack = NULL;", "  dsp->vv_exception   = v_exception(NULL);"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  /* Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\" */", "  dsp->did_emsg       = did_emsg;             did_emsg     = FALSE;", "  dsp->got_int        = got_int;              got_int      = FALSE;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  /* Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\" */", "  dsp->did_emsg       = did_emsg;             did_emsg     = FALSE;", "  dsp->got_int        = got_int;              got_int      = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  dsp->did_emsg       = did_emsg;             did_emsg     = FALSE;", "  dsp->got_int        = got_int;              got_int      = FALSE;", "  dsp->did_throw      = did_throw;            did_throw    = FALSE;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->did_emsg       = did_emsg;             did_emsg     = FALSE;", "  dsp->got_int        = got_int;              got_int      = FALSE;", "  dsp->did_throw      = did_throw;            did_throw    = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  dsp->got_int        = got_int;              got_int      = FALSE;", "  dsp->did_throw      = did_throw;            did_throw    = FALSE;", "  dsp->need_rethrow   = need_rethrow;         need_rethrow = FALSE;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->got_int        = got_int;              got_int      = FALSE;", "  dsp->did_throw      = did_throw;            did_throw    = FALSE;", "  dsp->need_rethrow   = need_rethrow;         need_rethrow = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  dsp->did_throw      = did_throw;            did_throw    = FALSE;", "  dsp->need_rethrow   = need_rethrow;         need_rethrow = FALSE;", "  dsp->check_cstack   = check_cstack;         check_cstack = FALSE;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->did_throw      = did_throw;            did_throw    = FALSE;", "  dsp->need_rethrow   = need_rethrow;         need_rethrow = FALSE;", "  dsp->check_cstack   = check_cstack;         check_cstack = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  dsp->need_rethrow   = need_rethrow;         need_rethrow = FALSE;", "  dsp->check_cstack   = check_cstack;         check_cstack = FALSE;", "  dsp->current_exception = current_exception; current_exception = NULL;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->need_rethrow   = need_rethrow;         need_rethrow = FALSE;", "  dsp->check_cstack   = check_cstack;         check_cstack = FALSE;", "  dsp->current_exception = current_exception; current_exception = NULL;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  dsp->check_cstack   = check_cstack;         check_cstack = FALSE;", "  dsp->current_exception = current_exception; current_exception = NULL;", "}"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["{", "  suppress_errthrow = FALSE;", "  trylevel = dsp->trylevel;"], "readability/bool"]
["src/nvim/ex_docmd.c", [" */", "void ", "do_exmode ("], "whitespace/end_of_line"]
["src/nvim/ex_docmd.c", ["void ", "do_exmode (", "    int improved                       /* TRUE for \"improved Ex\" mode */"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    if (ex_normal_busy > 0 && typebuf.tb_len == 0) {", "      exmode_active = FALSE;", "      break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    }", "    msg_scroll = TRUE;", "    need_wait_return = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    msg_scroll = TRUE;", "    need_wait_return = FALSE;", "    ex_pressedreturn = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    need_wait_return = FALSE;", "    ex_pressedreturn = FALSE;", "    ex_no_reprint = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    ex_pressedreturn = FALSE;", "    ex_no_reprint = FALSE;", "    changedtick = curbuf->b_changedtick;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      do_cmdline(NULL, getexline, NULL, 0);", "    } else", "      do_cmdline(NULL, getexmodeline, NULL, DOCMD_NOWAIT);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        EMSG(_(e_emptybuf));", "      else {", "        if (ex_pressedreturn) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        msg_col = 0;", "        print_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);", "        msg_clr_eos();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  update_screen(CLEAR);", "  need_wait_return = FALSE;", "  msg_scroll = save_msg_scroll;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  char_u      *cmdline_copy = NULL;     /* copy of cmd line */", "  int used_getline = FALSE;             /* used \"fgetline\" to obtain command */", "  static int recursive = 0;             /* recursive depth */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int count = 0;                        /* line number count */", "  int did_inc = FALSE;                  /* incremented RedrawingDisabled */", "  int retval = OK;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (!recursive) {", "    force_abort = FALSE;", "    suppress_errthrow = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    force_abort = FALSE;", "    suppress_errthrow = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["   */", "  did_throw = FALSE;", "  /*"], "readability/bool"]
["src/nvim/ex_docmd.c", ["   */", "  did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["      && !getline_equal(fgetline, cookie, getexline))", "    KeyTyped = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["        )", "      did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["        }", "      } else if (do_profiling == PROF_YES", "                 && getline_equal(fgetline, cookie, getsourceline))"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (count == 1 && getline_equal(fgetline, cookie, getexline))", "        msg_didout = TRUE;", "      if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,"], "readability/bool"]
["src/nvim/ex_docmd.c", ["                                   0 ? 0 : (cstack.cs_idx + 1) * 2", "                                   )) == NULL) {", "        /* Don't call wait_return for aborted command line.  The NULL"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["        if (KeyTyped && !(flags & DOCMD_REPEAT))", "          need_wait_return = FALSE;", "        retval = FAIL;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      }", "      used_getline = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["    /* 3. Make a copy of the command so we can mess with it. */", "    else if (cmdline_copy == NULL) {", "      next_cmdline = vim_strsave(next_cmdline);"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    }", "    did_endif = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["        msg_didout_before_start = msg_didout;", "        msg_didany = FALSE;         /* no output yet */", "        msg_start();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        msg_start();", "        msg_scroll = TRUE;          /* put messages below each other */", "        ++no_wait_return;           /* don't wait for return until finished */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        ++RedrawingDisabled;", "        did_inc = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        && !func_has_abort(real_cookie))", "      did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["       */", "      else if (cstack.cs_lflags & CSL_HAD_LOOP) {", "        cstack.cs_lflags &= ~CSL_HAD_LOOP;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["          did_throw ? (void *)current_exception : NULL);", "      did_emsg = got_int = did_throw = FALSE;", "      cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (trylevel == 0 && !did_emsg && !got_int && !did_throw)", "      force_abort = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["    (void)do_intthrow(&cstack);", "", "  }"], "whitespace/blank_line"]
["src/nvim/ex_docmd.c", ["             || cstack.cs_idx >= 0", "             || (flags & DOCMD_REPEAT)));", ""], "whitespace/empty_loop_body"]
["src/nvim/ex_docmd.c", ["  xfree(cmdline_copy);", "  did_emsg_syntax = FALSE;", "  GA_DEEP_CLEAR(&lines_ga, wcmd_T, FREE_WCMD);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    do {", "      int idx = cleanup_conditionals(&cstack, 0, TRUE);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["      discard_current_exception();              /* uses IObuff if 'verbose' */", "      suppress_errthrow = TRUE;", "      force_abort = TRUE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      suppress_errthrow = TRUE;", "      force_abort = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["     */", "    else if (got_int || (did_emsg && force_abort))", "      suppress_errthrow = TRUE;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    else if (got_int || (did_emsg && force_abort))", "      suppress_errthrow = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (did_throw)", "    need_rethrow = TRUE;", "  if ((getline_equal(fgetline, cookie, getsourceline)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (!did_throw)", "      check_cstack = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    --no_wait_return;", "    msg_scroll = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["        ) {", "      need_wait_return = FALSE;", "      msg_didany = FALSE;               /* don't wait when restarting edit */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      need_wait_return = FALSE;", "      msg_didany = FALSE;               /* don't wait when restarting edit */", "    } else if (need_wait_return) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      msg_didout |= msg_didout_before_start;", "      wait_return(FALSE);", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  did_endif = FALSE;    /* in case do_cmdline used recursively */", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  KeyTyped = FALSE;", "  ++cp->current_line;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int did_esilent = 0;", "  int did_sandbox = FALSE;", "  cmdmod_T save_cmdmod;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ea.cmd = (char_u *)\"+\";", "      ex_pressedreturn = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (*ea.cmd == NUL) {", "      ex_pressedreturn = TRUE;", "      goto doend;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        break;", "      cmdmod.confirm = TRUE;", "      continue;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    case 'k':   if (checkforcmd(&ea.cmd, \"keepmarks\", 3)) {", "        cmdmod.keepmarks = TRUE;", "        continue;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (checkforcmd(&ea.cmd, \"keepalt\", 5)) {", "        cmdmod.keepalt = TRUE;", "        continue;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (checkforcmd(&ea.cmd, \"keeppatterns\", 5)) {", "        cmdmod.keeppatterns = TRUE;", "        continue;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        break;", "      cmdmod.keepjumps = TRUE;", "      continue;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ea.cmd = p;", "      cmdmod.hide = TRUE;", "      continue;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    case 'l':   if (checkforcmd(&ea.cmd, \"lockmarks\", 3)) {", "        cmdmod.lockmarks = TRUE;", "        continue;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["          ++sandbox;", "        did_sandbox = TRUE;", "        continue;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (!ea.skip && got_int) {", "    ea.skip = TRUE;", "    (void)do_intthrow(cstack);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      /* '*' - visual area */", "      else if (*ea.cmd == '*') {", "        pos_T       *fp;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["        if (!ea.skip) {", "          fp = getmark('<', FALSE);", "          if (check_mark(fp) == FAIL)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["          ea.line1 = fp->lnum;", "          fp = getmark('>', FALSE);", "          if (check_mark(fp) == FAIL)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      }", "    } else", "      ea.line2 = lnum;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        curwin->w_cursor.lnum = ea.line2;", "    } else if (*ea.cmd != ',')", "      break;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        errormsg = (char_u *)_(e_invrange);", "      else {", "        if (ea.line2 == 0)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    p = vim_strnsave(ea.cmd, p - ea.cmd);", "    int ret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, TRUE, NULL);", "    xfree(p);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      errormsg = IObuff;", "      did_emsg_syntax = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["           || cmdnames[ea.cmdidx].cmd_func == ex_script_ni", "    ));", ""], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    ++p;", "    ea.forceit = TRUE;", "  } else"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    ea.forceit = TRUE;", "  } else", "    ea.forceit = FALSE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  } else", "    ea.forceit = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["        if (ask_yesno((char_u *)", "                _(\"Backwards range given, OK to swap\"), FALSE) != 'y')", "          goto doend;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ea.arg = skipwhite(ea.arg + 1);", "      ea.append = TRUE;", "    } else if (*ea.arg == '!' && ea.cmdidx == CMD_write) { /* :w !filter */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ++ea.arg;", "      ea.usefilter = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (ea.forceit) {", "      ea.usefilter = TRUE;                      /* :r! filter if ea.forceit */", "      ea.forceit = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ea.usefilter = TRUE;                      /* :r! filter if ea.forceit */", "      ea.forceit = FALSE;", "    } else if (*ea.arg == '!') {              /* :r !filter */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ++ea.arg;", "      ea.usefilter = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      p = skiptowhite_esc(ea.arg);", "    else {", "      p = ea.arg + STRLEN(ea.arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    ea.line2 = buflist_findpat(ea.arg, p, (ea.argt & BUFUNL) != 0,", "        FALSE, FALSE);", "    if (ea.line2 < 0)               /* failed */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (source_finished(fgetline, cookie))", "      do_finish(&ea, TRUE);", "    else if (getline_equal(fgetline, cookie, get_func_line)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["             && current_func_returned())", "      do_return(&ea, TRUE, FALSE, NULL);", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  need_rethrow = check_cstack = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["  return ea.nextcmd;", "}", ""], "readability/fn_size"]
["src/nvim/ex_docmd.c", [" */", "int ", "checkforcmd ("], "whitespace/end_of_line"]
["src/nvim/ex_docmd.c", ["int ", "checkforcmd (", "    char_u **pp,               /* start of command */"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    *pp = skipwhite(*pp + i);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      d += 4;", "    } else", "      MB_COPY_CHAR(s, d);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["            && cmdnames[(int)eap->cmdidx].cmd_name[len] == NUL)", "          *full = TRUE;", "        break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["static char_u *", "find_ucmd (", "    exarg_T *eap,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["  ucmd_T      *uc;", "  int found = FALSE;", "  int possible = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int found = FALSE;", "  int possible = FALSE;", "  char_u      *cp, *np;             /* Point into typed cmd and test name */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  garray_T    *gap;", "  int amb_local = FALSE;            /* Found ambiguous buffer-local command,", "                                       only full match global is accepted. */"], "readability/multiline_comment"]
["src/nvim/ex_docmd.c", ["  garray_T    *gap;", "  int amb_local = FALSE;            /* Found ambiguous buffer-local command,", "                                       only full match global is accepted. */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["            return NULL;", "          amb_local = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["          if (k == len)", "            found = TRUE;", "          else"], "readability/bool"]
["src/nvim/ex_docmd.c", ["          else", "            possible = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "          if (compl != NULL)", "            *compl = uc->uc_compl;"], "readability/alt_tokens"]
["src/nvim/ex_docmd.c", ["            if (full != NULL)", "              *full = TRUE;", "            amb_local = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["              *full = TRUE;", "            amb_local = FALSE;", "            break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["} cmdmods[] = {", "  {\"aboveleft\", 3, FALSE},", "  {\"belowright\", 3, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"aboveleft\", 3, FALSE},", "  {\"belowright\", 3, FALSE},", "  {\"botright\", 2, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"belowright\", 3, FALSE},", "  {\"botright\", 2, FALSE},", "  {\"browse\", 3, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"botright\", 2, FALSE},", "  {\"browse\", 3, FALSE},", "  {\"confirm\", 4, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"browse\", 3, FALSE},", "  {\"confirm\", 4, FALSE},", "  {\"hide\", 3, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"confirm\", 4, FALSE},", "  {\"hide\", 3, FALSE},", "  {\"keepalt\", 5, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"hide\", 3, FALSE},", "  {\"keepalt\", 5, FALSE},", "  {\"keepjumps\", 5, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"keepalt\", 5, FALSE},", "  {\"keepjumps\", 5, FALSE},", "  {\"keepmarks\", 3, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"keepjumps\", 5, FALSE},", "  {\"keepmarks\", 3, FALSE},", "  {\"keeppatterns\", 5, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"keepmarks\", 3, FALSE},", "  {\"keeppatterns\", 5, FALSE},", "  {\"leftabove\", 5, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"keeppatterns\", 5, FALSE},", "  {\"leftabove\", 5, FALSE},", "  {\"lockmarks\", 3, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"leftabove\", 5, FALSE},", "  {\"lockmarks\", 3, FALSE},", "  {\"noautocmd\", 3, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"lockmarks\", 3, FALSE},", "  {\"noautocmd\", 3, FALSE},", "  {\"noswapfile\", 3, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"noautocmd\", 3, FALSE},", "  {\"noswapfile\", 3, FALSE},", "  {\"rightbelow\", 6, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"noswapfile\", 3, FALSE},", "  {\"rightbelow\", 6, FALSE},", "  {\"sandbox\", 3, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"rightbelow\", 6, FALSE},", "  {\"sandbox\", 3, FALSE},", "  {\"silent\", 3, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"sandbox\", 3, FALSE},", "  {\"silent\", 3, FALSE},", "  {\"tab\", 3, TRUE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"silent\", 3, FALSE},", "  {\"tab\", 3, TRUE},", "  {\"topleft\", 2, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"tab\", 3, TRUE},", "  {\"topleft\", 2, FALSE},", "  {\"unsilent\", 3, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"topleft\", 2, FALSE},", "  {\"unsilent\", 3, FALSE},", "  {\"verbose\", 4, TRUE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"unsilent\", 3, FALSE},", "  {\"verbose\", 4, TRUE},", "  {\"vertical\", 4, FALSE},"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {\"verbose\", 4, TRUE},", "  {\"vertical\", 4, FALSE},", "};"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  exarg_T ea;", "  int full = FALSE;", "  int i;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["char_u *", "set_one_cmd_context (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["  exarg_T ea;", "  int                 compl = EXPAND_NOTHING;", "  int delim;"], "readability/alt_tokens"]
["src/nvim/ex_docmd.c", ["  int delim;", "  int forceit = FALSE;", "  int usefilter = FALSE;                    /* filter instead of file name */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int forceit = FALSE;", "  int usefilter = FALSE;                    /* filter instead of file name */", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["  for (cmd = buff; vim_strchr((char_u *)\" \\t:|\", *cmd) != NULL; cmd++)", "    ;", "  xp->xp_pattern = cmd;"], "whitespace/semicolon"]
["src/nvim/ex_docmd.c", ["          &compl", "          );", "      if (p == NULL)"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["  if (*p == '!') {                  /* forced commands */", "    forceit = TRUE;", "    ++p;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ++arg;", "      usefilter = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ++arg;", "      usefilter = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    p = arg + 1;", "    arg = skip_cmd_arg(arg, FALSE);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["    int c;", "    int in_quote = FALSE;", "    char_u  *bow = NULL;        /* Beginning of word */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["       * characters that end the command and white space. */", "      else if (c == '|'", "            || c == '\\n'"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["#ifndef BACKSLASH_IN_FILENAME", "      xp->xp_shell = TRUE;", "#endif"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        /* Avoid that the assignment uses EXPAND_FILES again. */", "        if (compl != EXPAND_USER_DEFINED && compl != EXPAND_USER_LIST)", "          compl = EXPAND_ENV_VARS;"], "readability/alt_tokens"]
["src/nvim/ex_docmd.c", ["        /* Avoid that the assignment uses EXPAND_FILES again. */", "        if (compl != EXPAND_USER_DEFINED && compl != EXPAND_USER_LIST)", "          compl = EXPAND_ENV_VARS;"], "readability/alt_tokens"]
["src/nvim/ex_docmd.c", ["        if (compl != EXPAND_USER_DEFINED && compl != EXPAND_USER_LIST)", "          compl = EXPAND_ENV_VARS;", "      }"], "readability/alt_tokens"]
["src/nvim/ex_docmd.c", ["      for (p = xp->xp_pattern + 1; *p != NUL && *p != '/'; ++p)", "        ;", "      /* Complete ~user only if it partially matches a user name."], "whitespace/semicolon"]
["src/nvim/ex_docmd.c", ["  case CMD_autocmd:", "    return set_context_in_autocmd(xp, arg, FALSE);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["  case CMD_doautoall:", "    return set_context_in_autocmd(xp, arg, TRUE);", "  case CMD_set:"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  case CMD_USER_BUF:", "    if (compl != EXPAND_NOTHING) {", "      /* XFILE: file names are handled above */"], "readability/alt_tokens"]
["src/nvim/ex_docmd.c", ["      if (!(ea.argt & XFILE)) {", "        if (compl == EXPAND_MENUS)", "          return set_context_in_menu_cmd(xp, cmd, arg, forceit);"], "readability/alt_tokens"]
["src/nvim/ex_docmd.c", ["          return set_context_in_menu_cmd(xp, cmd, arg, forceit);", "        if (compl == EXPAND_COMMANDS)", "          return arg;"], "readability/alt_tokens"]
["src/nvim/ex_docmd.c", ["          return arg;", "        if (compl == EXPAND_MAPPINGS)", "          return set_context_in_map_cmd(xp, (char_u *)\"map\","], "readability/alt_tokens"]
["src/nvim/ex_docmd.c", ["          return set_context_in_map_cmd(xp, (char_u *)\"map\",", "              arg, forceit, FALSE, FALSE, CMD_map);", "        /* Find start of last argument. */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    return set_context_in_map_cmd(xp, cmd, arg, forceit,", "        FALSE, FALSE, ea.cmdidx);", "  case CMD_unmap:"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    return set_context_in_map_cmd(xp, cmd, arg, forceit,", "        FALSE, TRUE, ea.cmdidx);", "  case CMD_abbreviate:    case CMD_noreabbrev:"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    return set_context_in_map_cmd(xp, cmd, arg, forceit,", "        TRUE, FALSE, ea.cmdidx);", "  case CMD_unabbreviate:"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    return set_context_in_map_cmd(xp, cmd, arg, forceit,", "        TRUE, TRUE, ea.cmdidx);", "  case CMD_menu:      case CMD_noremenu:      case CMD_unmenu:"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        xp->xp_pattern = skipwhite(p);", "      } else", "        xp->xp_context = EXPAND_NOTHING;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  return NULL;", "}", ""], "readability/fn_size"]
["src/nvim/ex_docmd.c", ["char_u *", "skip_range (", "    char_u *cmd,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["        ++cmd;", "      else {", "        /* Only accept a mark in another file when it is"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          lnum = curwin->w_cursor.lnum;", "        else {", "          if (check_mark(fp) == FAIL) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        i = RE_SEARCH;", "      else {", "        EMSG(_(e_backslash));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          lnum = pos.lnum;", "        else {", "          cmd = NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        i = *cmd++;", "      if (!ascii_isdigit(*cmd))           /* '+' is '+1', but '+0' is not '+1' */", "        n = 1;"], "whitespace/line_length"]
["src/nvim/ex_docmd.c", ["      if (addr_type == ADDR_LOADED_BUFFERS || addr_type == ADDR_BUFFERS)", "        lnum = compute_buffer_local_count(addr_type, lnum, (i == '-') ? -1 * n : n);", "      else if (i == '-')"], "whitespace/line_length"]
["src/nvim/ex_docmd.c", ["  if (eap->argt & RANGE) {", "    switch(eap->addr_type) {", "      case ADDR_LINES:"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["        expand_env_esc(eap->arg, NameBuff, MAXPATHL,", "            TRUE, TRUE, NULL);", "        has_wildcards = path_has_wildcard(NameBuff);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        p = NameBuff;", "      } else", "        p = NULL;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    /* Skip over `=expr` when wildcards are expanded. */", "    else if (p[0] == '`' && p[1] == '=' && (eap->argt & XFILE)) {", "      p += 2;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["     * :redir @\" doesn't either. */", "    else if ((*p == '\"' && !(eap->argt & NOTRLCOM)", "              && (eap->cmdidx != CMD_at || p != eap->arg)"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["      command = dollar_command;", "    else {", "      command = arg;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      command = arg;", "      arg = skip_cmd_arg(command, TRUE);", "      if (*arg != NUL)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["static char_u *", "skip_cmd_arg (", "    char_u *p,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["      eap->force_bin = FORCE_NOBIN;", "    } else", "      eap->force_bin = FORCE_BIN;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (STRNCMP(arg, \"edit\", 4) == 0) {", "    eap->read_edit = TRUE;", "    eap->arg = skipwhite(arg + 4);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  *pp = (int)(arg - eap->cmd);", "  arg = skip_cmd_arg(arg, FALSE);", "  eap->arg = skipwhite(arg);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  do_exmap(eap, TRUE);          /* almost the same as mapping */", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  do_exmap(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  do_exmap(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  map_clear(eap->cmd, eap->arg, eap->forceit, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  map_clear(eap->cmd, eap->arg, TRUE, TRUE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    eap->errmsg = e_curdir;", "  } else if (eap->cmdidx == CMD_autocmd)", "    do_autocmd(eap->arg, eap->forceit);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  (void)do_doautocmd(arg, TRUE);", "  if (call_do_modelines)    /* Only when there is no <nomodeline>. */"], "readability/bool"]
["src/nvim/ex_docmd.c", [" */", "static int ", "check_more ("], "whitespace/end_of_line"]
["src/nvim/ex_docmd.c", ["static int ", "check_more (", "    int message,                /* when FALSE check only, no messages */"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["", "  replace_termcodes(rep, &rep_buf, FALSE, FALSE, FALSE);", "  if (rep_buf == NULL) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ga_init(gap, (int)sizeof(ucmd_T), 4);", "  } else", "    gap = &ucmds;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  int i, j;", "  int found = FALSE;", "  ucmd_T      *cmd;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (!found)", "        MSG_PUTS_TITLE(_(\"\\n    Name        Args       Address   Complete  Definition\"));", "      found = TRUE;"], "whitespace/line_length"]
["src/nvim/ex_docmd.c", ["        MSG_PUTS_TITLE(_(\"\\n    Name        Args       Address   Complete  Definition\"));", "      found = TRUE;", "      msg_putchar('\\n');"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      case 0:                     IObuff[len++] = '0'; break;", "      case (EXTRA):               IObuff[len++] = '*'; break;", "      case (EXTRA|NOSPC):         IObuff[len++] = '?'; break;"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["      case (EXTRA):               IObuff[len++] = '*'; break;", "      case (EXTRA|NOSPC):         IObuff[len++] = '?'; break;", "      case (EXTRA|NEEDARG):       IObuff[len++] = '+'; break;"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["      case (EXTRA|NOSPC):         IObuff[len++] = '?'; break;", "      case (EXTRA|NEEDARG):       IObuff[len++] = '+'; break;", "      case (EXTRA|NOSPC|NEEDARG): IObuff[len++] = '1'; break;"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["      case (EXTRA|NEEDARG):       IObuff[len++] = '+'; break;", "      case (EXTRA|NOSPC|NEEDARG): IObuff[len++] = '1'; break;", "      }"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["          /* -count=N */", "          sprintf((char *)IObuff + len, \"%\" PRId64 \"c\", (int64_t)cmd->uc_def);", "          len += (int)STRLEN(IObuff + len);"], "runtime/printf"]
["src/nvim/ex_docmd.c", ["          len += (int)STRLEN(IObuff + len);", "        } else if (a & DFLALL)", "          IObuff[len++] = '%';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          /* -range=N */", "          sprintf((char *)IObuff + len, \"%\" PRId64 \"\", (int64_t)cmd->uc_def);", "          len += (int)STRLEN(IObuff + len);"], "runtime/printf"]
["src/nvim/ex_docmd.c", ["          len += (int)STRLEN(IObuff + len);", "        } else", "          IObuff[len++] = '.';"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "      msg_outtrans_special(cmd->uc_rep, FALSE);", "      if (p_verbose > 0)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    *argt |= TRLBAR;", "  else {", "    int i;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        if (*val == '0')", "          /* Do nothing - this is the default */;", "        else if (*val == '1')"], "whitespace/semicolon"]
["src/nvim/ex_docmd.c", ["  int flags = 0;", "  int     compl = EXPAND_NOTHING;", "  char_u  *compl_arg = NULL;"], "readability/alt_tokens"]
["src/nvim/ex_docmd.c", ["    end = skiptowhite(p);", "    if (uc_scan_attr(p, end - p, &argt, &def, &flags, &compl, &compl_arg, &addr_type_arg)", "        == FAIL)"], "whitespace/line_length"]
["src/nvim/ex_docmd.c", ["    return;", "  } else", "    uc_add_command(name, end - name, p, argt, def, flags, compl, compl_arg,"], "readability/braces"]
["src/nvim/ex_docmd.c", [" */", "static size_t ", "uc_check_code ("], "whitespace/end_of_line"]
["src/nvim/ex_docmd.c", ["static size_t ", "uc_check_code (", "    char_u *code,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["          STRCPY(buf, \"''\");", "      } else", "        result = 0;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "    sprintf(num_buf, \"%\" PRId64, (int64_t)num);", "    num_len = STRLEN(num_buf);"], "runtime/printf"]
["src/nvim/ex_docmd.c", ["        for (ksp = p; *ksp != NUL && *ksp != K_SPECIAL; ++ksp)", "          ;", "        if (*ksp == K_SPECIAL"], "whitespace/semicolon"]
["src/nvim/ex_docmd.c", ["            && ((ksp[1] == KS_SPECIAL && ksp[2] == KE_FILLER)", "                )) {", "          /* K_SPECIAL has been put in the buffer as K_SPECIAL"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["        totlen += len;", "      else {", "        memmove(q, p, len);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        len = 1;", "      } else", "        p = end;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    for (i = 0; err[i] == NUL || !ascii_iswhite(err[i]); i++)", "      ;", "    err[i] = NUL;"], "whitespace/semicolon"]
["src/nvim/ex_docmd.c", ["    ++emsg_off;", "    p = eval_to_string(expr, NULL, FALSE);", "    --emsg_off;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      xfree(p);", "    } else", "      MSG(\"default\");"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      MSG(\"default\");", "  } else if (load_colors(eap->arg) == FAIL)", "    EMSG2(_(\"E185: Cannot find color scheme '%s'\"), eap->arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    MSG(_(\"Greetings, Vim user!\"));", "  do_highlight(eap->arg, eap->forceit, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  exiting = FALSE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  apply_autocmds(EVENT_QUITPRE, NULL, NULL, FALSE, curbuf);", "  /* Refuse to quit when locked or when the buffer in the last window is"], "readability/bool"]
["src/nvim/ex_docmd.c", ["   */", "  if (check_more(FALSE, eap->forceit) == OK && only_one_window())", "    exiting = TRUE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (check_more(FALSE, eap->forceit) == OK && only_one_window())", "    exiting = TRUE;", "  if ((!P_HID(curbuf)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["           | CCGD_EXCMD))", "      || check_more(TRUE, eap->forceit) == FAIL", "      || (only_one_window() && check_changed_any(eap->forceit))) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  apply_autocmds(EVENT_QUITPRE, NULL, NULL, FALSE, curbuf);", "  /* Refuse to quit when locked or when the buffer in the last window is"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  exiting = TRUE;", "  if (eap->forceit || !check_changed_any(FALSE))"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  exiting = TRUE;", "  if (eap->forceit || !check_changed_any(FALSE))", "    getout(0);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ex_win_close(eap->forceit, curwin, NULL);", "    else {", "      for (win = firstwin; win != NULL; win = win->w_next) {"], "readability/braces"]
["src/nvim/ex_docmd.c", [" */", "static void ", "ex_win_close ("], "whitespace/end_of_line"]
["src/nvim/ex_docmd.c", ["static void ", "ex_win_close (", "    int forceit,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    if ((p_confirm || cmdmod.confirm) && p_write) {", "      dialog_changed(buf, FALSE);", "      if (buf_valid(buf) && bufIsChanged(buf))"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        return;", "      need_hide = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    EMSG(_(\"E784: Cannot close last tab page\"));", "  else {", "    if (eap->addr_count > 0) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    MSG(_(\"Already only one tab page\"));", "  else {", "    if (eap->addr_count > 0)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (lastwin != firstwin)", "    close_others(TRUE, forceit);", "  if (lastwin == firstwin)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  while (++done < 1000) {", "    sprintf((char *)prev_idx, \"%i\", tabpage_index(tp));", "    wp = tp->tp_firstwin;"], "runtime/printf"]
["src/nvim/ex_docmd.c", ["  }", "  apply_autocmds(EVENT_TABCLOSED, prev_idx, prev_idx, FALSE, curbuf);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  redraw_tabline = TRUE;", "  if (h != tabline_height())"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  close_others(TRUE, eap->forceit);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    eap->errmsg = e_invarg;", "  else {", "    /* \":hide\" or \":hide | cmd\": hide current window */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      if (eap->addr_count == 0)", "        win_close(curwin, FALSE); /* don't free buffer */", "      else {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        win_close(curwin, FALSE); /* don't free buffer */", "      else {", "        int winnr = 0;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          win = lastwin;", "        win_close(win, FALSE);", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  apply_autocmds(EVENT_QUITPRE, NULL, NULL, FALSE, curbuf);", "  /* Refuse to quit when locked or when the buffer in the last window is"], "readability/bool"]
["src/nvim/ex_docmd.c", ["   */", "  if (check_more(FALSE, eap->forceit) == OK && only_one_window())", "    exiting = TRUE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (check_more(FALSE, eap->forceit) == OK && only_one_window())", "    exiting = TRUE;", "  if (       ((eap->cmdidx == CMD_wq"], "readability/bool"]
["src/nvim/ex_docmd.c", ["              && do_write(eap) == FAIL)", "             || check_more(TRUE, eap->forceit) == FAIL", "             || (only_one_window() && check_changed_any(eap->forceit))) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_emptybuf));", "  else {", "    for (; !got_int; os_breakcheck()) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  ex_no_reprint = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    alist_set(&global_alist, new_arg_file_count, new_arg_files,", "        TRUE, fnum_list, fnum_len);", "    FreeWild(old_arg_count, old_arg_files);"], "readability/bool"]
["src/nvim/ex_docmd.c", [" */", "void alist_set(alist_T *al, int count, char_u **files, int use_curbuf, int *fnum_list, int fnum_len)", "{"], "whitespace/line_length"]
["src/nvim/ex_docmd.c", ["  if (al == &global_alist)", "    arg_had_last = FALSE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", [" */", "void ", "alist_add ("], "whitespace/end_of_line"]
["src/nvim/ex_docmd.c", ["void ", "alist_add (", "    alist_T *al,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["  curbuf->b_flags |= BF_PRESERVED;", "  ml_preserve(curbuf, TRUE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  /* Set recoverymode right away to avoid the ATTENTION prompt. */", "  recoverymode = TRUE;", "  if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      && (*eap->arg == NUL", "          || setfname(curbuf, eap->arg, NULL, TRUE) == OK))", "    ml_recover();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    ml_recover();", "  recoverymode = FALSE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    fname = find_file_in_path(eap->arg, STRLEN(eap->arg),", "                              FNAME_MESS, TRUE, curbuf->b_ffname);", "    if (fname == NULL)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["            : (int)eap->line2 + 1) != FAIL) {", "      apply_autocmds(EVENT_TABNEW, eap->arg, eap->arg,  FALSE, curbuf); ", "      do_exedit(eap, old_curwin);"], "whitespace/end_of_line"]
["src/nvim/ex_docmd.c", ["            : (int)eap->line2 + 1) != FAIL) {", "      apply_autocmds(EVENT_TABNEW, eap->arg, eap->arg,  FALSE, curbuf); ", "      do_exedit(eap, old_curwin);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      do_exedit(eap, old_curwin);", "      apply_autocmds(EVENT_TABNEWENTERED, NULL, NULL, FALSE, curbuf);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["      RESET_BINDING(curwin);", "    } else", "      do_check_scrollbind(FALSE);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    } else", "      do_check_scrollbind(FALSE);", "    do_exedit(eap, old_curwin);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    char_u *p = eap->arg;", "    int relative = 0;        /* argument +N/-N means: move N places to the", "                              * right/left relative to the current position. */"], "readability/multiline_comment"]
["src/nvim/ex_docmd.c", ["      p = eap->arg + 1;", "    } else", "      p = eap->arg;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (relative != 0)", "      tab_number = tab_number * relative + tabpage_index(curtab) - 1; ;", "  } else if (eap->addr_count != 0)"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    if (relative != 0)", "      tab_number = tab_number * relative + tabpage_index(curtab) - 1; ;", "  } else if (eap->addr_count != 0)"], "whitespace/semicolon"]
["src/nvim/ex_docmd.c", ["      tab_number = tab_number * relative + tabpage_index(curtab) - 1; ;", "  } else if (eap->addr_count != 0)", "    tab_number = eap->line2;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  msg_start();", "  msg_scroll = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["        home_replace(wp->w_buffer, wp->w_buffer->b_fname,", "            IObuff, IOSIZE, TRUE);", "      msg_outtrans(IObuff);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    for (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next)", "      ;", "  }"], "whitespace/semicolon"]
["src/nvim/ex_docmd.c", ["  fname = find_file_in_path(eap->arg, STRLEN(eap->arg),", "                            FNAME_MESS, TRUE, curbuf->b_ffname);", "  if (eap->addr_count > 0) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      xfree(fname);", "      fname = find_file_in_path(NULL, 0, FNAME_MESS, FALSE, curbuf->b_ffname);", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", [" */", "void ", "do_exedit ("], "whitespace/end_of_line"]
["src/nvim/ex_docmd.c", ["void ", "do_exedit (", "    exarg_T *eap,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["                        || eap->cmdidx == CMD_view)) {", "    exmode_active = FALSE;", "    if (*eap->arg == NUL) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        no_wait_return = 0;", "        need_wait_return = FALSE;", "        msg_scroll = 0;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["       || eap->cmdidx == CMD_vnew", "       ) && *eap->arg == NUL) {", "    /* \":new\" or \":tabnew\" without argument: edit an new empty buffer */"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    // \":edit <blank>\" is a no-op in terminal buffers. #2822", "    if (curbuf->terminal != NULL && eap->cmdidx == CMD_edit && *eap->arg == NUL) {", "      return;"], "whitespace/line_length"]
["src/nvim/ex_docmd.c", ["    if (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview)", "      readonlymode = TRUE;", "    else if (eap->cmdidx == CMD_enew)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    else if (eap->cmdidx == CMD_enew)", "      readonlymode = FALSE;         /* 'readonly' doesn't make sense in an", "                                       empty buffer */"], "readability/multiline_comment"]
["src/nvim/ex_docmd.c", ["    else if (eap->cmdidx == CMD_enew)", "      readonlymode = FALSE;         /* 'readonly' doesn't make sense in an", "                                       empty buffer */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["       * editing the same buffer. */", "      curbuf->b_p_ro = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  ex_no_reprint = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (y > 0)", "        scrollup(y, TRUE);", "      else"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      else", "        scrolldown(-y, TRUE);", "      curwin->w_scbind_pos = topline;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      cursor_correct();", "      curwin->w_redr_status = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (curwin->w_p_scb) {", "    did_syncbind = TRUE;", "    checkpcmark();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ctrl_o[1] = 0;", "      ins_typebuf(ctrl_o, REMAP_NONE, 0, TRUE, FALSE);", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (eap->usefilter)                   /* :r!cmd */", "    do_bang(1, eap, FALSE, FALSE, TRUE);", "  else {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    do_bang(1, eap, FALSE, FALSE, TRUE);", "  else {", "    if (u_save(eap->line2, (linenr_T)(eap->line2 + 1)) == FAIL)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);", "", "    }"], "whitespace/blank_line"]
["src/nvim/ex_docmd.c", ["        if (*ml_get(lnum) == NUL && u_savedel(lnum, 1L) == OK) {", "          ml_delete(lnum, FALSE);", "          if (curwin->w_cursor.lnum > 1"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  shorten_fnames(TRUE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      EMSG(_(e_failed));", "    else {", "      post_chdir(eap->cmdidx == CMD_lcd || eap->cmdidx == CMD_lchdir);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    msg(NameBuff);", "  } else", "    EMSG(_(\"E187: Unknown\"));"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  case NUL: len *= 1000L; break;", "  default: EMSG2(_(e_invarg2), eap->arg); return;", "  }"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    p = eap->arg + 2;", "  } else", "    p = eap->arg + 1;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  oa.motion_type = MLINE;", "  virtual_op = FALSE;", "  if (eap->cmdidx != CMD_yank) {        /* position cursor for undo */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      oa.op_type = OP_LSHIFT;", "    op_shift(&oa, FALSE, eap->amount);", "    break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    eap->line2 = 1;", "    eap->forceit = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  n = get_address(&eap->arg, eap->addr_type, FALSE, FALSE);", "  if (eap->arg == NULL) {           /* error detected */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      return;", "  } else", "    ex_copy(eap->line1, eap->line2, n);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        (eap->flags & EXFLAG_LIST));", "    ex_no_reprint = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  do_join(eap->line2 - eap->line1 + 1, !eap->forceit, TRUE, TRUE, true);", "  beginline(BL_WHITE | BL_FIX);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  /* Put the register in the typeahead buffer with the \"silent\" flag. */", "  if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)", "      == FAIL) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    exec_from_reg = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  do_bang(eap->addr_count, eap, eap->forceit, TRUE, TRUE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (eap->addr_count == 1)         /* :undo 123 */", "    undo_time(eap->line2, FALSE, FALSE, TRUE);", "  else"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  long count = 0;", "  int sec = FALSE;", "  int file = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int sec = FALSE;", "  int file = FALSE;", "  char_u      *p = eap->arg;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    switch (*p) {", "    case 's': ++p; sec = TRUE; break;", "    case 'm': ++p; sec = TRUE; count *= 60; break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    case 's': ++p; sec = TRUE; break;", "    case 'm': ++p; sec = TRUE; count *= 60; break;", "    case 'h': ++p; sec = TRUE; count *= 60 * 60; break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    case 'm': ++p; sec = TRUE; count *= 60; break;", "    case 'h': ++p; sec = TRUE; count *= 60 * 60; break;", "    case 'd': ++p; sec = TRUE; count *= 24 * 60 * 60; break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    case 'h': ++p; sec = TRUE; count *= 60 * 60; break;", "    case 'd': ++p; sec = TRUE; count *= 24 * 60 * 60; break;", "    case 'f': ++p; file = TRUE; break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    case 'd': ++p; sec = TRUE; count *= 24 * 60 * 60; break;", "    case 'f': ++p; file = TRUE; break;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    undo_time(eap->cmdidx == CMD_earlier ? -count : count,", "        sec, file, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    close_redir();", "  else {", "    if (*arg == '>') {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        mode = \"a\";", "      } else", "        mode = \"w\";"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          arg += 2;", "        else {", "          /* Can use both \"@a\" and \"@a>\". */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["          if (*arg == NUL && !isupper(redir_reg))", "            write_reg_contents(redir_reg, (char_u *)\"\", -1, FALSE);", "        }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        ++arg;", "        append = TRUE;", "      } else"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        append = TRUE;", "      } else", "        append = FALSE;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      } else", "        append = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["    /* TODO: redirect to a buffer */", "    else", "      EMSG2(_(e_invarg2), eap->arg);"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["      )", "    redir_off = FALSE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  RedrawingDisabled = 0;", "  p_lz = FALSE;", "  update_topline();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  /* Reset msg_didout, so that a message that's there is overwritten. */", "  msg_didout = FALSE;", "  msg_col = 0;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  /* No need to wait after an intentional redraw. */", "  need_wait_return = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["  RedrawingDisabled = 0;", "  p_lz = FALSE;", "  if (eap->forceit)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["# define MKSESSION_NL", "static int mksession_nl = FALSE;    /* use NL only in put_eol() */", "#endif"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  FILE        *fd;", "  int failed = FALSE;", "  int view_session = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int failed = FALSE;", "  int view_session = FALSE;", "  int using_vdir = FALSE;               /* using 'viewdir'? */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int view_session = FALSE;", "  int using_vdir = FALSE;               /* using 'viewdir'? */", "  char_u      *viewFile = NULL;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (eap->cmdidx == CMD_mksession || eap->cmdidx == CMD_mkview) {", "    view_session = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["   * short file name when 'acd' is set, that is checked later. */", "  did_lcd = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["          || (ascii_isdigit(*eap->arg) && eap->arg[1] == NUL))) {", "    eap->forceit = TRUE;", "    fname = (char_u *)get_view_file(*eap->arg);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    viewFile = fname;", "    using_vdir = TRUE;", "  } else if (*eap->arg != NUL)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    using_vdir = TRUE;", "  } else if (*eap->arg != NUL)", "    fname = eap->arg;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    if (view_session && (*flagp & SSOP_UNIX))", "      mksession_nl = TRUE;", "#endif"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (put_line(fd, \"let SessionLoad = 1\") == FAIL)", "        failed = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      failed |= (makemap(fd, NULL) == FAIL", "                 || makeset(fd, OPT_GLOBAL, FALSE) == FAIL);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["          == FAIL)", "        failed = TRUE;", "      if (eap->cmdidx == CMD_mksession) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["          if (vim_chdirfile(fname) == OK)", "            shorten_fnames(TRUE);", "        } else if (*dirnow != NUL"], "readability/bool"]
["src/nvim/ex_docmd.c", ["          if (os_chdir((char *)globaldir) == 0)", "            shorten_fnames(TRUE);", "        }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["            EMSG(_(e_prev_dir));", "          shorten_fnames(TRUE);", "          /* restore original dir */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["              EMSG(_(e_prev_dir));", "            shorten_fnames(TRUE);", "          }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["          == FAIL)", "        failed = TRUE;", "      if (put_line(fd, \"doautoall SessionLoadPost\") == FAIL)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (put_line(fd, \"doautoall SessionLoadPost\") == FAIL)", "        failed = TRUE;", "      if (eap->cmdidx == CMD_mksession) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        if (put_line(fd, \"unlet SessionLoad\") == FAIL)", "          failed = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (put_line(fd, \"\\\" vim: set ft=vim :\") == FAIL)", "      failed = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["      tbuf = xmalloc(MAXPATHL);", "      if (vim_FullName((char *)fname, (char *)tbuf, MAXPATHL, FALSE) == OK)", "        set_vim_var_string(VV_THIS_SESSION, tbuf, -1);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["#ifdef MKSESSION_NL", "    mksession_nl = FALSE;", "#endif"], "readability/bool"]
["src/nvim/ex_docmd.c", ["FILE *", "open_exfile (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    EMSG(_(e_trailing));", "  else {", "    pos = curwin->w_cursor;             /* save curwin->w_cursor */"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "  msg_scroll = FALSE;       /* no msg scrolling in Normal mode */", "  restart_edit = 0;         /* don't go to Insert mode */"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  restart_edit = 0;         /* don't go to Insert mode */", "  p_im = FALSE;             /* don't use 'insertmode' */", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["          arg != NULL ? arg :", "          eap->arg, eap->forceit ? REMAP_NONE : REMAP_YES, FALSE);", "    } while (eap->addr_count > 0 && eap->line1 <= eap->line2 && !got_int);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    curwin->w_curswant = MAXCOL;", "    curwin->w_set_curswant = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  restart_edit = 0;", "  stop_insert_mode = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  clear_oparg(&oa);", "  finish_op = FALSE;", "  ins_typebuf(cmd, remap, 0, TRUE, silent);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  finish_op = FALSE;", "  ins_typebuf(cmd, remap, 0, TRUE, silent);", "  while ((!stuff_empty() || (!typebuf_typed() && typebuf.tb_len > 0))"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    update_topline_cursor();", "    normal_cmd(&oa, TRUE);      /* execute a Normal mode cmd */", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,", "                       eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  int whole = TRUE;", "  long n;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (*eap->arg == '/') {   /* Match regexp, not just whole words */", "    whole = FALSE;", "    ++eap->arg;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  do_exedit(eap, NULL);", "  keep_help_flag = FALSE;", "  if (curwin != curwin_save && win_valid(curwin_save)) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,", "      eap->forceit, TRUE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["char_u *", "eval_vars (", "    char_u *src,               /* pointer into commandline */"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    char_u **errormsg,         /* pointer to error message */", "    int *escaped           /* return value has escaped white space (can", "                                 * be NULL) */"], "readability/multiline_comment"]
["src/nvim/ex_docmd.c", ["  int valid = VALID_HEAD + VALID_PATH;              /* assume valid result */", "  int skip_mod = FALSE;", "  char_u strbuf[30];"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (escaped != NULL)", "    *escaped = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["   */", "  else {", "    switch (spec_idx) {"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["   */", "  else {", "    switch (spec_idx) {"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        valid = 0;                  /* Must have \":p:h\" to be valid */", "      } else", "        result = curbuf->b_fname;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["        if (escaped != NULL)", "          *escaped = TRUE;", "        skip_mod = TRUE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["          *escaped = TRUE;", "        skip_mod = TRUE;", "        break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["          valid = 0;                        /* Must have \":p:h\" to be valid */", "        } else", "          result = buf->b_fname;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["         * postponed to avoid a delay when <afile> is not used. */", "        autocmd_fname_full = TRUE;", "        result = (char_u *)FullName_save((char *)autocmd_fname, FALSE);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        autocmd_fname_full = TRUE;", "        result = (char_u *)FullName_save((char *)autocmd_fname, FALSE);", "        xfree(autocmd_fname);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      }", "      sprintf((char *)strbuf, \"%d\", autocmd_bufnr);", "      result = strbuf;"], "runtime/printf"]
["src/nvim/ex_docmd.c", ["      }", "      sprintf((char *)strbuf, \"%\" PRId64, (int64_t)sourcing_lnum);", "      result = strbuf;"], "runtime/printf"]
["src/nvim/ex_docmd.c", ["    result = NULL;", "  } else", "    result = vim_strnsave(result, resultlen);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["      ++p;", "    else {", "      /* replace \"<sfile>\" with the sourced file name, and do \":\" stuff */"], "readability/braces"]
["src/nvim/ex_docmd.c", [" */", "static int ", "makeopens ("], "whitespace/end_of_line"]
["src/nvim/ex_docmd.c", ["static int ", "makeopens (", "    FILE *fd,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["{", "  int only_save_windows = TRUE;", "  int nr;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int cnr = 1;", "  int restore_size = TRUE;", "  win_T       *wp;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (ssop_flags & SSOP_BUFFERS)", "    only_save_windows = FALSE;                  /* Save ALL buffers */", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (put_line(fd,", "          \"if expand('%') == '' && !&modified && line('$') <= 1 && getline(1) == ''\")", "      =="], "whitespace/line_length"]
["src/nvim/ex_docmd.c", ["", "  int restore_stal = FALSE;", "  // When there are two or more tabpages and 'showtabline' is 1 the tabline"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    }", "    restore_stal = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  for (tabnr = 1;; ++tabnr) {", "    int need_tabnew = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (tabnr > 1)", "        need_tabnew = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["          return FAIL;", "        need_tabnew = FALSE;", "        if (!wp->w_arg_idx_invalid)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      else", "        restore_size = FALSE;", "      if (curwin == wp)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (ses_do_frame(frc))", "      return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    return ssop_flags & SSOP_HELP;", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", [" */", "static int ", "put_view ("], "whitespace/end_of_line"]
["src/nvim/ex_docmd.c", ["static int ", "put_view (", "    FILE *fd,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["    unsigned *flagp,             /* vop_flags or ssop_flags */", "    int current_arg_idx             /* current argument index of the window, use", "                                  * -1 if unknown */"], "readability/multiline_comment"]
["src/nvim/ex_docmd.c", ["  int do_cursor;", "  int did_next = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["      return FAIL;", "    did_next = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      }", "      do_cursor = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (do_cursor) {", "", "    /* Restore the cursor line in the file and relatively in the"], "whitespace/blank_line"]
["src/nvim/ex_docmd.c", ["      return FAIL;", "    did_lcd = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", [" */", "static int ", "ses_arglist ("], "whitespace/end_of_line"]
["src/nvim/ex_docmd.c", ["static int ", "ses_arglist (", "    FILE *fd,"], "whitespace/parens"]
["src/nvim/ex_docmd.c", ["        buf = xmalloc(MAXPATHL);", "        (void)vim_FullName((char *)s, (char *)buf, MAXPATHL, FALSE);", "        s = buf;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  /* escape special characters */", "  p = vim_strsave_fnameescape(sname, FALSE);", "  xfree(sname);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (fname != NULL) {", "    if (do_source((char_u *)fname, FALSE, DOSO_NONE) == FAIL) {", "      EMSG2(_(e_notopen), fname);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  // a directory.", "  // \"normal\" path separator\t-> \"=+\"", "  // \"=\"\t\t\t-> \"==\""], "whitespace/tab"]
["src/nvim/ex_docmd.c", ["  // \"normal\" path separator\t-> \"=+\"", "  // \"=\"\t\t\t-> \"==\"", "  // \":\" path separator\t-> \"=-\""], "whitespace/tab"]
["src/nvim/ex_docmd.c", ["  // \"=\"\t\t\t-> \"==\"", "  // \":\" path separator\t-> \"=-\"", "  size_t len = 0;"], "whitespace/tab"]
["src/nvim/ex_docmd.c", ["      *s++ = '+';", "    } else", "      *s++ = *p;"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  *s++ = c;", "  strcpy(s, \".vim\");", ""], "runtime/printf"]
["src/nvim/ex_docmd.c", ["    set_option_value((char_u *)\"keymodel\", 0L, (char_u *)\"\", 0);", "  } else", "    EMSG2(_(e_invarg2), eap->arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["", "static int filetype_detect = FALSE;", "static int filetype_plugin = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["static int filetype_detect = FALSE;", "static int filetype_plugin = FALSE;", "static int filetype_indent = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["static int filetype_plugin = FALSE;", "static int filetype_indent = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["  char_u      *arg = eap->arg;", "  int plugin = FALSE;", "  int indent = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int plugin = FALSE;", "  int indent = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (STRNCMP(arg, \"plugin\", 6) == 0) {", "      plugin = TRUE;", "      arg = skipwhite(arg + 6);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (STRNCMP(arg, \"indent\", 6) == 0) {", "      indent = TRUE;", "      arg = skipwhite(arg + 6);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (*arg == 'o' || !filetype_detect) {", "      source_runtime((char_u *)FILETYPE_FILE, TRUE);", "      filetype_detect = TRUE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      source_runtime((char_u *)FILETYPE_FILE, TRUE);", "      filetype_detect = TRUE;", "      if (plugin) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (plugin) {", "        source_runtime((char_u *)FTPLUGIN_FILE, TRUE);", "        filetype_plugin = TRUE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        source_runtime((char_u *)FTPLUGIN_FILE, TRUE);", "        filetype_plugin = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (indent) {", "        source_runtime((char_u *)INDENT_FILE, TRUE);", "        filetype_indent = TRUE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        source_runtime((char_u *)INDENT_FILE, TRUE);", "        filetype_indent = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (*arg == 'd') {", "      (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", TRUE);", "      do_modelines(0);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (plugin) {", "        source_runtime((char_u *)FTPLUGOF_FILE, TRUE);", "        filetype_plugin = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        source_runtime((char_u *)FTPLUGOF_FILE, TRUE);", "        filetype_plugin = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (indent) {", "        source_runtime((char_u *)INDOFF_FILE, TRUE);", "        filetype_indent = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        source_runtime((char_u *)INDOFF_FILE, TRUE);", "        filetype_indent = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    } else {", "      source_runtime((char_u *)FTOFF_FILE, TRUE);", "      filetype_detect = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      source_runtime((char_u *)FTOFF_FILE, TRUE);", "      filetype_detect = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    }", "  } else", "    EMSG2(_(e_invarg2), arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["{", "  SET_NO_HLSEARCH(TRUE);", "  redraw_all_later(SOME_VALID);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    id = eap->line2;", "  else {", "    EMSG(e_invcmd);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (!eap->skip)", "    match_delete(curwin, id, FALSE);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["    end = eap->arg + 4;", "  else {", "    p = skiptowhite(eap->arg);"], "readability/braces"]
["src/nvim/ex_docmd.c", ["    }", "    end = skip_regexp(p + 1, *p, TRUE, NULL);", "    if (!eap->skip) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  if (foldManualAllowed(TRUE))", "    foldCreate(eap->line1, eap->line2);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  opFoldRange(eap->line1, eap->line2, eap->cmdidx == CMD_foldopen,", "      eap->forceit, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["           \":enew%s | call termopen(%s%s%s) | startinsert\",", "           eap->forceit==TRUE ? \"!\" : \"\", lquote, name, rquote);", "  do_cmdline_cmd(ex_cmd);"], "whitespace/operators"]
["src/nvim/ex_docmd.c", ["           \":enew%s | call termopen(%s%s%s) | startinsert\",", "           eap->forceit==TRUE ? \"!\" : \"\", lquote, name, rquote);", "  do_cmdline_cmd(ex_cmd);"], "readability/bool"]
["src/nvim/ex_eval.c", ["/* Values used for the Vim release. */", "# define THROW_ON_ERROR         TRUE", "# define THROW_ON_ERROR_TRUE"], "readability/bool"]
["src/nvim/ex_eval.c", ["# define THROW_ON_ERROR_TRUE", "# define THROW_ON_INTERRUPT     TRUE", "# define THROW_ON_INTERRUPT_TRUE"], "readability/bool"]
["src/nvim/ex_eval.c", [" */", "static int cause_abort = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (cause_abort)", "    force_abort = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (suppress_errthrow)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["    cause_abort = force_abort;", "    force_abort = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (((trylevel == 0 && !cause_abort) || emsg_silent) && !did_throw)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (mesg == (char_u *)_(e_interr)) {", "    *ignore = TRUE;", "    return TRUE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    *ignore = TRUE;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["   */", "  cause_abort = TRUE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["    if (current_exception->type == ET_INTERRUPT)", "      got_int = FALSE;", "    discard_current_exception();"], "readability/bool"]
["src/nvim/ex_eval.c", ["     */", "    return FALSE;", "  } else"], "readability/bool"]
["src/nvim/ex_eval.c", ["    return FALSE;", "  } else", "#endif"], "readability/braces"]
["src/nvim/ex_eval.c", ["    }", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (cause_abort) {", "    cause_abort = FALSE;", "    force_abort = TRUE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    cause_abort = FALSE;", "    force_abort = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    free_msglist(*msg_list);", "  else {", "    if (cstack != NULL)"], "readability/braces"]
["src/nvim/ex_eval.c", ["    else", "      need_rethrow = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (!got_int || (trylevel == 0 && !did_throw))", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["      discard_current_exception();", "  } else", "#endif"], "readability/braces"]
["src/nvim/ex_eval.c", ["      if (current_exception->type == ET_INTERRUPT)", "        return FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_eval.c", [" */", "char_u *get_exception_string(void *value, int type, char_u *cmdname, int *should_free)", "{"], "whitespace/line_length"]
["src/nvim/ex_eval.c", ["  if (type == ET_ERROR) {", "    *should_free = FALSE;", "    mesg = ((struct msglist *)value)->throw_msg;"], "readability/bool"]
["src/nvim/ex_eval.c", ["          STRCAT(val, mesg);            /* 'E123' missing or at beginning */", "        else {", "          /* '\"filename\" E123: message text' */"], "readability/braces"]
["src/nvim/ex_eval.c", ["          p[-2] = NUL;", "          sprintf((char *)(val + STRLEN(p)), \" (%s)\", &mesg[1]);", "          p[-2] = '\"';"], "runtime/printf"]
["src/nvim/ex_eval.c", ["  } else {", "    *should_free = FALSE;", "    ret = (char_u *) value;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/bool"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["  xfree(excp);", "  suppress_errthrow = TRUE;", "  EMSG(_(e_outofmem));"], "readability/bool"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/bool"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", "    smsg(was_finished ? _(\"Exception finished: %s\")"], "readability/bool"]
["src/nvim/ex_eval.c", ["{", "  discard_exception(current_exception, FALSE);", "  current_exception = NULL;"], "readability/bool"]
["src/nvim/ex_eval.c", ["  current_exception = NULL;", "  did_throw = FALSE;", "  need_rethrow = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["  did_throw = FALSE;", "  need_rethrow = FALSE;", "}"], "readability/bool"]
["src/nvim/ex_eval.c", ["    set_vim_var_string(VV_THROWPOINT, IObuff, -1);", "  } else", "    /* throw_name not set on an exception from a command that was typed. */"], "readability/braces"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0)", "      msg_silent = FALSE;               /* display messages */", "    else"], "readability/bool"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL)", "      msg_scroll = TRUE;            /* always scroll up, don't overwrite */", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["      set_vim_var_string(VV_THROWPOINT, IObuff, -1);", "    } else", "      /* throw_name not set on an exception from a command that was"], "readability/braces"]
["src/nvim/ex_eval.c", ["  /* Discard the exception, but use the finish message for 'verbose'. */", "  discard_exception(excp, TRUE);", "}"], "readability/bool"]
["src/nvim/ex_eval.c", ["      s = (char *)((except_T *)value)->value;", "    } else if ((pending & CSTP_ERROR) && (pending & CSTP_INTERRUPT))", "      s = _(\"Error and interrupt\");"], "readability/braces"]
["src/nvim/ex_eval.c", ["  if (debug_break_level > 0)", "    msg_silent = FALSE;         /* display messages */", "  ++no_wait_return;"], "readability/bool"]
["src/nvim/ex_eval.c", ["  ++no_wait_return;", "  msg_scroll = TRUE;            /* always scroll up, don't overwrite */", "  smsg(mesg, s);"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E579: :if nesting too deep\");", "  else {", "    ++cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        cstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;", "    } else", "      /* set TRUE, so this conditional will never get active */"], "readability/braces"]
["src/nvim/ex_eval.c", ["{", "  did_endif = TRUE;", "  if (eap->cstack->cs_idx < 0"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E580: :endif without :if\");", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E582: :elseif without :if\");", "    skip = TRUE;", "  } else if (cstack->cs_flags[cstack->cs_idx] & CSF_ELSE) {"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E584: :elseif after :else\");", "    skip = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;", "    skip = TRUE;        /* don't evaluate an \":elseif\" */", "  } else"], "readability/bool"]
["src/nvim/ex_eval.c", ["    skip = TRUE;        /* don't evaluate an \":elseif\" */", "  } else", "    cstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    (void)do_intthrow(cstack);", "    skip = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["        cstack->cs_flags[cstack->cs_idx] = 0;", "    } else if (eap->errmsg == NULL)", "      /* set TRUE, so this conditional will never get active */"], "readability/braces"]
["src/nvim/ex_eval.c", ["      cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;", "  } else", "    cstack->cs_flags[cstack->cs_idx] |= CSF_ELSE;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E585: :while/:for nesting too deep\");", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["        fi = cstack->cs_forinfo[cstack->cs_idx];", "        error = FALSE;", "      } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["      else", "        result = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E586: :continue without :while or :for\");", "  else {", "    /* Try to find the matching \":while\".  This might stop at a try"], "readability/braces"]
["src/nvim/ex_eval.c", ["     * itself (if reached). */", "    idx = cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);", "    assert(idx >= 0);"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E587: :break without :while or :for\");", "  else {", "    /* Inactivate conditionals until the matching \":while\" or a try"], "readability/braces"]
["src/nvim/ex_eval.c", ["     * pending for execution at the \":endtry\". */", "    idx = cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, TRUE);", "    if (idx >= 0 && !(cstack->cs_flags[idx] & (CSF_WHILE | CSF_FOR))) {"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = err;", "  else {", "    fl =  cstack->cs_flags[cstack->cs_idx];"], "readability/braces"]
["src/nvim/ex_eval.c", ["      /* Cleanup and rewind all contained (and unclosed) conditionals. */", "      (void)cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);", "      rewind_conditionals(cstack, idx, CSF_TRY, &cstack->cs_trylevel);"], "readability/bool"]
["src/nvim/ex_eval.c", ["     */", "    else if (cstack->cs_flags[cstack->cs_idx] & CSF_TRUE", "             && !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE)"], "whitespace/newline"]
["src/nvim/ex_eval.c", ["    value = eval_to_string_skip(arg, &eap->nextcmd, eap->skip);", "  else {", "    EMSG(_(e_argreq));"], "readability/braces"]
["src/nvim/ex_eval.c", ["  int idx;", "  int inactivate_try = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (did_emsg && !THROW_ON_ERROR) {", "    inactivate_try = TRUE;", "    did_emsg = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    inactivate_try = TRUE;", "    did_emsg = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (got_int && !THROW_ON_INTERRUPT) {", "    inactivate_try = TRUE;", "    got_int = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    inactivate_try = TRUE;", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  did_throw = TRUE;", "}"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E601: :try nesting too deep\");", "  else {", "    ++cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/ex_eval.c", ["  int idx = 0;", "  int give_up = FALSE;", "  int skip = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["  int give_up = FALSE;", "  int skip = FALSE;", "  int caught = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["  int skip = FALSE;", "  int caught = FALSE;", "  char_u      *end;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E603: :catch without :try\");", "    give_up = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["      eap->errmsg = get_end_emsg(cstack);", "      skip = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["      eap->errmsg = (char_u *)N_(\"E604: :catch after :finally\");", "      give_up = TRUE;", "    } else"], "readability/bool"]
["src/nvim/ex_eval.c", ["      give_up = TRUE;", "    } else", "      rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,"], "readability/braces"]
["src/nvim/ex_eval.c", ["    pat = eap->arg + 1;", "    end = skip_regexp(pat, *eap->arg, TRUE, NULL);", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    if (!did_throw || !(cstack->cs_flags[idx] & CSF_TRUE))", "      skip = TRUE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["        regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);", "        regmatch.rm_ic = FALSE;", "        if (end != NULL)"], "readability/bool"]
["src/nvim/ex_eval.c", ["          EMSG2(_(e_invarg2), pat);", "        else {", "          /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["          prev_got_int = got_int;", "          got_int = FALSE;", "          caught = vim_regexec_nl(&regmatch, current_exception->value,"], "readability/bool"]
["src/nvim/ex_eval.c", ["      cstack->cs_flags[idx] |= CSF_ACTIVE | CSF_CAUGHT;", "      did_emsg = got_int = did_throw = FALSE;", "      catch_exception((except_T *)cstack->cs_exception[idx]);"], "readability/bool"]
["src/nvim/ex_eval.c", ["       */", "      cleanup_conditionals(cstack, CSF_TRY, TRUE);", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  int idx;", "  int skip = FALSE;", "  int pending = CSTP_NONE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E606: :finally without :try\");", "  else {", "    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY)) {"], "readability/braces"]
["src/nvim/ex_eval.c", ["      pending = CSTP_ERROR;", "    } else", "      idx = cstack->cs_idx;"], "readability/braces"]
["src/nvim/ex_eval.c", ["       */", "      cleanup_conditionals(cstack, CSF_TRY, FALSE);", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["  int skip;", "  int rethrow = FALSE;", "  int pending = CSTP_NONE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    eap->errmsg = (char_u *)N_(\"E602: :endtry without :try\");", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["        --idx;", "      while (idx > 0 && !(cstack->cs_flags[idx] & CSF_TRY));", "      rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,"], "whitespace/empty_loop_body"]
["src/nvim/ex_eval.c", ["          &cstack->cs_looplevel);", "      skip = TRUE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["          && !(cstack->cs_flags[idx] & CSF_FINALLY))", "        rethrow = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["      if (got_int) {", "        skip = TRUE;", "        (void)do_intthrow(cstack);"], "readability/bool"]
["src/nvim/ex_eval.c", ["         * cstack->cs_pending[idx].*/", "        rethrow = FALSE;", "        if (did_throw && !(cstack->cs_flags[idx] & CSF_FINALLY))"], "readability/bool"]
["src/nvim/ex_eval.c", ["        if (did_throw && !(cstack->cs_flags[idx] & CSF_FINALLY))", "          rethrow = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_eval.c", ["     */", "    (void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["      case CSTP_RETURN:", "        do_return(eap, FALSE, FALSE, rettv);", "        break;"], "readability/bool"]
["src/nvim/ex_eval.c", ["      case CSTP_FINISH:", "        do_finish(eap, FALSE);", "        break;"], "readability/bool"]
["src/nvim/ex_eval.c", ["        if (pending & CSTP_ERROR)", "          did_emsg = TRUE;", "        if (pending & CSTP_INTERRUPT)"], "readability/bool"]
["src/nvim/ex_eval.c", ["        if (pending & CSTP_INTERRUPT)", "          got_int = TRUE;", "        if (pending & CSTP_THROW)"], "readability/bool"]
["src/nvim/ex_eval.c", ["        if (pending & CSTP_THROW)", "          rethrow = TRUE;", "        break;"], "readability/bool"]
["src/nvim/ex_eval.c", ["      csp->exception = current_exception;", "    else {", "      csp->exception = NULL;"], "readability/braces"]
["src/nvim/ex_eval.c", ["        force_abort |= cause_abort;", "        cause_abort = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    did_emsg = got_int = did_throw = need_rethrow = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["      /* Cancel the pending exception (includes report). */", "      discard_exception(csp->exception, FALSE);", "    else"], "readability/bool"]
["src/nvim/ex_eval.c", ["   */", "  else {", "    /*"], "whitespace/newline"]
["src/nvim/ex_eval.c", ["   */", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["      cause_abort = force_abort;", "      force_abort = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    if (pending & CSTP_ERROR)", "      did_emsg = TRUE;", "    if (pending & CSTP_INTERRUPT)"], "readability/bool"]
["src/nvim/ex_eval.c", ["    if (pending & CSTP_INTERRUPT)", "      got_int = TRUE;", "    if (pending & CSTP_THROW)"], "readability/bool"]
["src/nvim/ex_eval.c", ["    if (pending & CSTP_THROW)", "      need_rethrow = TRUE;          /* did_throw will be set by do_one_cmd() */", ""], "readability/bool"]
["src/nvim/ex_eval.c", [" */", "int cleanup_conditionals(struct condstack *cstack, int searched_cond, int inclusive)", "{"], "whitespace/line_length"]
["src/nvim/ex_eval.c", ["  int idx;", "  int stop = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["                  cstack->cs_exception[idx],", "                  FALSE);", "            } else"], "readability/bool"]
["src/nvim/ex_eval.c", ["                  FALSE);", "            } else", "              report_discard_pending(cstack->cs_pending[idx],"], "readability/braces"]
["src/nvim/ex_eval.c", ["            break;", "          stop = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_eval.c", ["        break;", "      stop = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", [" */", "void rewind_conditionals(struct condstack *cstack, int idx, int cond_type, int *cond_level)", "{"], "whitespace/line_length"]
["src/nvim/ex_eval.c", ["      || (p[0] == 'f' && p[1] == 'o' && p[2] == 'r'))", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["  int cmdattr;                  /* attributes for prompt */", "  int overstrike;               /* Typing mode on the command line.  Shared by", "                                   getcmdline() and put_on_cmdline(). */"], "readability/multiline_comment"]
["src/nvim/ex_getln.c", ["                                   getcmdline() and put_on_cmdline(). */", "  expand_T    *xpc;             /* struct being used for expansion, xp_pattern", "                                   may point into cmdbuff */"], "readability/multiline_comment"]
["src/nvim/ex_getln.c", ["char_u *", "getcmdline (", "    int firstc,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["char_u *", "getcmdline_prompt (", "    int firstc,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["  if (cmdwin_type != 0)", "    return TRUE;", "  return textlock != 0;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    EMSG(_(\"E788: Not allowed to edit another buffer now\"));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["    EMSG(_(\"E811: Not allowed to change buffer information now\"));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["      m = MAXCOL;", "  } else", "    m = MAXCOL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["char_u *", "getexline (", "    int c,                          /* normally ':', NUL for \":append\" */"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["char_u *", "getexmodeline (", "    int promptc,                    /* normally ':', NUL for \":append\" and '?' for"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["getexmodeline (", "    int promptc,                    /* normally ':', NUL for \":append\" and '?' for", "                                   :s prompt */"], "readability/multiline_comment"]
["src/nvim/ex_getln.c", ["getexmodeline (", "    int promptc,                    /* normally ':', NUL for \":append\" and '?' for", "                                   :s prompt */"], "whitespace/line_length"]
["src/nvim/ex_getln.c", ["  int c1 = 0;", "  int escaped = FALSE;                  /* CTRL-V typed */", "  int vcol = 0;"], "readability/bool"]
["src/nvim/ex_getln.c", ["   */", "  got_int = FALSE;", "  while (!got_int) {"], "readability/bool"]
["src/nvim/ex_getln.c", ["        p[line_ga.ga_len] = NUL;", "        indent = get_indent_str(p, 8, FALSE);", "        num_spaces = sw - indent % sw;"], "readability/bool"]
["src/nvim/ex_getln.c", ["          if (prev_char == '^')", "            ex_keep_indent = TRUE;", "          indent = 0;"], "readability/bool"]
["src/nvim/ex_getln.c", ["          p[line_ga.ga_len] = NUL;", "          indent = get_indent_str(p, 8, FALSE);", "          if (indent == 0) {"], "readability/bool"]
["src/nvim/ex_getln.c", ["        int old_indent;", "        while ((old_indent = get_indent_str(p, 8, FALSE)) > indent) {", "          *--to = NUL;"], "readability/bool"]
["src/nvim/ex_getln.c", ["      if (c1 == Ctrl_V || c1 == Ctrl_Q) {", "        escaped = TRUE;", "        continue;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    line_ga.ga_len += len;", "    escaped = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["  /* make following messages go to the next line */", "  msg_didout = FALSE;", "  msg_col = 0;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    ++msg_row;", "  emsg_on_display = FALSE;              /* don't want os_delay() */", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["    }", "  else if (p_arshape && !p_tbidi && enc_utf8 && len > 0) {", "    static int buflen = 0;"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["            pc = NUL;", "          else {", "            int pcc[MAX_MCO];"], "readability/braces"]
["src/nvim/ex_getln.c", ["    msg_outtrans_len(arshape_buf, newlen);", "  } else", "    msg_outtrans_len(ccline.cmdbuff + start, len);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    return;", "  msg_no_more = TRUE;", "  msg_putchar(c);"], "readability/bool"]
["src/nvim/ex_getln.c", ["    draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);", "  msg_no_more = FALSE;", "  cursorcmd();"], "readability/bool"]
["src/nvim/ex_getln.c", ["    return;", "  msg_no_more = TRUE;", "  if (ccline.cmdlen == ccline.cmdpos)"], "readability/bool"]
["src/nvim/ex_getln.c", ["    draw_cmdline(ccline.cmdpos, 1);", "  msg_no_more = FALSE;", "  cursorcmd();"], "readability/bool"]
["src/nvim/ex_getln.c", ["        ccline.cmdlen += ccline.cmdpos + len - i;", "      } else", "        ccline.cmdlen = ccline.cmdpos + len;"], "readability/braces"]
["src/nvim/ex_getln.c", ["        ccline.cmdlen = ccline.cmdpos + len;", "    } else if (ccline.cmdpos + len > ccline.cmdlen)", "      ccline.cmdlen = ccline.cmdpos + len;"], "readability/braces"]
["src/nvim/ex_getln.c", ["        len += i;", "      } else", "        i = 0;"], "readability/braces"]
["src/nvim/ex_getln.c", ["  if (redraw && !cmd_silent) {", "    msg_no_more = TRUE;", "    i = cmdline_row;"], "readability/bool"]
["src/nvim/ex_getln.c", ["      msg_clr_eos();", "    msg_no_more = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["        m = MAXCOL;", "    } else", "      m = MAXCOL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["static struct cmdline_info prev_ccline;", "static int prev_ccline_used = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["    memset(&prev_ccline, 0, sizeof(struct cmdline_info));", "    prev_ccline_used = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", [" */", "static int ", "cmdline_paste ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["static int ", "cmdline_paste (", "    int regname,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["  ++textlock;", "  i = get_spec_reg(regname, &arg, &allocated, TRUE);", "  --textlock;"], "readability/bool"]
["src/nvim/ex_getln.c", ["  if (literally)", "    put_on_cmdline(s, -1, TRUE);", "  else"], "readability/bool"]
["src/nvim/ex_getln.c", ["    return;", "  need_wait_return = FALSE;", "  compute_cmdrow();"], "readability/bool"]
["src/nvim/ex_getln.c", ["      --ccline.cmdindent;", "  } else", "    for (i = ccline.cmdindent; i > 0; --i)"], "readability/braces"]
["src/nvim/ex_getln.c", ["  /* Don't use more prompt, truncate the cmdline if it doesn't fit. */", "  msg_no_more = TRUE;", "  draw_cmdline(0, ccline.cmdlen);"], "readability/bool"]
["src/nvim/ex_getln.c", ["  msg_clr_eos();", "  msg_no_more = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["   */", "  msg_scroll = FALSE;           /* next message overwrites cmdline */", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["   * in cmdline mode */", "  skip_redraw = FALSE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["  if (p_paste || no_abbr)           /* no abbreviations or in paste mode */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", [" */", "static int ", "nextwild ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["static int ", "nextwild (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["      p2 = NULL;", "    else {", "      int use_options = options |"], "readability/braces"]
["src/nvim/ex_getln.c", ["char_u *", "ExpandOne (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["  static char_u *orig_save = NULL;      /* kept value of orig */", "  int orig_saved = FALSE;", "  int i;"], "readability/bool"]
["src/nvim/ex_getln.c", ["        --findex;", "      } else        /* mode == WILD_NEXT */", "        ++findex;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      return vim_strsave(xp->xp_files[findex]);", "    } else", "      return NULL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    orig_save = orig;", "    orig_saved = TRUE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["            break;", "        } else if (xp->xp_files[i][len] != xp->xp_files[0][len])", "          break;"], "readability/braces"]
["src/nvim/ex_getln.c", ["#ifndef BACKSLASH_IN_FILENAME", "  xp->xp_shell = FALSE;", "#endif"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "void ExpandEscape(expand_T *xp, char_u *str, int numfiles, char_u **files, int options)", "{"], "whitespace/line_length"]
["src/nvim/ex_getln.c", ["#ifdef BACKSLASH_IN_FILENAME", "        p = vim_strsave_fnameescape(files[i], FALSE);", "#else"], "readability/bool"]
["src/nvim/ex_getln.c", ["  if (!wildmenu) {", "    msg_didany = FALSE;                 /* lines_left will be set */", "    msg_start();                        /* prepare for paging */"], "readability/bool"]
["src/nvim/ex_getln.c", ["    cmdline_row = msg_row;", "    msg_didany = FALSE;                 /* lines_left will be set again */", "    msg_start();                        /* prepare for paging */"], "readability/bool"]
["src/nvim/ex_getln.c", ["  if (got_int)", "    got_int = FALSE;            /* only int. the completion, not the cmd line */", "  else if (wildmenu)"], "readability/bool"]
["src/nvim/ex_getln.c", ["    win_redr_status_matches(xp, num_files, files_found, 0, showtail);", "  else {", "    /* find the length of the longest file name */"], "readability/braces"]
["src/nvim/ex_getln.c", ["                        || xp->xp_context == EXPAND_BUFFERS)) {", "        home_replace(NULL, files_found[i], NameBuff, MAXPATHL, TRUE);", "        j = vim_strsize(NameBuff);"], "readability/bool"]
["src/nvim/ex_getln.c", ["        j = vim_strsize(NameBuff);", "      } else", "        j = vim_strsize(L_SHOWFILE(i));"], "readability/braces"]
["src/nvim/ex_getln.c", ["      lines = num_files;", "    else {", "      /* compute the number of columns and lines for the listing */"], "readability/braces"]
["src/nvim/ex_getln.c", ["             * $HOME has been replaced with ~/. */", "            exp_path = expand_env_save_opt(files_found[k], TRUE);", "            halved_slash = backslash_halve_save("], "readability/bool"]
["src/nvim/ex_getln.c", ["            xfree(halved_slash);", "          } else", "            /* Expansion was done here, file names are literal. */"], "readability/braces"]
["src/nvim/ex_getln.c", ["            p = L_SHOWFILE(k);", "          else {", "            home_replace(NULL, files_found[k], NameBuff, MAXPATHL,"], "readability/braces"]
["src/nvim/ex_getln.c", ["            home_replace(NULL, files_found[k], NameBuff, MAXPATHL,", "                TRUE);", "            p = NameBuff;"], "readability/bool"]
["src/nvim/ex_getln.c", ["        } else {", "          j = FALSE;", "          p = L_SHOWFILE(k);"], "readability/bool"]
["src/nvim/ex_getln.c", ["      if (got_int) {", "        got_int = FALSE;", "        break;"], "readability/bool"]
["src/nvim/ex_getln.c", ["  char_u      *t = s;", "  int had_sep = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["        )", "      had_sep = TRUE;", "    else if (had_sep) {"], "readability/bool"]
["src/nvim/ex_getln.c", ["      t = p;", "      had_sep = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_getln.c", ["      && xp->xp_context != EXPAND_DIRECTORIES)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["  if (end == xp->xp_pattern)            /* there is no path separator */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["    else if (vim_strchr((char_u *)\"*?[\", *s) != NULL)", "      return FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["char_u *", "addstar (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["      retval = vim_strnsave(fname, len);", "    else {", "      new_len = len + 2;                /* +2 for '^' at start, NUL at end */"], "readability/braces"]
["src/nvim/ex_getln.c", ["        if (fname[i] == '*' || fname[i] == '~')", "          new_len++;                    /* '*' needs to be replaced by \".*\"", "                                           '~' needs to be replaced by \"\\~\" */"], "readability/multiline_comment"]
["src/nvim/ex_getln.c", ["", "void ", "set_cmd_context ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["void ", "set_cmd_context (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["    xp->xp_arg = ccline.xp_arg;", "  } else", "    while (nextcomm != NULL)"], "readability/braces"]
["src/nvim/ex_getln.c", [" */", "int ", "expand_cmdline ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["int ", "expand_cmdline (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", [" */", "static int ", "ExpandFromContext ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["static int ", "ExpandFromContext (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["     */", "    int free_pat = FALSE;", "    int i;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    if (xp->xp_backslash != XP_BS_NONE) {", "      free_pat = TRUE;", "      pat = vim_strsave(pat);"], "readability/bool"]
["src/nvim/ex_getln.c", ["    if (find_help_tags(*pat == NUL ? (char_u *)\"help\" : pat,", "            num_file, file, FALSE) == OK) {", "      cleanup_help_tags(*num_file, *file);"], "readability/bool"]
["src/nvim/ex_getln.c", ["    ret = ExpandUserDefined(xp, &regmatch, num_file, file);", "  else {", "    static struct expgen {"], "readability/braces"]
["src/nvim/ex_getln.c", ["    {", "      {EXPAND_COMMANDS, get_command_name, FALSE, TRUE},", "      {EXPAND_BEHAVE, get_behave_arg, TRUE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_COMMANDS, get_command_name, FALSE, TRUE},", "      {EXPAND_BEHAVE, get_behave_arg, TRUE, TRUE},", "      {EXPAND_HISTORY, get_history_arg, TRUE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_BEHAVE, get_behave_arg, TRUE, TRUE},", "      {EXPAND_HISTORY, get_history_arg, TRUE, TRUE},", "      {EXPAND_USER_COMMANDS, get_user_commands, FALSE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_HISTORY, get_history_arg, TRUE, TRUE},", "      {EXPAND_USER_COMMANDS, get_user_commands, FALSE, TRUE},", "      {EXPAND_USER_ADDR_TYPE, get_user_cmd_addr_type, FALSE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_USER_COMMANDS, get_user_commands, FALSE, TRUE},", "      {EXPAND_USER_ADDR_TYPE, get_user_cmd_addr_type, FALSE, TRUE},", "      {EXPAND_USER_CMD_FLAGS, get_user_cmd_flags, FALSE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_USER_ADDR_TYPE, get_user_cmd_addr_type, FALSE, TRUE},", "      {EXPAND_USER_CMD_FLAGS, get_user_cmd_flags, FALSE, TRUE},", "      {EXPAND_USER_NARGS, get_user_cmd_nargs, FALSE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_USER_CMD_FLAGS, get_user_cmd_flags, FALSE, TRUE},", "      {EXPAND_USER_NARGS, get_user_cmd_nargs, FALSE, TRUE},", "      {EXPAND_USER_COMPLETE, get_user_cmd_complete, FALSE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_USER_NARGS, get_user_cmd_nargs, FALSE, TRUE},", "      {EXPAND_USER_COMPLETE, get_user_cmd_complete, FALSE, TRUE},", "      {EXPAND_USER_VARS, get_user_var_name, FALSE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_USER_COMPLETE, get_user_cmd_complete, FALSE, TRUE},", "      {EXPAND_USER_VARS, get_user_var_name, FALSE, TRUE},", "      {EXPAND_FUNCTIONS, get_function_name, FALSE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_USER_VARS, get_user_var_name, FALSE, TRUE},", "      {EXPAND_FUNCTIONS, get_function_name, FALSE, TRUE},", "      {EXPAND_USER_FUNC, get_user_func_name, FALSE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_FUNCTIONS, get_function_name, FALSE, TRUE},", "      {EXPAND_USER_FUNC, get_user_func_name, FALSE, TRUE},", "      {EXPAND_EXPRESSION, get_expr_name, FALSE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_USER_FUNC, get_user_func_name, FALSE, TRUE},", "      {EXPAND_EXPRESSION, get_expr_name, FALSE, TRUE},", "      {EXPAND_MENUS, get_menu_name, FALSE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_EXPRESSION, get_expr_name, FALSE, TRUE},", "      {EXPAND_MENUS, get_menu_name, FALSE, TRUE},", "      {EXPAND_MENUNAMES, get_menu_names, FALSE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_MENUS, get_menu_name, FALSE, TRUE},", "      {EXPAND_MENUNAMES, get_menu_names, FALSE, TRUE},", "      {EXPAND_SYNTAX, get_syntax_name, TRUE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_MENUNAMES, get_menu_names, FALSE, TRUE},", "      {EXPAND_SYNTAX, get_syntax_name, TRUE, TRUE},", "      {EXPAND_SYNTIME, get_syntime_arg, TRUE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_SYNTAX, get_syntax_name, TRUE, TRUE},", "      {EXPAND_SYNTIME, get_syntime_arg, TRUE, TRUE},", "      {EXPAND_HIGHLIGHT, get_highlight_name, TRUE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_SYNTIME, get_syntime_arg, TRUE, TRUE},", "      {EXPAND_HIGHLIGHT, get_highlight_name, TRUE, TRUE},", "      {EXPAND_EVENTS, get_event_name, TRUE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_HIGHLIGHT, get_highlight_name, TRUE, TRUE},", "      {EXPAND_EVENTS, get_event_name, TRUE, TRUE},", "      {EXPAND_AUGROUP, get_augroup_name, TRUE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_EVENTS, get_event_name, TRUE, TRUE},", "      {EXPAND_AUGROUP, get_augroup_name, TRUE, TRUE},", "      {EXPAND_CSCOPE, get_cscope_name, TRUE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_AUGROUP, get_augroup_name, TRUE, TRUE},", "      {EXPAND_CSCOPE, get_cscope_name, TRUE, TRUE},", "      {EXPAND_SIGN, get_sign_name, TRUE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_CSCOPE, get_cscope_name, TRUE, TRUE},", "      {EXPAND_SIGN, get_sign_name, TRUE, TRUE},", "      {EXPAND_PROFILE, get_profile_name, TRUE, TRUE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_SIGN, get_sign_name, TRUE, TRUE},", "      {EXPAND_PROFILE, get_profile_name, TRUE, TRUE},", "#ifdef HAVE_WORKING_LIBINTL"], "readability/bool"]
["src/nvim/ex_getln.c", ["#ifdef HAVE_WORKING_LIBINTL", "      {EXPAND_LANGUAGE, get_lang_arg, TRUE, FALSE},", "      {EXPAND_LOCALES, get_locales, TRUE, FALSE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_LANGUAGE, get_lang_arg, TRUE, FALSE},", "      {EXPAND_LOCALES, get_locales, TRUE, FALSE},", "#endif"], "readability/bool"]
["src/nvim/ex_getln.c", ["#endif", "      {EXPAND_ENV_VARS, get_env_name, TRUE, TRUE},", "      {EXPAND_USER, get_users, TRUE, FALSE},"], "readability/bool"]
["src/nvim/ex_getln.c", ["      {EXPAND_ENV_VARS, get_env_name, TRUE, TRUE},", "      {EXPAND_USER, get_users, TRUE, FALSE},", "    };"], "readability/bool"]
["src/nvim/ex_getln.c", ["        if (tab[i].ic) {", "          regmatch.rm_ic = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_getln.c", ["    str = (*func)(xp, i);", "    if (str == NULL) // end of list", "      break;"], "whitespace/comments"]
["src/nvim/ex_getln.c", ["      break;", "    if (*str == NUL) // skip empty strings", "      continue;"], "whitespace/comments"]
["src/nvim/ex_getln.c", ["    str = (*func)(xp, i);", "    if (str == NULL) // end of list", "      break;"], "whitespace/comments"]
["src/nvim/ex_getln.c", ["      break;", "    if (*str == NUL) // skip empty strings", "      continue;"], "whitespace/comments"]
["src/nvim/ex_getln.c", ["    path = (char_u *)\".\";", "  else {", "    path = (char_u *)vim_getenv(\"PATH\");"], "readability/braces"]
["src/nvim/ex_getln.c", ["            ((char_u **)ga.ga_data)[ga.ga_len++] = s;", "          } else", "            xfree(s);"], "readability/braces"]
["src/nvim/ex_getln.c", ["  args[1] = xp->xp_line;", "  sprintf((char *)num, \"%d\", xp->xp_col);", "  args[2] = num;"], "runtime/printf"]
["src/nvim/ex_getln.c", ["", "  ret = user_expand_func(xp->xp_arg, 3, args, FALSE);", ""], "readability/bool"]
["src/nvim/ex_getln.c", [" */", "static int ExpandUserDefined(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file)", "{"], "whitespace/line_length"]
["src/nvim/ex_getln.c", [" */", "static int ExpandRTDir(char_u *pat, int *num_file, char_u ***file, char *dirnames[])", "{"], "whitespace/line_length"]
["src/nvim/ex_getln.c", [" */", "static int ", "in_history ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["static int ", "in_history (", "    int type,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["  if (hisidx[type] < 0)", "    return FALSE;", "  i = hisidx[type];"], "readability/bool"]
["src/nvim/ex_getln.c", ["    if (history[type][i].hisstr == NULL)", "      return FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["      if (!move_to_front)", "        return TRUE;", "      last_i = i;"], "readability/bool"]
["src/nvim/ex_getln.c", [" */", "void ", "add_to_history ("], "whitespace/end_of_line"]
["src/nvim/ex_getln.c", ["void ", "add_to_history (", "    int histype,"], "whitespace/parens"]
["src/nvim/ex_getln.c", ["  histentry_T *hist;", "  int wrapped = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["        i += hislen;", "        wrapped = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_getln.c", ["  regmatch.regprog = NULL;", "  regmatch.rm_ic = FALSE;       /* always match case */", "  if (hislen != 0"], "readability/bool"]
["src/nvim/ex_getln.c", ["  if (i < 0)", "    return FALSE;", "  idx = hisidx[histype];"], "readability/bool"]
["src/nvim/ex_getln.c", ["  hisidx[histype] = i;", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["  int len;", "  int first = FALSE;", "  long num;"], "readability/bool"]
["src/nvim/ex_getln.c", ["  if (**str == '-' || ascii_isdigit(**str)) {  /* parse \"from\" part of range */", "    vim_str2nr(*str, NULL, &len, FALSE, FALSE, &num, NULL);", "    *str += len;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    *num1 = (int)num;", "    first = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["    *str = skipwhite(*str + 1);", "    vim_str2nr(*str, NULL, &len, FALSE, FALSE, &num, NULL);", "    if (len > 0) {"], "readability/bool"]
["src/nvim/ex_getln.c", ["      *str = skipwhite(*str + len);", "    } else if (!first)                  /* no number given at all */", "      return FAIL;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      return FAIL;", "  } else if (first)                     /* only one number given */", "    *num2 = *num1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["      }", "    } else", "      histype2 = histype1;"], "readability/braces"]
["src/nvim/ex_getln.c", ["    *end = i;", "  } else", "    end = arg;"], "readability/braces"]
["src/nvim/ex_getln.c", ["          msg_putchar('\\n');", "          sprintf((char *)IObuff, \"%c%6d  \", i == idx ? '>' : ' ',", "              hist[i].hisnum);"], "runtime/printf"]
["src/nvim/ex_getln.c", ["  (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);", "  (void)setfname(curbuf, (char_u *)\"[Command Line]\", NULL, TRUE);", "  set_option_value((char_u *)\"bt\", 0L, (char_u *)\"nofile\", OPT_LOCAL);"], "readability/bool"]
["src/nvim/ex_getln.c", ["  set_option_value((char_u *)\"swf\", 0L, NULL, OPT_LOCAL);", "  curbuf->b_p_ma = TRUE;", "  curwin->w_p_fen = FALSE;"], "readability/bool"]
["src/nvim/ex_getln.c", ["  curbuf->b_p_ma = TRUE;", "  curwin->w_p_fen = FALSE;", "  curwin->w_p_rl = cmdmsg_rl;"], "readability/bool"]
["src/nvim/ex_getln.c", ["  curwin->w_p_rl = cmdmsg_rl;", "  cmdmsg_rl = FALSE;", "  RESET_BINDING(curwin);"], "readability/bool"]
["src/nvim/ex_getln.c", ["  /* Showing the prompt may have set need_wait_return, reset it. */", "  need_wait_return = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["          ml_append(lnum++, history[histtype][i].hisstr,", "              (colnr_T)0, FALSE);", "      } while (i != hisidx[histtype]);"], "readability/bool"]
["src/nvim/ex_getln.c", ["   * cursor there. */", "  ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);", "  curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"], "readability/bool"]
["src/nvim/ex_getln.c", ["  typestr[1] = NUL;", "  apply_autocmds(EVENT_CMDWINENTER, typestr, typestr, FALSE, curbuf);", "  if (restart_edit != 0)        /* autocmd with \":startinsert\" */"], "readability/bool"]
["src/nvim/ex_getln.c", ["  /* Trigger CmdwinLeave autocommands. */", "  apply_autocmds(EVENT_CMDWINLEAVE, typestr, typestr, FALSE, curbuf);", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["      ccline.cmdbuff = NULL;", "    } else", "      ccline.cmdbuff = vim_strsave(get_cursor_line_ptr());"], "readability/braces"]
["src/nvim/ex_getln.c", ["      cmdwin_result = Ctrl_C;", "    else {", "      ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);"], "readability/braces"]
["src/nvim/ex_getln.c", ["    win_goto(old_curwin);", "    win_close(wp, TRUE);", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["    if (buf_valid(bp))", "      close_buffer(NULL, bp, DOBUF_WIPE, FALSE);", ""], "readability/bool"]
["src/nvim/farsi.c", ["    case _HE_      : tempc = F_HE     ; break;", "    default        : tempc = c        ;", "  }"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _AYN_     : tempc = _AYN     ; break;", "    case AYN_      : tempc = AYN      ; break; // exception - there are many", "    case _GHAYN_   : tempc = _GHAYN   ; break;"], "whitespace/comments"]
["src/nvim/farsi.c", ["    case _GHAYN_   : tempc = _GHAYN   ; break;", "    case GHAYN_    : tempc = GHAYN    ; break; // exception - there are many", "    case _HE_      : tempc = _HE      ; break;"], "whitespace/comments"]
["src/nvim/farsi.c", ["  switch ((curc = gchar_cursor())) {", "    case _BE     : tempc = BE     ; break ;", "    case _PE     : tempc = PE     ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["  switch ((curc = gchar_cursor())) {", "    case _BE     : tempc = BE     ; break ;", "    case _PE     : tempc = PE     ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _BE     : tempc = BE     ; break ;", "    case _PE     : tempc = PE     ; break ;", "    case _TE     : tempc = TE     ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _BE     : tempc = BE     ; break ;", "    case _PE     : tempc = PE     ; break ;", "    case _TE     : tempc = TE     ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _PE     : tempc = PE     ; break ;", "    case _TE     : tempc = TE     ; break ;", "    case _SE     : tempc = SE     ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _PE     : tempc = PE     ; break ;", "    case _TE     : tempc = TE     ; break ;", "    case _SE     : tempc = SE     ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _TE     : tempc = TE     ; break ;", "    case _SE     : tempc = SE     ; break ;", "    case _JIM    : tempc = JIM    ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _TE     : tempc = TE     ; break ;", "    case _SE     : tempc = SE     ; break ;", "    case _JIM    : tempc = JIM    ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _SE     : tempc = SE     ; break ;", "    case _JIM    : tempc = JIM    ; break ;", "    case _CHE    : tempc = CHE    ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _SE     : tempc = SE     ; break ;", "    case _JIM    : tempc = JIM    ; break ;", "    case _CHE    : tempc = CHE    ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _JIM    : tempc = JIM    ; break ;", "    case _CHE    : tempc = CHE    ; break ;", "    case _HE_J   : tempc = HE_J   ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _JIM    : tempc = JIM    ; break ;", "    case _CHE    : tempc = CHE    ; break ;", "    case _HE_J   : tempc = HE_J   ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _CHE    : tempc = CHE    ; break ;", "    case _HE_J   : tempc = HE_J   ; break ;", "    case _XE     : tempc = XE     ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _CHE    : tempc = CHE    ; break ;", "    case _HE_J   : tempc = HE_J   ; break ;", "    case _XE     : tempc = XE     ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _HE_J   : tempc = HE_J   ; break ;", "    case _XE     : tempc = XE     ; break ;", "    case _SIN    : tempc = SIN    ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _HE_J   : tempc = HE_J   ; break ;", "    case _XE     : tempc = XE     ; break ;", "    case _SIN    : tempc = SIN    ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _XE     : tempc = XE     ; break ;", "    case _SIN    : tempc = SIN    ; break ;", "    case _SHIN   : tempc = SHIN   ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _XE     : tempc = XE     ; break ;", "    case _SIN    : tempc = SIN    ; break ;", "    case _SHIN   : tempc = SHIN   ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _SIN    : tempc = SIN    ; break ;", "    case _SHIN   : tempc = SHIN   ; break ;", "    case _SAD    : tempc = SAD    ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _SIN    : tempc = SIN    ; break ;", "    case _SHIN   : tempc = SHIN   ; break ;", "    case _SAD    : tempc = SAD    ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _SHIN   : tempc = SHIN   ; break ;", "    case _SAD    : tempc = SAD    ; break ;", "    case _ZAD    : tempc = ZAD    ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _SHIN   : tempc = SHIN   ; break ;", "    case _SAD    : tempc = SAD    ; break ;", "    case _ZAD    : tempc = ZAD    ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _SAD    : tempc = SAD    ; break ;", "    case _ZAD    : tempc = ZAD    ; break ;", "    case _FE     : tempc = FE     ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _SAD    : tempc = SAD    ; break ;", "    case _ZAD    : tempc = ZAD    ; break ;", "    case _FE     : tempc = FE     ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _ZAD    : tempc = ZAD    ; break ;", "    case _FE     : tempc = FE     ; break ;", "    case _GHAF   : tempc = GHAF   ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _ZAD    : tempc = ZAD    ; break ;", "    case _FE     : tempc = FE     ; break ;", "    case _GHAF   : tempc = GHAF   ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _FE     : tempc = FE     ; break ;", "    case _GHAF   : tempc = GHAF   ; break ;", "    case _KAF_H  :"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _FE     : tempc = FE     ; break ;", "    case _GHAF   : tempc = GHAF   ; break ;", "    case _KAF_H  :"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _KAF_H  :", "    case _KAF    : tempc = KAF    ; break ;", "    case _GAF    : tempc = GAF    ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _KAF_H  :", "    case _KAF    : tempc = KAF    ; break ;", "    case _GAF    : tempc = GAF    ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _KAF    : tempc = KAF    ; break ;", "    case _GAF    : tempc = GAF    ; break ;", "    case _AYN    : tempc = AYN    ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _KAF    : tempc = KAF    ; break ;", "    case _GAF    : tempc = GAF    ; break ;", "    case _AYN    : tempc = AYN    ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _GAF    : tempc = GAF    ; break ;", "    case _AYN    : tempc = AYN    ; break ;", "    case _AYN_   : tempc = AYN_   ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _GAF    : tempc = GAF    ; break ;", "    case _AYN    : tempc = AYN    ; break ;", "    case _AYN_   : tempc = AYN_   ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _AYN    : tempc = AYN    ; break ;", "    case _AYN_   : tempc = AYN_   ; break ;", "    case _GHAYN  : tempc = GHAYN  ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _AYN    : tempc = AYN    ; break ;", "    case _AYN_   : tempc = AYN_   ; break ;", "    case _GHAYN  : tempc = GHAYN  ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _AYN_   : tempc = AYN_   ; break ;", "    case _GHAYN  : tempc = GHAYN  ; break ;", "    case _GHAYN_ : tempc = GHAYN_ ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _AYN_   : tempc = AYN_   ; break ;", "    case _GHAYN  : tempc = GHAYN  ; break ;", "    case _GHAYN_ : tempc = GHAYN_ ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _GHAYN  : tempc = GHAYN  ; break ;", "    case _GHAYN_ : tempc = GHAYN_ ; break ;", "    case _LAM    : tempc = LAM    ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _GHAYN  : tempc = GHAYN  ; break ;", "    case _GHAYN_ : tempc = GHAYN_ ; break ;", "    case _LAM    : tempc = LAM    ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _GHAYN_ : tempc = GHAYN_ ; break ;", "    case _LAM    : tempc = LAM    ; break ;", "    case _MIM    : tempc = MIM    ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _GHAYN_ : tempc = GHAYN_ ; break ;", "    case _LAM    : tempc = LAM    ; break ;", "    case _MIM    : tempc = MIM    ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _LAM    : tempc = LAM    ; break ;", "    case _MIM    : tempc = MIM    ; break ;", "    case _NOON   : tempc = NOON   ; break ;"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _LAM    : tempc = LAM    ; break ;", "    case _MIM    : tempc = MIM    ; break ;", "    case _NOON   : tempc = NOON   ; break ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _MIM    : tempc = MIM    ; break ;", "    case _NOON   : tempc = NOON   ; break ;", "    case _HE     :"], "whitespace/newline"]
["src/nvim/farsi.c", ["    case _MIM    : tempc = MIM    ; break ;", "    case _NOON   : tempc = NOON   ; break ;", "    case _HE     :"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case YEE      : tempc = YEE_      ; break;", "    default       : tempc = 0         ;", "  }"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case YEE      : tempc = YEE_      ; break;", "    default       : tempc = 0         ;", "  }"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case YEE_      : tempc = YEE      ; break;", "    default        : tempc = 0        ;", "  }"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["", "    arrow_used = TRUE;", "    (void)stop_arrow();"], "readability/bool"]
["src/nvim/farsi.c", ["    if (revins) {", "      arrow_used = TRUE;", "      (void)stop_arrow();"], "readability/bool"]
["src/nvim/farsi.c", ["          switch (c) {", "            case '0'  : return FARSI_0     ;", "            case '1'  : return FARSI_1     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '0'  : return FARSI_0     ;", "            case '1'  : return FARSI_1     ;", "            case '2'  : return FARSI_2     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '1'  : return FARSI_1     ;", "            case '2'  : return FARSI_2     ;", "            case '3'  : return FARSI_3     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '2'  : return FARSI_2     ;", "            case '3'  : return FARSI_3     ;", "            case '4'  : return FARSI_4     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '3'  : return FARSI_3     ;", "            case '4'  : return FARSI_4     ;", "            case '5'  : return FARSI_5     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '4'  : return FARSI_4     ;", "            case '5'  : return FARSI_5     ;", "            case '6'  : return FARSI_6     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '5'  : return FARSI_5     ;", "            case '6'  : return FARSI_6     ;", "            case '7'  : return FARSI_7     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '6'  : return FARSI_6     ;", "            case '7'  : return FARSI_7     ;", "            case '8'  : return FARSI_8     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '7'  : return FARSI_7     ;", "            case '8'  : return FARSI_8     ;", "            case '9'  : return FARSI_9     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '8'  : return FARSI_8     ;", "            case '9'  : return FARSI_9     ;", "            case 'B'  : return F_PSP       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '9'  : return FARSI_9     ;", "            case 'B'  : return F_PSP       ;", "            case 'E'  : return JAZR_N      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'B'  : return F_PSP       ;", "            case 'E'  : return JAZR_N      ;", "            case 'F'  : return ALEF_D_H    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'E'  : return JAZR_N      ;", "            case 'F'  : return ALEF_D_H    ;", "            case 'H'  : return ALEF_A      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'F'  : return ALEF_D_H    ;", "            case 'H'  : return ALEF_A      ;", "            case 'I'  : return TASH        ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'H'  : return ALEF_A      ;", "            case 'I'  : return TASH        ;", "            case 'K'  : return F_LQUOT     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'I'  : return TASH        ;", "            case 'K'  : return F_LQUOT     ;", "            case 'L'  : return F_RQUOT     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'K'  : return F_LQUOT     ;", "            case 'L'  : return F_RQUOT     ;", "            case 'M'  : return HAMZE       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'L'  : return F_RQUOT     ;", "            case 'M'  : return HAMZE       ;", "            case 'O'  : return '['         ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'M'  : return HAMZE       ;", "            case 'O'  : return '['         ;", "            case 'P'  : return ']'         ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'O'  : return '['         ;", "            case 'P'  : return ']'         ;", "            case 'Q'  : return OO          ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'P'  : return ']'         ;", "            case 'Q'  : return OO          ;", "            case 'R'  : return MAD_N       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'Q'  : return OO          ;", "            case 'R'  : return MAD_N       ;", "            case 'T'  : return OW          ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'R'  : return MAD_N       ;", "            case 'T'  : return OW          ;", "            case 'U'  : return MAD         ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'T'  : return OW          ;", "            case 'U'  : return MAD         ;", "            case 'W'  : return OW_OW       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'U'  : return MAD         ;", "            case 'W'  : return OW_OW       ;", "            case 'Y'  : return JAZR        ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'W'  : return OW_OW       ;", "            case 'Y'  : return JAZR        ;", "            case '`'  : return F_PCN       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case 'Y'  : return JAZR        ;", "            case '`'  : return F_PCN       ;", "            case '!'  : return F_EXCL      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '`'  : return F_PCN       ;", "            case '!'  : return F_EXCL      ;", "            case '@'  : return F_COMMA     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '!'  : return F_EXCL      ;", "            case '@'  : return F_COMMA     ;", "            case '#'  : return F_DIVIDE    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '@'  : return F_COMMA     ;", "            case '#'  : return F_DIVIDE    ;", "            case '$'  : return F_CURRENCY  ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '#'  : return F_DIVIDE    ;", "            case '$'  : return F_CURRENCY  ;", "            case '%'  : return F_PERCENT   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '$'  : return F_CURRENCY  ;", "            case '%'  : return F_PERCENT   ;", "            case '^'  : return F_MUL       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '%'  : return F_PERCENT   ;", "            case '^'  : return F_MUL       ;", "            case '&'  : return F_BCOMMA    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '^'  : return F_MUL       ;", "            case '&'  : return F_BCOMMA    ;", "            case '*'  : return F_STAR      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '&'  : return F_BCOMMA    ;", "            case '*'  : return F_STAR      ;", "            case '('  : return F_LPARENT   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '*'  : return F_STAR      ;", "            case '('  : return F_LPARENT   ;", "            case ')'  : return F_RPARENT   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '('  : return F_LPARENT   ;", "            case ')'  : return F_RPARENT   ;", "            case '-'  : return F_MINUS     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case ')'  : return F_RPARENT   ;", "            case '-'  : return F_MINUS     ;", "            case '_'  : return F_UNDERLINE ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '-'  : return F_MINUS     ;", "            case '_'  : return F_UNDERLINE ;", "            case '='  : return F_EQUALS    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '_'  : return F_UNDERLINE ;", "            case '='  : return F_EQUALS    ;", "            case '+'  : return F_PLUS      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '='  : return F_EQUALS    ;", "            case '+'  : return F_PLUS      ;", "            case '\\\\' : return F_BSLASH    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '+'  : return F_PLUS      ;", "            case '\\\\' : return F_BSLASH    ;", "            case '|'  : return F_PIPE      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '\\\\' : return F_BSLASH    ;", "            case '|'  : return F_PIPE      ;", "            case ':'  : return F_DCOLON    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '|'  : return F_PIPE      ;", "            case ':'  : return F_DCOLON    ;", "            case '\"'  : return F_SEMICOLON ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case ':'  : return F_DCOLON    ;", "            case '\"'  : return F_SEMICOLON ;", "            case '.'  : return F_PERIOD    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '\"'  : return F_SEMICOLON ;", "            case '.'  : return F_PERIOD    ;", "            case '/'  : return F_SLASH     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '.'  : return F_PERIOD    ;", "            case '/'  : return F_SLASH     ;", "            case '<'  : return F_LESS      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '/'  : return F_SLASH     ;", "            case '<'  : return F_LESS      ;", "            case '>'  : return F_GREATER   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '<'  : return F_LESS      ;", "            case '>'  : return F_GREATER   ;", "            case '?'  : return F_QUESTION  ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '>'  : return F_GREATER   ;", "            case '?'  : return F_QUESTION  ;", "            case ' '  : return F_BLANK     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["            case '?'  : return F_QUESTION  ;", "            case ' '  : return F_BLANK     ;", "          }"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["      switch (c) {", "        case '0'  : return FARSI_0     ;", "        case '1'  : return FARSI_1     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '0'  : return FARSI_0     ;", "        case '1'  : return FARSI_1     ;", "        case '2'  : return FARSI_2     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '1'  : return FARSI_1     ;", "        case '2'  : return FARSI_2     ;", "        case '3'  : return FARSI_3     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '2'  : return FARSI_2     ;", "        case '3'  : return FARSI_3     ;", "        case '4'  : return FARSI_4     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '3'  : return FARSI_3     ;", "        case '4'  : return FARSI_4     ;", "        case '5'  : return FARSI_5     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '4'  : return FARSI_4     ;", "        case '5'  : return FARSI_5     ;", "        case '6'  : return FARSI_6     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '5'  : return FARSI_5     ;", "        case '6'  : return FARSI_6     ;", "        case '7'  : return FARSI_7     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '6'  : return FARSI_6     ;", "        case '7'  : return FARSI_7     ;", "        case '8'  : return FARSI_8     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '7'  : return FARSI_7     ;", "        case '8'  : return FARSI_8     ;", "        case '9'  : return FARSI_9     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '8'  : return FARSI_8     ;", "        case '9'  : return FARSI_9     ;", "        case 'B'  : return F_PSP       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '9'  : return FARSI_9     ;", "        case 'B'  : return F_PSP       ;", "        case 'E'  : return JAZR_N      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'B'  : return F_PSP       ;", "        case 'E'  : return JAZR_N      ;", "        case 'F'  : return ALEF_D_H    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'E'  : return JAZR_N      ;", "        case 'F'  : return ALEF_D_H    ;", "        case 'H'  : return ALEF_A      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'F'  : return ALEF_D_H    ;", "        case 'H'  : return ALEF_A      ;", "        case 'I'  : return TASH        ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'H'  : return ALEF_A      ;", "        case 'I'  : return TASH        ;", "        case 'K'  : return F_LQUOT     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'I'  : return TASH        ;", "        case 'K'  : return F_LQUOT     ;", "        case 'L'  : return F_RQUOT     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'K'  : return F_LQUOT     ;", "        case 'L'  : return F_RQUOT     ;", "        case 'M'  : return HAMZE       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'L'  : return F_RQUOT     ;", "        case 'M'  : return HAMZE       ;", "        case 'O'  : return '['         ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'M'  : return HAMZE       ;", "        case 'O'  : return '['         ;", "        case 'P'  : return ']'         ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'O'  : return '['         ;", "        case 'P'  : return ']'         ;", "        case 'Q'  : return OO          ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'P'  : return ']'         ;", "        case 'Q'  : return OO          ;", "        case 'R'  : return MAD_N       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'Q'  : return OO          ;", "        case 'R'  : return MAD_N       ;", "        case 'T'  : return OW          ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'R'  : return MAD_N       ;", "        case 'T'  : return OW          ;", "        case 'U'  : return MAD         ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'T'  : return OW          ;", "        case 'U'  : return MAD         ;", "        case 'W'  : return OW_OW       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'U'  : return MAD         ;", "        case 'W'  : return OW_OW       ;", "        case 'Y'  : return JAZR        ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'W'  : return OW_OW       ;", "        case 'Y'  : return JAZR        ;", "        case '`'  : return F_PCN       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'Y'  : return JAZR        ;", "        case '`'  : return F_PCN       ;", "        case '!'  : return F_EXCL      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '`'  : return F_PCN       ;", "        case '!'  : return F_EXCL      ;", "        case '@'  : return F_COMMA     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '!'  : return F_EXCL      ;", "        case '@'  : return F_COMMA     ;", "        case '#'  : return F_DIVIDE    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '@'  : return F_COMMA     ;", "        case '#'  : return F_DIVIDE    ;", "        case '$'  : return F_CURRENCY  ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '#'  : return F_DIVIDE    ;", "        case '$'  : return F_CURRENCY  ;", "        case '%'  : return F_PERCENT   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '$'  : return F_CURRENCY  ;", "        case '%'  : return F_PERCENT   ;", "        case '^'  : return F_MUL       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '%'  : return F_PERCENT   ;", "        case '^'  : return F_MUL       ;", "        case '&'  : return F_BCOMMA    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '^'  : return F_MUL       ;", "        case '&'  : return F_BCOMMA    ;", "        case '*'  : return F_STAR      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '&'  : return F_BCOMMA    ;", "        case '*'  : return F_STAR      ;", "        case '('  : return F_LPARENT   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '*'  : return F_STAR      ;", "        case '('  : return F_LPARENT   ;", "        case ')'  : return F_RPARENT   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '('  : return F_LPARENT   ;", "        case ')'  : return F_RPARENT   ;", "        case '-'  : return F_MINUS     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case ')'  : return F_RPARENT   ;", "        case '-'  : return F_MINUS     ;", "        case '_'  : return F_UNDERLINE ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '-'  : return F_MINUS     ;", "        case '_'  : return F_UNDERLINE ;", "        case '='  : return F_EQUALS    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '_'  : return F_UNDERLINE ;", "        case '='  : return F_EQUALS    ;", "        case '+'  : return F_PLUS      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '='  : return F_EQUALS    ;", "        case '+'  : return F_PLUS      ;", "        case '\\\\' : return F_BSLASH    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '+'  : return F_PLUS      ;", "        case '\\\\' : return F_BSLASH    ;", "        case '|'  : return F_PIPE      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '\\\\' : return F_BSLASH    ;", "        case '|'  : return F_PIPE      ;", "        case ':'  : return F_DCOLON    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '|'  : return F_PIPE      ;", "        case ':'  : return F_DCOLON    ;", "        case '\"'  : return F_SEMICOLON ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case ':'  : return F_DCOLON    ;", "        case '\"'  : return F_SEMICOLON ;", "        case '.'  : return F_PERIOD    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '\"'  : return F_SEMICOLON ;", "        case '.'  : return F_PERIOD    ;", "        case '/'  : return F_SLASH     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '.'  : return F_PERIOD    ;", "        case '/'  : return F_SLASH     ;", "        case '<'  : return F_LESS      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '/'  : return F_SLASH     ;", "        case '<'  : return F_LESS      ;", "        case '>'  : return F_GREATER   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '<'  : return F_LESS      ;", "        case '>'  : return F_GREATER   ;", "        case '?'  : return F_QUESTION  ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '>'  : return F_GREATER   ;", "        case '?'  : return F_QUESTION  ;", "        case ' '  : return F_BLANK     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '?'  : return F_QUESTION  ;", "        case ' '  : return F_BLANK     ;", "      }"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        chg_l_toXor_X();", "        del_char(FALSE);", "        AppendCharToRedobuff(K_BS);"], "readability/bool"]
["src/nvim/farsi.c", ["  return c;", "}", ""], "readability/fn_size"]
["src/nvim/farsi.c", ["    case YEE_     : tempc = _YEE      ; break;", "    default       : tempc = c         ;", "  }"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case _HE_    : tempc = F_HE   ; break;", "    default      : tempc = c      ;", "  }"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["      switch (c) {", "        case '0'  : return FARSI_0     ;", "        case '1'  : return FARSI_1     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '0'  : return FARSI_0     ;", "        case '1'  : return FARSI_1     ;", "        case '2'  : return FARSI_2     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '1'  : return FARSI_1     ;", "        case '2'  : return FARSI_2     ;", "        case '3'  : return FARSI_3     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '2'  : return FARSI_2     ;", "        case '3'  : return FARSI_3     ;", "        case '4'  : return FARSI_4     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '3'  : return FARSI_3     ;", "        case '4'  : return FARSI_4     ;", "        case '5'  : return FARSI_5     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '4'  : return FARSI_4     ;", "        case '5'  : return FARSI_5     ;", "        case '6'  : return FARSI_6     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '5'  : return FARSI_5     ;", "        case '6'  : return FARSI_6     ;", "        case '7'  : return FARSI_7     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '6'  : return FARSI_6     ;", "        case '7'  : return FARSI_7     ;", "        case '8'  : return FARSI_8     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '7'  : return FARSI_7     ;", "        case '8'  : return FARSI_8     ;", "        case '9'  : return FARSI_9     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '8'  : return FARSI_8     ;", "        case '9'  : return FARSI_9     ;", "        case 'B'  : return F_PSP       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '9'  : return FARSI_9     ;", "        case 'B'  : return F_PSP       ;", "        case 'E'  : return JAZR_N      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'B'  : return F_PSP       ;", "        case 'E'  : return JAZR_N      ;", "        case 'F'  : return ALEF_D_H    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'E'  : return JAZR_N      ;", "        case 'F'  : return ALEF_D_H    ;", "        case 'H'  : return ALEF_A      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'F'  : return ALEF_D_H    ;", "        case 'H'  : return ALEF_A      ;", "        case 'I'  : return TASH        ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'H'  : return ALEF_A      ;", "        case 'I'  : return TASH        ;", "        case 'K'  : return F_LQUOT     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'I'  : return TASH        ;", "        case 'K'  : return F_LQUOT     ;", "        case 'L'  : return F_RQUOT     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'K'  : return F_LQUOT     ;", "        case 'L'  : return F_RQUOT     ;", "        case 'M'  : return HAMZE       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'L'  : return F_RQUOT     ;", "        case 'M'  : return HAMZE       ;", "        case 'O'  : return '['         ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'M'  : return HAMZE       ;", "        case 'O'  : return '['         ;", "        case 'P'  : return ']'         ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'O'  : return '['         ;", "        case 'P'  : return ']'         ;", "        case 'Q'  : return OO          ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'P'  : return ']'         ;", "        case 'Q'  : return OO          ;", "        case 'R'  : return MAD_N       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'Q'  : return OO          ;", "        case 'R'  : return MAD_N       ;", "        case 'T'  : return OW          ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'R'  : return MAD_N       ;", "        case 'T'  : return OW          ;", "        case 'U'  : return MAD         ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'T'  : return OW          ;", "        case 'U'  : return MAD         ;", "        case 'W'  : return OW_OW       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'U'  : return MAD         ;", "        case 'W'  : return OW_OW       ;", "        case 'Y'  : return JAZR        ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'W'  : return OW_OW       ;", "        case 'Y'  : return JAZR        ;", "        case '`'  : return F_PCN       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case 'Y'  : return JAZR        ;", "        case '`'  : return F_PCN       ;", "        case '!'  : return F_EXCL      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '`'  : return F_PCN       ;", "        case '!'  : return F_EXCL      ;", "        case '@'  : return F_COMMA     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '!'  : return F_EXCL      ;", "        case '@'  : return F_COMMA     ;", "        case '#'  : return F_DIVIDE    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '@'  : return F_COMMA     ;", "        case '#'  : return F_DIVIDE    ;", "        case '$'  : return F_CURRENCY  ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '#'  : return F_DIVIDE    ;", "        case '$'  : return F_CURRENCY  ;", "        case '%'  : return F_PERCENT   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '$'  : return F_CURRENCY  ;", "        case '%'  : return F_PERCENT   ;", "        case '^'  : return F_MUL       ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '%'  : return F_PERCENT   ;", "        case '^'  : return F_MUL       ;", "        case '&'  : return F_BCOMMA    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '^'  : return F_MUL       ;", "        case '&'  : return F_BCOMMA    ;", "        case '*'  : return F_STAR      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '&'  : return F_BCOMMA    ;", "        case '*'  : return F_STAR      ;", "        case '('  : return F_LPARENT   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '*'  : return F_STAR      ;", "        case '('  : return F_LPARENT   ;", "        case ')'  : return F_RPARENT   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '('  : return F_LPARENT   ;", "        case ')'  : return F_RPARENT   ;", "        case '-'  : return F_MINUS     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case ')'  : return F_RPARENT   ;", "        case '-'  : return F_MINUS     ;", "        case '_'  : return F_UNDERLINE ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '-'  : return F_MINUS     ;", "        case '_'  : return F_UNDERLINE ;", "        case '='  : return F_EQUALS    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '_'  : return F_UNDERLINE ;", "        case '='  : return F_EQUALS    ;", "        case '+'  : return F_PLUS      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '='  : return F_EQUALS    ;", "        case '+'  : return F_PLUS      ;", "        case '\\\\' : return F_BSLASH    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '+'  : return F_PLUS      ;", "        case '\\\\' : return F_BSLASH    ;", "        case '|'  : return F_PIPE      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '\\\\' : return F_BSLASH    ;", "        case '|'  : return F_PIPE      ;", "        case ':'  : return F_DCOLON    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '|'  : return F_PIPE      ;", "        case ':'  : return F_DCOLON    ;", "        case '\"'  : return F_SEMICOLON ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case ':'  : return F_DCOLON    ;", "        case '\"'  : return F_SEMICOLON ;", "        case '.'  : return F_PERIOD    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '\"'  : return F_SEMICOLON ;", "        case '.'  : return F_PERIOD    ;", "        case '/'  : return F_SLASH     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '.'  : return F_PERIOD    ;", "        case '/'  : return F_SLASH     ;", "        case '<'  : return F_LESS      ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '/'  : return F_SLASH     ;", "        case '<'  : return F_LESS      ;", "        case '>'  : return F_GREATER   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '<'  : return F_LESS      ;", "        case '>'  : return F_GREATER   ;", "        case '?'  : return F_QUESTION  ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '>'  : return F_GREATER   ;", "        case '?'  : return F_QUESTION  ;", "        case ' '  : return F_BLANK     ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["        case '?'  : return F_QUESTION  ;", "        case ' '  : return F_BLANK     ;", "      }"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["", "    case 'a' : return _SHIN ;", "    case 'A' : return WAW_H ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'a' : return _SHIN ;", "    case 'A' : return WAW_H ;", "    case 'b' : return ZAL   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'A' : return WAW_H ;", "    case 'b' : return ZAL   ;", "    case 'c' : return ZE    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'b' : return ZAL   ;", "    case 'c' : return ZE    ;", "    case 'C' : return JE    ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'c' : return ZE    ;", "    case 'C' : return JE    ;", "    case 'd' : return _YE   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'C' : return JE    ;", "    case 'd' : return _YE   ;", "    case 'D' : return _YEE  ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'd' : return _YE   ;", "    case 'D' : return _YEE  ;", "    case 'e' : return _SE   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'D' : return _YEE  ;", "    case 'e' : return _SE   ;", "    case 'f' : return _BE   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'e' : return _SE   ;", "    case 'f' : return _BE   ;", "    case 'g' : return _LAM  ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'f' : return _BE   ;", "    case 'g' : return _LAM  ;", ""], "whitespace/semicolon"]
["src/nvim/farsi.c", ["", "    case 'k' : return _NOON ;", "    case 'l' : return _MIM  ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'k' : return _NOON ;", "    case 'l' : return _MIM  ;", "    case 'm' : return _PE   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'l' : return _MIM  ;", "    case 'm' : return _PE   ;", "    case 'n' :"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'n' :", "    case 'N' : return DAL   ;", "    case 'o' : return _XE   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'N' : return DAL   ;", "    case 'o' : return _XE   ;", "    case 'p' : return _HE_J ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'o' : return _XE   ;", "    case 'p' : return _HE_J ;", "    case 'q' : return _ZAD  ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'p' : return _HE_J ;", "    case 'q' : return _ZAD  ;", "    case 'r' : return _GHAF ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'q' : return _ZAD  ;", "    case 'r' : return _GHAF ;", "    case 's' : return _SIN  ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'r' : return _GHAF ;", "    case 's' : return _SIN  ;", "    case 'S' : return _IE   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 's' : return _SIN  ;", "    case 'S' : return _IE   ;", "    case 't' : return _FE   ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'S' : return _IE   ;", "    case 't' : return _FE   ;", ""], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'v' :", "    case 'V' : return RE   ;", "    case 'w' : return _SAD ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'V' : return RE   ;", "    case 'w' : return _SAD ;", "    case 'x' :"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'x' :", "    case 'X' : return _TA  ;", ""], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'z'  :", "    case 'Z'  : return _ZA  ;", "    case ';'  : return _KAF ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case 'Z'  : return _ZA  ;", "    case ';'  : return _KAF ;", "    case '\\'' : return _GAF ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case ';'  : return _KAF ;", "    case '\\'' : return _GAF ;", "    case ','  : return WAW  ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case '\\'' : return _GAF ;", "    case ','  : return WAW  ;", "    case '['  : return _JIM ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case ','  : return WAW  ;", "    case '['  : return _JIM ;", "    case ']'  : return _CHE ;"], "whitespace/semicolon"]
["src/nvim/farsi.c", ["    case '['  : return _JIM ;", "    case ']'  : return _CHE ;", "  }"], "whitespace/semicolon"]
["src/nvim/fileio.c", ["#if defined(HAVE_UTIME) && defined(HAVE_UTIME_H)", "# include <utime.h>             /* for struct utimbuf */", "#endif"], "build/include_order"]
["src/nvim/fileio.c", ["typedef struct AutoCmd {", "  char_u          *cmd;                 /* The command to be executed (NULL", "                                           when command has been removed) */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["typedef struct AutoCmd {", "  char_u          *cmd;                 /* The command to be executed (NULL", "                                           when command has been removed) */"], "whitespace/parens"]
["src/nvim/fileio.c", ["typedef struct AutoPat {", "  char_u          *pat;                 /* pattern as typed (NULL when pattern", "                                           has been removed) */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["typedef struct AutoPat {", "  char_u          *pat;                 /* pattern as typed (NULL when pattern", "                                           has been removed) */"], "whitespace/parens"]
["src/nvim/fileio.c", ["  event_T event;                /* current event */", "  int arg_bufnr;                /* initially equal to <abuf>, set to zero when", "                                   buf is deleted */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)", "    msg_scroll = FALSE;", "  if (!msg_scroll)      /* wait a bit when overwriting an error msg */"], "readability/bool"]
["src/nvim/fileio.c", ["  if (!msg_scroll)      /* wait a bit when overwriting an error msg */", "    check_for_delay(FALSE);", "  msg_start();"], "readability/bool"]
["src/nvim/fileio.c", ["  msg_scroll = msg_scroll_save;", "  msg_scrolled_ign = TRUE;", "  /* may truncate the message to avoid a hit-return prompt */"], "readability/bool"]
["src/nvim/fileio.c", ["  /* may truncate the message to avoid a hit-return prompt */", "  msg_outtrans_attr(msg_may_trunc(FALSE, IObuff), attr);", "  msg_clr_eos();"], "readability/bool"]
["src/nvim/fileio.c", ["  ui_flush();", "  msg_scrolled_ign = FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", [" */", "int ", "readfile ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["int ", "readfile (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/fileio.c", ["  off_t filesize = 0;", "  int skip_read = FALSE;", "  context_sha256_T sha_ctx;"], "readability/bool"]
["src/nvim/fileio.c", ["  context_sha256_T sha_ctx;", "  int read_undo_file = FALSE;", "  int split = 0;                        /* number of split lines */"], "readability/bool"]
["src/nvim/fileio.c", ["  linenr_T linecnt;", "  int error = FALSE;                    /* errors encountered */", "  int ff_error = EOL_UNKNOWN;           /* file format with errors */"], "readability/bool"]
["src/nvim/fileio.c", ["  int fileformat = 0;                   /* end-of-line format */", "  int keep_fileformat = FALSE;", "  int file_readonly;"], "readability/bool"]
["src/nvim/fileio.c", ["  int msg_save = msg_scroll;", "  linenr_T read_no_eol_lnum = 0;        /* non-zero lnum when last line of", "                                        * last read was missing the eol */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["  int try_unix = (vim_strchr(p_ffs, 'x') != NULL);", "  int file_rewind = FALSE;", "  int can_retry;"], "readability/bool"]
["src/nvim/fileio.c", ["  linenr_T illegal_byte = 0;            /* line nr with illegal byte */", "  int keep_dest_enc = FALSE;            /* don't retry when char doesn't fit", "                                           in destination encoding */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["  linenr_T illegal_byte = 0;            /* line nr with illegal byte */", "  int keep_dest_enc = FALSE;            /* don't retry when char doesn't fit", "                                           in destination encoding */"], "readability/bool"]
["src/nvim/fileio.c", ["  char_u      *fenc_next = NULL;        /* next item in 'fencs' or NULL */", "  int advance_fenc = FALSE;", "  long real_size = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["  iconv_t iconv_fd = (iconv_t)-1;       /* descriptor for iconv() or -1 */", "  int did_iconv = FALSE;                /* TRUE when iconv() failed and trying", "                                           'charconvert' next */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["  iconv_t iconv_fd = (iconv_t)-1;       /* descriptor for iconv() or -1 */", "  int did_iconv = FALSE;                /* TRUE when iconv() failed and trying", "                                           'charconvert' next */"], "readability/bool"]
["src/nvim/fileio.c", ["# endif", "  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it"], "readability/bool"]
["src/nvim/fileio.c", ["  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it", "                                           wasn't possible */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["  int converted = FALSE;                /* TRUE if conversion done */", "  int notconverted = FALSE;             /* TRUE if conversion wanted but it", "                                           wasn't possible */"], "readability/bool"]
["src/nvim/fileio.c", ["   * display the line. */", "  ex_no_reprint = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["  /* don't display the file info for another buffer now */", "  need_fileinfo = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["      if (apply_autocmds_exarg(EVENT_BUFREADCMD, NULL, sfname,", "              FALSE, curbuf, eap))", "        return aborting() ? FAIL : OK;"], "readability/bool"]
["src/nvim/fileio.c", ["        return aborting() ? FAIL : OK;", "    } else if (apply_autocmds_exarg(EVENT_FILEREADCMD, sfname, sfname,", "                   FALSE, NULL, eap))"], "readability/braces"]
["src/nvim/fileio.c", ["    } else if (apply_autocmds_exarg(EVENT_FILEREADCMD, sfname, sfname,", "                   FALSE, NULL, eap))", "      return aborting() ? FAIL : OK;"], "readability/bool"]
["src/nvim/fileio.c", ["  if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)", "    msg_scroll = FALSE;         /* overwrite previous file message */", "  else"], "readability/bool"]
["src/nvim/fileio.c", ["  else", "    msg_scroll = TRUE;          /* don't overwrite previous file message */", ""], "readability/bool"]
["src/nvim/fileio.c", ["  if (check_readonly && !readonlymode)", "    curbuf->b_p_ro = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["   */", "  file_readonly = FALSE;", "  if (!read_buffer && !read_stdin) {"], "readability/bool"]
["src/nvim/fileio.c", ["    if (!newfile || readonlymode) {", "      file_readonly = TRUE;", "    } else if ((fd = os_open((char *)fname, O_RDWR, 0)) < 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["      // opening in readwrite mode failed => file is readonly", "      file_readonly = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    if (file_readonly == TRUE) {", "      // try to open readonly"], "readability/bool"]
["src/nvim/fileio.c", ["      filemess(curbuf, sfname, (char_u *)_(\"is a directory\"), 0);", "      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */", "    } else"], "readability/bool"]
["src/nvim/fileio.c", ["      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */", "    } else", "#endif"], "readability/braces"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_BUFNEWFILE, sfname, sfname,", "          FALSE, curbuf, eap);", "      /* remember the current fileformat */"], "readability/bool"]
["src/nvim/fileio.c", ["            _(\"[Permission Denied]\")), 0);", "      curbuf->b_p_ro = TRUE;                  /* must use \"w!\" now */", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["  if ((check_readonly && file_readonly) || curbuf->b_help)", "    curbuf->b_p_ro = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["    if (!read_buffer) {", "      curbuf->b_p_eol = TRUE;", "      curbuf->b_start_eol = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["      curbuf->b_p_eol = TRUE;", "      curbuf->b_start_eol = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    curbuf->b_p_bomb = FALSE;", "    curbuf->b_start_bomb = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    curbuf->b_p_bomb = FALSE;", "    curbuf->b_start_bomb = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["    if (!read_stdin && (curbuf != old_curbuf", "                        || (using_b_ffname && (old_b_ffname != curbuf->b_ffname))", "                        || (using_b_fname &&"], "whitespace/line_length"]
["src/nvim/fileio.c", ["     */", "    msg_scroll = TRUE;", "    if (filtering)"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERREADPRE, NULL, sfname,", "          FALSE, curbuf, eap);", "    else if (read_stdin)"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_STDINREADPRE, NULL, sfname,", "          FALSE, curbuf, eap);", "    else if (newfile)"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_BUFREADPRE, NULL, sfname,", "          FALSE, curbuf, eap);", "    else"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEREADPRE, sfname, sfname,", "          FALSE, NULL, eap);", "    if (msg_scrolled == n)"], "readability/bool"]
["src/nvim/fileio.c", ["      msg_scroll = msg_save;", "      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */", "      return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["    if (!read_stdin && (curbuf != old_curbuf", "                        || (using_b_ffname && (old_b_ffname != curbuf->b_ffname))", "                        || (using_b_fname && (old_b_fname != curbuf->b_fname))"], "whitespace/line_length"]
["src/nvim/fileio.c", ["        EMSG(_(\"E201: *ReadPre autocommands must not change current buffer\"));", "      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */", "      return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["      mch_msg(_(\"Nvim: Reading from stdin...\\n\"));", "    } else if (!read_buffer)", "      filemess(curbuf, sfname, (char_u *)\"\", 0);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  msg_scroll = FALSE;                   /* overwrite the file message */", ""], "readability/bool"]
["src/nvim/fileio.c", ["      curbuf->b_bad_char = eap->bad_char;", "  } else", "    curbuf->b_bad_char = 0;"], "readability/braces"]
["src/nvim/fileio.c", ["    fenc = enc_canonize(eap->cmd + eap->force_enc);", "    fenc_alloced = TRUE;", "    keep_dest_enc = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["    fenc_alloced = TRUE;", "    keep_dest_enc = TRUE;", "  } else if (curbuf->b_p_bin) {"], "readability/bool"]
["src/nvim/fileio.c", ["    fenc = (char_u *)\"\";                /* binary: don't convert */", "    fenc_alloced = FALSE;", "  } else if (curbuf->b_help) {"], "readability/bool"]
["src/nvim/fileio.c", ["          if (*p >= 0x80) {", "            c = TRUE;", "            break;"], "readability/bool"]
["src/nvim/fileio.c", ["      if (!enc_utf8)", "        keep_dest_enc = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    fenc_alloced = FALSE;", "  } else if (*p_fencs == NUL) {"], "readability/bool"]
["src/nvim/fileio.c", ["    fenc = curbuf->b_p_fenc;            /* use format from buffer */", "    fenc_alloced = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["    fenc = next_fenc(&fenc_next);", "    fenc_alloced = TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["      /* Can't rewind the file, give up. */", "      error = TRUE;", "      goto failed;"], "readability/bool"]
["src/nvim/fileio.c", ["    while (lnum > from)", "      ml_delete(lnum--, FALSE);", "    file_rewind = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["      ml_delete(lnum--, FALSE);", "    file_rewind = FALSE;", "    if (set_options) {"], "readability/bool"]
["src/nvim/fileio.c", ["    if (set_options) {", "      curbuf->b_p_bomb = FALSE;", "      curbuf->b_start_bomb = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["      curbuf->b_p_bomb = FALSE;", "      curbuf->b_start_bomb = FALSE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["  if (keep_fileformat)", "    keep_fileformat = FALSE;", "  else {"], "readability/bool"]
["src/nvim/fileio.c", ["    keep_fileformat = FALSE;", "  else {", "    if (eap != NULL && eap->force_ff != 0) {"], "readability/braces"]
["src/nvim/fileio.c", ["      fileformat = get_fileformat_force(curbuf, eap);", "      try_unix = try_dos = try_mac = FALSE;", "    } else if (curbuf->b_p_bin)"], "readability/bool"]
["src/nvim/fileio.c", ["      try_unix = try_dos = try_mac = FALSE;", "    } else if (curbuf->b_p_bin)", "      fileformat = EOL_UNIX;                    /* binary: use Unix format */"], "readability/braces"]
["src/nvim/fileio.c", ["     */", "    advance_fenc = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["       * without conversion. */", "      notconverted = TRUE;", "      conv_error = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["      fenc = (char_u *)\"\";", "      fenc_alloced = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/fileio.c", ["        fenc = (char_u *)\"\";", "        fenc_alloced = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["  if (converted) {", "", "    /* \"ucs-bom\" means we need to check the first bytes of the file"], "whitespace/blank_line"]
["src/nvim/fileio.c", ["#  ifdef USE_ICONV", "      did_iconv = FALSE;", "#  endif"], "readability/bool"]
["src/nvim/fileio.c", ["          /* Conversion failed.  Try another one. */", "          advance_fenc = TRUE;", "          if (fd < 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["            EMSG(_(\"E202: Conversion made file unreadable!\"));", "            error = TRUE;", "            goto failed;"], "readability/bool"]
["src/nvim/fileio.c", ["         * Try the next conversion in 'fileencodings' */", "        advance_fenc = TRUE;", "        goto retry;"], "readability/bool"]
["src/nvim/fileio.c", ["        if (new_buffer == NULL) {", "          error = TRUE;", "          break;"], "readability/bool"]
["src/nvim/fileio.c", ["            size = 0;", "          else {", "            int n, ni;"], "readability/braces"]
["src/nvim/fileio.c", ["          if (size < 0)                             /* read error */", "            error = TRUE;", "          else if (conv_restlen > 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["            /* Remember the first linenr with an illegal byte */", "            else if (illegal_byte == 0)", "              illegal_byte = curbuf->b_ml.ml_line_count"], "whitespace/newline"]
["src/nvim/fileio.c", ["# endif", "                                                    )) {", "                while (conv_restlen > 0) {"], "whitespace/parens"]
["src/nvim/fileio.c", ["", "      skip_read = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["          if (set_options) {", "            curbuf->b_p_bomb = TRUE;", "            curbuf->b_start_bomb = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["            curbuf->b_p_bomb = TRUE;", "            curbuf->b_start_bomb = TRUE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["            /* No BOM detected: retry with next encoding. */", "            advance_fenc = TRUE;", "          } else {"], "readability/bool"]
["src/nvim/fileio.c", ["            fenc = ccname;", "            fenc_alloced = FALSE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["          /* retry reading without getting new bytes or rewinding */", "          skip_read = TRUE;", "          goto retry;"], "readability/bool"]
["src/nvim/fileio.c", ["              u8c = *p;", "            else {", "              len = utf_head_off(ptr, p);"], "readability/braces"]
["src/nvim/fileio.c", ["                *dest = 0xBF;", "            } else", "              *dest = u8c;"], "readability/braces"]
["src/nvim/fileio.c", ["      } else if (enc_utf8 && !curbuf->b_p_bin) {", "        int incomplete_tail = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["              if (p > ptr || filesize > 0)", "                incomplete_tail = TRUE;", "              /* Incomplete byte sequence, move it to conv_rest[]"], "readability/bool"]
["src/nvim/fileio.c", ["                --size;", "              } else if (bad_char_behavior != BAD_KEEP)", "                *p = bad_char_behavior;"], "readability/braces"]
["src/nvim/fileio.c", ["                *p = bad_char_behavior;", "            } else", "              p += l - 1;"], "readability/braces"]
["src/nvim/fileio.c", ["            /* iconv() failed, try 'charconvert' */", "            did_iconv = TRUE;", "          else"], "readability/bool"]
["src/nvim/fileio.c", ["          /* use next item from 'fileencodings' */", "          advance_fenc = TRUE;", "          file_rewind = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["          advance_fenc = TRUE;", "          file_rewind = TRUE;", "          goto retry;"], "readability/bool"]
["src/nvim/fileio.c", ["            for (; p >= ptr && *p != CAR; p--)", "              ;", "            if (p >= ptr) {"], "whitespace/semicolon"]
["src/nvim/fileio.c", ["          *ptr = CAR;           /* NLs are replaced by CRs! */", "        else {", "          if (skip_count == 0) {"], "readability/braces"]
["src/nvim/fileio.c", ["            if (ml_append(lnum, line_start, len, newfile) == FAIL) {", "              error = TRUE;", "              break;"], "readability/bool"]
["src/nvim/fileio.c", ["            if (--read_count == 0) {", "              error = TRUE;                     /* break loop */", "              line_start = ptr;                 /* nothing left to write */"], "readability/bool"]
["src/nvim/fileio.c", ["            }", "          } else", "            --skip_count;"], "readability/braces"]
["src/nvim/fileio.c", ["          *ptr = NL;            /* NULs are replaced by newlines! */", "        else {", "          if (skip_count == 0) {"], "readability/braces"]
["src/nvim/fileio.c", ["               */", "              else if (ff_error != EOL_DOS) {", "                if (   try_unix"], "whitespace/newline"]
["src/nvim/fileio.c", ["                    set_fileformat(EOL_UNIX, OPT_LOCAL);", "                  file_rewind = TRUE;", "                  keep_fileformat = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["                  file_rewind = TRUE;", "                  keep_fileformat = TRUE;", "                  goto retry;"], "readability/bool"]
["src/nvim/fileio.c", ["            if (ml_append(lnum, line_start, len, newfile) == FAIL) {", "              error = TRUE;", "              break;"], "readability/bool"]
["src/nvim/fileio.c", ["            if (--read_count == 0) {", "              error = TRUE;                         /* break loop */", "              line_start = ptr;                 /* nothing left to write */"], "readability/bool"]
["src/nvim/fileio.c", ["            }", "          } else", "            --skip_count;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (error && read_count == 0)", "    error = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["    if (set_options)", "      curbuf->b_p_eol = FALSE;", "    *ptr = NUL;"], "readability/bool"]
["src/nvim/fileio.c", ["    if (ml_append(lnum, line_start, len, newfile) == FAIL)", "      error = TRUE;", "    else {"], "readability/bool"]
["src/nvim/fileio.c", ["      error = TRUE;", "    else {", "      if (read_undo_file)"], "readability/braces"]
["src/nvim/fileio.c", ["    // If editing a new file: set 'fenc' for the current buffer.", "    // Also for \":read ++edit file\". ", "    set_string_option_direct((char_u *)\"fenc\", -1, fenc,"], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["#ifdef HAVE_FD_CLOEXEC", "  else {", "    int fdflags = fcntl(fd, F_GETFD);"], "readability/braces"]
["src/nvim/fileio.c", ["    if (newfile && wasempty && !(curbuf->b_ml.ml_flags & ML_EMPTY)) {", "      ml_delete(curbuf->b_ml.ml_line_count, FALSE);", "      --linecnt;"], "readability/bool"]
["src/nvim/fileio.c", ["      foldUpdateAll(curwin);", "    } else if (linecnt)                 /* appended at least one line */", "      appended_lines_mark(from, linecnt);"], "readability/braces"]
["src/nvim/fileio.c", ["        if (newfile)", "          curbuf->b_p_ro = TRUE;                /* must use \"w!\" now */", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      msg_add_fname(curbuf, sfname);         /* fname in IObuff with quotes */", "      c = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[fifo/socket]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[fifo]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[socket]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[character special]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, shortmess(SHM_RO) ? _(\"[RO]\") : _(\"[readonly]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        msg_add_eol();", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[CR missing]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[long lines split]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[NOT converted]\"));", "        c = TRUE;", "      } else if (converted) {"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[converted]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (conv_error != 0) {", "        sprintf((char *)IObuff + STRLEN(IObuff),", "            _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);"], "runtime/printf"]
["src/nvim/fileio.c", ["            _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);", "        c = TRUE;", "      } else if (illegal_byte > 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["      } else if (illegal_byte > 0) {", "        sprintf((char *)IObuff + STRLEN(IObuff),", "            _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);"], "runtime/printf"]
["src/nvim/fileio.c", ["            _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);", "        c = TRUE;", "      } else if (error)  {"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[READ ERRORS]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (msg_add_fileformat(fileformat))", "        c = TRUE;", "        msg_add_lines(c, (long)linecnt, filesize);"], "readability/bool"]
["src/nvim/fileio.c", ["      keep_msg = NULL;", "      msg_scrolled_ign = TRUE;", "      p = msg_trunc_attr(IObuff, FALSE, 0);"], "readability/bool"]
["src/nvim/fileio.c", ["      msg_scrolled_ign = TRUE;", "      p = msg_trunc_attr(IObuff, FALSE, 0);", "      if (read_stdin || read_buffer || restart_edit != 0"], "readability/bool"]
["src/nvim/fileio.c", ["        set_keep_msg(p, 0);", "      msg_scrolled_ign = FALSE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["                    || (illegal_byte > 0 && bad_char_behavior != BAD_KEEP)", "                    ))", "      curbuf->b_p_ro = TRUE;"], "whitespace/parens"]
["src/nvim/fileio.c", ["                    ))", "      curbuf->b_p_ro = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["    curbuf->b_op_end.col = 0;", "", "  }"], "whitespace/blank_line"]
["src/nvim/fileio.c", ["     */", "    msg_scroll = TRUE;", "    if (filtering)"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERREADPOST, NULL, sfname,", "          FALSE, curbuf, eap);", "    else if (newfile)"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_BUFREADPOST, NULL, sfname,", "          FALSE, curbuf, eap);", "    else"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEREADPOST, sfname, sfname,", "          FALSE, NULL, eap);", "    if (msg_scrolled == n)"], "readability/bool"]
["src/nvim/fileio.c", ["  return OK;", "}", ""], "readability/fn_size"]
["src/nvim/fileio.c", [" */", "static linenr_T ", "readfile_linenr ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["static linenr_T ", "readfile_linenr (", "    linenr_T linecnt,               /* line count before reading more bytes */"], "whitespace/parens"]
["src/nvim/fileio.c", ["", "  sprintf((char *)eap->cmd, \"e ++ff=%s ++enc=%s\", buf->b_p_ff, buf->b_p_fenc);", "  eap->force_enc = 14 + (int)STRLEN(buf->b_p_ff);"], "runtime/printf"]
["src/nvim/fileio.c", ["  eap->force_bin = buf->b_p_bin ? FORCE_BIN : FORCE_NOBIN;", "  eap->read_edit = FALSE;", "  eap->forceit = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["  eap->read_edit = FALSE;", "  eap->forceit = FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["static char_u *", "readfile_charconvert (", "    char_u *fname,             /* name of input file */"], "whitespace/parens"]
["src/nvim/fileio.c", ["    errmsg = (char_u *)_(\"Can't find temp file for conversion\");", "  else {", "    close(*fdp);                /* close the input file, ignore errors */"], "readability/braces"]
["src/nvim/fileio.c", ["#ifdef UNIX", "static void ", "set_file_time ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["static void ", "set_file_time (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/fileio.c", [" */", "int ", "buf_write ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["int ", "buf_write (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/fileio.c", ["    linenr_T end,", "    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be", "                                           NULL! */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be", "                                           NULL! */", "    int append,                             /* append to the file */"], "whitespace/operators"]
["src/nvim/fileio.c", ["  char_u          *backup = NULL;", "  int backup_copy = FALSE;               /* copy the original file? */", "  int dobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["  char_u          *errmsg = NULL;", "  int errmsg_allocated = FALSE;", "  char_u          *errnum = NULL;"], "readability/bool"]
["src/nvim/fileio.c", ["  int retval = OK;", "  int newfile = FALSE;                      /* TRUE if file doesn't exist yet */", "  int msg_save = msg_scroll;"], "readability/bool"]
["src/nvim/fileio.c", ["  int overwriting;                          /* TRUE if writing over original */", "  int no_eol = FALSE;                       /* no end-of-line written */", "  int device = FALSE;                       /* writing to a device */"], "readability/bool"]
["src/nvim/fileio.c", ["  int no_eol = FALSE;                       /* no end-of-line written */", "  int device = FALSE;                       /* writing to a device */", "  int prev_got_int = got_int;"], "readability/bool"]
["src/nvim/fileio.c", ["#if defined(UNIX)", "  int made_writable = FALSE;                /* 'w' bit has been set */", "#endif"], "readability/bool"]
["src/nvim/fileio.c", ["  struct bw_info write_info;            /* info for buf_write_bytes() */", "  int converted = FALSE;", "  int notconverted = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["  int converted = FALSE;", "  int notconverted = FALSE;", "  char_u          *fenc;                /* effective 'fileencoding' */"], "readability/bool"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  vim_acl_T acl = NULL;                 /* ACL copied from original file to", "                                           backup or new file */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["#endif", "  int write_undo_file = FALSE;", "  context_sha256_T sha_ctx;"], "readability/bool"]
["src/nvim/fileio.c", ["  write_info.bw_conv_buf = NULL;", "  write_info.bw_conv_error = FALSE;", "  write_info.bw_conv_error_lnum = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["   * the line. */", "  ex_no_reprint = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["  if (buf->b_ffname != NULL && fnamecmp(ffname, buf->b_ffname) == 0)", "    overwriting = TRUE;", "  else"], "readability/bool"]
["src/nvim/fileio.c", ["  else", "    overwriting = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["    aco_save_T aco;", "    int buf_ffname = FALSE;", "    int buf_sfname = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_ffname = FALSE;", "    int buf_sfname = FALSE;", "    int buf_fname_f = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_sfname = FALSE;", "    int buf_fname_f = FALSE;", "    int buf_fname_s = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_fname_f = FALSE;", "    int buf_fname_s = FALSE;", "    int did_cmd = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_fname_s = FALSE;", "    int did_cmd = FALSE;", "    int nofile_err = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int did_cmd = FALSE;", "    int nofile_err = FALSE;", "    int empty_memline = (buf->b_ml.ml_mfp == NULL);"], "readability/bool"]
["src/nvim/fileio.c", ["    if (ffname == buf->b_ffname)", "      buf_ffname = TRUE;", "    if (sfname == buf->b_sfname)"], "readability/bool"]
["src/nvim/fileio.c", ["    if (sfname == buf->b_sfname)", "      buf_sfname = TRUE;", "    if (fname == buf->b_ffname)"], "readability/bool"]
["src/nvim/fileio.c", ["    if (fname == buf->b_ffname)", "      buf_fname_f = TRUE;", "    if (fname == buf->b_sfname)"], "readability/bool"]
["src/nvim/fileio.c", ["    if (fname == buf->b_sfname)", "      buf_fname_s = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,", "                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))"], "readability/bool"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;", "        else"], "readability/bool"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPRE,", "          NULL, sfname, FALSE, curbuf, eap);", "    } else if (reset_changed && whole)   {"], "readability/bool"]
["src/nvim/fileio.c", ["      did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,", "          sfname, sfname, FALSE, curbuf, eap);", "      if (did_cmd) {"], "readability/bool"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;", "        else"], "readability/bool"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_BUFWRITEPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,", "                sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf))"], "readability/bool"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf))", "          nofile_err = TRUE;", "        else"], "readability/bool"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEWRITEPRE,", "              sfname, sfname, FALSE, curbuf, eap);", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        end += buf->b_ml.ml_line_count - old_line_count;", "      else {                                                    /* less lines */", "        end -= old_line_count - buf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/fileio.c", ["          msg_scroll = msg_save;", "          EMSG(_(\"E204: Autocommand changed number of lines in unexpected way\"));", "          return FAIL;"], "whitespace/line_length"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_OVER) && !exiting)", "    msg_scroll = FALSE;             /* overwrite previous file message */", "  else"], "readability/bool"]
["src/nvim/fileio.c", ["  else", "    msg_scroll = TRUE;              /* don't overwrite previous file message */", "  if (!filtering)"], "readability/bool"]
["src/nvim/fileio.c", ["        (char_u *)\"\", 0);               /* show that we are busy */", "  msg_scroll = FALSE;               /* always overwrite the file message now */", ""], "readability/bool"]
["src/nvim/fileio.c", ["    bufsize = SMBUFSIZE;", "  } else", "    bufsize = BUFSIZE;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (!os_fileinfo((char *)fname, &file_info_old)) {", "    newfile = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["       * but for which we can't make a backup. */", "      device = TRUE;", "      newfile = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["      device = TRUE;", "      newfile = TRUE;", "      perm = -1;"], "readability/bool"]
["src/nvim/fileio.c", ["  if (c == NODE_WRITABLE) {", "    device = TRUE;", "    newfile = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["    device = TRUE;", "    newfile = TRUE;", "    perm = -1;"], "readability/bool"]
["src/nvim/fileio.c", ["    if (perm < 0)", "      newfile = TRUE;", "    else if (os_isdir(fname)) {"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/fileio.c", ["  if (dobackup && *p_bsk != NUL && match_file_list(p_bsk, sfname, ffname))", "    dobackup = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["  prev_got_int = got_int;", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["    if ((bkc & BKC_YES) || append) {       /* \"yes\" */", "      backup_copy = TRUE;", "    } else if ((bkc & BKC_AUTO)) {          /* \"auto\" */"], "readability/bool"]
["src/nvim/fileio.c", ["          || !os_fileinfo_id_equal(&file_info, &file_info_old)) {", "        backup_copy = TRUE;", "      } else"], "readability/bool"]
["src/nvim/fileio.c", ["        backup_copy = TRUE;", "      } else", "# endif"], "readability/braces"]
["src/nvim/fileio.c", ["        for (i = 4913;; i += 123) {", "          sprintf((char *)path_tail(IObuff), \"%d\", i);", "          if (!os_fileinfo_link((char *)IObuff, &file_info)) {"], "runtime/printf"]
["src/nvim/fileio.c", ["        if (fd < 0)             /* can't write in directory */", "          backup_copy = TRUE;", "        else {"], "readability/bool"]
["src/nvim/fileio.c", ["          backup_copy = TRUE;", "        else {", "# ifdef UNIX"], "readability/braces"]
["src/nvim/fileio.c", ["              || (long)file_info.stat.st_mode != perm) {", "            backup_copy = TRUE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["          && !os_fileinfo_id_equal(&file_info, &file_info_old)) {", "        backup_copy = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["              || os_fileinfo_id_equal(&file_info, &file_info_old))) {", "        backup_copy = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      char_u      *copybuf, *wp;", "      int some_error = FALSE;", "      char_u      *dirp;"], "readability/bool"]
["src/nvim/fileio.c", ["        // out of memory", "        some_error = TRUE;", "        goto nobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["        if (rootname == NULL) {", "          some_error = TRUE;                /* out of memory */", "          goto nobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["           */", "          backup = (char_u *)modname((char *)rootname, (char *)backup_ext, FALSE);", "          if (backup == NULL) {"], "whitespace/line_length"]
["src/nvim/fileio.c", ["           */", "          backup = (char_u *)modname((char *)rootname, (char *)backup_ext, FALSE);", "          if (backup == NULL) {"], "readability/bool"]
["src/nvim/fileio.c", ["            xfree(rootname);", "            some_error = TRUE;                          /* out of memory */", "            goto nobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["          backup = NULL;", "        else {", "          backup = (char_u *)modname((char *)rootname, (char *)backup_ext, FALSE);"], "readability/braces"]
["src/nvim/fileio.c", ["        else {", "          backup = (char_u *)modname((char *)rootname, (char *)backup_ext, FALSE);", "          xfree(rootname);"], "whitespace/line_length"]
["src/nvim/fileio.c", ["        else {", "          backup = (char_u *)modname((char *)rootname, (char *)backup_ext, FALSE);", "          xfree(rootname);"], "readability/bool"]
["src/nvim/fileio.c", ["      if (backup == NULL && !forceit) {", "        errmsg = (char_u *)_(\"E510: Can't make backup file (add ! to override)\");", "        goto fail;"], "whitespace/line_length"]
["src/nvim/fileio.c", ["    (void)os_setperm(fname, perm);", "    made_writable = TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["  if (forceit && overwriting && vim_strchr(p_cpo, CPO_KEEPRO) == NULL) {", "    buf->b_p_ro = FALSE;", "    need_maketitle = TRUE;          /* set window title later */"], "readability/bool"]
["src/nvim/fileio.c", ["    buf->b_p_ro = FALSE;", "    need_maketitle = TRUE;          /* set window title later */", "    status_redraw_all();            /* redraw status lines later */"], "readability/bool"]
["src/nvim/fileio.c", ["      && !(exiting && backup != NULL)) {", "    ml_preserve(buf, FALSE);", "    if (got_int) {"], "readability/bool"]
["src/nvim/fileio.c", ["    fenc_tofree = fenc;", "  } else", "    fenc = buf->b_p_fenc;"], "readability/braces"]
["src/nvim/fileio.c", ["      }", "      write_info.bw_first = TRUE;", "    } else"], "readability/bool"]
["src/nvim/fileio.c", ["      write_info.bw_first = TRUE;", "    } else", "#  endif"], "readability/braces"]
["src/nvim/fileio.c", ["    }", "    notconverted = TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["        errmsg = (char_u *)_(\"E166: Can't open linked file for writing\");", "      } else", "#endif"], "readability/braces"]
["src/nvim/fileio.c", ["          if (!(perm & 0200))", "            made_writable = TRUE;", "          perm |= 0200;"], "readability/bool"]
["src/nvim/fileio.c", ["     */", "    ptr = ml_get_buf(buf, lnum, FALSE) - 1;", "    if (write_undo_file)"], "readability/bool"]
["src/nvim/fileio.c", ["      ++lnum;                           /* written the line, count it */", "      no_eol = TRUE;", "      break;"], "readability/bool"]
["src/nvim/fileio.c", ["      *s++ = NL;", "    else {", "      *s++ = CAR;                       /* EOL_MAC or EOL_DOS: write CR */"], "readability/braces"]
["src/nvim/fileio.c", ["              wfname, fname) == FAIL) {", "        write_info.bw_conv_error = TRUE;", "        end = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["          errmsg = (char_u *)_(", "              \"E513: write error, conversion failed (make 'fenc' empty to override)\");", "        else {"], "whitespace/line_length"]
["src/nvim/fileio.c", ["              \"E513: write error, conversion failed (make 'fenc' empty to override)\");", "        else {", "          errmsg_allocated = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["        else {", "          errmsg_allocated = TRUE;", "          errmsg = xmalloc(300);"], "readability/bool"]
["src/nvim/fileio.c", ["          errmsg = xmalloc(300);", "          vim_snprintf((char *)errmsg, 300,", "              _(\"E513: write error, conversion failed in line %\" PRId64"], "runtime/printf"]
["src/nvim/fileio.c", ["        }", "      } else if (got_int)", "        errmsg = (char_u *)_(e_interr);"], "readability/braces"]
["src/nvim/fileio.c", ["    msg_add_fname(buf, fname);          /* put fname in IObuff with quotes */", "    c = FALSE;", "    if (write_info.bw_conv_error) {"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\" CONVERSION ERROR\"));", "      c = TRUE;", "      if (write_info.bw_conv_error_lnum != 0)"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[NOT converted]\"));", "      c = TRUE;", "    } else if (converted) {"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[converted]\"));", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[Device]\"));", "      c = TRUE;", "    } else if (newfile) {"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, shortmess(SHM_NEW) ? _(\"[New]\") : _(\"[New File]\"));", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["      msg_add_eol();", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    if (msg_add_fileformat(fileformat))", "      c = TRUE;", "    msg_add_lines(c, (long)lnum, nchars);       /* add line/char count */"], "readability/bool"]
["src/nvim/fileio.c", ["", "    set_keep_msg(msg_trunc_attr(IObuff, FALSE, 0), 0);", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["      ) {", "    unchanged(buf, TRUE);", "    /* buf->b_changedtick is always incremented in unchanged() but that"], "readability/bool"]
["src/nvim/fileio.c", ["  if (*p_pm && dobackup) {", "    char *org = modname((char *)fname, (char *)p_pm, FALSE);", ""], "readability/bool"]
["src/nvim/fileio.c", ["     */", "    else {", "      int empty_fd;"], "whitespace/newline"]
["src/nvim/fileio.c", ["     */", "    else {", "      int empty_fd;"], "readability/braces"]
["src/nvim/fileio.c", ["#endif", "        );                      /* put file name in IObuff with quotes */", "    if (STRLEN(IObuff) + STRLEN(errmsg) + numlen >= IOSIZE)"], "whitespace/parens"]
["src/nvim/fileio.c", ["    sha256_finish(&sha_ctx, hash);", "    u_write_undo(NULL, FALSE, buf, hash);", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "    curbuf->b_no_eol_lnum = 0;      /* in case it was set by the previous read */", ""], "whitespace/line_length"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,", "          FALSE, curbuf, eap);", "    else if (filtering)"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,", "          FALSE, curbuf, eap);", "    else if (reset_changed && whole)"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,", "          FALSE, curbuf, eap);", "    else"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,", "          FALSE, curbuf, eap);", ""], "readability/bool"]
["src/nvim/fileio.c", ["    if (aborting())         /* autocmds may abort script processing */", "      retval = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["  return retval;", "}", ""], "readability/fn_size"]
["src/nvim/fileio.c", ["  if (curbuf->b_p_bl)", "    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);", "  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);"], "readability/bool"]
["src/nvim/fileio.c", ["    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);", "  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */"], "readability/bool"]
["src/nvim/fileio.c", ["", "  if (setfname(curbuf, fname, sfname, FALSE) == OK)", "    curbuf->b_flags |= BF_NOTEDITED;"], "readability/bool"]
["src/nvim/fileio.c", ["  /* ....and a new named one is created */", "  apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, curbuf);", "  if (curbuf->b_p_bl)"], "readability/bool"]
["src/nvim/fileio.c", ["  if (curbuf->b_p_bl)", "    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);", "  if (aborting())           /* autocmds may abort script processing */"], "readability/bool"]
["src/nvim/fileio.c", ["    if (au_has_group((char_u *)\"filetypedetect\"))", "      (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", FALSE);", "    do_modelines(0);"], "readability/bool"]
["src/nvim/fileio.c", ["    fname = (char_u *)\"-stdin-\";", "  home_replace(buf, fname, IObuff + 1, IOSIZE - 4, TRUE);", "  IObuff[0] = '\"';"], "readability/bool"]
["src/nvim/fileio.c", ["    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(\"[dos]\") : _(\"[dos format]\"));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(\"[mac]\") : _(\"[mac format]\"));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(\"[unix]\") : _(\"[unix format]\"));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["#endif", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_LINES)) {", "     sprintf((char *)p, \"%\" PRId64 \"L, %\" PRId64 \"C\",", "             (int64_t)lnum, (int64_t)nchars);"], "runtime/printf"]
["src/nvim/fileio.c", ["  }", "  else {", "    if (lnum == 1)"], "whitespace/newline"]
["src/nvim/fileio.c", ["  }", "  else {", "    if (lnum == 1)"], "readability/braces"]
["src/nvim/fileio.c", ["    else", "      sprintf((char *)p, _(\"%\" PRId64 \" lines, \"), (int64_t)lnum);", "    p += STRLEN(p);"], "runtime/printf"]
["src/nvim/fileio.c", ["      STRCPY(p, _(\"1 character\"));", "    else {", "      sprintf((char *)p, _(\"%\" PRId64 \" characters\"), (int64_t)nchars);"], "readability/braces"]
["src/nvim/fileio.c", ["    else {", "      sprintf((char *)p, _(\"%\" PRId64 \" characters\"), (int64_t)nchars);", "    }"], "runtime/printf"]
["src/nvim/fileio.c", ["                      buf->b_mtime_read)) {", "    msg_scroll = TRUE;              /* don't overwrite messages here */", "    msg_silent = 0;                 /* must give this prompt */"], "readability/bool"]
["src/nvim/fileio.c", ["    if (ask_yesno((char_u *)_(\"Do you really want to write to it\"),", "            TRUE) == 'n')", "      return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["      return FAIL;", "    msg_scroll = FALSE;             /* always overwrite the file message now */", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["        if (ucs2bytes(c, &p, flags) && !ip->bw_conv_error) {", "          ip->bw_conv_error = TRUE;", "          ip->bw_conv_error_lnum = ip->bw_start_lnum;"], "readability/bool"]
["src/nvim/fileio.c", ["        len = (int)(p - buf);", "      else {", "        buf = ip->bw_conv_buf;"], "readability/braces"]
["src/nvim/fileio.c", ["        }", "        ip->bw_first = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["          || fromlen > CONV_RESTLEN) {", "        ip->bw_conv_error = TRUE;", "        return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", [" */", "static int ", "ucs2bytes ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["static int ", "ucs2bytes (", "    unsigned c,                     /* in: character */"], "whitespace/parens"]
["src/nvim/fileio.c", ["  char_u      *p = *pp;", "  int error = FALSE;", "  int cc;"], "readability/bool"]
["src/nvim/fileio.c", ["        if (c >= 0x100000)", "          error = TRUE;", "        cc = ((c >> 10) & 0x3ff) + 0xd800;"], "readability/bool"]
["src/nvim/fileio.c", ["        c = (c & 0x3ff) + 0xdc00;", "      } else", "        error = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["      } else", "        error = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    if (c >= 0x100) {", "      error = TRUE;", "      *p++ = 0xBF;"], "readability/bool"]
["src/nvim/fileio.c", ["      *p++ = 0xBF;", "    } else", "      *p++ = c;"], "readability/braces"]
["src/nvim/fileio.c", ["  if (*fenc == NUL || STRCMP(p_enc, fenc) == 0) {", "    same_encoding = TRUE;", "    fenc_flags = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["      len = 4;", "    } else if (flags == (FIO_UCS2 | FIO_ENDIAN_L))", "      name = \"ucs-2le\";         /* FF FE */"], "readability/braces"]
["src/nvim/fileio.c", ["  status_redraw_all();", "  redraw_tabline = TRUE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["    fnamelen = strlen(retval);", "    prepend_dot = FALSE;  // nothing to prepend a dot to", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["    retval = xmalloc(fnamelen + extlen + 3);", "    strcpy(retval, fname);", "  }"], "runtime/printf"]
["src/nvim/fileio.c", ["  // ext can start with '.' and cannot exceed 3 more characters.", "  strcpy(s, ext);", ""], "runtime/printf"]
["src/nvim/fileio.c", ["    for (n = 123; n < 99999; ++n) {", "      sprintf((char *)path_tail(tempname), \"%d\", n);", "      if (!os_file_exists(tempname)) {"], "runtime/printf"]
["src/nvim/fileio.c", ["", "static int already_warned = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", [" */", "int ", "check_timestamps ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["int ", "check_timestamps (", "    int focus                      /* called for GUI focus event */"], "whitespace/parens"]
["src/nvim/fileio.c", ["  if (no_check_timestamps > 0)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["  if (focus && did_check_timestamps) {", "    need_check_timestamps = TRUE;", "    return FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    need_check_timestamps = TRUE;", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["      )", "    need_check_timestamps = TRUE;               /* check later */", "  else {"], "readability/bool"]
["src/nvim/fileio.c", ["    need_check_timestamps = TRUE;               /* check later */", "  else {", "    ++no_wait_return;"], "readability/braces"]
["src/nvim/fileio.c", ["    ++no_wait_return;", "    did_check_timestamps = TRUE;", "    already_warned = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    did_check_timestamps = TRUE;", "    already_warned = FALSE;", "    for (buf = firstbuf; buf != NULL; ) {"], "readability/bool"]
["src/nvim/fileio.c", ["    --no_wait_return;", "    need_check_timestamps = FALSE;", "    if (need_wait_return && didit == 2) {"], "readability/bool"]
["src/nvim/fileio.c", ["  for (lnum = 1; lnum <= frombuf->b_ml.ml_line_count; ++lnum) {", "    p = vim_strsave(ml_get_buf(frombuf, lnum, FALSE));", "    if (ml_append(lnum - 1, p, 0, FALSE) == FAIL) {"], "readability/bool"]
["src/nvim/fileio.c", ["    p = vim_strsave(ml_get_buf(frombuf, lnum, FALSE));", "    if (ml_append(lnum - 1, p, 0, FALSE) == FAIL) {", "      xfree(p);"], "readability/bool"]
["src/nvim/fileio.c", ["    for (lnum = curbuf->b_ml.ml_line_count; lnum > 0; --lnum)", "      if (ml_delete(lnum, FALSE) == FAIL) {", "        /* Oops!  We could try putting back the saved lines, but that"], "readability/bool"]
["src/nvim/fileio.c", [" */", "int ", "buf_check_timestamp ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["int ", "buf_check_timestamp (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/fileio.c", ["  char        *mesg2 = \"\";", "  int helpmesg = FALSE;", "  int reload = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["  int helpmesg = FALSE;", "  int reload = FALSE;", "  int can_reload = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["  int reload = FALSE;", "  int can_reload = FALSE;", "  uint64_t orig_size = buf->b_orig_size;"], "readability/bool"]
["src/nvim/fileio.c", ["  int orig_mode = buf->b_orig_mode;", "  static int busy = FALSE;", "  int n;"], "readability/bool"]
["src/nvim/fileio.c", ["          || (int)file_info.stat.st_mode != buf->b_orig_mode", "          )) {", "    retval = 1;"], "whitespace/parens"]
["src/nvim/fileio.c", ["    if (os_isdir(buf->b_fname))", "      ;", ""], "whitespace/semicolon"]
["src/nvim/fileio.c", ["             && !bufIsChanged(buf) && file_info_ok)", "      reload = TRUE;", "    else {"], "readability/bool"]
["src/nvim/fileio.c", ["      reload = TRUE;", "    else {", "      if (!file_info_ok)"], "readability/braces"]
["src/nvim/fileio.c", ["       */", "      busy = TRUE;", "      set_vim_var_string(VV_FCS_REASON, (char_u *)reason, -1);"], "readability/bool"]
["src/nvim/fileio.c", ["      n = apply_autocmds(EVENT_FILECHANGEDSHELL,", "          buf->b_fname, buf->b_fname, FALSE, buf);", "      --allbuf_lock;"], "readability/bool"]
["src/nvim/fileio.c", ["      --allbuf_lock;", "      busy = FALSE;", "      if (n) {"], "readability/bool"]
["src/nvim/fileio.c", ["        if (STRCMP(s, \"reload\") == 0 && *reason != 'd')", "          reload = TRUE;", "        else if (STRCMP(s, \"ask\") == 0)"], "readability/bool"]
["src/nvim/fileio.c", ["        else if (STRCMP(s, \"ask\") == 0)", "          n = FALSE;", "        else"], "readability/bool"]
["src/nvim/fileio.c", ["          mesg = _(\"E211: File \\\"%s\\\" no longer available\");", "        else {", "          helpmesg = TRUE;"], "readability/braces"]
["src/nvim/fileio.c", ["        else {", "          helpmesg = TRUE;", "          can_reload = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["          helpmesg = TRUE;", "          can_reload = TRUE;", "          /*"], "readability/bool"]
["src/nvim/fileio.c", ["            mesg = _(", "                \"W12: Warning: File \\\"%s\\\" has changed and the buffer was changed in Vim as well\");", "            mesg2 = _(\"See \\\":help W12\\\" for more info.\");"], "whitespace/line_length"]
["src/nvim/fileio.c", ["            mesg = _(", "                \"W16: Warning: Mode of file \\\"%s\\\" has changed since editing started\");", "            mesg2 = _(\"See \\\":help W16\\\" for more info.\");"], "whitespace/line_length"]
["src/nvim/fileio.c", ["            mesg2 = _(\"See \\\":help W16\\\" for more info.\");", "          } else", "            /* Only timestamp changed, store it to avoid a warning"], "readability/braces"]
["src/nvim/fileio.c", ["    retval = 1;", "    mesg = _(\"W13: Warning: File \\\"%s\\\" has been created after editing started\");", "    buf->b_flags |= BF_NEW_W;"], "whitespace/line_length"]
["src/nvim/fileio.c", ["    buf->b_flags |= BF_NEW_W;", "    can_reload = TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["    tbuf = xmalloc(STRLEN(path) + STRLEN(mesg) + STRLEN(mesg2) + 2);", "    sprintf((char *)tbuf, mesg, path);", "    /* Set warningmsg here, before the unimportant and output-specific"], "runtime/printf"]
["src/nvim/fileio.c", ["      if (do_dialog(VIM_WARNING, (char_u *)_(\"Warning\"), tbuf,", "                    (char_u *)_(\"&OK\\n&Load File\"), 1, NULL, TRUE) == 2)", "        reload = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["                    (char_u *)_(\"&OK\\n&Load File\"), 1, NULL, TRUE) == 2)", "        reload = TRUE;", "    } else if (State > NORMAL_BUSY || (State & CMDLINE) || already_warned) {"], "readability/bool"]
["src/nvim/fileio.c", ["          /* don't redraw and erase the message */", "          redraw_cmdline = FALSE;", "        }"], "readability/bool"]
["src/nvim/fileio.c", ["      }", "      already_warned = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["      u_compute_hash(hash);", "      u_write_undo(NULL, FALSE, buf, hash);", "      curbuf = save_curbuf;"], "readability/bool"]
["src/nvim/fileio.c", ["    (void)apply_autocmds(EVENT_FILECHANGEDSHELLPOST,", "        buf->b_fname, buf->b_fname, FALSE, buf);", ""], "readability/bool"]
["src/nvim/fileio.c", ["     * Sync first so that this is a separate undo-able action. */", "    u_sync(FALSE);", "    saved = u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE);"], "readability/bool"]
["src/nvim/fileio.c", ["    u_sync(FALSE);", "    saved = u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE);", "    flags |= READ_KEEP_UNDO;"], "readability/bool"]
["src/nvim/fileio.c", ["    savebuf = NULL;", "  else {", "    /* Allocate a buffer without putting it in the buffer list. */"], "readability/braces"]
["src/nvim/fileio.c", ["    curbuf->b_flags |= BF_CHECK_RO;           /* check for RO again */", "    keep_filetype = TRUE;                     /* don't detect 'filetype' */", "    if (readfile(buf->b_ffname, buf->b_fname, (linenr_T)0,"], "readability/bool"]
["src/nvim/fileio.c", ["        while (!bufempty())", "          if (ml_delete(buf->b_ml.ml_line_count, FALSE) == FAIL)", "            break;"], "readability/bool"]
["src/nvim/fileio.c", ["      /* Mark the buffer as unmodified and free undo info. */", "      unchanged(buf, TRUE);", "      if ((flags & READ_KEEP_UNDO) == 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["  if (savebuf != NULL && buf_valid(savebuf))", "    wipe_buffer(savebuf, FALSE);", ""], "readability/bool"]
["src/nvim/fileio.c", ["  update_topline();", "  keep_filetype = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "static int au_need_clean = FALSE;   /* need to delete marked patterns */", ""], "readability/bool"]
["src/nvim/fileio.c", ["  ap->buflocal_nr = -1;", "  au_need_clean = TRUE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["  }", "  au_need_clean = TRUE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["          xfree(ac);", "        } else", "          prev_ac = &(ac->next);"], "readability/braces"]
["src/nvim/fileio.c", ["        xfree(ap);", "      } else", "        prev_ap = &(ap->next);"], "readability/braces"]
["src/nvim/fileio.c", ["", "  au_need_clean = FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["    EMSG2(_(\"E367: No such group: \\\"%s\\\"\"), name);", "  else {", "    xfree(AUGROUP_NAME(i));"], "readability/braces"]
["src/nvim/fileio.c", ["      au_del_group(arg);", "  } else if (STRICMP(arg, \"end\") == 0)   /* \":aug end\": back to group 0 */", "    current_augroup = AUGROUP_DEFAULT;"], "readability/braces"]
["src/nvim/fileio.c", ["       ++current_augroup)", "    do_autocmd((char_u *)\"\", TRUE);", "  ga_clear_strings(&augroups);"], "readability/bool"]
["src/nvim/fileio.c", ["  for (p = start; *p && !ascii_iswhite(*p) && *p != ','; ++p)", "    ;", "  for (i = 0; event_names[i].name != NULL; ++i) {"], "whitespace/semicolon"]
["src/nvim/fileio.c", ["static char_u *", "find_end_event (", "    char_u *arg,"], "whitespace/parens"]
["src/nvim/fileio.c", ["    if (STRNICMP(p, \"all\", 3) == 0 && (p[3] == NUL || p[3] == ','))", "      return TRUE;", "    if (event_name2nr(p, &p) == event)"], "readability/bool"]
["src/nvim/fileio.c", ["    if (event_name2nr(p, &p) == event)", "      return TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["        ++p;", "    } else if (event_name2nr(p, &p) == NUM_EVENTS)", "      return FAIL;"], "readability/braces"]
["src/nvim/fileio.c", ["  event_T event;", "  int need_free = FALSE;", "  int nested = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["  int need_free = FALSE;", "  int nested = FALSE;", "  int group;"], "readability/bool"]
["src/nvim/fileio.c", ["", "    p_ssl = TRUE;", "#endif"], "readability/bool"]
["src/nvim/fileio.c", ["  if (*cmd != NUL && STRNCMP(cmd, \"nested\", 6) == 0 && ascii_iswhite(cmd[6])) {", "    nested = TRUE;", "    cmd = skipwhite(cmd + 6);"], "readability/bool"]
["src/nvim/fileio.c", ["      return;", "    need_free = TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", [" */", "static int do_autocmd_event(event_T event, char_u *pat, int nested, char_u *cmd, int forceit, int group)", "{"], "whitespace/line_length"]
["src/nvim/fileio.c", ["          au_remove_pat(ap);", "      } else if (group == AUGROUP_ALL || ap->group == group)", "        show_autocmd(ap, event);"], "readability/braces"]
["src/nvim/fileio.c", ["     */", "    is_buflocal = FALSE;", "    buflocal_nr = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["       * printing and removing will proceed silently. */", "      is_buflocal = TRUE;", "      if (patlen == 8)"], "readability/bool"]
["src/nvim/fileio.c", ["      /* normalize pat into standard \"<buffer>#N\" form */", "      sprintf((char *)buflocal_pat, \"<buffer=%d>\", buflocal_nr);", "      pat = buflocal_pat;                       /* can modify pat and patlen */"], "runtime/printf"]
["src/nvim/fileio.c", ["           */", "          else if (*cmd == NUL)", "            show_autocmd(ap, event);"], "whitespace/newline"]
["src/nvim/fileio.c", ["          reg_pat = file_pat_to_reg_pat(pat, endpat,", "              &ap->allow_dirs, TRUE);", "          if (reg_pat != NULL)"], "readability/bool"]
["src/nvim/fileio.c", [" */", "int ", "do_doautocmd ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["int ", "do_doautocmd (", "    char_u *arg,"], "whitespace/parens"]
["src/nvim/fileio.c", ["  char_u      *fname;", "  int nothing_done = TRUE;", "  int group;"], "readability/bool"]
["src/nvim/fileio.c", ["    if (apply_autocmds_group(event_name2nr(arg, &arg),", "            fname, NULL, TRUE, group, curbuf, NULL))", "      nothing_done = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["            fname, NULL, TRUE, group, curbuf, NULL))", "      nothing_done = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["    /* execute the autocommands for this buffer */", "    retval = do_doautocmd(arg, FALSE);", ""], "readability/bool"]
["src/nvim/fileio.c", ["    *argp = skipwhite(*argp + 12);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/fileio.c", [" */", "void ", "aucmd_prepbuf ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["void ", "aucmd_prepbuf (", "    aco_save_T *aco,               /* structure to save values in */"], "whitespace/parens"]
["src/nvim/fileio.c", ["     * \"buf\" is curbuf). */", "    aco->use_aucmd_win = FALSE;", "    curwin = win;"], "readability/bool"]
["src/nvim/fileio.c", ["     * unexpected results. */", "    aco->use_aucmd_win = TRUE;", "    aucmd_win_used = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["    aco->use_aucmd_win = TRUE;", "    aucmd_win_used = TRUE;", "    aucmd_win->w_buffer = buf;"], "readability/bool"]
["src/nvim/fileio.c", [" */", "void ", "aucmd_restbuf ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["void ", "aucmd_restbuf (", "    aco_save_T *aco               /* structure holding saved values */"], "whitespace/parens"]
["src/nvim/fileio.c", ["          if (tp != curtab) {", "            goto_tabpage_tp(tp, TRUE, TRUE);", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["    win_remove(curwin, NULL);", "    aucmd_win_used = FALSE;", "    last_status(FALSE);             /* may need to remove last status line */"], "readability/bool"]
["src/nvim/fileio.c", ["    aucmd_win_used = FALSE;", "    last_status(FALSE);             /* may need to remove last status line */", "    restore_snapshot(SNAP_AUCMD_IDX, FALSE);"], "readability/bool"]
["src/nvim/fileio.c", ["    last_status(FALSE);             /* may need to remove last status line */", "    restore_snapshot(SNAP_AUCMD_IDX, FALSE);", "    (void)win_comp_pos();       /* recompute window positions */"], "readability/bool"]
["src/nvim/fileio.c", ["", "static int autocmd_nested = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", [" */", "int ", "apply_autocmds ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["int ", "apply_autocmds (", "    event_T event,"], "whitespace/parens"]
["src/nvim/fileio.c", [" */", "static int apply_autocmds_exarg(event_T event, char_u *fname, char_u *fname_io, int force, buf_T *buf, exarg_T *eap)", "{"], "whitespace/line_length"]
["src/nvim/fileio.c", [" */", "int ", "apply_autocmds_retval ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["int ", "apply_autocmds_retval (", "    event_T event,"], "whitespace/parens"]
["src/nvim/fileio.c", ["  if (should_abort(*retval))", "    return FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["    if (state == NORMAL_BUSY || (state & INSERT) != 0)", "      return TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["", "static int ", "apply_autocmds_group ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["static int ", "apply_autocmds_group (", "    event_T event,"], "whitespace/parens"]
["src/nvim/fileio.c", ["    char_u *fname,         /* NULL or empty means use actual file name */", "    char_u *fname_io,      /* fname to use for <afile> on cmdline, NULL means", "                               use fname */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["  buf_T       *old_curbuf;", "  int retval = FALSE;", "  char_u      *save_sourcing_name;"], "readability/bool"]
["src/nvim/fileio.c", ["  long save_cmdbang;", "  static int filechangeshell_busy = FALSE;", "  proftime_T wait_time;"], "readability/bool"]
["src/nvim/fileio.c", ["      autocmd_fname = NULL;", "  } else", "    autocmd_fname = fname_io;"], "readability/braces"]
["src/nvim/fileio.c", ["    autocmd_fname = vim_strsave(autocmd_fname);", "  autocmd_fname_full = FALSE;   /* call FullName_save() later */", ""], "readability/bool"]
["src/nvim/fileio.c", ["      fname = NULL;", "    else {", "      if (event == EVENT_SYNTAX)"], "readability/braces"]
["src/nvim/fileio.c", ["        fname = buf->b_p_ft;", "      else {", "        if (buf->b_sfname != NULL)"], "readability/braces"]
["src/nvim/fileio.c", ["    else", "      fname = (char_u *)FullName_save((char *)fname, FALSE);", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["    xfree(sfname);", "    retval = FALSE;", "    goto BYPASS_AU;"], "readability/bool"]
["src/nvim/fileio.c", ["   */", "  autocmd_busy = TRUE;", "  filechangeshell_busy = (event == EVENT_FILECHANGEDSHELL);"], "readability/bool"]
["src/nvim/fileio.c", ["  if (event == EVENT_FILETYPE)", "    did_filetype = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["  patcmd.next = NULL;", "  auto_next_pat(&patcmd, FALSE);", ""], "readability/bool"]
["src/nvim/fileio.c", ["      set_vim_var_nr(VV_CMDBANG, (long)eap->forceit);", "    } else", "      save_cmdarg = NULL;       /* avoid gcc warning */"], "readability/braces"]
["src/nvim/fileio.c", ["      save_cmdarg = NULL;       /* avoid gcc warning */", "    retval = TRUE;", "    /* mark the last pattern, to avoid an endless loop when more patterns"], "readability/bool"]
["src/nvim/fileio.c", ["    for (ap = patcmd.curpat; ap->next != NULL; ap = ap->next)", "      ap->last = FALSE;", "    ap->last = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["      ap->last = FALSE;", "    ap->last = TRUE;", "    check_lnums(TRUE);          /* make sure cursor and topline are valid */"], "readability/bool"]
["src/nvim/fileio.c", ["    ap->last = TRUE;", "    check_lnums(TRUE);          /* make sure cursor and topline are valid */", "    do_cmdline(NULL, getnextac, (void *)&patcmd,"], "readability/bool"]
["src/nvim/fileio.c", ["  autocmd_busy = save_autocmd_busy;", "  filechangeshell_busy = FALSE;", "  autocmd_nested = save_autocmd_nested;"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    did_filetype = FALSE;", "    while (au_pending_free_buf != NULL) {"], "readability/bool"]
["src/nvim/fileio.c", ["    if (curbuf->b_changed != save_changed)", "      need_maketitle = TRUE;", "    curbuf->b_changed = save_changed;"], "readability/bool"]
["src/nvim/fileio.c", ["      && get_vim_var_str(VV_TERMRESPONSE) != old_termresponse)", "    apply_autocmds(EVENT_TERMRESPONSE, NULL, NULL, FALSE, curbuf);", "}"], "readability/bool"]
["src/nvim/fileio.c", [" */", "static void ", "auto_next_pat ("], "whitespace/end_of_line"]
["src/nvim/fileio.c", ["static void ", "auto_next_pat (", "    AutoPatCmd *apc,"], "whitespace/parens"]
["src/nvim/fileio.c", ["        sourcing_name = xmalloc(STRLEN(s) + STRLEN(name) + ap->patlen + 1);", "        sprintf((char *)sourcing_name, s,", "            (char *)name, (char *)ap->pat);"], "runtime/printf"]
["src/nvim/fileio.c", ["        for (cp = ap->cmds; cp->next != NULL; cp = cp->next)", "          cp->last = FALSE;", "        cp->last = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["          cp->last = FALSE;", "        cp->last = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["    if (acp->curpat != NULL)", "      auto_next_pat(acp, TRUE);", "    if (acp->curpat == NULL)"], "readability/bool"]
["src/nvim/fileio.c", ["  char_u      *tail = path_tail(sfname);", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  fname = (char_u *)FullName_save((char *)sfname, FALSE);", "  if (fname == NULL)"], "readability/bool"]
["src/nvim/fileio.c", ["  if (fname == NULL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["            : buf != NULL && ap->buflocal_nr == buf->b_fnum", "            )) {", "      retval = TRUE;"], "whitespace/parens"]
["src/nvim/fileio.c", ["            )) {", "      retval = TRUE;", "      break;"], "readability/bool"]
["src/nvim/fileio.c", ["", "static int include_groups = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["char_u *", "set_context_in_autocmd (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/fileio.c", ["  /* check for a group name, skip it if present */", "  include_groups = FALSE;", "  p = arg;"], "readability/bool"]
["src/nvim/fileio.c", ["    if (group == AUGROUP_ALL)", "      include_groups = TRUE;", "    xp->xp_context = EXPAND_EVENTS;         /* expand event name */"], "readability/bool"]
["src/nvim/fileio.c", ["  int group;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["      /* \"Group\": group name is present and it's recognized */", "      retval = TRUE;", "      goto theend;"], "readability/bool"]
["src/nvim/fileio.c", ["                : ap->buflocal_nr == buflocal_buf->b_fnum))) {", "      retval = TRUE;", "      break;"], "readability/bool"]
["src/nvim/fileio.c", ["    copy_option_part(&p, buf, 100, \",\");", "    regpat = file_pat_to_reg_pat(buf, NULL, &allow_dirs, FALSE);", "    if (regpat == NULL)"], "readability/bool"]
["src/nvim/fileio.c", ["    if (match)", "      return TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["char_u *", "file_pat_to_reg_pat (", "    char_u *pat,"], "whitespace/parens"]
["src/nvim/fileio.c", ["  int nested = 0;", "  int add_dollar = TRUE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["  if (allow_dirs != NULL)", "    *allow_dirs = FALSE;", "  if (pat_end == NULL)"], "readability/bool"]
["src/nvim/fileio.c", ["      endp--;", "    add_dollar = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["          if (allow_dirs != NULL)", "            *allow_dirs = TRUE;", "          break;"], "readability/bool"]
["src/nvim/fileio.c", ["            )", "          *allow_dirs = TRUE;", "        reg_pat[i++] = '\\\\';"], "readability/bool"]
["src/nvim/fileio.c", ["      if (allow_dirs != NULL)", "        *allow_dirs = TRUE;", "      break;"], "readability/bool"]
["src/nvim/fileio.c", ["        reg_pat[i++] = '|';", "      } else", "        reg_pat[i++] = ',';"], "readability/braces"]
["src/nvim/fileio.c", ["      else if (allow_dirs != NULL && vim_ispathsep(*p))", "        *allow_dirs = TRUE;", "      reg_pat[i++] = *p;"], "readability/bool"]
["src/nvim/fileio.c", ["        break;", "    } else", "      ret += wlen;"], "readability/braces"]
["src/nvim/file_search.c", ["  int ffs_filearray_size;", "  char_u ffs_filearray_cur;                  /* needed for partly handled dirs */", ""], "whitespace/line_length"]
["src/nvim/file_search.c", ["  ff_visited_T                *ffvl_visited_list;", "", "} ff_visited_list_hdr_T;"], "whitespace/blank_line"]
["src/nvim/file_search.c", ["void *", "vim_findfile_init (", "    char_u *path,"], "whitespace/parens"]
["src/nvim/file_search.c", ["    search_ctx = search_ctx_arg;", "  else {", "    search_ctx = xcalloc(1, sizeof(ff_search_ctx_T));"], "readability/braces"]
["src/nvim/file_search.c", ["  /* clear visited list if wanted */", "  if (free_visited == TRUE)", "    vim_findfile_free_visited(search_ctx);"], "readability/bool"]
["src/nvim/file_search.c", ["    vim_findfile_free_visited(search_ctx);", "  else {", "    /* Reuse old visited lists. Get the visited list for the given"], "readability/braces"]
["src/nvim/file_search.c", ["      STRLCPY(ff_expand_buffer, rel_fname, len + 1);", "      search_ctx->ffsc_start_dir = (char_u *)FullName_save((char *)ff_expand_buffer, FALSE);", "    } else"], "whitespace/line_length"]
["src/nvim/file_search.c", ["      STRLCPY(ff_expand_buffer, rel_fname, len + 1);", "      search_ctx->ffsc_start_dir = (char_u *)FullName_save((char *)ff_expand_buffer, FALSE);", "    } else"], "readability/bool"]
["src/nvim/file_search.c", ["      search_ctx->ffsc_start_dir = (char_u *)FullName_save((char *)ff_expand_buffer, FALSE);", "    } else", "      search_ctx->ffsc_start_dir = vim_strnsave(rel_fname, len);"], "readability/braces"]
["src/nvim/file_search.c", ["      drive[2] = NUL;", "      if (vim_FullName(drive, ff_expand_buffer, MAXPATHL, TRUE) == FAIL)", "        goto error_return;"], "readability/bool"]
["src/nvim/file_search.c", ["      path += 2;", "    } else", "#endif"], "readability/braces"]
["src/nvim/file_search.c", ["        walker++;", "      } else", "        /* this might be \"\", which means ascent till top"], "readability/braces"]
["src/nvim/file_search.c", ["      dircount++;", "", "    } while (walker != NULL);"], "whitespace/blank_line"]
["src/nvim/file_search.c", ["          EMSG2(_(", "                  \"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"),", "              PATHSEPSTR);"], "whitespace/line_length"]
["src/nvim/file_search.c", ["        }", "      } else", "        ff_expand_buffer[len++] = *wc_part++;"], "readability/braces"]
["src/nvim/file_search.c", ["    search_ctx->ffsc_wc_path = vim_strsave(ff_expand_buffer);", "  } else", "    search_ctx->ffsc_fix_path = vim_strsave(path);"], "readability/braces"]
["src/nvim/file_search.c", ["        add_pathsep((char *)ff_expand_buffer);", "      } else", "        len = (int)STRLEN(search_ctx->ffsc_fix_path);"], "readability/braces"]
["src/nvim/file_search.c", ["    r_ptr++;", "  } else if (*r_ptr == NUL)", "    r_ptr = NULL;"], "readability/braces"]
["src/nvim/file_search.c", ["              , stackp->ffs_wc_path", "              ) == FAIL) {", "#ifdef FF_VERBOSE"], "whitespace/parens"]
["src/nvim/file_search.c", ["              STRMOVE(rest_of_wildcards, rest_of_wildcards + 3);", "            } else", "              rest_of_wildcards += 3;"], "readability/braces"]
["src/nvim/file_search.c", ["          stackp->ffs_filearray_size = 1;", "        } else", "          /* Add EW_NOTWILD because the expanded path may contain"], "readability/braces"]
["src/nvim/file_search.c", ["        stackp->ffs_stage = 0;", "      } else", "        rest_of_wildcards = &stackp->ffs_wc_path["], "readability/braces"]
["src/nvim/file_search.c", ["                          , (char_u *)\"\"", "                          ) == OK)", "#endif"], "whitespace/parens"]
["src/nvim/file_search.c", ["                        , (char_u *)\"\"", "                        ) == FAIL) {", "                  if (p_verbose >= 5) {"], "whitespace/parens"]
["src/nvim/file_search.c", ["      ff_free_stack_element(stackp);", "", "    }"], "whitespace/blank_line"]
["src/nvim/file_search.c", ["              (int)(path_end - search_ctx->ffsc_start_dir),", "              search_ctx->ffsc_stopdirs_v) == TRUE)", "        break;"], "readability/bool"]
["src/nvim/file_search.c", ["      ff_push(search_ctx, sptr);", "    } else", "      break;"], "readability/braces"]
["src/nvim/file_search.c", [" */", "static ff_visited_list_hdr_T *ff_get_visited_list(char_u *filename, ff_visited_list_hdr_T **list_headp)", "{"], "whitespace/line_length"]
["src/nvim/file_search.c", ["  if (s1 == s2)", "    return TRUE;", ""], "readability/bool"]
["src/nvim/file_search.c", ["  if (s1 == NULL || s2 == NULL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/file_search.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/file_search.c", [" */", "static int ff_check_visited(ff_visited_T **visited_list, char_u *fname, char_u *wc_path)", "{"], "whitespace/line_length"]
["src/nvim/file_search.c", ["      /* are the wildcard parts equal */", "      if (ff_wc_equal(vp->ffv_wc_path, wc_path) == TRUE)", "        /* already visited */"], "readability/bool"]
["src/nvim/file_search.c", [" */", "static ff_stack_T *ff_create_stack_element(char_u *fix_part, char_u *wc_part, int level, int star_star_empty)", "{"], "whitespace/line_length"]
["src/nvim/file_search.c", ["  new->ffs_level         = level;", "  new->ffs_star_star_empty = star_star_empty;;", ""], "whitespace/newline"]
["src/nvim/file_search.c", ["  if (path_len == 0)", "    return TRUE;", ""], "readability/bool"]
["src/nvim/file_search.c", ["          && vim_ispathsep(stopdirs_v[i][path_len]))", "        return TRUE;", "    } else {"], "readability/bool"]
["src/nvim/file_search.c", ["      if (fnamecmp(stopdirs_v[i], path) == 0)", "        return TRUE;", "    }"], "readability/bool"]
["src/nvim/file_search.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/file_search.c", ["char_u *", "find_file_in_path (", "    char_u *ptr,               /* file name */"], "whitespace/parens"]
["src/nvim/file_search.c", ["char_u *", "find_directory_in_path (", "    char_u *ptr,               /* file name */"], "whitespace/parens"]
["src/nvim/file_search.c", ["{", "  return find_file_in_path_option(ptr, len, options, TRUE, p_cdpath,", "                                  FINDFILE_DIR, rel_fname, (char_u *)\"\");"], "readability/bool"]
["src/nvim/file_search.c", ["char_u *", "find_file_in_path_option (", "    char_u *ptr,               /* file name */"], "whitespace/parens"]
["src/nvim/file_search.c", ["  static char_u       *dir;", "  static int did_findfile_init = FALSE;", "  char_u save_char;"], "readability/bool"]
["src/nvim/file_search.c", ["", "  if (first == TRUE) {", "    /* copy file name into NameBuff, expanding environment variables */"], "readability/bool"]
["src/nvim/file_search.c", ["     */", "    if (first == TRUE) {", "      if (path_with_url((char *)ff_file_to_find)) {"], "readability/bool"]
["src/nvim/file_search.c", ["     */", "    if (first == TRUE) {", "      /* vim_findfile_free_visited can handle a possible NULL pointer */"], "readability/bool"]
["src/nvim/file_search.c", ["      dir = path_option;", "      did_findfile_init = FALSE;", "    }"], "readability/bool"]
["src/nvim/file_search.c", ["", "        did_findfile_init = FALSE;", "      } else {"], "readability/bool"]
["src/nvim/file_search.c", ["        fdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,", "            r_ptr, 100, FALSE, find_what,", "            fdip_search_ctx, FALSE, rel_fname);"], "readability/bool"]
["src/nvim/file_search.c", ["            r_ptr, 100, FALSE, find_what,", "            fdip_search_ctx, FALSE, rel_fname);", "        if (fdip_search_ctx != NULL)"], "readability/bool"]
["src/nvim/file_search.c", ["        if (fdip_search_ctx != NULL)", "          did_findfile_init = TRUE;", "        xfree(buf);"], "readability/bool"]
["src/nvim/file_search.c", ["  if (file_name == NULL && (options & FNAME_MESS)) {", "    if (first == TRUE) {", "      if (find_what == FINDFILE_DIR)"], "readability/bool"]
["src/nvim/fold.c", ["typedef struct {", "  linenr_T fd_top;              /* first line of fold; for nested fold", "                                 * relative to parent */"], "readability/multiline_comment"]
["src/nvim/fold.c", ["  char fd_flags;                /* see below */", "  char fd_small;                /* TRUE, FALSE or MAYBE: fold smaller than", "                                   'foldminlines'; MAYBE applies to nested"], "readability/multiline_comment"]
["src/nvim/fold.c", ["  char fd_flags;                /* see below */", "  char fd_small;                /* TRUE, FALSE or MAYBE: fold smaller than", "                                   'foldminlines'; MAYBE applies to nested"], "readability/bool"]
["src/nvim/fold.c", ["  int lvl_next;                 /* level used for next line */", "  int start;                    /* number of folds that are forced to start at", "                                   this line. */"], "readability/multiline_comment"]
["src/nvim/fold.c", ["                                   this line. */", "  int end;                      /* level of fold that is forced to end below", "                                   this line */"], "readability/multiline_comment"]
["src/nvim/fold.c", ["                                   this line */", "  int had_end;                  /* level of fold that is forced to end above", "                                   this line (copy of \"end\" of prev. line) */"], "readability/multiline_comment"]
["src/nvim/fold.c", ["  int had_end;                  /* level of fold that is forced to end above", "                                   this line (copy of \"end\" of prev. line) */", "} fline_T;"], "whitespace/parens"]
["src/nvim/fold.c", ["{", "  return hasFoldingWin(curwin, lnum, firstp, lastp, TRUE, NULL);", "}"], "readability/bool"]
["src/nvim/fold.c", ["{", "  int had_folded = FALSE;", "  linenr_T first = 0;"], "readability/bool"]
["src/nvim/fold.c", ["  int level = 0;", "  int use_level = FALSE;", "  int maybe_small = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int use_level = FALSE;", "  int maybe_small = FALSE;", "  garray_T    *gap;"], "readability/bool"]
["src/nvim/fold.c", ["  garray_T    *gap;", "  int low_level = 0;;", ""], "whitespace/newline"]
["src/nvim/fold.c", ["", "/* lineFolded()\t{{{2 */", "/*"], "whitespace/tab"]
["src/nvim/fold.c", ["", "  if (hasFoldingWin(win, lnum, NULL, &last, FALSE, infop))", "    return (long)(last - lnum + 1);"], "readability/bool"]
["src/nvim/fold.c", ["{", "  setFoldRepeat(lnum, count, FALSE);", "}"], "readability/bool"]
["src/nvim/fold.c", ["{", "  (void)setManualFold(lnum, FALSE, TRUE, NULL);", "}"], "readability/bool"]
["src/nvim/fold.c", [" */", "void ", "opFoldRange ("], "whitespace/end_of_line"]
["src/nvim/fold.c", ["void ", "opFoldRange (", "    linenr_T first,"], "whitespace/parens"]
["src/nvim/fold.c", ["{", "  setFoldRepeat(lnum, count, TRUE);", "}"], "readability/bool"]
["src/nvim/fold.c", ["{", "  (void)setManualFold(lnum, TRUE, TRUE, NULL);", "}"], "readability/bool"]
["src/nvim/fold.c", ["      done = DONE_NOTHING;", "      (void)setManualFold(curwin->w_cursor.lnum, TRUE, FALSE, &done);", "      if (!(done & DONE_ACTION))"], "readability/bool"]
["src/nvim/fold.c", ["  fold_T      *fp;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["        fp[i].fd_flags = FD_LEVEL;", "        retval = TRUE;", "      } else"], "readability/bool"]
["src/nvim/fold.c", ["        retval = TRUE;", "      } else", "        retval |= checkCloseRec(&fp[i].fd_nested, lnum - fp[i].fd_top,"], "readability/braces"]
["src/nvim/fold.c", ["  if (foldmethodIsManual(curwin) || foldmethodIsMarker(curwin))", "    return TRUE;", "  if (create)"], "readability/bool"]
["src/nvim/fold.c", ["    EMSG(_(\"E351: Cannot delete fold with current 'foldmethod'\"));", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/fold.c", ["  int cont;", "  int use_level = FALSE;", "  int closed = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int use_level = FALSE;", "  int closed = FALSE;", "  int level = 0;"], "readability/bool"]
["src/nvim/fold.c", ["      if (use_level || fp->fd_flags == FD_LEVEL) {", "        use_level = TRUE;", "        if (level >= curwin->w_p_fdl)"], "readability/bool"]
["src/nvim/fold.c", ["        if (level >= curwin->w_p_fdl)", "          closed = TRUE;", "      } else if (fp->fd_flags == FD_CLOSED)"], "readability/bool"]
["src/nvim/fold.c", ["          closed = TRUE;", "      } else if (fp->fd_flags == FD_CLOSED)", "        closed = TRUE;"], "readability/braces"]
["src/nvim/fold.c", ["      } else if (fp->fd_flags == FD_CLOSED)", "        closed = TRUE;", "      ++level;"], "readability/bool"]
["src/nvim/fold.c", [" */", "void ", "deleteFold ("], "whitespace/end_of_line"]
["src/nvim/fold.c", ["void ", "deleteFold (", "    linenr_T start,"], "whitespace/parens"]
["src/nvim/fold.c", ["  int use_level;", "  int maybe_small = FALSE;", "  int level = 0;"], "readability/bool"]
["src/nvim/fold.c", ["  linenr_T lnum_off;", "  int did_one = FALSE;", "  linenr_T first_lnum = MAXLNUM;"], "readability/bool"]
["src/nvim/fold.c", ["    lnum_off = 0;", "    use_level = FALSE;", "    for (;; ) {"], "readability/bool"]
["src/nvim/fold.c", ["            (int)(found_fp - (fold_T *)found_ga->ga_data), recursive);", "      else {", "        if (first_lnum > found_fp->fd_top + found_off)"], "readability/braces"]
["src/nvim/fold.c", ["      }", "      did_one = TRUE;", ""], "readability/bool"]
["src/nvim/fold.c", ["      redraw_curbuf_later(INVERTED);", "  } else", "    /* Deleting markers may make cursor column invalid. */"], "readability/braces"]
["src/nvim/fold.c", ["    /* reset got_int here, otherwise it won't work */", "    got_int = FALSE;", "    foldUpdateIEMS(wp, top, bot);"], "readability/bool"]
["src/nvim/fold.c", [" */", "int ", "foldMoveTo ("], "whitespace/end_of_line"]
["src/nvim/fold.c", ["int ", "foldMoveTo (", "    int updown,"], "whitespace/parens"]
["src/nvim/fold.c", ["    gap = &curwin->w_folds;", "    use_level = FALSE;", "    maybe_small = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["    use_level = FALSE;", "    maybe_small = FALSE;", "    lnum_found = curwin->w_cursor.lnum;"], "readability/bool"]
["src/nvim/fold.c", ["    level = 0;", "    last = FALSE;", "    for (;; ) {"], "readability/bool"]
["src/nvim/fold.c", ["         * the cursor too far. */", "        last = TRUE;", "      }"], "readability/bool"]
["src/nvim/fold.c", ["                &maybe_small, lnum_off))", "          last = TRUE;", ""], "readability/bool"]
["src/nvim/fold.c", ["      retval = OK;", "    } else", "      break;"], "readability/braces"]
["src/nvim/fold.c", ["      low = i + 1;", "    else {", "      /* lnum is inside this fold */"], "readability/braces"]
["src/nvim/fold.c", ["      *fpp = fp + i;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/fold.c", ["  *fpp = fp + low;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/fold.c", ["    done = DONE_NOTHING;", "    (void)setManualFold(lnum, do_open, FALSE, &done);", "    if (!(done & DONE_ACTION)) {"], "readability/bool"]
["src/nvim/fold.c", [" */", "static linenr_T ", "setManualFold ("], "whitespace/end_of_line"]
["src/nvim/fold.c", ["static linenr_T ", "setManualFold (", "    linenr_T lnum,"], "whitespace/parens"]
["src/nvim/fold.c", [" */", "static linenr_T ", "setManualFoldWin ("], "whitespace/end_of_line"]
["src/nvim/fold.c", ["static linenr_T ", "setManualFoldWin (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/fold.c", ["  int level = 0;", "  int use_level = FALSE;", "  int found_fold = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int use_level = FALSE;", "  int found_fold = FALSE;", "  garray_T    *gap;"], "readability/bool"]
["src/nvim/fold.c", ["    /* lnum is inside this fold */", "    found_fold = TRUE;", ""], "readability/bool"]
["src/nvim/fold.c", ["    if (use_level || fp->fd_flags == FD_LEVEL) {", "      use_level = TRUE;", "      if (level >= wp->w_p_fdl)"], "readability/bool"]
["src/nvim/fold.c", ["    done |= DONE_FOLD;", "  } else if (donep == NULL && wp == curwin)", "    EMSG(_(e_nofold));"], "readability/braces"]
["src/nvim/fold.c", [" */", "void foldMarkAdjust(win_T *wp, linenr_T line1, linenr_T line2, long amount, long amount_after)", "{"], "whitespace/line_length"]
["src/nvim/fold.c", ["/* foldMarkAdjustRecurse() {{{2 */", "static void foldMarkAdjustRecurse(garray_T *gap, linenr_T line1, linenr_T line2, long amount, long amount_after)", "{"], "whitespace/line_length"]
["src/nvim/fold.c", ["          /* Deleting lines: delete the fold completely */", "          deleteFoldEntry(gap, i, TRUE);", "          --i;              /* adjust index for deletion */"], "readability/bool"]
["src/nvim/fold.c", ["          --fp;", "        } else", "          fp->fd_top += amount;"], "readability/braces"]
["src/nvim/fold.c", [" */", "static int ", "check_closed ("], "whitespace/end_of_line"]
["src/nvim/fold.c", ["static int ", "check_closed (", "    win_T *win,"], "whitespace/parens"]
["src/nvim/fold.c", ["{", "  int closed = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["  if (*use_levelp || fp->fd_flags == FD_LEVEL) {", "    *use_levelp = TRUE;", "    if (level >= win->w_p_fdl)"], "readability/bool"]
["src/nvim/fold.c", ["    if (level >= win->w_p_fdl)", "      closed = TRUE;", "  } else if (fp->fd_flags == FD_CLOSED)"], "readability/bool"]
["src/nvim/fold.c", ["      closed = TRUE;", "  } else if (fp->fd_flags == FD_CLOSED)", "    closed = TRUE;"], "readability/braces"]
["src/nvim/fold.c", ["  } else if (fp->fd_flags == FD_CLOSED)", "    closed = TRUE;", ""], "readability/bool"]
["src/nvim/fold.c", ["  if (fp->fd_small == MAYBE)", "    *maybe_smallp = TRUE;", "  if (closed) {"], "readability/bool"]
["src/nvim/fold.c", ["    checkSmall(win, fp, lnum_off);", "    if (fp->fd_small == TRUE)", "      closed = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["    if (fp->fd_small == TRUE)", "      closed = FALSE;", "  }"], "readability/bool"]
["src/nvim/fold.c", [" */", "static void ", "checkSmall ("], "whitespace/end_of_line"]
["src/nvim/fold.c", ["static void ", "checkSmall (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/fold.c", ["    if (fp->fd_len > curwin->w_p_fml)", "      fp->fd_small = FALSE;", "    else {"], "readability/bool"]
["src/nvim/fold.c", ["      fp->fd_small = FALSE;", "    else {", "      count = 0;"], "readability/braces"]
["src/nvim/fold.c", ["        if (count > curwin->w_p_fml) {", "          fp->fd_small = FALSE;", "          return;"], "readability/bool"]
["src/nvim/fold.c", ["      }", "      fp->fd_small = TRUE;", "    }"], "readability/bool"]
["src/nvim/fold.c", ["      STRLCPY(newline + line_len, marker, markerlen + 1);", "    else {", "      STRCPY(newline + line_len, cms);"], "readability/braces"]
["src/nvim/fold.c", ["", "    ml_replace(lnum, newline, FALSE);", "  }"], "readability/bool"]
["src/nvim/fold.c", [" */", "static void ", "deleteFoldMarkers ("], "whitespace/end_of_line"]
["src/nvim/fold.c", ["static void ", "deleteFoldMarkers (", "    fold_T *fp,"], "whitespace/parens"]
["src/nvim/fold.c", ["    for (int i = 0; i < fp->fd_nested.ga_len; ++i) {", "      deleteFoldMarkers((fold_T *)fp->fd_nested.ga_data + i, TRUE,", "                        lnum_off + fp->fd_top);"], "readability/bool"]
["src/nvim/fold.c", ["      STRCPY(newline + (p - line), p + len);", "      ml_replace(lnum, newline, FALSE);", "    }"], "readability/bool"]
["src/nvim/fold.c", ["  /* an error occurred when evaluating 'fdt' setting */", "  static int got_fdt_error = FALSE;", "  int save_did_emsg = did_emsg;"], "readability/bool"]
["src/nvim/fold.c", ["    /* window changed, try evaluating foldtext setting once again */", "    got_fdt_error = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["    /* a previous error should not abort evaluating 'foldexpr' */", "    did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["      if (text == NULL || did_emsg)", "        got_fdt_error = TRUE;", ""], "readability/bool"]
["src/nvim/fold.c", ["          p += len - 1;", "        } else if (*p == TAB)", "          *p = ' ';"], "readability/braces"]
["src/nvim/fold.c", ["  if (text == NULL) {", "    sprintf((char *)buf, _(\"+--%3ld lines folded \"),", "        (long)(lnume - lnum + 1));"], "runtime/printf"]
["src/nvim/fold.c", ["  char_u      *p;", "  int did1 = FALSE;", "  int did2 = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int did1 = FALSE;", "  int did2 = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["      for (p = s; p > str && ascii_iswhite(p[-1]); --p)", "        ;", "      if (p >= str + cms_slen"], "whitespace/semicolon"]
["src/nvim/fold.c", ["        len = cms_slen;", "        did1 = TRUE;", "      } else if (!did2 && cms_elen > 0"], "readability/bool"]
["src/nvim/fold.c", ["        len = cms_elen;", "        did2 = TRUE;", "      }"], "readability/bool"]
["src/nvim/fold.c", ["", "  fold_changed = FALSE;", "  fline.wp = wp;"], "readability/bool"]
["src/nvim/fold.c", ["        --fline.lnum;", "    } else if (foldmethodIsSyntax(wp))", "      getlevel = foldlevelSyntax;"], "readability/braces"]
["src/nvim/fold.c", ["  int i;", "  int finish = FALSE;", "  linenr_T linecount = flp->wp->w_buffer->b_ml.ml_line_count - flp->off;"], "readability/bool"]
["src/nvim/fold.c", ["          bot = fp2->fd_top + fp2->fd_len - 1 + fp->fd_top;", "      } else if (fp->fd_top + fp->fd_len <= flp->lnum && lvl >= level)", "        finish = TRUE;"], "readability/braces"]
["src/nvim/fold.c", ["      } else if (fp->fd_top + fp->fd_len <= flp->lnum && lvl >= level)", "        finish = TRUE;", "      else"], "readability/bool"]
["src/nvim/fold.c", ["              fp->fd_top = firstlnum;", "              fold_changed = TRUE;", "            } else if (flp->start != 0 && lvl == level"], "readability/bool"]
["src/nvim/fold.c", ["                  || getlevel == foldlevelSyntax)", "                finish = TRUE;", "            }"], "readability/bool"]
["src/nvim/fold.c", ["            deleteFoldEntry(gap,", "                (int)(fp - (fold_T *)gap->ga_data), TRUE);", "          } else {"], "readability/bool"]
["src/nvim/fold.c", ["                (linenr_T)MAXLNUM, 0L);", "            fold_changed = TRUE;", "          }"], "readability/bool"]
["src/nvim/fold.c", ["              flp->wp->w_fold_manual = true;", "          } else", "            fp->fd_flags = (fp - 1)->fd_flags;"], "readability/braces"]
["src/nvim/fold.c", ["              || getlevel == foldlevelSyntax)", "            finish = TRUE;", "          fold_changed = TRUE;"], "readability/bool"]
["src/nvim/fold.c", ["            finish = TRUE;", "          fold_changed = TRUE;", "          break;"], "readability/bool"]
["src/nvim/fold.c", ["    fp->fd_small = MAYBE;", "    fold_changed = TRUE;", "  }"], "readability/bool"]
["src/nvim/fold.c", ["        }", "      } else", "        fp->fd_len = flp->lnum - fp->fd_top;"], "readability/braces"]
["src/nvim/fold.c", ["        fp->fd_len = flp->lnum - fp->fd_top;", "      fold_changed = TRUE;", "    }"], "readability/bool"]
["src/nvim/fold.c", ["        fp2->fd_top = flp->lnum;", "        fold_changed = TRUE;", "      }"], "readability/bool"]
["src/nvim/fold.c", ["    }", "    fold_changed = TRUE;", "    deleteFoldEntry(gap, (int)(fp2 - (fold_T *)gap->ga_data), TRUE);"], "readability/bool"]
["src/nvim/fold.c", ["    fold_changed = TRUE;", "    deleteFoldEntry(gap, (int)(fp2 - (fold_T *)gap->ga_data), TRUE);", "  }"], "readability/bool"]
["src/nvim/fold.c", ["  fp->fd_len = top - fp->fd_top;", "  fold_changed = TRUE;", "}"], "readability/bool"]
["src/nvim/fold.c", ["      }", "      fold_changed = TRUE;", "      continue;"], "readability/bool"]
["src/nvim/fold.c", ["      /* Found an entry below top. */", "      fold_changed = TRUE;", "      if (fp->fd_top + fp->fd_len - 1 > bot) {"], "readability/bool"]
["src/nvim/fold.c", ["      /* 4: Delete completely contained fold. */", "      deleteFoldEntry(gap, (int)(fp - (fold_T *)gap->ga_data), TRUE);", "    }"], "readability/bool"]
["src/nvim/fold.c", ["  fp1->fd_len += fp2->fd_len;", "  deleteFoldEntry(gap, (int)(fp2 - (fold_T *)gap->ga_data), TRUE);", "  fold_changed = TRUE;"], "readability/bool"]
["src/nvim/fold.c", ["  deleteFoldEntry(gap, (int)(fp2 - (fold_T *)gap->ga_data), TRUE);", "  fold_changed = TRUE;", "}"], "readability/bool"]
["src/nvim/fold.c", ["  buf = flp->wp->w_buffer;", "  s = skipwhite(ml_get_buf(buf, lnum, FALSE));", ""], "readability/bool"]
["src/nvim/fold.c", ["      flp->lvl = -1;", "  } else", "    flp->lvl = get_indent_buf(buf, lnum) / get_sw_value(curbuf);"], "readability/braces"]
["src/nvim/fold.c", ["", "  s = ml_get_buf(flp->wp->w_buffer, flp->lnum + flp->off, FALSE);", "  while (*s) {"], "readability/bool"]
["src/nvim/fold.c", ["        }", "      } else", "        --flp->lvl_next;"], "readability/braces"]
["src/nvim/fold.c", ["        --flp->lvl_next;", "    } else", "      mb_ptr_adv(s);"], "readability/braces"]
["src/nvim/fold.c", [" */", "static int put_foldopen_recurse(FILE *fd, win_T *wp, garray_T *gap, linenr_T off)", "{"], "whitespace/line_length"]
["src/nvim/garray.c", ["  }", "  strcpy(s, strings[nelem - 1]);", ""], "runtime/printf"]
["src/nvim/getchar.c", [" */", "static int block_redo = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["static mapblock_T       *(maphash[256]);", "static int maphash_valid = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["", "  p = get_buffcont(&recordbuff, TRUE);", "  free_buff(&recordbuff);"], "readability/bool"]
["src/nvim/getchar.c", ["{", "  return get_buffcont(&redobuff, FALSE);", "}"], "readability/bool"]
["src/nvim/getchar.c", [" */", "static void ", "add_buff ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["static void ", "add_buff (", "    buffheader_T *buf,"], "whitespace/parens"]
["src/nvim/getchar.c", ["    return;", "  } else if (buf->bh_index != 0)", "    memmove(buf->bh_first.b_next->b_str,"], "readability/braces"]
["src/nvim/getchar.c", ["", "  sprintf((char *)number, \"%\" PRId64, (int64_t)n);", "  add_buff(buf, number, -1L);"], "runtime/printf"]
["src/nvim/getchar.c", ["  start_stuff();", "  while (read_readbuffers(TRUE) != NUL) {", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["               typebuf.tb_change_cnt) != 0)", "      ;", "    typebuf.tb_off = MAXMAPLEN;"], "whitespace/semicolon"]
["src/nvim/getchar.c", ["  typebuf.tb_silent = 0;", "  cmd_silent = FALSE;", "  typebuf.tb_no_abbr_cnt = 0;"], "readability/bool"]
["src/nvim/getchar.c", ["    start_stuff();", "    while (read_readbuffers(TRUE) != NUL) {", "    }"], "readability/bool"]
["src/nvim/getchar.c", ["    /* Make a copy, so that \":normal .\" in a function works. */", "    s = get_buffcont(&save_redobuff, FALSE);", "    if (s != NULL) {"], "readability/bool"]
["src/nvim/getchar.c", [" */", "void ", "AppendToRedobuffLit ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["void ", "AppendToRedobuffLit (", "    char_u *str,"], "whitespace/parens"]
["src/nvim/getchar.c", ["", "  while ((c = read_redo(FALSE, old_redo)) != NUL) {", "    add_char_buff(&readbuf2, c);"], "readability/bool"]
["src/nvim/getchar.c", ["  /* init the pointers; return if nothing to redo */", "  if (read_redo(TRUE, old_redo) == FAIL)", "    return FAIL;"], "readability/bool"]
["src/nvim/getchar.c", ["", "  c = read_redo(FALSE, old_redo);", ""], "readability/bool"]
["src/nvim/getchar.c", ["    add_buff(&readbuf2, (char_u *)\"\\\"\", 1L);", "    c = read_redo(FALSE, old_redo);", ""], "readability/bool"]
["src/nvim/getchar.c", ["    add_char_buff(&readbuf2, c);", "    c = read_redo(FALSE, old_redo);", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["    VIsual = curwin->w_cursor;", "    VIsual_active = TRUE;", "    VIsual_select = FALSE;"], "readability/bool"]
["src/nvim/getchar.c", ["    VIsual_active = TRUE;", "    VIsual_select = FALSE;", "    VIsual_reselect = TRUE;"], "readability/bool"]
["src/nvim/getchar.c", ["    VIsual_select = FALSE;", "    VIsual_reselect = TRUE;", "    redo_VIsual_busy = TRUE;"], "readability/bool"]
["src/nvim/getchar.c", ["    VIsual_reselect = TRUE;", "    redo_VIsual_busy = TRUE;", "    c = read_redo(FALSE, old_redo);"], "readability/bool"]
["src/nvim/getchar.c", ["    redo_VIsual_busy = TRUE;", "    c = read_redo(FALSE, old_redo);", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["    while (ascii_isdigit(c))      /* skip \"old\" count */", "      c = read_redo(FALSE, old_redo);", "    add_num_buff(&readbuf2, count);"], "readability/bool"]
["src/nvim/getchar.c", ["", "  if (read_redo(TRUE, FALSE) == FAIL)", "    return FAIL;"], "readability/bool"]
["src/nvim/getchar.c", ["  /* skip the count and the command character */", "  while ((c = read_redo(FALSE, FALSE)) != NUL) {", "    if (vim_strchr((char_u *)\"AaIiRrOo\", c) != NULL) {"], "readability/bool"]
["src/nvim/getchar.c", ["  /* copy the typed text from the redo buffer into the stuff buffer */", "  copy_redo(FALSE);", "  block_redo = TRUE;"], "readability/bool"]
["src/nvim/getchar.c", ["  copy_redo(FALSE);", "  block_redo = TRUE;", "  return OK;"], "readability/bool"]
["src/nvim/getchar.c", ["{", "  block_redo = FALSE;", "}"], "readability/bool"]
["src/nvim/getchar.c", ["   */", "  else {", "    newoff = MAXMAPLEN + 4;"], "whitespace/newline"]
["src/nvim/getchar.c", ["   */", "  else {", "    newoff = MAXMAPLEN + 4;"], "readability/braces"]
["src/nvim/getchar.c", ["    typebuf.tb_silent += addlen;", "    cmd_silent = TRUE;", "  }"], "readability/bool"]
["src/nvim/getchar.c", [" */", "int ", "typebuf_changed ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["int ", "typebuf_changed (", "    int tb_change_cnt              /* old value of typebuf.tb_change_cnt */"], "whitespace/parens"]
["src/nvim/getchar.c", ["                                || typebuf_was_filled", "                                );", "}"], "whitespace/parens"]
["src/nvim/getchar.c", ["   */", "  else {", "    i = typebuf.tb_off + offset;"], "readability/braces"]
["src/nvim/getchar.c", ["   * was inserted in the typeahead buffer. */", "  typebuf_was_filled = FALSE;", "  if (++typebuf.tb_change_cnt == 0)"], "readability/bool"]
["src/nvim/getchar.c", ["  /* output \"debug mode\" message next time in debug mode */", "  debug_did_msg = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["      && scriptin[curscript] == NULL)", "    u_sync(FALSE);", "}"], "readability/bool"]
["src/nvim/getchar.c", ["  alloc_typebuf();", "  tp->typebuf_valid = TRUE;", "  tp->old_char = old_char;"], "readability/bool"]
["src/nvim/getchar.c", [" */", "void ", "openscript ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["void ", "openscript (", "    char_u *name,"], "whitespace/parens"]
["src/nvim/getchar.c", ["    State = NORMAL;", "    msg_scroll = FALSE;         /* no msg scrolling in Normal mode */", "    restart_edit = 0;           /* don't go to Insert mode */"], "readability/bool"]
["src/nvim/getchar.c", ["    restart_edit = 0;           /* don't go to Insert mode */", "    p_im = FALSE;               /* don't use 'insertmode' */", "    clear_oparg(&oa);"], "readability/bool"]
["src/nvim/getchar.c", ["    clear_oparg(&oa);", "    finish_op = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["      update_topline_cursor();          /* update cursor position and topline */", "      normal_cmd(&oa, FALSE);           /* execute one command */", "      vpeekc();                         /* check for end of file */"], "readability/bool"]
["src/nvim/getchar.c", ["  if (c == 0 || (p_uc > 0 && ++count >= p_uc)) {", "    ml_sync_all(c == 0, TRUE);", "    count = 0;"], "readability/bool"]
["src/nvim/getchar.c", ["      }", "      c = vgetorpeek(TRUE);", "      if (mod_mask) {"], "readability/bool"]
["src/nvim/getchar.c", ["        allow_keys = 0;                 /* make sure BS is not found */", "        c2 = vgetorpeek(TRUE);          /* no mapping for these chars */", "        c = vgetorpeek(TRUE);"], "readability/bool"]
["src/nvim/getchar.c", ["        c2 = vgetorpeek(TRUE);          /* no mapping for these chars */", "        c = vgetorpeek(TRUE);", "        --no_mapping;"], "readability/bool"]
["src/nvim/getchar.c", ["        c = TO_SPECIAL(c2, c);", "", "      }"], "whitespace/blank_line"]
["src/nvim/getchar.c", ["      case K_KPOINT:", "        c = '.'; break;", "      case K_K0:          c = '0'; break;"], "whitespace/newline"]
["src/nvim/getchar.c", ["          mod_mask = 0;", "      } else", "          c = K_HOME;"], "readability/braces"]
["src/nvim/getchar.c", ["          mod_mask = 0;", "      } else", "          c = K_END;"], "readability/braces"]
["src/nvim/getchar.c", ["        for (i = 1; i < n; ++i) {", "          buf[i] = vgetorpeek(TRUE);", "          if (buf[i] == K_SPECIAL"], "readability/bool"]
["src/nvim/getchar.c", ["             * of a K_SPECIAL - KS_EXTRA - KE_CSI, which is CSI too. */", "            c = vgetorpeek(TRUE);", "            if (vgetorpeek(TRUE) == (int)KE_CSI && c == KS_EXTRA)"], "readability/bool"]
["src/nvim/getchar.c", ["            c = vgetorpeek(TRUE);", "            if (vgetorpeek(TRUE) == (int)KE_CSI && c == KS_EXTRA)", "              buf[i] = CSI;"], "readability/bool"]
["src/nvim/getchar.c", ["   */", "  may_garbage_collect = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["    return old_char;", "  return vgetorpeek(FALSE);", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "void ", "vungetc ( /* unget one character (can only be done once!) */"], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["void ", "vungetc ( /* unget one character (can only be done once!) */", "    int c"], "whitespace/parens"]
["src/nvim/getchar.c", ["  int mp_match_len = 0;", "  int timedout = FALSE;                     /* waited for more than 1 second", "                                                for mapping to complete */"], "readability/multiline_comment"]
["src/nvim/getchar.c", ["  int mp_match_len = 0;", "  int timedout = FALSE;                     /* waited for more than 1 second", "                                                for mapping to complete */"], "readability/bool"]
["src/nvim/getchar.c", ["  int mapdepth = 0;                 /* check for recursive mapping */", "  int mode_deleted = FALSE;             /* set when mode has been deleted */", "  int local_State;"], "readability/bool"]
["src/nvim/getchar.c", ["  if (advance)", "    KeyStuffed = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["  if (advance && typebuf.tb_maplen == 0)", "    Exec_reg = FALSE;", "  do {"], "readability/bool"]
["src/nvim/getchar.c", ["         * needed for CTRL-W CTRl-] to open a fold, for example. */", "        KeyStuffed = TRUE;", "      }"], "readability/bool"]
["src/nvim/getchar.c", ["            c = Ctrl_C;", "          flush_buffers(TRUE);                  /* flush all typeahead */", ""], "readability/bool"]
["src/nvim/getchar.c", ["          }", "          cmd_silent = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["              nolmaplen = 2;", "            else {", "              LANGMAP_ADJUST(c1, (State & (CMDLINE | INSERT)) == 0);"], "readability/braces"]
["src/nvim/getchar.c", ["                  else", "                    LANGMAP_ADJUST(c2, TRUE);", "                  if (mp->m_keys[mlen] != c2)"], "readability/bool"]
["src/nvim/getchar.c", ["                  }", "                } else", "                /* No match; may have to check for"], "readability/braces"]
["src/nvim/getchar.c", ["              keylen = 0;", "            } else", "              keylen = 0;"], "readability/braces"]
["src/nvim/getchar.c", ["                  if (typebuf.tb_maplen > 0)", "                    KeyTyped = FALSE;", "                  else {"], "readability/bool"]
["src/nvim/getchar.c", ["                    KeyTyped = FALSE;", "                  else {", "                    KeyTyped = TRUE;"], "readability/braces"]
["src/nvim/getchar.c", ["                  else {", "                    KeyTyped = TRUE;", "                    /* write char to script file(s) */"], "readability/bool"]
["src/nvim/getchar.c", ["                setcursor();", "              flush_buffers(FALSE);", "              mapdepth = 0;                     /* for next one */"], "readability/bool"]
["src/nvim/getchar.c", ["                && (mp->m_mode & VISUAL)) {", "              VIsual_select = FALSE;", "              (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE,"], "readability/bool"]
["src/nvim/getchar.c", ["              (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE,", "                  0, TRUE, FALSE);", "            }"], "readability/bool"]
["src/nvim/getchar.c", ["              vgetc_busy = save_vgetc_busy;", "            } else", "              s = mp->m_str;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = FAIL;", "            else {", "              int noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = ins_typebuf(s, noremap,", "                  0, TRUE, cmd_silent || save_m_silent);", "              if (save_m_expr)"], "readability/bool"]
["src/nvim/getchar.c", ["          if (mode_displayed) {", "            unshowmode(TRUE);", "            mode_deleted = TRUE;"], "readability/bool"]
["src/nvim/getchar.c", ["            unshowmode(TRUE);", "            mode_deleted = TRUE;", "          }"], "readability/bool"]
["src/nvim/getchar.c", ["        if (typebuf.tb_len >= typebuf.tb_maplen + MAXMAPLEN) {", "          timedout = TRUE;", "          continue;"], "readability/bool"]
["src/nvim/getchar.c", ["          if (typebuf.tb_len > 0) {", "            timedout = TRUE;", "            continue;"], "readability/bool"]
["src/nvim/getchar.c", ["              edit_putchar(typebuf.tb_buf[typebuf.tb_off", "                                          + typebuf.tb_len - 1], FALSE);", "              setcursor();               /* put cursor back where it belongs */"], "readability/bool"]
["src/nvim/getchar.c", ["            putcmdline(typebuf.tb_buf[typebuf.tb_off", "                                      + typebuf.tb_len - 1], FALSE);", "            c1 = 1;"], "readability/bool"]
["src/nvim/getchar.c", ["          if (wait_tb_len > 0) {                /* timed out */", "            timedout = TRUE;", "            continue;"], "readability/bool"]
["src/nvim/getchar.c", ["      if (typebuf.tb_len && !KeyTyped)", "        redraw_cmdline = TRUE;              /* delete mode later */", "      else"], "readability/bool"]
["src/nvim/getchar.c", ["      else", "        unshowmode(FALSE);", "    } else if (c != ESC && mode_deleted) {"], "readability/bool"]
["src/nvim/getchar.c", ["      if (typebuf.tb_len && !KeyTyped)", "        redraw_cmdline = TRUE;              /* show mode later */", "      else"], "readability/bool"]
["src/nvim/getchar.c", [" */", "int ", "inchar ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["int ", "inchar (", "    char_u *buf,"], "whitespace/parens"]
["src/nvim/getchar.c", ["  int len = 0;                      /* init for GCC */", "  int retesc = FALSE;               /* return ESC with gotint */", "  int script_char;"], "readability/bool"]
["src/nvim/getchar.c", ["  if (State != HITRETURN) {", "    did_outofmem_msg = FALSE;       /* display out of memory message (again) */", "    did_swapwrite_msg = FALSE;      /* display swap file write error again */"], "readability/bool"]
["src/nvim/getchar.c", ["    did_outofmem_msg = FALSE;       /* display out of memory message (again) */", "    did_swapwrite_msg = FALSE;      /* display swap file write error again */", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["  }", "  undo_off = FALSE;                 /* restart undo now */", ""], "readability/bool"]
["src/nvim/getchar.c", ["         ) {", "", ""], "whitespace/blank_line"]
["src/nvim/getchar.c", ["      if (got_int)", "        retesc = TRUE;", "      else"], "readability/bool"]
["src/nvim/getchar.c", [" */", "int ", "fix_input_buffer ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["int ", "fix_input_buffer (", "    char_u *buf,"], "whitespace/parens"]
["src/nvim/getchar.c", ["  // Two characters are special: NUL and K_SPECIAL.", "  // Replace\t     NUL by K_SPECIAL KS_ZERO\t KE_FILLER", "  // Replace K_SPECIAL by K_SPECIAL KS_SPECIAL KE_FILLER"], "whitespace/tab"]
["src/nvim/getchar.c", [" */", "int ", "do_map ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["int ", "do_map (", "    int maptype,"], "whitespace/parens"]
["src/nvim/getchar.c", ["  int haskey;", "  int did_it = FALSE;", "  int did_local = FALSE;"], "readability/bool"]
["src/nvim/getchar.c", ["  int did_it = FALSE;", "  int did_local = FALSE;", "  int round;"], "readability/bool"]
["src/nvim/getchar.c", ["  mapblock_T  **map_table;", "  int unique = FALSE;", "  int nowait = FALSE;"], "readability/bool"]
["src/nvim/getchar.c", ["  int unique = FALSE;", "  int nowait = FALSE;", "  int silent = FALSE;"], "readability/bool"]
["src/nvim/getchar.c", ["  int nowait = FALSE;", "  int silent = FALSE;", "  int special = FALSE;"], "readability/bool"]
["src/nvim/getchar.c", ["  int silent = FALSE;", "  int special = FALSE;", "  int expr = FALSE;"], "readability/bool"]
["src/nvim/getchar.c", ["  int special = FALSE;", "  int expr = FALSE;", "  int noremap;"], "readability/bool"]
["src/nvim/getchar.c", ["      keys = skipwhite(keys + 8);", "      nowait = TRUE;", "      continue;"], "readability/bool"]
["src/nvim/getchar.c", ["      keys = skipwhite(keys + 8);", "      silent = TRUE;", "      continue;"], "readability/bool"]
["src/nvim/getchar.c", ["      keys = skipwhite(keys + 9);", "      special = TRUE;", "      continue;"], "readability/bool"]
["src/nvim/getchar.c", ["      keys = skipwhite(keys + 6);", "      expr = TRUE;", "      continue;"], "readability/bool"]
["src/nvim/getchar.c", ["      keys = skipwhite(keys + 8);", "      unique = TRUE;", "      continue;"], "readability/bool"]
["src/nvim/getchar.c", ["  if (haskey)", "    keys = replace_termcodes(keys, &keys_buf, TRUE, TRUE, special);", "  orig_rhs = rhs;"], "readability/bool"]
["src/nvim/getchar.c", ["    else", "      rhs = replace_termcodes(rhs, &arg_buf, FALSE, TRUE, special);", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["        }", "      } else if (vim_iswordc(keys[len - 1]))    /* ends in keyword char */", "        for (n = 0; n < len - 2; ++n)"], "readability/braces"]
["src/nvim/getchar.c", ["  if (haskey && hasarg && abbrev)       /* if we will add an abbreviation */", "    no_abbr = FALSE;                    /* reset flag that indicates there are", "                                                            no abbreviations */"], "readability/multiline_comment"]
["src/nvim/getchar.c", ["  if (haskey && hasarg && abbrev)       /* if we will add an abbreviation */", "    no_abbr = FALSE;                    /* reset flag that indicates there are", "                                                            no abbreviations */"], "readability/bool"]
["src/nvim/getchar.c", ["        mp = first_abbr;", "      } else", "        mp = maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["        mp = curbuf->b_first_abbr;", "      } else", "        mp = curbuf->b_maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["          if (!haskey) {                            /* show all entries */", "            showmap(mp, TRUE);", "            did_local = TRUE;"], "readability/bool"]
["src/nvim/getchar.c", ["            showmap(mp, TRUE);", "            did_local = TRUE;", "          } else {"], "readability/bool"]
["src/nvim/getchar.c", ["                    (size_t)(n < len ? n : len)) == 0) {", "              showmap(mp, TRUE);", "              did_local = TRUE;"], "readability/bool"]
["src/nvim/getchar.c", ["              showmap(mp, TRUE);", "              did_local = TRUE;", "            }"], "readability/bool"]
["src/nvim/getchar.c", ["        mpp = abbr_table;", "      } else", "        mpp = &(map_table[hash]);"], "readability/braces"]
["src/nvim/getchar.c", ["      for (mp = *mpp; mp != NULL && !got_int; mp = *mpp) {", "", "        if (!(mp->m_mode & mode)) {         /* skip entries with wrong mode */"], "whitespace/blank_line"]
["src/nvim/getchar.c", ["          showmap(mp, map_table != maphash);", "          did_it = TRUE;", "        } else {                          /* do we have a match? */"], "readability/bool"]
["src/nvim/getchar.c", ["              mp->m_mode &= ~mode;", "              did_it = TRUE;                    /* remember we did something */", "            } else if (!hasarg) {             /* show matching entry */"], "readability/bool"]
["src/nvim/getchar.c", ["              showmap(mp, map_table != maphash);", "              did_it = TRUE;", "            } else if (n != len) {            /* new entry is ambiguous */"], "readability/bool"]
["src/nvim/getchar.c", ["                mp->m_script_ID = current_SID;", "                did_it = TRUE;", "              }"], "readability/bool"]
["src/nvim/getchar.c", ["      /* If CTRL-C has been unmapped, reuse it for Interrupting. */", "      mapped_ctrl_c = FALSE;", "    }"], "readability/bool"]
["src/nvim/getchar.c", ["  if (*keys == Ctrl_C)", "    mapped_ctrl_c = TRUE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["    memset(maphash, 0, sizeof(maphash));", "    maphash_valid = TRUE;", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["    mode = TERM_FOCUS;                            // :tmap", "  else {", "    --p;"], "readability/braces"]
["src/nvim/getchar.c", [" */", "void ", "map_clear_int ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["void ", "map_clear_int (", "    buf_T *buf,        /* buffer for local mappings */"], "whitespace/parens"]
["src/nvim/getchar.c", ["    ga_append(&mapmode, ' ');                           /* :map */", "  else {", "    if (mode & NORMAL)"], "readability/braces"]
["src/nvim/getchar.c", ["      ga_append(&mapmode, 'v');                         /* :vmap */", "    else {", "      if (mode & VISUAL)"], "readability/braces"]
["src/nvim/getchar.c", ["", "static void ", "showmap ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["static void ", "showmap (", "    mapblock_T *mp,"], "whitespace/parens"]
["src/nvim/getchar.c", ["  /* Display the LHS.  Get length of what we write. */", "  len = msg_outtrans_special(mp->m_keys, TRUE);", "  do {"], "readability/bool"]
["src/nvim/getchar.c", ["    msg_puts_attr((char_u *)\"<Nop>\", hl_attr(HLF_8));", "  else {", "    /* Remove escaping of CSI, because \"m_str\" is in a format to be used"], "readability/braces"]
["src/nvim/getchar.c", ["    vim_unescape_csi(s);", "    msg_outtrans_special(s, FALSE);", "    xfree(s);"], "readability/bool"]
["src/nvim/getchar.c", ["", "  rhs = replace_termcodes(str, &buf, FALSE, TRUE, FALSE);", ""], "readability/bool"]
["src/nvim/getchar.c", ["  int hash;", "  int expand_buffer = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["          mp = first_abbr;", "      } else if (expand_buffer)", "        mp = curbuf->b_maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["            && strstr((char *)mp->m_str, (char *)rhs) != NULL)", "          return TRUE;", "      }"], "readability/bool"]
["src/nvim/getchar.c", ["      break;", "    expand_buffer = TRUE;", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/getchar.c", ["static int expand_isabbrev = 0;", "static int expand_buffer = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["char_u *", "set_context_in_map_cmd (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/getchar.c", ["    xp->xp_context = EXPAND_NOTHING;", "  else {", "    if (isunmap)"], "readability/braces"]
["src/nvim/getchar.c", ["      expand_mapmodes = get_map_mode(&cmd, forceit || isabbrev);", "    else {", "      expand_mapmodes = INSERT + CMDLINE;"], "readability/braces"]
["src/nvim/getchar.c", ["    xp->xp_context = EXPAND_MAPPINGS;", "    expand_buffer = FALSE;", "    for (;; ) {"], "readability/bool"]
["src/nvim/getchar.c", ["      if (STRNCMP(arg, \"<buffer>\", 8) == 0) {", "        expand_buffer = TRUE;", "        arg = skipwhite(arg + 8);"], "readability/bool"]
["src/nvim/getchar.c", ["        mp = first_abbr;", "      } else if (expand_buffer)", "        mp = curbuf->b_maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["        if (mp->m_mode & expand_mapmodes) {", "          p = translate_mapping(mp->m_keys, TRUE);", "          if (p != NULL && vim_regexec(regmatch, p, (colnr_T)0)) {"], "readability/bool"]
["src/nvim/getchar.c", ["              ++count;", "            else {", "              (*file)[count++] = p;"], "readability/braces"]
["src/nvim/getchar.c", ["        *++ptr1 = *ptr2++;", "      else {", "        xfree(*ptr2++);"], "readability/braces"]
["src/nvim/getchar.c", ["  int clen = 0;                 /* length in characters */", "  int is_id = TRUE;", "  int vim_abbr;"], "readability/bool"]
["src/nvim/getchar.c", ["  if (typebuf.tb_no_abbr_cnt)   /* abbrev. are not recursive */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["  if ((KeyNoremap & (RM_NONE|RM_SCRIPT)) != 0 && c != Ctrl_RSB)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["  if (col == 0)                                 /* cannot be an abbr. */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["    if (!vim_iswordp(p))", "      vim_abbr = TRUE;                          /* Vim added abbr. */", "    else {"], "readability/bool"]
["src/nvim/getchar.c", ["      vim_abbr = TRUE;                          /* Vim added abbr. */", "    else {", "      vim_abbr = FALSE;                         /* vi compatible abbr. */"], "readability/braces"]
["src/nvim/getchar.c", ["    else {", "      vim_abbr = FALSE;                         /* vi compatible abbr. */", "      if (p > ptr)"], "readability/bool"]
["src/nvim/getchar.c", ["    if (!vim_iswordc(ptr[col - 1]))", "      vim_abbr = TRUE;                          /* Vim added abbr. */", "    else {"], "readability/bool"]
["src/nvim/getchar.c", ["      vim_abbr = TRUE;                          /* Vim added abbr. */", "    else {", "      vim_abbr = FALSE;                         /* vi compatible abbr. */"], "readability/braces"]
["src/nvim/getchar.c", ["    else {", "      vim_abbr = FALSE;                         /* vi compatible abbr. */", "      if (col > 1)"], "readability/bool"]
["src/nvim/getchar.c", ["         && (vim_abbr || is_id == vim_iswordc(ptr[scol - 1])); --scol)", "      ;", "  }"], "whitespace/semicolon"]
["src/nvim/getchar.c", ["            j += (*mb_char2bytes)(c, tb + j);", "          } else", "            tb[j++] = c;"], "readability/braces"]
["src/nvim/getchar.c", ["        /* insert the last typed char */", "        (void)ins_typebuf(tb, 1, 0, TRUE, mp->m_silent);", "      }"], "readability/bool"]
["src/nvim/getchar.c", ["        /* insert the to string */", "        (void)ins_typebuf(s, mp->m_noremap, 0, TRUE, mp->m_silent);", "        /* no abbrev. for these chars */"], "readability/bool"]
["src/nvim/getchar.c", ["      while (len-- > 0)                 /* delete the from string */", "        (void)ins_typebuf(tb, 1, 0, TRUE, mp->m_silent);", "      return TRUE;"], "readability/bool"]
["src/nvim/getchar.c", ["        (void)ins_typebuf(tb, 1, 0, TRUE, mp->m_silent);", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/getchar.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/getchar.c", ["static char_u *", "eval_map_expr (", "    char_u *str,"], "whitespace/parens"]
["src/nvim/getchar.c", ["  save_msg_row = msg_row;", "  p = eval_to_string(expr, NULL, FALSE);", "  --textlock;"], "readability/bool"]
["src/nvim/getchar.c", ["      s += 3;", "    } else", "      *d++ = *s++;"], "readability/braces"]
["src/nvim/getchar.c", [" */", "int ", "makemap ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["int ", "makemap (", "    FILE *fd,"], "whitespace/parens"]
["src/nvim/getchar.c", ["  int hash;", "  int did_cpo = FALSE;", "  int i;"], "readability/bool"]
["src/nvim/getchar.c", ["            if (*mp->m_str == NUL)                      /* will use <Nop> */", "              did_cpo = TRUE;", "            else"], "readability/bool"]
["src/nvim/getchar.c", ["                  if (*p == K_SPECIAL || *p == NL)", "                    did_cpo = TRUE;", "            if (did_cpo) {"], "readability/bool"]
["src/nvim/getchar.c", ["char_u *", "check_map (", "    char_u *keys,"], "whitespace/parens"]
["src/nvim/getchar.c", ["          mp = first_abbr;", "      } else if (local)", "        mp = curbuf->b_maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["  s = vim_strsave(map);", "  (void)do_map(0, s, mode, FALSE);", "  xfree(s);"], "readability/bool"]
["src/nvim/getchar.c", ["// Returns NULL when there is a problem.", "static char_u * translate_mapping (", "    char_u *str,"], "whitespace/parens"]
["src/nvim/getchar.c", ["      }", "      ", "      if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL) {"], "whitespace/end_of_line"]
["src/nvim/hardcopy.c", ["  {", "  {\"top\",     TRUE, 0, NULL, 0, FALSE},", "  {\"bottom\",  TRUE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"top\",     TRUE, 0, NULL, 0, FALSE},", "  {\"bottom\",  TRUE, 0, NULL, 0, FALSE},", "  {\"left\",    TRUE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"bottom\",  TRUE, 0, NULL, 0, FALSE},", "  {\"left\",    TRUE, 0, NULL, 0, FALSE},", "  {\"right\",   TRUE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"left\",    TRUE, 0, NULL, 0, FALSE},", "  {\"right\",   TRUE, 0, NULL, 0, FALSE},", "  {\"header\",  TRUE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"right\",   TRUE, 0, NULL, 0, FALSE},", "  {\"header\",  TRUE, 0, NULL, 0, FALSE},", "  {\"syntax\",  FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"header\",  TRUE, 0, NULL, 0, FALSE},", "  {\"syntax\",  FALSE, 0, NULL, 0, FALSE},", "  {\"number\",  FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"syntax\",  FALSE, 0, NULL, 0, FALSE},", "  {\"number\",  FALSE, 0, NULL, 0, FALSE},", "  {\"wrap\",    FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"number\",  FALSE, 0, NULL, 0, FALSE},", "  {\"wrap\",    FALSE, 0, NULL, 0, FALSE},", "  {\"duplex\",  FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"wrap\",    FALSE, 0, NULL, 0, FALSE},", "  {\"duplex\",  FALSE, 0, NULL, 0, FALSE},", "  {\"portrait\", FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"duplex\",  FALSE, 0, NULL, 0, FALSE},", "  {\"portrait\", FALSE, 0, NULL, 0, FALSE},", "  {\"paper\",   FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"portrait\", FALSE, 0, NULL, 0, FALSE},", "  {\"paper\",   FALSE, 0, NULL, 0, FALSE},", "  {\"collate\", FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"paper\",   FALSE, 0, NULL, 0, FALSE},", "  {\"collate\", FALSE, 0, NULL, 0, FALSE},", "  {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"collate\", FALSE, 0, NULL, 0, FALSE},", "  {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},", "  {\"formfeed\", FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},", "  {\"formfeed\", FALSE, 0, NULL, 0, FALSE},", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  }", ";", ""], "whitespace/semicolon"]
["src/nvim/hardcopy.c", ["{", "  {\"c\",       FALSE, 0, NULL, 0, FALSE},", "  {\"a\",       FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"c\",       FALSE, 0, NULL, 0, FALSE},", "  {\"a\",       FALSE, 0, NULL, 0, FALSE},", "  {\"r\",       FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"a\",       FALSE, 0, NULL, 0, FALSE},", "  {\"r\",       FALSE, 0, NULL, 0, FALSE},", "  {\"b\",       FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"r\",       FALSE, 0, NULL, 0, FALSE},", "  {\"b\",       FALSE, 0, NULL, 0, FALSE},", "  {\"i\",       FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"b\",       FALSE, 0, NULL, 0, FALSE},", "  {\"i\",       FALSE, 0, NULL, 0, FALSE},", "  {\"o\",       FALSE, 0, NULL, 0, FALSE},"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"i\",       FALSE, 0, NULL, 0, FALSE},", "  {\"o\",       FALSE, 0, NULL, 0, FALSE},", "};"], "readability/bool"]
["src/nvim/hardcopy.c", [" */", "static char_u *parse_list_options(char_u *option_str, option_table_T *table, int table_size)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["  for (idx = 0; idx < table_size; ++idx)", "    table[idx].present = FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["    p = colonp + 1;", "    table[idx].present = TRUE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", [" */", "static void prt_line_number(prt_settings_T *psettings, int page_line, linenr_T lnum)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["      psettings->number.underline);", "  mch_print_start_line(TRUE, page_line);", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["   * PRINT_NUMBER_WIDTH. */", "  sprintf((char *)tbuf, \"%6ld\", (long)lnum);", "  for (i = 0; i < 6; i++)"], "runtime/printf"]
["src/nvim/hardcopy.c", ["    current_syn_id = -1;", "  else {", "    /* Set colors and font back to normal. */"], "readability/braces"]
["src/nvim/hardcopy.c", ["    prt_set_bg(PRCOLOR_WHITE);", "    prt_set_font(FALSE, FALSE, FALSE);", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    linenr_T tmp_lnum, tmp_topline, tmp_botline;", "    int use_sandbox = FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["    curwin->w_botline = tmp_botline;", "  } else", "    sprintf((char *)tbuf, _(\"Page %d\"), pagenum);"], "readability/braces"]
["src/nvim/hardcopy.c", ["  } else", "    sprintf((char *)tbuf, _(\"Page %d\"), pagenum);", ""], "runtime/printf"]
["src/nvim/hardcopy.c", ["  prt_set_bg(PRCOLOR_WHITE);", "  prt_set_font(TRUE, FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["  page_line = 0 - prt_header_height();", "  mch_print_start_line(TRUE, page_line);", "  for (p = tbuf; *p != NUL; ) {"], "readability/bool"]
["src/nvim/hardcopy.c", ["        break;", "      mch_print_start_line(TRUE, page_line);", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    current_syn_id = -1;", "  else {", "    /* Set colors and font back to normal. */"], "readability/braces"]
["src/nvim/hardcopy.c", ["    prt_set_bg(PRCOLOR_WHITE);", "    prt_set_font(FALSE, FALSE, FALSE);", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  memset(&settings, 0, sizeof(prt_settings_T));", "  settings.has_color = TRUE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["    settings.outfile = skipwhite(eap->arg + 1);", "  } else if (*eap->arg != NUL)", "    settings.arguments = eap->arg;"], "readability/braces"]
["src/nvim/hardcopy.c", ["  if (!syntax_present(curwin))", "    settings.do_syntax = FALSE;", "  else if (printer_opts[OPT_PRINT_SYNTAX].present"], "readability/bool"]
["src/nvim/hardcopy.c", ["  settings.number.bg_color = PRCOLOR_WHITE;", "  settings.number.bold = FALSE;", "  settings.number.italic = TRUE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  settings.number.bold = FALSE;", "  settings.number.italic = TRUE;", "  settings.number.underline = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  settings.number.italic = TRUE;", "  settings.number.underline = FALSE;", "  /*"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_set_bg(PRCOLOR_WHITE);", "  prt_set_font(FALSE, FALSE, FALSE);", "  current_syn_id = -1;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  jobsplit = (printer_opts[OPT_PRINT_JOBSPLIT].present", "              && TOLOWER_ASC(printer_opts[OPT_PRINT_JOBSPLIT].string[0]) == 'y');", ""], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["          assert(prtpos.bytes_printed <= SIZE_MAX / 100);", "          sprintf((char *)IObuff, _(\"Printing page %d (%zu%%)\"),", "                  page_count + 1 + side,"], "runtime/printf"]
["src/nvim/hardcopy.c", ["          if (settings.n_collated_copies > 1)", "            sprintf((char *)IObuff + STRLEN(IObuff),", "                _(\" Copy %d of %d\"),"], "runtime/printf"]
["src/nvim/hardcopy.c", ["  if (got_int || settings.user_abort) {", "    sprintf((char *)IObuff, \"%s\", _(\"Printing aborted\"));", "    prt_message(IObuff);"], "runtime/printf"]
["src/nvim/hardcopy.c", [" */", "static colnr_T hardcopy_line(prt_settings_T *psettings, int page_line, prt_pos_T *ppos)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["  char_u      *line;", "  int need_break = FALSE;", "  int outputlen;"], "readability/bool"]
["src/nvim/hardcopy.c", ["      prt_line_number(psettings, page_line, ppos->file_line);", "    ppos->ff = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (psettings->do_syntax) {", "      id = syn_get_id(curwin, ppos->file_line, col, 1, NULL, FALSE);", "      if (id > 0)"], "readability/bool"]
["src/nvim/hardcopy.c", ["               == 'y') {", "      ppos->ff = TRUE;", "      need_break = 1;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  {\"GB_2312-80\",  \"GB\",       CS_GB_2312_80},", "  {\"GBT_12345-90\",\"GBT\",      CS_GBT_12345_90},", "  {\"MAC\",         \"GBpc\",     CS_SC_MAC},"], "whitespace/comma"]
["src/nvim/hardcopy.c", ["  {PRT_DSC_VERSION,     SIZEOF_CSTR(PRT_DSC_VERSION),", "   PRT_DSC_VERSION_TYPE},", "  {PRT_DSC_ENDCOMMENTS, SIZEOF_CSTR(PRT_DSC_ENDCOMMENTS),"], "whitespace/indent"]
["src/nvim/hardcopy.c", ["  {PRT_DSC_ENDCOMMENTS, SIZEOF_CSTR(PRT_DSC_ENDCOMMENTS),", "   PRT_DSC_ENDCOMMENTS_TYPE}", "};"], "whitespace/indent"]
["src/nvim/hardcopy.c", ["    EMSG(_(\"E455: Error writing to PostScript output file\"));", "    prt_file_error = TRUE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["{", "  sprintf((char *)prt_line_buffer, \"%d \", i);", "  prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["{", "  sprintf((char *)prt_line_buffer, \"%s \", (b ? \"T\" : \"F\"));", "  prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["  if (prt_out_mbyte)", "    sprintf((char *)prt_line_buffer, \"/%s %d %f /_%s sffs\\n\",", "        new_name, height, 500./prt_ps_courier_font.wx, new_name);"], "runtime/printf"]
["src/nvim/hardcopy.c", [" */", "static void prt_real_bits(double real, int precision, int *pinteger, int *pfraction)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["  /* Emit integer part */", "  sprintf((char *)prt_line_buffer, \"%d\", integer);", "  prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["    /* Emit fraction left padded with zeros */", "    sprintf((char *)prt_line_buffer, \".%0*d\", prec, fraction);", "    prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["  }", "  sprintf((char *)prt_line_buffer, \" \");", "  prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["  prt_write_real(value, prec);", "  sprintf((char *)prt_line_buffer, \"d\\n\");", "  prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["        prt_write_string(\"m\\n\");", "        prt_do_moveto = FALSE;", "      }"], "readability/bool"]
["src/nvim/hardcopy.c", ["        prt_write_string(\"m\\n\");", "        prt_do_moveto = FALSE;", "      }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      prt_write_string(\"ms\\n\");", "      prt_do_moveto = FALSE;", "    } else   /* Simple show */"], "readability/bool"]
["src/nvim/hardcopy.c", ["      prt_do_moveto = FALSE;", "    } else   /* Simple show */", "      prt_write_string(\"s\\n\");"], "readability/braces"]
["src/nvim/hardcopy.c", ["  resource->filename[0] = NUL;", "  retval = (do_in_runtimepath(buffer, FALSE, prt_resource_name,", "                resource->filename)"], "readability/bool"]
["src/nvim/hardcopy.c", ["  if (!prt_resfile_next_line())", "    return FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["  if (prt_resfile_strncmp(0, \"%%\", 2) != 0)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (offset == -1)", "      return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  if (offset == -1)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["    EMSG2(_(\"E624: Can't open file \\\"%s\\\"\"), resource->filename);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    fclose(fd_resource);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  if (!prt_resfile_next_line())", "    return FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["        resource->filename);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  if (offset == -1)", "    return FALSE;", "  offset = prt_resfile_skip_ws(offset);"], "readability/bool"]
["src/nvim/hardcopy.c", ["  if (offset == -1)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["        resource->filename);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    resource->type = PRT_RESOURCE_TYPE_CMAP;", "  else {", "    EMSG2(_(\"E619: file \\\"%s\\\" is not a supported PostScript resource file\"),"], "readability/braces"]
["src/nvim/hardcopy.c", ["        resource->filename);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  resource->version[0] = '\\0';", "  seen_title = FALSE;", "  seen_version = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  seen_title = FALSE;", "  seen_version = FALSE;", "  seen_all = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  seen_version = FALSE;", "  seen_all = FALSE;", "  while (!seen_all && prt_next_dsc(&dsc_line)) {"], "readability/bool"]
["src/nvim/hardcopy.c", ["      STRLCPY(resource->title, dsc_line.string, dsc_line.len + 1);", "      seen_title = TRUE;", "      if (seen_version)"], "readability/bool"]
["src/nvim/hardcopy.c", ["      if (seen_version)", "        seen_all = TRUE;", "      break;"], "readability/bool"]
["src/nvim/hardcopy.c", ["      STRLCPY(resource->version, dsc_line.string, dsc_line.len + 1);", "      seen_version = TRUE;", "      if (seen_title)"], "readability/bool"]
["src/nvim/hardcopy.c", ["      if (seen_title)", "        seen_all = TRUE;", "      break;"], "readability/bool"]
["src/nvim/hardcopy.c", ["      /* Wont find title or resource after this comment, stop searching */", "      seen_all = TRUE;", "      break;"], "readability/bool"]
["src/nvim/hardcopy.c", ["        resource->filename);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "static int prt_check_resource(struct prt_ps_resource_S *resource, char_u *version)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["        resource->name);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  /* Other checks to be added as needed */", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["  for (i = 0; i < count; i++) {", "    sprintf((char *)prt_line_buffer, \" %d\", ints[i]);", "    prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["", "static void ", "prt_dsc_resources ("], "whitespace/end_of_line"]
["src/nvim/hardcopy.c", ["static void ", "prt_dsc_resources (", "    char *comment,           /* if NULL add to previous */"], "whitespace/parens"]
["src/nvim/hardcopy.c", ["", "static void prt_dsc_requirements(int duplex, int tumble, int collate, int color, int num_copies)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["", "  sprintf((char *)prt_line_buffer, \"%%%%Requirements:\");", "  prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["    /* Note: no space wanted so don't use prt_write_int() */", "    sprintf((char *)prt_line_buffer, \"%d\", num_copies);", "    prt_write_file(prt_line_buffer);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["", "static void prt_dsc_docmedia(char *paper_name, double width, double height, double weight, char *colour, char *type)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["    convert_setup(&prt_conv, NULL, NULL);", "    prt_do_conv = FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    prt_ps_fd = NULL;", "    prt_file_error = FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", [" */", "static void prt_page_margins(double width, double height, double *left, double *right, double *top, double *bottom)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["    prt_left_margin += prt_number_width;", "  } else", "    prt_number_width = 0.0;"], "readability/braces"]
["src/nvim/hardcopy.c", ["", "static int prt_match_encoding(char *p_encoding, struct prt_ps_mbfont_S *p_cmap, struct prt_ps_encoding_S **pp_mbenc)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["      *pp_mbenc = p_mbenc;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "static int prt_match_charset(char *p_charset, struct prt_ps_mbfont_S *p_cmap, struct prt_ps_charset_S **pp_mbchar)", "{"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["      *pp_mbchar = p_mbchar;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["        EMSG(_(\"E673: Incompatible multi-byte encoding and character set.\"));", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      if (*p_pmcs == NUL) {", "        EMSG(_(\"E674: printmbcharset cannot be empty with multi-byte encoding.\"));", "        return FALSE;"], "whitespace/line_length"]
["src/nvim/hardcopy.c", ["        EMSG(_(\"E674: printmbcharset cannot be empty with multi-byte encoding.\"));", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      EMSG(_(\"E675: No default font specified for multi-byte printing.\"));", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["                             mbfont_opts[OPT_MBFONT_BOLD].strlen);", "", "    }"], "whitespace/blank_line"]
["src/nvim/hardcopy.c", ["  } else {", "    prt_use_courier = FALSE;", "    prt_ps_font = &prt_ps_courier_font;"], "readability/bool"]
["src/nvim/hardcopy.c", ["   */", "  prt_duplex = TRUE;", "  prt_tumble = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_duplex = TRUE;", "  prt_tumble = FALSE;", "  psettings->duplex = 1;"], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (STRNICMP(printer_opts[OPT_PRINT_DUPLEX].string, \"off\", 3) == 0) {", "      prt_duplex = FALSE;", "      psettings->duplex = 0;"], "readability/bool"]
["src/nvim/hardcopy.c", ["      psettings->duplex = 0;", "    } else if (STRNICMP(printer_opts[OPT_PRINT_DUPLEX].string, \"short\", 5)", "               == 0)"], "readability/braces"]
["src/nvim/hardcopy.c", ["               == 0)", "      prt_tumble = TRUE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  prt_attribute_change = FALSE;", "  prt_need_moveto = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_attribute_change = FALSE;", "  prt_need_moveto = FALSE;", "  prt_need_font = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_need_moveto = FALSE;", "  prt_need_font = FALSE;", "  prt_need_fgcol = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_need_font = FALSE;", "  prt_need_fgcol = FALSE;", "  prt_need_bgcol = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_need_fgcol = FALSE;", "  prt_need_bgcol = FALSE;", "  prt_need_underline = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_need_bgcol = FALSE;", "  prt_need_underline = FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  prt_file_error = FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["    EMSG2(_(\"E456: Can't open file \\\"%s\\\"\"), resource->filename);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      fclose(fd_resource);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      fclose(fd_resource);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["  struct prt_ps_resource_S res_cmap;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["  now = time(NULL);", "  p_time = ctime(&now);", "  /* Note: ctime() adds a \\n so we have to remove it :-( */"], "runtime/threadsafe_fn"]
["src/nvim/hardcopy.c", ["    EMSG(_(\"E456: Can't find PostScript resource file \\\"prolog.ps\\\"\"));", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  if (!prt_open_resource(&res_prolog))", "    return FALSE;", "  if (!prt_check_resource(&res_prolog, PRT_PROLOG_VERSION))"], "readability/bool"]
["src/nvim/hardcopy.c", ["  if (!prt_check_resource(&res_prolog, PRT_PROLOG_VERSION))", "    return FALSE;", "  if (prt_out_mbyte) {"], "readability/bool"]
["src/nvim/hardcopy.c", ["      EMSG(_(\"E456: Can't find PostScript resource file \\\"cidfont.ps\\\"\"));", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (!prt_open_resource(&res_cidfont))", "      return FALSE;", "    if (!prt_check_resource(&res_cidfont, PRT_CID_PROLOG_VERSION))"], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (!prt_check_resource(&res_cidfont, PRT_CID_PROLOG_VERSION))", "      return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["              p_encoding);", "          return FALSE;", "        }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (!prt_open_resource(&res_encoding))", "      return FALSE;", "    /* For the moment there are no checks on encoding resource files to"], "readability/bool"]
["src/nvim/hardcopy.c", ["            prt_ascii_encoding);", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      if (!prt_open_resource(&res_encoding))", "        return FALSE;", "      /* For the moment there are no checks on encoding resource files to"], "readability/bool"]
["src/nvim/hardcopy.c", ["          p_encoding);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    }", "    prt_do_conv = TRUE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["          prt_cmap);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (!prt_open_resource(&res_cmap))", "      return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  if (!prt_add_resource(&res_prolog))", "    return FALSE;", "  if (prt_out_mbyte) {"], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (!prt_add_resource(&res_cidfont))", "      return FALSE;", "    if (prt_custom_cmap && !prt_add_resource(&res_cmap))"], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (prt_custom_cmap && !prt_add_resource(&res_cmap))", "      return FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (!prt_add_resource(&res_encoding))", "      return FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["          prt_ps_mb_font.ps_fontname[PRT_PS_FONT_BOLD]);", "    } else", "      /* Use ROMAN for BOLD */"], "readability/braces"]
["src/nvim/hardcopy.c", ["          prt_ps_mb_font.ps_fontname[PRT_PS_FONT_OBLIQUE]);", "    } else", "      /* Use ROMAN for OBLIQUE */"], "readability/braces"]
["src/nvim/hardcopy.c", ["          prt_ps_mb_font.ps_fontname[PRT_PS_FONT_BOLDOBLIQUE]);", "    } else", "      /* Use BOLD for BOLDOBLIQUE */"], "readability/braces"]
["src/nvim/hardcopy.c", ["{", "  return mch_print_begin_page(NULL) ? (mch_print_end_page()) : FALSE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  prt_attribute_change = TRUE;", "  prt_need_moveto = TRUE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_attribute_change = TRUE;", "  prt_need_moveto = TRUE;", "  prt_half_width = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_need_moveto = TRUE;", "  prt_half_width = FALSE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["        /* No longer in ASCII range - need to switch font */", "        prt_in_ascii = FALSE;", "        prt_need_font = TRUE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["        prt_in_ascii = FALSE;", "        prt_need_font = TRUE;", "        prt_attribute_change = TRUE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["        prt_need_font = TRUE;", "        prt_attribute_change = TRUE;", "      }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      /* Now in ASCII range - need to switch font */", "      prt_in_ascii = TRUE;", "      prt_need_font = TRUE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["      prt_in_ascii = TRUE;", "      prt_need_font = TRUE;", "      prt_attribute_change = TRUE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["      prt_need_font = TRUE;", "      prt_attribute_change = TRUE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      if (!half_width) {", "        prt_half_width = FALSE;", "        prt_pos_x += prt_char_width/4;"], "readability/bool"]
["src/nvim/hardcopy.c", ["        prt_pos_x += prt_char_width/4;", "        prt_need_moveto = TRUE;", "        prt_attribute_change = TRUE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["        prt_need_moveto = TRUE;", "        prt_attribute_change = TRUE;", "      }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    } else if (half_width) {", "      prt_half_width = TRUE;", "      prt_pos_x += prt_char_width/4;"], "readability/bool"]
["src/nvim/hardcopy.c", ["      prt_pos_x += prt_char_width/4;", "      prt_need_moveto = TRUE;", "      prt_attribute_change = TRUE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["      prt_need_moveto = TRUE;", "      prt_attribute_change = TRUE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      prt_pos_y_moveto = prt_pos_y;", "      prt_do_moveto = TRUE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["", "      prt_need_moveto = FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      prt_write_string(\"sf\\n\");", "      prt_need_font = FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["        prt_write_string(\"g\\n\");", "      else {", "        prt_write_real(g / 255.0, 3);"], "readability/braces"]
["src/nvim/hardcopy.c", ["      }", "      prt_need_fgcol = FALSE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      if (prt_need_bgcol)", "        prt_do_bgcol = TRUE;", "    } else"], "readability/bool"]
["src/nvim/hardcopy.c", ["        prt_do_bgcol = TRUE;", "    } else", "      prt_do_bgcol = FALSE;"], "readability/braces"]
["src/nvim/hardcopy.c", ["    } else", "      prt_do_bgcol = FALSE;", "    prt_need_bgcol = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["      prt_do_bgcol = FALSE;", "    prt_need_bgcol = FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["      prt_do_underline = prt_underline;", "    prt_need_underline = FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["", "    prt_attribute_change = FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["      default:", "        sprintf((char *)ch_buff, \"%03o\", (unsigned int)ch);", "        ga_append(&prt_ps_buffer, (char)ch_buff[0]);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["      }", "    } else", "      ga_append(&prt_ps_buffer, (char)ch);"], "readability/braces"]
["src/nvim/hardcopy.c", ["    prt_font = font;", "    prt_attribute_change = TRUE;", "    prt_need_font = TRUE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["    prt_attribute_change = TRUE;", "    prt_need_font = TRUE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["    prt_underline = iUnderline;", "    prt_attribute_change = TRUE;", "    prt_need_underline = TRUE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["    prt_attribute_change = TRUE;", "    prt_need_underline = TRUE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_bgcol = bgcol;", "  prt_attribute_change = TRUE;", "  prt_need_bgcol = TRUE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_attribute_change = TRUE;", "  prt_need_bgcol = TRUE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["    prt_fgcol = fgcol;", "    prt_attribute_change = TRUE;", "    prt_need_fgcol = TRUE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["    prt_attribute_change = TRUE;", "    prt_need_fgcol = TRUE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "#include <sys/types.h>", "#include <sys/stat.h>"], "build/include_order"]
["src/nvim/if_cscope.c", ["#include <sys/types.h>", "#include <sys/stat.h>", "#if defined(UNIX)"], "build/include_order"]
["src/nvim/if_cscope.c", ["#if defined(UNIX)", "# include <sys/wait.h>", "#endif"], "build/include_order"]
["src/nvim/if_cscope.c", [" */", "static void ", "do_cscope_general ("], "whitespace/end_of_line"]
["src/nvim/if_cscope.c", ["static void ", "do_cscope_general (", "    exarg_T *eap,"], "whitespace/parens"]
["src/nvim/if_cscope.c", ["{", "  do_cscope_general(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["{", "  do_cscope_general(eap, TRUE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["{", "  int ret = FALSE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["    if (cs_check_for_connections()) {", "      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);"], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);", "      if (ret == FALSE) {"], "readability/bool"]
["src/nvim/if_cscope.c", ["          FALSE, *eap->cmdlinep);", "      if (ret == FALSE) {", "        cs_free_tags();"], "readability/bool"]
["src/nvim/if_cscope.c", ["        if (cs_check_for_tags())", "          ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);", "      }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    } else if (cs_check_for_tags()) {", "      ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);", "    }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    if (cs_check_for_tags()) {", "      ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);", "      if (ret == FALSE) {"], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = do_tag(eap->arg, DT_JUMP, 0, eap->forceit, FALSE);", "      if (ret == FALSE) {", "        if (msg_col)"], "readability/bool"]
["src/nvim/if_cscope.c", ["          ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit,", "              FALSE, FALSE, *eap->cmdlinep);", "          if (ret == FALSE)"], "readability/bool"]
["src/nvim/if_cscope.c", ["              FALSE, FALSE, *eap->cmdlinep);", "          if (ret == FALSE)", "            cs_free_tags();"], "readability/bool"]
["src/nvim/if_cscope.c", ["    } else if (cs_check_for_connections()) {", "      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);"], "readability/bool"]
["src/nvim/if_cscope.c", ["      ret = cs_find_common(\"g\", (char *)(eap->arg), eap->forceit, FALSE,", "          FALSE, *eap->cmdlinep);", "      if (ret == FALSE)"], "readability/bool"]
["src/nvim/if_cscope.c", ["          FALSE, *eap->cmdlinep);", "      if (ret == FALSE)", "        cs_free_tags();"], "readability/bool"]
["src/nvim/if_cscope.c", ["  }", "", "} /* do_cscope */"], "whitespace/blank_line"]
["src/nvim/if_cscope.c", ["", "  return FALSE;", "} /* cs_fgets */"], "readability/bool"]
["src/nvim/if_cscope.c", ["    if (num == 0)", "      return TRUE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["      if (strstr(csinfo[i].fname, (char *)dbpath))", "        return TRUE;", "      break;"], "readability/bool"]
["src/nvim/if_cscope.c", ["      if (strcmp(csinfo[i].fname, (char *)dbpath) == 0)", "        return TRUE;", "      break;"], "readability/bool"]
["src/nvim/if_cscope.c", ["                  && strstr(csinfo[i].ppath, (char *)ppath))))", "        return TRUE;", "      break;"], "readability/bool"]
["src/nvim/if_cscope.c", ["                  && (strcmp(csinfo[i].ppath, (char *)ppath) == 0))))", "        return TRUE;", "      break;"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  return FALSE;", "} /* cs_connection */"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  if ((fname = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Add);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  }", "  if ((ppath = strtok((char *)NULL, (const char *)\" \")) != NULL)", "    flags = strtok((char *)NULL, (const char *)\" \");"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  if ((ppath = strtok((char *)NULL, (const char *)\" \")) != NULL)", "    flags = strtok((char *)NULL, (const char *)\" \");", ""], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "  (void)sprintf(buf, stat_emsg, fname, errno);", "  (void)EMSG(buf);"], "runtime/printf"]
["src/nvim/if_cscope.c", [" */", "static int ", "cs_add_common ("], "whitespace/end_of_line"]
["src/nvim/if_cscope.c", ["static int ", "cs_add_common (", "    char *arg1,         /* filename - may contain environment variables */"], "whitespace/parens"]
["src/nvim/if_cscope.c", ["    if (fname[0] == '\\0')", "      (void)sprintf(fname2, \"/%s\", CSCOPE_DBFILE);", "    else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    else", "      (void)sprintf(fname2, \"%s/%s\", fname, CSCOPE_DBFILE);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["  }", "  else if (S_ISREG(file_info.stat.st_mode) || S_ISLNK(file_info.stat.st_mode))", "  {"], "whitespace/newline"]
["src/nvim/if_cscope.c", ["     */", "    if ((stok = strtok(buf, (const char *)\" \")) == NULL)", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL)", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL)", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  char *cmd;", "  short search;", "  char *pat;"], "runtime/int"]
["src/nvim/if_cscope.c", ["", "  (void)sprintf(cmd, \"%d%s\", search, pat);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["  sa.nLength = sizeof(SECURITY_ATTRIBUTES);", "  sa.bInheritHandle = TRUE;", "  sa.lpSecurityDescriptor = NULL;"], "readability/bool"]
["src/nvim/if_cscope.c", ["#if defined(UNIX)", "    (void)sprintf(cmd, \"exec %s -dl -f %s\", prog, csinfo[i].fname);", "#else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    /* WIN32 */", "    (void)sprintf(cmd, \"%s -dl -f %s\", prog, csinfo[i].fname);", "#endif"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].ppath != NULL) {", "      (void)strcat(cmd, \" -P\");", "      (void)strcat(cmd, csinfo[i].ppath);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      (void)strcat(cmd, \" -P\");", "      (void)strcat(cmd, csinfo[i].ppath);", "    }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].flags != NULL) {", "      (void)strcat(cmd, \" \");", "      (void)strcat(cmd, csinfo[i].flags);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      (void)strcat(cmd, \" \");", "      (void)strcat(cmd, csinfo[i].flags);", "    }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    si.hStdInput  = stdin_rd;", "    created = CreateProcess(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE,", "        NULL, NULL, &si, &pi);"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  if (cs_check_for_connections() == FALSE) {", "    (void)EMSG(_(\"E567: no cscope connections\"));"], "readability/bool"]
["src/nvim/if_cscope.c", ["    (void)EMSG(_(\"E567: no cscope connections\"));", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  if ((opt = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Find);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    cs_usage_msg(Find);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    cs_usage_msg(Find);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  return cs_find_common(opt, pat, eap->forceit, TRUE,", "      eap->cmdidx == CMD_lcscope, *eap->cmdlinep);"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "      sprintf(buf, nf, *qfpos, *(qfpos-1));", "      (void)EMSG(buf);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      xfree(buf);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/if_cscope.c", ["      apply_autocmds(EVENT_QUICKFIXCMDPRE, (char_u *)\"cscope\",", "          curbuf->b_fname, TRUE, curbuf);", "      if (did_throw || force_abort)"], "readability/bool"]
["src/nvim/if_cscope.c", ["      if (did_throw || force_abort)", "        return FALSE;", "    }"], "readability/bool"]
["src/nvim/if_cscope.c", ["  if (cmd == NULL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["      xfree(nummatches);", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    buf = xmalloc(strlen(opt) + strlen(pat) + strlen(nf));", "    sprintf(buf, nf, opt, pat);", "    (void)EMSG(buf);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    xfree(nummatches);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["      EMSG2(_(e_notopen), tmp);", "    else {", "      cs_file_results(f, nummatches);"], "readability/braces"]
["src/nvim/if_cscope.c", ["        apply_autocmds(EVENT_QUICKFIXCMDPOST, (char_u *)\"cscope\",", "            curbuf->b_fname, TRUE, curbuf);", "        if (use_ll)"], "readability/bool"]
["src/nvim/if_cscope.c", ["    xfree(nummatches);", "    return TRUE;", "  } else {"], "readability/bool"]
["src/nvim/if_cscope.c", ["    if (matches == NULL)", "      return FALSE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["  }", "", "} /* cs_find_common */"], "whitespace/blank_line"]
["src/nvim/if_cscope.c", ["", "  wait_return(TRUE);", "  return CSCOPE_SUCCESS;"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  (void)strcpy(csinfo[i].fname, (const char *)fname);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["    csinfo[i].ppath = xmalloc(strlen(ppath) + 1);", "    (void)strcpy(csinfo[i].ppath, (const char *)ppath);", "  } else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    (void)strcpy(csinfo[i].ppath, (const char *)ppath);", "  } else", "    csinfo[i].ppath = NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["    csinfo[i].flags = xmalloc(strlen(flags) + 1);", "    (void)strcpy(csinfo[i].flags, (const char *)flags);", "  } else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    (void)strcpy(csinfo[i].flags, (const char *)flags);", "  } else", "    csinfo[i].flags = NULL;"], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  if ((stok = strtok((char *)(eap->arg), (const char *)\" \")) == NULL)", "    return NULL;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "  if ((stok = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Kill);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  }", "  cs_release_csp(i, TRUE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "    (void)sprintf(buf, \"%s\\t%s\\t%s;\\\"\\t%s\", tagstr, fname, slno, search);", "  } else {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "    (void)sprintf(buf, \"%s\\t%s\\t%s;\\\"\", tagstr, fname, slno);", "  }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    while ((ch = getc(csinfo[cnumber].fr_fp)) != EOF && ch != '\\n')", "      ;", "    return NULL;"], "whitespace/semicolon"]
["src/nvim/if_cscope.c", ["   */", "  if ((name = strtok((char *)buf, (const char *)\" \")) == NULL)", "    return NULL;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    return NULL;", "  if ((*context = strtok(NULL, (const char *)\" \")) == NULL)", "    return NULL;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    return NULL;", "  if ((*linenumber = strtok(NULL, (const char *)\" \")) == NULL)", "    return NULL;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "      if (strcmp(cntx, \"<global>\")==0)", "        strcpy(context, \"<<global>>\");"], "whitespace/operators"]
["src/nvim/if_cscope.c", ["      if (strcmp(cntx, \"<global>\")==0)", "        strcpy(context, \"<<global>>\");", "      else"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      else", "        sprintf(context, \"<<%s>>\", cntx);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["    (void)cs_read_prompt(i);", "", "  }   /* for all cscope connections */"], "whitespace/blank_line"]
["src/nvim/if_cscope.c", ["        cntxts[totsofar] = NULL;", "      else {", "        cntxts[totsofar] = xstrdup(cntx);"], "readability/braces"]
["src/nvim/if_cscope.c", ["      totsofar++;", "", "    }     /* for all matches */"], "whitespace/blank_line"]
["src/nvim/if_cscope.c", ["    (void)cs_read_prompt(i);", "", "  }   /* for all cscope connections */"], "whitespace/blank_line"]
["src/nvim/if_cscope.c", ["", "  assert (num_matches > 0);", ""], "whitespace/parens"]
["src/nvim/if_cscope.c", ["", "  strcpy(tbuf, matches[0]);", "  ptag = strtok(tbuf, \"\\t\");"], "runtime/printf"]
["src/nvim/if_cscope.c", ["  strcpy(tbuf, matches[0]);", "  ptag = strtok(tbuf, \"\\t\");", ""], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  size_t bufsize = newsize;  // Track available bufsize", "  (void)sprintf(buf, cstag_msg, ptag);", "  MSG_PUTS_ATTR(buf, hl_attr(HLF_T));"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    tbuf = xmalloc(strlen(matches[idx]) + 1);", "    (void)strcpy(tbuf, matches[idx]);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "    if (strtok(tbuf, (const char *)\"\\t\") == NULL)", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["      continue;", "    if ((fname = strtok(NULL, (const char *)\"\\t\")) == NULL)", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["      continue;", "    if ((lno = strtok(NULL, (const char *)\"\\t\")) == NULL)", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["      continue;", "    extra = strtok(NULL, (const char *)\"\\t\");", ""], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    }", "    (void)sprintf(buf, csfmt_str, num, lno);", "    MSG_PUTS_ATTR(buf, hl_attr(HLF_CM));"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    }", "    (void)sprintf(buf, cntxformat, context);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["    if (got_int) {", "      got_int = FALSE;          /* don't print any more matches */", "      break;"], "readability/bool"]
["src/nvim/if_cscope.c", ["          cs_reading_emsg(i);           /* don't have additional information */", "        cs_release_csp(i, TRUE);", "        xfree(buf);"], "readability/bool"]
["src/nvim/if_cscope.c", ["# ifdef ECHILD", "      int alive = TRUE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["          if (kill(csinfo[i].pid, 0) != 0) {", "            alive = FALSE;             /* cscope process no longer exists */", "            break;"], "readability/bool"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].fname != NULL)", "      cs_release_csp(i, FALSE);", "  }"], "readability/bool"]
["src/nvim/if_cscope.c", ["    fullname = xmalloc(len);", "    (void)sprintf(fullname, \"%s/%s\", csinfo[i].ppath, name);", "  } else if (csdir != NULL && csinfo[i].fname != NULL && *csdir != NUL) {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["     * cscope output. */", "    fullname = concat_fnames((char *)csdir, name, TRUE);", "  } else {"], "readability/bool"]
["src/nvim/if_cscope.c", ["    MSG_PUTS(_(\"no cscope connections\\n\"));", "  else {", "    MSG_PUTS_ATTR("], "readability/braces"]
["src/nvim/if_cscope.c", ["", "  wait_return(TRUE);", "  return CSCOPE_SUCCESS;"], "readability/bool"]
["src/nvim/indent_c.c", ["pos_T *", "find_start_comment (  /* XXX */", "    int ind_maxcomment"], "whitespace/parens"]
["src/nvim/indent_c.c", ["  }", "  if (!vim_isIDc(*s))\t{   // need at least one ID character", "    return FALSE;"], "whitespace/tab"]
["src/nvim/indent_c.c", ["  }", "  if (!vim_isIDc(*s))\t{   // need at least one ID character", "    return FALSE;"], "whitespace/braces"]
["src/nvim/indent_c.c", ["  if (!vim_isIDc(*s))\t{   // need at least one ID character", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/indent_c.c", ["  if (!vim_isIDc(**s))              /* need at least one ID character */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["  if (cin_isdefault(s))", "    return FALSE;", "  if (cin_isscopedecl(s))"], "readability/bool"]
["src/nvim/indent_c.c", ["  if (cin_isscopedecl(s))", "    return FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["  if (!cin_islabel_skip(&s)) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/indent_c.c", ["    curwin->w_cursor = cursor_save;", "    if (cin_isterminated(line, TRUE, FALSE)", "        || cin_isscopedecl(line)"], "readability/bool"]
["src/nvim/indent_c.c", ["        || cin_isscopedecl(line)", "        || cin_iscase(line, TRUE)", "        || (cin_islabel_skip(&line) && cin_nocode(line)))"], "readability/bool"]
["src/nvim/indent_c.c", ["        || (cin_islabel_skip(&line) && cin_nocode(line)))", "      return TRUE;", "    return FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["      return TRUE;", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/indent_c.c", ["  curwin->w_cursor = cursor_save;", "  return TRUE;                /* label at start of file??? */", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["  if (cin_starts_with(s, \"enum\"))", "    return TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["  if (cin_ends_in(s, (char_u *)\"=\", (char_u *)\"{\"))", "    return TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", [" */", "int ", "cin_iscase ("], "whitespace/end_of_line"]
["src/nvim/indent_c.c", ["int ", "cin_iscase (", "    char_u *s,"], "whitespace/parens"]
["src/nvim/indent_c.c", ["        else", "          return TRUE;", "      }"], "readability/bool"]
["src/nvim/indent_c.c", ["      else if (*s == '/' && (s[1] == '*' || s[1] == '/'))", "        return FALSE;                   /* stop at comment */", "      else if (*s == '\"') {"], "readability/bool"]
["src/nvim/indent_c.c", ["        if (strict)", "          return FALSE;                         /* stop at string */", "        else"], "readability/bool"]
["src/nvim/indent_c.c", ["        else", "          return TRUE;", "      }"], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/indent_c.c", ["  if (cin_isdefault(s))", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["  else", "    return FALSE;", "  return *(s = cin_skipcomment(s + i)) == ':' && s[1] != ':';"], "readability/bool"]
["src/nvim/indent_c.c", ["  char_u      *p;", "  int has_name = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["      if (ascii_iswhite(*p)) {", "        has_name = TRUE;         /* found end of a name */", "        p = cin_skipcomment(skipwhite(p));"], "readability/bool"]
["src/nvim/indent_c.c", ["        if (has_name)", "          return FALSE;           /* word character after skipping past name */", "        ++p;"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else {", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["        ++l;", "      else if (!cin_iscase(l + 1, FALSE))", "        break;"], "readability/bool"]
["src/nvim/indent_c.c", ["        break;", "    } else if (*l == '\\'' && l[1] && l[2] == '\\'')", "      l += 2;                       /* skip over 'x' */"], "readability/braces"]
["src/nvim/indent_c.c", [" */", "static int ", "get_indent_nolabel (     /* XXX */"], "whitespace/end_of_line"]
["src/nvim/indent_c.c", ["static int ", "get_indent_nolabel (     /* XXX */", "    linenr_T lnum"], "whitespace/parens"]
["src/nvim/indent_c.c", ["  /* XXX */", "  if (cin_iscase(l, FALSE) || cin_isscopedecl(l) || cin_islabel()) {", "    amount = get_indent_nolabel(lnum);"], "readability/bool"]
["src/nvim/indent_c.c", ["  for (len = 0; vim_isIDc(p[len]); ++len)", "    ;", "  if (len == 0 || !ascii_iswhite(p[len]) || cin_nocode(p))"], "whitespace/semicolon"]
["src/nvim/indent_c.c", ["  if (*skipwhite(s) == '#')", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["  linenr_T lnum = *lnump;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["    if (cin_ispreproc(line)) {", "      retval = TRUE;", "      *lnump = lnum;"], "readability/bool"]
["src/nvim/indent_c.c", ["static char_u", "cin_isterminated (", "    char_u *s,"], "whitespace/parens"]
["src/nvim/indent_c.c", ["  unsigned n_open = 0;", "  int is_else = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["  linenr_T lnum = first_lnum;", "  int retval = FALSE;", "  pos_T       *trypos;"], "readability/bool"]
["src/nvim/indent_c.c", ["  pos_T       *trypos;", "  int just_started = TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["    if (lnum < min_lnum)", "      return FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["  if (cin_ispreproc(s))", "    return FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["  if (*s != '(')", "    return FALSE;               /* ';', ' or \"  before any () or no '(' */", ""], "readability/bool"]
["src/nvim/indent_c.c", ["      if (*s == NUL || s[STRLEN(s) - 1] != '\\\\')", "        retval = TRUE;", "      goto done;"], "readability/bool"]
["src/nvim/indent_c.c", ["        break;", "      just_started = FALSE;", "    } else if (cin_iscomment(s))        /* ignore comments */"], "readability/bool"]
["src/nvim/indent_c.c", ["      just_started = FALSE;", "    } else if (cin_iscomment(s))        /* ignore comments */", "      s = cin_skipcomment(s);"], "readability/braces"]
["src/nvim/indent_c.c", ["      s = cin_skipcomment(s);", "    else {", "      ++s;"], "readability/braces"]
["src/nvim/indent_c.c", ["      ++s;", "      just_started = FALSE;", "    }"], "readability/bool"]
["src/nvim/indent_c.c", [" */", "static int ", "cin_iswhileofdo ( /* XXX */"], "whitespace/end_of_line"]
["src/nvim/indent_c.c", ["static int ", "cin_iswhileofdo ( /* XXX */", "    char_u *p,"], "whitespace/parens"]
["src/nvim/indent_c.c", ["  pos_T       *trypos;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["        && *cin_skipcomment(ml_get_pos(trypos) + 1) == ';')", "      retval = TRUE;", "    curwin->w_cursor = cursor_save;"], "readability/bool"]
["src/nvim/indent_c.c", ["  if (terminated != ';')        /* there must be a ';' at the end */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["            curwin->w_cursor.lnum = trypos->lnum;", "            return TRUE;", "          }"], "readability/bool"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", [" */", "static int ", "cin_is_cpp_baseclass ("], "whitespace/end_of_line"]
["src/nvim/indent_c.c", ["static int ", "cin_is_cpp_baseclass (", "    colnr_T *col           /* return: column to align with */"], "whitespace/parens"]
["src/nvim/indent_c.c", ["  if (*s == '#')                /* skip #define FOO x ? (x) : x */", "    return FALSE;", "  s = cin_skipcomment(s);"], "readability/bool"]
["src/nvim/indent_c.c", ["  if (*s == NUL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["         * initialization any more */", "        lookfor_ctor_init = FALSE;", "        s = cin_skipcomment(s + 2);"], "readability/bool"]
["src/nvim/indent_c.c", ["         * cpp-base-class-declaration or constructor-initialization */", "        cpp_base_class = TRUE;", "        lookfor_ctor_init = class_or_struct = FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["        cpp_base_class = TRUE;", "        lookfor_ctor_init = class_or_struct = FALSE;", "        *col = 0;"], "readability/bool"]
["src/nvim/indent_c.c", ["        s = cin_skipcomment(s + 1);", "      } else", "        s = cin_skipcomment(s + 1);"], "readability/braces"]
["src/nvim/indent_c.c", ["               || (STRNCMP(s, \"struct\", 6) == 0 && !vim_isIDc(s[6]))) {", "      class_or_struct = TRUE;", "      lookfor_ctor_init = FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["      class_or_struct = TRUE;", "      lookfor_ctor_init = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["      if (s[0] == '{' || s[0] == '}' || s[0] == ';') {", "        cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;", "      } else if (s[0] == ')') {"], "readability/bool"]
["src/nvim/indent_c.c", ["         * something like \"):\" */", "        class_or_struct = FALSE;", "        lookfor_ctor_init = TRUE;"], "readability/bool"]
["src/nvim/indent_c.c", ["        class_or_struct = FALSE;", "        lookfor_ctor_init = TRUE;", "      } else if (s[0] == '?') {"], "readability/bool"]
["src/nvim/indent_c.c", ["        /* Avoid seeing '() :' after '?' as constructor init. */", "        return FALSE;", "      } else if (!vim_isIDc(s[0])) {"], "readability/bool"]
["src/nvim/indent_c.c", ["        /* if it is not an identifier, we are wrong */", "        class_or_struct = FALSE;", "        lookfor_ctor_init = FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["        class_or_struct = FALSE;", "        lookfor_ctor_init = FALSE;", "      } else if (*col == 0) {"], "readability/bool"]
["src/nvim/indent_c.c", ["        /* it can't be a constructor-initialization any more */", "        lookfor_ctor_init = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["      if (cin_nocode(r))", "        return TRUE;", "    }"], "readability/bool"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["      p = cin_skipcomment(p);", "    else {", "      p = skip_string(p);"], "readability/braces"]
["src/nvim/indent_c.c", ["/* foo()    */", "/* {\t    */", "/* }\t    */"], "whitespace/tab"]
["src/nvim/indent_c.c", ["/* {\t    */", "/* }\t    */", ""], "whitespace/tab"]
["src/nvim/indent_c.c", ["    pos = NULL;", "    /* ignore the { if it's in a // or / *  * / comment */", "    if ((colnr_T)cin_skip2pos(trypos) == trypos->col"], "readability/multiline_comment"]
["src/nvim/indent_c.c", ["    pos = NULL;", "    /* ignore the { if it's in a // or / *  * / comment */", "    if ((colnr_T)cin_skip2pos(trypos) == trypos->col"], "whitespace/comments"]
["src/nvim/indent_c.c", ["  if ((trypos = findmatchlimit(NULL, c, 0, ind_maxparen)) != NULL) {", "    /* check if the ( is in a // comment */", "    if ((colnr_T)cin_skip2pos(trypos) > trypos->col)"], "readability/multiline_comment"]
["src/nvim/indent_c.c", ["  if ((trypos = findmatchlimit(NULL, c, 0, ind_maxparen)) != NULL) {", "    /* check if the ( is in a // comment */", "    if ((colnr_T)cin_skip2pos(trypos) > trypos->col)"], "whitespace/comments"]
["src/nvim/indent_c.c", ["      trypos = NULL;", "    else {", "      pos_copy = *trypos;           /* copy trypos, findmatch will change it */"], "readability/braces"]
["src/nvim/indent_c.c", ["  int i;", "  int retval = FALSE;", "  int open_count = 0;"], "readability/bool"]
["src/nvim/indent_c.c", ["        --open_count;", "      else {", "        curwin->w_cursor.col = i;"], "readability/braces"]
["src/nvim/indent_c.c", ["        curwin->w_cursor.col = i;", "        retval = TRUE;", "      }"], "readability/bool"]
["src/nvim/indent_c.c", ["        n = sw;         /* just \"s\" is one 'shiftwidth' */", "      else {", "        n *= sw;"], "readability/braces"]
["src/nvim/indent_c.c", ["  int lookfor_break;", "  int lookfor_cpp_namespace = FALSE;", "  int cont_amount = 0;              /* amount for continuation line */"], "readability/bool"]
["src/nvim/indent_c.c", ["   */", "  if (*theline == '#' && (*linecopy == '#' || in_cinkeys('#', ' ', TRUE)))", "    amount = curbuf->b_ind_hash_comment;"], "readability/bool"]
["src/nvim/indent_c.c", ["   */", "  else if (cin_islinecomment(theline)", "           && (trypos = find_line_comment()) != NULL) { /* XXX */"], "whitespace/newline"]
["src/nvim/indent_c.c", ["   */", "  else if (!cin_iscomment(theline)", "           && (trypos = ind_find_start_comment()) != NULL) {"], "whitespace/newline"]
["src/nvim/indent_c.c", ["    int start_off = 0;", "    int done = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["        }", "        else", "          ++p;"], "whitespace/newline"]
["src/nvim/indent_c.c", ["            && STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0) {", "          done = TRUE;", "          if (curwin->w_cursor.lnum > 1) {"], "readability/bool"]
["src/nvim/indent_c.c", ["             * start of the comment, skip this entry. XXX */", "            else if (STRNCMP(ml_get(trypos->lnum) + trypos->col,", "                         lead_start, lead_start_len) != 0)"], "whitespace/newline"]
["src/nvim/indent_c.c", ["                      - vim_strsize(lead_middle);", "          done = TRUE;", "          break;"], "readability/bool"]
["src/nvim/indent_c.c", ["    if (done)", "      ;", "    else if (theline[0] == '*')"], "whitespace/semicolon"]
["src/nvim/indent_c.c", ["      amount += 1;", "    else {", "      /*"], "readability/braces"]
["src/nvim/indent_c.c", ["  // Are we looking at a ']' that has a match?", "  else if (*skipwhite(theline) == ']'", "           && (trypos = find_match_char('[', curbuf->b_ind_maxparen)) != NULL) {"], "whitespace/newline"]
["src/nvim/indent_c.c", ["   */\t\t\t\t\t\t    /* XXX */", "  else if (((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL", "            && curbuf->b_ind_java == 0)"], "whitespace/newline"]
["src/nvim/indent_c.c", ["              amount += n * curbuf->b_ind_unclosed_wrapped;", "            } else if (curbuf->b_ind_unclosed_whiteok)", "              our_paren_pos.col++;"], "readability/braces"]
["src/nvim/indent_c.c", ["              our_paren_pos.col++;", "            else {", "              col = our_paren_pos.col + 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["            amount += curbuf->b_ind_unclosed;", "          else {", "            curwin->w_cursor.lnum = our_paren_pos.lnum;"], "readability/braces"]
["src/nvim/indent_c.c", ["        // It could have been something like", "        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {"], "whitespace/tab"]
["src/nvim/indent_c.c", ["        // It could have been something like", "        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {"], "whitespace/comments"]
["src/nvim/indent_c.c", ["        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {", "        //\t\t    }"], "whitespace/tab"]
["src/nvim/indent_c.c", ["        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {", "        //\t\t    }"], "whitespace/comments"]
["src/nvim/indent_c.c", ["        //\t\t\tldfd) {", "        //\t\t    }", "        if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)"], "whitespace/tab"]
["src/nvim/indent_c.c", ["        //\t\t\tldfd) {", "        //\t\t    }", "        if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)"], "whitespace/comments"]
["src/nvim/indent_c.c", ["        if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)", "            && cin_iscase(skipwhite(get_cursor_line_ptr()), FALSE)) {", "          amount = get_indent();"], "readability/bool"]
["src/nvim/indent_c.c", ["          amount = curbuf->b_ind_open_left_imag;", "          lookfor_cpp_namespace = TRUE;", "        } else if (start_brace == BRACE_AT_START &&"], "readability/bool"]
["src/nvim/indent_c.c", ["                   lookfor_cpp_namespace) {       /* '{' is at start */", "", "          lookfor_cpp_namespace = TRUE;"], "whitespace/blank_line"]
["src/nvim/indent_c.c", ["", "          lookfor_cpp_namespace = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/indent_c.c", ["", "        lookfor_break = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "        if (cin_iscase(theline, FALSE)) {       /* it's a switch() label */", "          lookfor = LOOKFOR_CASE;       /* find a previous switch() label */"], "readability/bool"]
["src/nvim/indent_c.c", ["            /* break; ... */", "            lookfor_break = TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "              terminated = cin_isterminated(l, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/indent_c.c", ["           */", "          iscase = cin_iscase(l, FALSE);", "          if (iscase || cin_isscopedecl(l)) {"], "readability/bool"]
["src/nvim/indent_c.c", ["           */\t\t\t\t\t\t    /* XXX */", "          n = FALSE;", "          if (lookfor != LOOKFOR_TERM && curbuf->b_ind_cpp_baseclass > 0) {"], "readability/bool"]
["src/nvim/indent_c.c", ["              continue;", "            } else", "              /* XXX */"], "readability/braces"]
["src/nvim/indent_c.c", ["             */", "            if (cin_isterminated(l, TRUE, FALSE))", "              break;"], "readability/bool"]
["src/nvim/indent_c.c", ["           */", "          terminated = cin_isterminated(l, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/indent_c.c", ["          if (js_cur_has_key) {", "            js_cur_has_key = false; // only check the first line", "            if (curbuf->b_ind_js && terminated == ',') {"], "whitespace/comments"]
["src/nvim/indent_c.c", ["            // that starts it so we can get the right prevailing indent", "            //\t   if ( foo &&", "            //\t\t    bar )"], "whitespace/tab"]
["src/nvim/indent_c.c", ["            // that starts it so we can get the right prevailing indent", "            //\t   if ( foo &&", "            //\t\t    bar )"], "whitespace/comments"]
["src/nvim/indent_c.c", ["            //\t   if ( foo &&", "            //\t\t    bar )", ""], "whitespace/tab"]
["src/nvim/indent_c.c", ["            //\t   if ( foo &&", "            //\t\t    bar )", ""], "whitespace/comments"]
["src/nvim/indent_c.c", ["              l = get_cursor_line_ptr();", "              if (cin_iscase(l, FALSE) || cin_isscopedecl(l)) {", "                ++curwin->w_cursor.lnum;"], "readability/bool"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "readability/braces"]
["src/nvim/indent_c.c", ["                    // XXX", "                    cont_amount = cin_get_equal_amount( curwin->w_cursor.lnum);", "                  }"], "whitespace/parens"]
["src/nvim/indent_c.c", ["           */", "          else if (cin_iswhileofdo_end(terminated)) {  // XXX", "            /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["           */", "          else {", "            /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["           */", "          else {", "            /*"], "readability/braces"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "readability/braces"]
["src/nvim/indent_c.c", ["                l = get_cursor_line_ptr();", "                if (cin_iscase(l, FALSE) || cin_isscopedecl(l)) {", "                  ++curwin->w_cursor.lnum;"], "readability/bool"]
["src/nvim/indent_c.c", ["              iscase = (curbuf->b_ind_keep_case_label", "                        && cin_iscase(l, FALSE));", ""], "readability/bool"]
["src/nvim/indent_c.c", ["  }", "  else {", "    // Ok -- we're not inside any sort of structure at all!"], "whitespace/newline"]
["src/nvim/indent_c.c", ["  }", "  else {", "    // Ok -- we're not inside any sort of structure at all!"], "readability/braces"]
["src/nvim/indent_c.c", ["     */", "    else if (cur_curpos.lnum < curbuf->b_ml.ml_line_count", "             && !cin_nocode(theline)"], "whitespace/newline"]
["src/nvim/indent_c.c", ["                 cur_curpos.lnum + 1)", "             && !cin_isterminated(theline, FALSE, TRUE)) {", "      amount = curbuf->b_ind_func_type;"], "readability/bool"]
["src/nvim/indent_c.c", ["         */\t\t\t\t\t\t    /* XXX */", "        n = FALSE;", "        if (curbuf->b_ind_cpp_baseclass != 0 && theline[0] != '{') {"], "readability/bool"]
["src/nvim/indent_c.c", ["  return amount;", "}", ""], "readability/fn_size"]
["src/nvim/keymap.c", ["static struct modmasktable {", "  short mod_mask;               /* Bit-mask for particular key modifier */", "  short mod_flag;               /* Bit(s) for particular key modifier */"], "runtime/int"]
["src/nvim/keymap.c", ["  short mod_mask;               /* Bit-mask for particular key modifier */", "  short mod_flag;               /* Bit(s) for particular key modifier */", "  char_u name;                  /* Single letter name of modifier */"], "runtime/int"]
["src/nvim/keymap.c", ["{", "  /*  mod mask\t    with modifier\t\twithout modifier */", "  MOD_MASK_SHIFT, '&', '9',                   '@', '1',         /* begin */"], "whitespace/tab"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '*', '3',                   '@', '6',         /* create */", "  MOD_MASK_SHIFT, '*', '4',                   'k', 'D',         /* delete char */", "  MOD_MASK_SHIFT, '*', '5',                   'k', 'L',         /* delete line */"], "whitespace/line_length"]
["src/nvim/keymap.c", ["  MOD_MASK_SHIFT, '*', '4',                   'k', 'D',         /* delete char */", "  MOD_MASK_SHIFT, '*', '5',                   'k', 'L',         /* delete line */", "  MOD_MASK_SHIFT, '*', '7',                   '@', '7',         /* end */"], "whitespace/line_length"]
["src/nvim/keymap.c", ["  {K_MOUSERIGHT,      (char_u *)\"ScrollWheelLeft\"},", "  {K_MOUSEDOWN,       (char_u *)\"MouseDown\"},   /* OBSOLETE: Use\t  */", "  {K_MOUSEUP,         (char_u *)\"MouseUp\"},     /* ScrollWheelXXX instead */"], "whitespace/tab"]
["src/nvim/keymap.c", ["{", "  {(int)KE_LEFTMOUSE,         MOUSE_LEFT,     TRUE,   FALSE},", "  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_LEFTMOUSE,         MOUSE_LEFT,     TRUE,   FALSE},", "  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},", "  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_LEFTDRAG,          MOUSE_LEFT,     FALSE,  TRUE},", "  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},", "  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_LEFTRELEASE,       MOUSE_LEFT,     FALSE,  FALSE},", "  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},", "  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_MIDDLEMOUSE,       MOUSE_MIDDLE,   TRUE,   FALSE},", "  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},", "  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_MIDDLEDRAG,        MOUSE_MIDDLE,   FALSE,  TRUE},", "  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},", "  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_MIDDLERELEASE,     MOUSE_MIDDLE,   FALSE,  FALSE},", "  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},", "  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_RIGHTMOUSE,        MOUSE_RIGHT,    TRUE,   FALSE},", "  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},", "  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_RIGHTDRAG,         MOUSE_RIGHT,    FALSE,  TRUE},", "  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},", "  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_RIGHTRELEASE,      MOUSE_RIGHT,    FALSE,  FALSE},", "  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},", "  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_X1MOUSE,           MOUSE_X1,       TRUE,   FALSE},", "  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},", "  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_X1DRAG,            MOUSE_X1,       FALSE,  TRUE},", "  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},", "  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_X1RELEASE,         MOUSE_X1,       FALSE,  FALSE},", "  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},", "  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_X2MOUSE,           MOUSE_X2,       TRUE,   FALSE},", "  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},", "  {(int)KE_X2RELEASE,         MOUSE_X2,       FALSE,  FALSE},"], "readability/bool"]
["src/nvim/keymap.c", ["  {(int)KE_X2DRAG,            MOUSE_X2,       FALSE,  TRUE},", "  {(int)KE_X2RELEASE,         MOUSE_X2,       FALSE,  FALSE},", "  /* DRAG without CLICK */"], "readability/bool"]
["src/nvim/keymap.c", ["  /* DRAG without CLICK */", "  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  TRUE},", "  /* RELEASE without CLICK */"], "readability/bool"]
["src/nvim/keymap.c", ["  /* RELEASE without CLICK */", "  {(int)KE_IGNORE,            MOUSE_RELEASE,  FALSE,  FALSE},", "  {0,                         0,              0,      0},"], "readability/bool"]
["src/nvim/keymap.c", ["    /* Not a special key, only modifiers, output directly */", "    else {", "      if (has_mbyte && (*mb_char2len)(c) > 1)"], "whitespace/newline"]
["src/nvim/keymap.c", ["    /* Not a special key, only modifiers, output directly */", "    else {", "      if (has_mbyte && (*mb_char2len)(c) > 1)"], "readability/braces"]
["src/nvim/keymap.c", ["        string[idx++] = (char_u)c;", "      else {", "        s = transchar(c);"], "readability/braces"]
["src/nvim/keymap.c", [" */", "unsigned int ", "trans_special ("], "whitespace/end_of_line"]
["src/nvim/keymap.c", ["unsigned int ", "trans_special (", "    char_u **srcp,"], "whitespace/parens"]
["src/nvim/keymap.c", ["", "  key = find_special_key(srcp, &modifiers, keycode, FALSE);", "  if (key == 0)"], "readability/bool"]
["src/nvim/keymap.c", ["    dst[dlen++] = KEY2TERMCAP1(key);", "  } else if (has_mbyte && !keycode)", "    dlen += (unsigned int)(*mb_char2bytes)(key, dst + dlen);"], "readability/braces"]
["src/nvim/keymap.c", ["  }", "  else", "    dst[dlen++] = (char_u)key;"], "whitespace/newline"]
["src/nvim/keymap.c", [" */", "int ", "find_special_key ("], "whitespace/end_of_line"]
["src/nvim/keymap.c", ["int ", "find_special_key (", "    char_u **srcp,"], "whitespace/parens"]
["src/nvim/keymap.c", ["    int *modp,", "    int keycode,                 /* prefer key code, e.g. K_DEL instead of DEL */", "    int keep_x_key              /* don't translate xHome to Home key */"], "whitespace/line_length"]
["src/nvim/keymap.c", ["    else if (STRNICMP(bp, \"char-\", 5) == 0) {", "      vim_str2nr(bp + 5, NULL, &l, TRUE, TRUE, NULL, NULL);", "      bp += l + 5;"], "readability/bool"]
["src/nvim/keymap.c", ["        /* <Char-123> or <Char-033> or <Char-0x33> */", "        vim_str2nr(last_dash + 6, NULL, NULL, TRUE, TRUE, NULL, &n);", "        key = (int)n;"], "readability/bool"]
["src/nvim/keymap.c", ["          key = PTR2CHAR(last_dash + 1);", "        else {", "          key = get_special_key_code(last_dash + 1);"], "readability/braces"]
["src/nvim/keymap.c", ["// Replace any terminal code strings in from[] with the equivalent internal", "// vim representation.\tThis is used for the \"from\" and \"to\" part of a", "// mapping, and the \"to\" part of a menu command."], "whitespace/tab"]
["src/nvim/keymap.c", ["// instead of a CTRL-V.", "char_u * replace_termcodes (", "    char_u *from,"], "whitespace/parens"]
["src/nvim/keymap.c", ["          result[dlen++] = (int)KE_SNR;", "          sprintf((char *)result + dlen, \"%\" PRId64, (int64_t)current_SID);", "          dlen += STRLEN(result + dlen);"], "runtime/printf"]
["src/nvim/keymap.c", ["", "      slen = trans_special(&src, result + dlen, TRUE);", "      if (slen) {"], "readability/bool"]
["src/nvim/main.c", ["  char_u      *fname = NULL;            /* file name from command line */", "  mparm_T params;                       /* various parameters passed between", "                                         * main() and other functions. */"], "readability/multiline_comment"]
["src/nvim/main.c", ["  if (recoverymode && fname == NULL)", "    params.want_full_screen = FALSE;", ""], "readability/bool"]
["src/nvim/main.c", ["  if (params.diff_mode)", "    diff_win_options(firstwin, FALSE);", ""], "readability/bool"]
["src/nvim/main.c", ["", "  msg_scroll = TRUE;", "  no_wait_return = TRUE;"], "readability/bool"]
["src/nvim/main.c", ["  msg_scroll = TRUE;", "  no_wait_return = TRUE;", ""], "readability/bool"]
["src/nvim/main.c", ["", "  init_highlight(TRUE, FALSE);   /* set the default highlight groups */", "  TIME_MSG(\"init highlight\");"], "readability/bool"]
["src/nvim/main.c", ["  if (recoverymode && fname == NULL) {", "    recover_names(NULL, TRUE, 0, NULL);", "    mch_exit(0);"], "readability/bool"]
["src/nvim/main.c", ["  if (curwin->w_p_rl && p_altkeymap) {", "    p_hkmap = FALSE;              /* Reset the Hebrew keymap mode */", "    curwin->w_p_arab = FALSE;       /* Reset the Arabic keymap mode */"], "readability/bool"]
["src/nvim/main.c", ["    p_hkmap = FALSE;              /* Reset the Hebrew keymap mode */", "    curwin->w_p_arab = FALSE;       /* Reset the Arabic keymap mode */", "    p_fkmap = TRUE;               /* Set the Farsi keymap mode */"], "readability/bool"]
["src/nvim/main.c", ["    curwin->w_p_arab = FALSE;       /* Reset the Arabic keymap mode */", "    p_fkmap = TRUE;               /* Set the Farsi keymap mode */", "  }"], "readability/bool"]
["src/nvim/main.c", ["  starting = NO_BUFFERS;", "  no_wait_return = FALSE;", "  if (!exmode_active)"], "readability/bool"]
["src/nvim/main.c", ["  if (!exmode_active)", "    msg_scroll = FALSE;", ""], "readability/bool"]
["src/nvim/main.c", ["    TIME_MSG(\"waiting for return\");", "    wait_return(TRUE);", "  }"], "readability/bool"]
["src/nvim/main.c", ["    must_redraw = CLEAR;", "  else {", "    screenclear();                        /* clear screen */"], "readability/braces"]
["src/nvim/main.c", ["", "  no_wait_return = TRUE;", ""], "readability/bool"]
["src/nvim/main.c", ["", "  apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);", "  TIME_MSG(\"BufEnter autocommands\");"], "readability/bool"]
["src/nvim/main.c", ["  if (params.edit_type == EDIT_QF) {", "    qf_jump(NULL, 0, 0, FALSE);", "    TIME_MSG(\"jump to first error\");"], "readability/bool"]
["src/nvim/main.c", ["    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "      diff_win_options(wp, TRUE);", "    }"], "readability/bool"]
["src/nvim/main.c", ["   */", "  shorten_fnames(FALSE);", ""], "readability/bool"]
["src/nvim/main.c", ["  redraw_all_later(NOT_VALID);", "  no_wait_return = FALSE;", "  starting = 0;"], "readability/bool"]
["src/nvim/main.c", ["  if (p_im)", "    need_start_insertmode = TRUE;", ""], "readability/bool"]
["src/nvim/main.c", ["", "  apply_autocmds(EVENT_VIMENTER, NULL, NULL, FALSE, curbuf);", "  TIME_MSG(\"VimEnter autocommands\");"], "readability/bool"]
["src/nvim/main.c", ["", "  exiting = TRUE;", ""], "readability/bool"]
["src/nvim/main.c", ["          apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname,", "              buf->b_fname, FALSE, buf);", "          buf->b_changedtick = -1;            /* note that we did it already */"], "readability/bool"]
["src/nvim/main.c", ["        apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname,", "            FALSE, buf);", "        if (!buf_valid(buf))            /* autocmd may delete the buffer */"], "readability/bool"]
["src/nvim/main.c", ["    }", "    apply_autocmds(EVENT_VIMLEAVEPRE, NULL, NULL, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/main.c", ["  if (get_vim_var_nr(VV_DYING) <= 1)", "    apply_autocmds(EVENT_VIMLEAVE, NULL, NULL, FALSE, curbuf);", ""], "readability/bool"]
["src/nvim/main.c", ["    /* give the user a chance to read the (error) message */", "    no_wait_return = FALSE;", "    wait_return(FALSE);"], "readability/bool"]
["src/nvim/main.c", ["    no_wait_return = FALSE;", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/main.c", ["  int argv_idx;                         /* index in argv[n][] */", "  int had_minmin = FALSE;               /* found \"--\" argument */", "  int want_argument;                    /* option argument with argument */"], "readability/bool"]
["src/nvim/main.c", ["     */", "    else if (argv[0][0] == '-' && !had_minmin) {", "      want_argument = FALSE;"], "whitespace/newline"]
["src/nvim/main.c", ["    else if (argv[0][0] == '-' && !had_minmin) {", "      want_argument = FALSE;", "      c = argv[0][argv_idx++];"], "readability/bool"]
["src/nvim/main.c", ["            // \"ex -\" silent mode", "            silent_mode = TRUE;", "          } else {"], "readability/bool"]
["src/nvim/main.c", ["", "        case '-':                 /* \"--\" don't take any more option arguments */", "          /* \"--help\" give help message */"], "whitespace/line_length"]
["src/nvim/main.c", ["#if !defined(UNIX)", "            parmp->literal = TRUE;", "#endif"], "readability/bool"]
["src/nvim/main.c", ["#endif", "          } else if (STRNICMP(argv[0] + argv_idx, \"noplugin\", 8) == 0)", "            p_lpl = FALSE;"], "readability/braces"]
["src/nvim/main.c", ["          } else if (STRNICMP(argv[0] + argv_idx, \"noplugin\", 8) == 0)", "            p_lpl = FALSE;", "          else if (STRNICMP(argv[0] + argv_idx, \"cmd\", 3) == 0) {"], "readability/bool"]
["src/nvim/main.c", ["          else if (STRNICMP(argv[0] + argv_idx, \"cmd\", 3) == 0) {", "            want_argument = TRUE;", "            argv_idx += 3;"], "readability/bool"]
["src/nvim/main.c", ["          } else if (STRNICMP(argv[0] + argv_idx, \"startuptime\", 11) == 0) {", "            want_argument = TRUE;", "            argv_idx += 11;"], "readability/bool"]
["src/nvim/main.c", ["              mainerr(err_opt_unknown, argv[0]);", "            had_minmin = TRUE;", "          }"], "readability/bool"]
["src/nvim/main.c", ["        case 'F':                 /* \"-F\" start in Farsi mode: rl + fkmap set */", "          p_fkmap = TRUE;", "          set_option_value((char_u *)\"rl\", 1L, NULL, 0);"], "readability/bool"]
["src/nvim/main.c", ["", "        case 'H':                 /* \"-H\" start in Hebrew mode: rl + hkmap set */", "          p_hkmap = TRUE;"], "whitespace/line_length"]
["src/nvim/main.c", ["        case 'H':                 /* \"-H\" start in Hebrew mode: rl + hkmap set */", "          p_hkmap = TRUE;", "          set_option_value((char_u *)\"rl\", 1L, NULL, 0);"], "readability/bool"]
["src/nvim/main.c", ["", "        case 'l':                 /* \"-l\" lisp mode, 'lisp' and 'showmatch' on */", "          set_option_value((char_u *)\"lisp\", 1L, NULL, 0);"], "whitespace/line_length"]
["src/nvim/main.c", ["          set_option_value((char_u *)\"lisp\", 1L, NULL, 0);", "          p_sm = TRUE;", "          break;"], "readability/bool"]
["src/nvim/main.c", ["        case 'm':                 /* \"-m\"  no writing of files */", "          p_write = FALSE;", "          break;"], "readability/bool"]
["src/nvim/main.c", ["        case 'n':                 /* \"-n\" no swap file */", "          parmp->no_swap_file = TRUE;", "          break;"], "readability/bool"]
["src/nvim/main.c", ["            argv_idx = -1;", "          } else if (argc > 1)                    /* \"-q {errorfile}\" */", "            want_argument = TRUE;"], "readability/braces"]
["src/nvim/main.c", ["          } else if (argc > 1)                    /* \"-q {errorfile}\" */", "            want_argument = TRUE;", "          break;"], "readability/bool"]
["src/nvim/main.c", ["        case 'R':                 /* \"-R\" readonly mode */", "          readonlymode = TRUE;", "          curbuf->b_p_ro = TRUE;"], "readability/bool"]
["src/nvim/main.c", ["          readonlymode = TRUE;", "          curbuf->b_p_ro = TRUE;", "          p_uc = 10000;                           /* don't update very often */"], "readability/bool"]
["src/nvim/main.c", ["          if (exmode_active)              /* \"-s\" silent (batch) mode */", "            silent_mode = TRUE;", "          else                    /* \"-s {scriptin}\" read from script file */"], "readability/bool"]
["src/nvim/main.c", ["          else                    /* \"-s {scriptin}\" read from script file */", "            want_argument = TRUE;", "          break;"], "readability/bool"]
["src/nvim/main.c", ["            argv_idx = -1;", "          } else                                  /* \"-t {tag}\" */", "            want_argument = TRUE;"], "readability/braces"]
["src/nvim/main.c", ["          } else                                  /* \"-t {tag}\" */", "            want_argument = TRUE;", "          break;"], "readability/bool"]
["src/nvim/main.c", ["", "        case 'D':                 /* \"-D\"\t\tDebugging */", "          parmp->use_debug_break_level = 9999;"], "whitespace/tab"]
["src/nvim/main.c", ["          break;", "        case 'd':                 /* \"-d\"\t\t'diff' */", "          parmp->diff_mode = TRUE;"], "whitespace/tab"]
["src/nvim/main.c", ["        case 'd':                 /* \"-d\"\t\t'diff' */", "          parmp->diff_mode = TRUE;", "          break;"], "readability/bool"]
["src/nvim/main.c", ["          mch_exit(0);", "        case 'V':                 /* \"-V{N}\"\tVerbose level */", "          /* default is 10: a little bit verbose */"], "whitespace/tab"]
["src/nvim/main.c", ["", "        case 'w':                 /* \"-w{number}\"\tset window height */", "          /* \"-w {scriptout}\"\twrite to script */"], "whitespace/tab"]
["src/nvim/main.c", ["        case 'w':                 /* \"-w{number}\"\tset window height */", "          /* \"-w {scriptout}\"\twrite to script */", "          if (ascii_isdigit(((char_u *)argv[0])[argv_idx])) {"], "whitespace/tab"]
["src/nvim/main.c", ["          }", "          want_argument = TRUE;", "          break;"], "readability/bool"]
["src/nvim/main.c", ["        case 'Z':                 /* \"-Z\"  restricted mode */", "          restricted = TRUE;", "          break;"], "readability/bool"]
["src/nvim/main.c", ["", "        case 'c':                 /* \"-c{command}\" or \"-c {command}\" execute", "                                     command */"], "readability/multiline_comment"]
["src/nvim/main.c", ["        case 'W':                 /* \"-W {scriptout}\" overwrite */", "          want_argument = TRUE;", "          break;"], "readability/bool"]
["src/nvim/main.c", ["              char *s = xmalloc(STRLEN(a) + 4);", "              sprintf(s, \"so %s\", a);", "              parmp->cmds_tofree[parmp->n_commands] = TRUE;"], "runtime/printf"]
["src/nvim/main.c", ["              sprintf(s, \"so %s\", a);", "              parmp->cmds_tofree[parmp->n_commands] = TRUE;", "              parmp->commands[parmp->n_commands++] = s;"], "readability/bool"]
["src/nvim/main.c", ["            break;", "", "        }"], "whitespace/blank_line"]
["src/nvim/main.c", ["     */", "    else {", "      argv_idx = -1;                /* skip to next argument */"], "whitespace/newline"]
["src/nvim/main.c", ["     */", "    else {", "      argv_idx = -1;                /* skip to next argument */"], "readability/braces"]
["src/nvim/main.c", ["", "        r = (char_u *)concat_fnames((char *)p, (char *)path_tail(alist_name(&GARGLIST[0])), TRUE);", "        xfree(p);"], "whitespace/line_length"]
["src/nvim/main.c", ["", "        r = (char_u *)concat_fnames((char *)p, (char *)path_tail(alist_name(&GARGLIST[0])), TRUE);", "        xfree(p);"], "readability/bool"]
["src/nvim/main.c", ["#endif", "          );", ""], "whitespace/parens"]
["src/nvim/main.c", ["          );", "", "    }"], "whitespace/blank_line"]
["src/nvim/main.c", ["    p = xmalloc(STRLEN(parmp->commands[0]) + 3);", "    sprintf((char *)p, \":%s\\r\", parmp->commands[0]);", "    set_vim_var_string(VV_SWAPCOMMAND, p, -1);"], "runtime/printf"]
["src/nvim/main.c", ["  for (int i = 1; i < paramp->argc; i++) {", "    if (STRICMP(paramp->argv[i], \"--startuptime\") == 0 && i + 1 < paramp->argc) {", "      time_fd = mch_fopen(paramp->argv[i + 1], \"a\");"], "whitespace/line_length"]
["src/nvim/main.c", ["  if (p_lpl) {", "    source_runtime((char_u *)\"plugin/**/*.vim\", TRUE);", "    TIME_MSG(\"loading plugins\");"], "readability/bool"]
["src/nvim/main.c", ["    vim_snprintf((char *)IObuff, IOSIZE, \"cfile %s\", p_ef);", "    if (qf_init(NULL, p_ef, p_efm, TRUE, IObuff) < 0) {", "      ui_putc('\\n');"], "readability/bool"]
["src/nvim/main.c", ["  if (tagname != NULL) {", "    swap_exists_did_quit = FALSE;", ""], "readability/bool"]
["src/nvim/main.c", ["        && (!parmp->output_isatty || !parmp->input_isatty))) {", "", "    if (!parmp->output_isatty) {"], "whitespace/blank_line"]
["src/nvim/main.c", ["  swap_exists_action = SEA_DIALOG;", "  no_wait_return = TRUE;", "  i = msg_didany;"], "readability/bool"]
["src/nvim/main.c", ["  i = msg_didany;", "  set_buflisted(TRUE);", "  (void)open_buffer(TRUE, NULL, 0);     /* create memfile and read file */"], "readability/bool"]
["src/nvim/main.c", ["  set_buflisted(TRUE);", "  (void)open_buffer(TRUE, NULL, 0);     /* create memfile and read file */", "  no_wait_return = FALSE;"], "readability/bool"]
["src/nvim/main.c", ["  (void)open_buffer(TRUE, NULL, 0);     /* create memfile and read file */", "  no_wait_return = FALSE;", "  msg_didany = i;"], "readability/bool"]
["src/nvim/main.c", ["      TIME_MSG(\"making windows\");", "    } else", "      parmp->window_count = win_count();"], "readability/braces"]
["src/nvim/main.c", ["      parmp->window_count = win_count();", "  } else", "    parmp->window_count = 1;"], "readability/braces"]
["src/nvim/main.c", ["  if (recoverymode) {                   /* do recover */", "    msg_scroll = TRUE;                  /* scroll message up */", "    ml_recover();"], "readability/bool"]
["src/nvim/main.c", ["    ++autocmd_no_leave;", "    dorewind = TRUE;", "    while (done++ < 1000) {"], "readability/bool"]
["src/nvim/main.c", ["      }", "      dorewind = FALSE;", "      curbuf = curwin->w_buffer;"], "readability/bool"]
["src/nvim/main.c", ["        swap_exists_action = SEA_DIALOG;", "        set_buflisted(TRUE);", ""], "readability/bool"]
["src/nvim/main.c", ["        /* create memfile, read file */", "        (void)open_buffer(FALSE, NULL, 0);", ""], "readability/bool"]
["src/nvim/main.c", ["            /* abort selected or quit and only one window */", "            did_emsg = FALSE;               /* avoid hit-enter prompt */", "            getout(1);"], "readability/bool"]
["src/nvim/main.c", ["           * index to -1 to delete it later. */", "          setfname(curbuf, NULL, NULL, FALSE);", "          curwin->w_arg_idx = -1;"], "readability/bool"]
["src/nvim/main.c", ["          swap_exists_action = SEA_NONE;", "        } else", "          handle_swap_exists(NULL);"], "readability/braces"]
["src/nvim/main.c", ["          handle_swap_exists(NULL);", "        dorewind = TRUE;                        /* start again */", "      }"], "readability/bool"]
["src/nvim/main.c", ["  int i;", "  int advance = TRUE;", "  win_T       *win;"], "readability/bool"]
["src/nvim/main.c", ["  if (curwin->w_arg_idx == -1) {", "    win_close(curwin, TRUE);", "    advance = FALSE;"], "readability/bool"]
["src/nvim/main.c", ["    win_close(curwin, TRUE);", "    advance = FALSE;", "  }"], "readability/bool"]
["src/nvim/main.c", ["      ++arg_idx;", "      win_close(curwin, TRUE);", "      advance = FALSE;"], "readability/bool"]
["src/nvim/main.c", ["      win_close(curwin, TRUE);", "      advance = FALSE;", "      continue;"], "readability/bool"]
["src/nvim/main.c", ["    }", "    advance = TRUE;", ""], "readability/bool"]
["src/nvim/main.c", ["       * at the ATTENTION prompt close the window. */", "      swap_exists_did_quit = FALSE;", "      (void)do_ecmd(0, arg_idx < GARGCOUNT"], "readability/bool"]
["src/nvim/main.c", ["          /* abort selected and only one window */", "          did_emsg = FALSE;             /* avoid hit-enter prompt */", "          getout(1);"], "readability/bool"]
["src/nvim/main.c", ["        }", "        win_close(curwin, TRUE);", "        advance = FALSE;"], "readability/bool"]
["src/nvim/main.c", ["        win_close(curwin, TRUE);", "        advance = FALSE;", "      }"], "readability/bool"]
["src/nvim/main.c", ["      if (arg_idx == GARGCOUNT - 1)", "        arg_had_last = TRUE;", "      ++arg_idx;"], "readability/bool"]
["src/nvim/main.c", ["   */", "  msg_scroll = TRUE;", "  if (parmp->tagname == NULL && curwin->w_cursor.lnum <= 1)"], "readability/bool"]
["src/nvim/main.c", ["  if (!exmode_active)", "    msg_scroll = FALSE;", ""], "readability/bool"]
["src/nvim/main.c", ["  if (parmp->edit_type == EDIT_QF)", "    qf_jump(NULL, 0, 0, FALSE);", "  TIME_MSG(\"executing command arguments\");"], "readability/bool"]
["src/nvim/main.c", ["    } else {", "      if (do_source((char_u *)parmp->use_vimrc, FALSE, DOSO_NONE) != OK)", "        EMSG2(_(\"E282: Cannot read from \\\"%s\\\"\"), parmp->use_vimrc);"], "readability/bool"]
["src/nvim/main.c", ["    sourcing_lnum = save_sourcing_lnum;", "    current_SID = save_sid;;", "    return OK;"], "whitespace/newline"]
["src/nvim/main.c", ["{", "  info_message = TRUE;  // use mch_msg(), not mch_errmsg()", "  list_version();"], "readability/bool"]
["src/nvim/main.c", ["  msg_putchar('\\n');", "  msg_didout = FALSE;", "}"], "readability/bool"]
["src/nvim/main.c", ["  mch_msg(_(\"  nvim [arguments] -               Read text from stdin\\n\"));", "  mch_msg(_(\"  nvim [arguments] -t <tag>        Edit file where tag is defined\\n\"));", "  mch_msg(_(\"  nvim [arguments] -q [errorfile]  Edit file with first error\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -E                    Improved Ex mode\\n\"));", "  mch_msg(_(\"  -s                    Silent (batch) mode (only for ex mode)\\n\"));", "  mch_msg(_(\"  -d                    Diff mode\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -Z                    Restricted mode\\n\"));", "  mch_msg(_(\"  -m                    Modifications (writing files) not allowed\\n\"));", "  mch_msg(_(\"  -M                    Modifications in text not allowed\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -H                    Hebrew mode\\n\"));", "  mch_msg(_(\"  -V[N][file]           Be verbose [level N][log messages to file]\\n\"));", "  mch_msg(_(\"  -D                    Debugging mode\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  --noplugin            Don't load plugin scripts\\n\"));", "  mch_msg(_(\"  -o[N]                 Open N windows (default: one for each file)\\n\"));", "  mch_msg(_(\"  -O[N]                 Like -o but split vertically\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -O[N]                 Like -o but split vertically\\n\"));", "  mch_msg(_(\"  -p[N]                 Open N tab pages (default: one for each file)\\n\"));", "  mch_msg(_(\"  +                     Start at end of file\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  +<linenum>            Start at line <linenum>\\n\"));", "  mch_msg(_(\"  +/<pattern>           Start at first occurrence of <pattern>\\n\"));", "  mch_msg(_(\"  --cmd <command>       Execute <command> before loading any vimrc\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  +/<pattern>           Start at first occurrence of <pattern>\\n\"));", "  mch_msg(_(\"  --cmd <command>       Execute <command> before loading any vimrc\\n\"));", "  mch_msg(_(\"  -c <command>          Execute <command> after loading the first file\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  --cmd <command>       Execute <command> before loading any vimrc\\n\"));", "  mch_msg(_(\"  -c <command>          Execute <command> after loading the first file\\n\"));", "  mch_msg(_(\"  -S <session>          Source <session> after loading the first file\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -c <command>          Execute <command> after loading the first file\\n\"));", "  mch_msg(_(\"  -S <session>          Source <session> after loading the first file\\n\"));", "  mch_msg(_(\"  -s <scriptin>         Read Normal mode commands from <scriptin>\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -S <session>          Source <session> after loading the first file\\n\"));", "  mch_msg(_(\"  -s <scriptin>         Read Normal mode commands from <scriptin>\\n\"));", "  mch_msg(_(\"  -w <scriptout>        Append all typed characters to <scriptout>\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -s <scriptin>         Read Normal mode commands from <scriptin>\\n\"));", "  mch_msg(_(\"  -w <scriptout>        Append all typed characters to <scriptout>\\n\"));", "  mch_msg(_(\"  -W <scriptout>        Write all typed characters to <scriptout>\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -w <scriptout>        Append all typed characters to <scriptout>\\n\"));", "  mch_msg(_(\"  -W <scriptout>        Write all typed characters to <scriptout>\\n\"));", "  mch_msg(_(\"  --startuptime <file>  Write startup timing messages to <file>\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  -W <scriptout>        Write all typed characters to <scriptout>\\n\"));", "  mch_msg(_(\"  --startuptime <file>  Write startup timing messages to <file>\\n\"));", "  mch_msg(_(\"  --api-info            Dump API metadata serialized to msgpack and exit\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  --startuptime <file>  Write startup timing messages to <file>\\n\"));", "  mch_msg(_(\"  --api-info            Dump API metadata serialized to msgpack and exit\\n\"));", "  mch_msg(_(\"  --embed               Use stdin/stdout as a msgpack-rpc channel\\n\"));"], "whitespace/line_length"]
["src/nvim/main.c", ["  mch_msg(_(\"  --api-info            Dump API metadata serialized to msgpack and exit\\n\"));", "  mch_msg(_(\"  --embed               Use stdin/stdout as a msgpack-rpc channel\\n\"));", "  mch_msg(_(\"  --headless            Don't start a user interface\\n\"));"], "whitespace/line_length"]
["src/nvim/mark.c", ["      curwin->w_prev_pcmark = curwin->w_pcmark;", "    } else", "      curwin->w_pcmark = *pos;"], "readability/braces"]
["src/nvim/mark.c", ["", "  if (c > 'z')              /* some islower() and isupper() cannot handle", "                                characters above 127 */"], "readability/multiline_comment"]
["src/nvim/mark.c", ["      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,", "              0, FALSE) == FAIL)", "        return (pos_T *)NULL;"], "readability/bool"]
["src/nvim/mark.c", ["      pos = (pos_T *)-1;", "    } else", "      pos = &(jmp->fmark.mark);"], "readability/braces"]
["src/nvim/mark.c", ["    n = curbuf->b_changelistlen - 1;", "  } else", "    n += count;"], "readability/braces"]
["src/nvim/mark.c", ["    pos = curwin->w_cursor;", "    listcmd_busy = TRUE;            /* avoid that '' is changed */", "    if (findpar(&oa.inclusive,"], "readability/bool"]
["src/nvim/mark.c", ["    if (findpar(&oa.inclusive,", "            c == '}' ? FORWARD : BACKWARD, 1L, NUL, FALSE)) {", "      pos_copy = curwin->w_cursor;"], "readability/bool"]
["src/nvim/mark.c", ["    pos = curwin->w_cursor;", "    listcmd_busy = TRUE;            /* avoid that '' is changed */", "    if (findsent(c == ')' ? FORWARD : BACKWARD, 1L)) {"], "readability/bool"]
["src/nvim/mark.c", ["        if (buflist_getfile(namedfm[c].fmark.fnum,", "                (linenr_T)1, GETF_SETMARK, FALSE) == OK) {", "          /* Set the lnum now, autocommands could have changed it */"], "readability/bool"]
["src/nvim/mark.c", ["        pos_copy.lnum = -1;             /* can't get file */", "      } else", "        pos_copy.lnum = 0;              /* mark exists, but is not valid in"], "readability/braces"]
["src/nvim/mark.c", ["      } else", "        pos_copy.lnum = 0;              /* mark exists, but is not valid in", "                                           current buffer */"], "readability/multiline_comment"]
["src/nvim/mark.c", ["pos_T *", "getnextmark (", "    pos_T *startpos,          /* where to start */"], "whitespace/parens"]
["src/nvim/mark.c", ["#endif", "                                )) {", "      int len;"], "whitespace/parens"]
["src/nvim/mark.c", ["      STRLCPY(NameBuff + len, fm->fname + 2, MAXPATHL - len);", "    } else", "      STRLCPY(NameBuff, fm->fname, MAXPATHL);"], "readability/braces"]
["src/nvim/mark.c", ["    return mark_line(&(fmark->mark), lead_len);", "  return buflist_nr2name(fmark->fnum, FALSE, TRUE);", "}"], "readability/bool"]
["src/nvim/mark.c", ["", "static void ", "show_one_mark ("], "whitespace/end_of_line"]
["src/nvim/mark.c", ["static void ", "show_one_mark (", "    int c,"], "whitespace/parens"]
["src/nvim/mark.c", ["{", "  static int did_title = FALSE;", "  int mustfree = FALSE;"], "readability/bool"]
["src/nvim/mark.c", ["  static int did_title = FALSE;", "  int mustfree = FALSE;", ""], "readability/bool"]
["src/nvim/mark.c", ["    if (did_title)", "      did_title = FALSE;", "    else {"], "readability/bool"]
["src/nvim/mark.c", ["      did_title = FALSE;", "    else {", "      if (arg == NULL)"], "readability/braces"]
["src/nvim/mark.c", ["  /* don't output anything if 'q' typed at --more-- prompt */", "  else if (!got_int", "           && (arg == NULL || vim_strchr(arg, c) != NULL)"], "whitespace/newline"]
["src/nvim/mark.c", ["      MSG_PUTS_TITLE(_(\"\\nmark line  col file/text\"));", "      did_title = TRUE;", "    }"], "readability/bool"]
["src/nvim/mark.c", ["    if (!got_int) {", "      sprintf((char *)IObuff, \" %c %6ld %4d \", c, p->lnum, p->col);", "      msg_outtrans(IObuff);"], "runtime/printf"]
["src/nvim/mark.c", ["        name = mark_line(p, 15);", "        mustfree = TRUE;", "      }"], "readability/bool"]
["src/nvim/mark.c", ["    EMSG(_(e_argreq));", "  else {", "    /* clear specified marks only */"], "readability/braces"]
["src/nvim/mark.c", ["          p += 2;", "        } else", "          /* clear one lower case mark */"], "readability/braces"]
["src/nvim/mark.c", ["        }", "      } else", "        switch (*p) {"], "readability/braces"]
["src/nvim/mark.c", ["      }", "      sprintf((char *)IObuff, \"%c %2d %5ld %4d \",", "          i == curwin->w_jumplistidx ? '>' : ' ',"], "runtime/printf"]
["src/nvim/mark.c", ["        break;", "      sprintf((char *)IObuff, \"%c %3d %5ld %4d \",", "          i == curwin->w_changelistidx ? '>' : ' ',"], "runtime/printf"]
["src/nvim/mark.c", ["        *lp = 0; \\", "      else \\", "        *lp += amount; \\"], "whitespace/newline"]
["src/nvim/mark.c", ["        *lp = line1; \\", "      else \\", "        *lp += amount; \\"], "whitespace/newline"]
["src/nvim/mark.c", ["        posp->col = 0; \\", "      else \\", "        posp->col += (colnr_T)col_amount; \\"], "whitespace/newline"]
["src/nvim/mark.c", [" */", "void mark_col_adjust(linenr_T lnum, colnr_T mincol, long lnum_amount, long col_amount)", "{"], "whitespace/line_length"]
["src/nvim/mbyte.c", ["{", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,", "  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,", "  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1,", "};"], "whitespace/comma"]
["src/nvim/mbyte.c", ["{", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", "  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,", "  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,", "  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,", "  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,", "  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,", "  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0,"], "whitespace/comma"]
["src/nvim/mbyte.c", ["  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,", "  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0,", "};"], "whitespace/comma"]
["src/nvim/mbyte.c", ["static struct", "{   const char *name;   int prop;              int codepage; }", "enc_canon_table[] ="], "whitespace/newline"]
["src/nvim/mbyte.c", ["static struct", "{   const char *name; int canon; }", "enc_alias_table[] ="], "whitespace/newline"]
["src/nvim/mbyte.c", ["    }", "  } else    /* Don't know what encoding this is, reject it. */", "    return e_invarg;"], "readability/braces"]
["src/nvim/mbyte.c", ["      n = 1;", "    else {", "      char buf[MB_MAXBYTES + 1];"], "readability/braces"]
["src/nvim/mbyte.c", ["        n = 1;", "      else {", "        buf[0] = i;"], "readability/braces"]
["src/nvim/mbyte.c", ["            n = 1;", "          } else", "            n = 2;"], "readability/braces"]
["src/nvim/mbyte.c", ["            n = 2;", "        } else", "#endif"], "readability/braces"]
["src/nvim/mbyte.c", ["   * after Vim has been setup for the new encoding. */", "  apply_autocmds(EVENT_ENCODINGCHANGED, NULL, (char_u *)\"\", FALSE, curbuf);", ""], "readability/bool"]
["src/nvim/mbyte.c", ["      }", "    } else if (STRCMP(curbuf->b_p_fenc, \"utf-8\") == 0)", "      n = 3;"], "readability/braces"]
["src/nvim/mbyte.c", ["          return 21;", "        else switch (c1) {", "          case 0xA1:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["  /* Characters below 0x100 are influenced by 'isprint' option */", "  else if (c >= 0x80 && !vim_isprintc(c))", "    return 4;                   /* unprintable, displays <xx> */"], "whitespace/newline"]
["src/nvim/mbyte.c", ["", "  if (c >= 0x80 && *p_ambw == 'd' && intable(ambiguous, ARRAY_SIZE(ambiguous), c))", "    return 2;"], "whitespace/line_length"]
["src/nvim/mbyte.c", ["    }", "    sprintf((char *)IObuff + rlen, \"%02x \",", "        (line[i] == NL) ? NUL : line[i]);          /* NUL is stored as NL */"], "runtime/printf"]
["src/nvim/mbyte.c", ["    }", "    else {", "      q += dbcs_ptr2len(q);"], "whitespace/newline"]
["src/nvim/mbyte.c", ["    }", "    else {", "      q += dbcs_ptr2len(q);"], "readability/braces"]
["src/nvim/mbyte.c", ["    for (i = 0; (p[i] & 0xc0) == 0x80; ++i)", "      ;", "    if (i > 0) {"], "whitespace/semicolon"]
["src/nvim/mbyte.c", ["    for (i = 0; (p[i + 1] & 0xc0) == 0x80; ++i)", "      ;", "    /* Check for illegal sequence. */"], "whitespace/semicolon"]
["src/nvim/mbyte.c", ["          curwin->w_cursor.col += (colnr_T)(p - get_cursor_pos_ptr());", "        else {", "          int l;"], "readability/braces"]
["src/nvim/mbyte.c", ["     ) {", "    p = ml_get_buf(buf, lp->lnum, FALSE);", "    lp->col -= (*mb_head_off)(p, p + lp->col);"], "readability/bool"]
["src/nvim/mbyte.c", ["      n += 2;", "    } else if (str[n] == K_SPECIAL", "        )"], "readability/braces"]
["src/nvim/mbyte.c", ["      /* copy \"XY.EUC\" to \"euc-XY\" to buf[10] */", "      strcpy(buf + 10, \"euc-\");", "      buf[14] = p[-2];"], "runtime/printf"]
["src/nvim/mbyte.c", ["      s = buf + 10;", "    } else", "      s = p + 1;"], "readability/braces"]
["src/nvim/mbyte.c", ["      fd = (iconv_t)-1;", "    } else", "      iconv_working = kWorking;"], "readability/braces"]
["src/nvim/mbyte.c", ["     * iconv library may use one of them. */", "    else if (!vcp->vc_fail", "        && (ICONV_ERRNO == ICONV_EILSEQ || ICONV_ERRNO == EILSEQ"], "whitespace/newline"]
["src/nvim/mbyte.c", ["        l = utfc_ptr2len_len((const char_u *)from, (int)fromlen);", "      else {", "        l = (*mb_ptr2len)((char_u *)from);"], "readability/braces"]
["src/nvim/mbyte.c", ["# ifdef USE_ICONV", "  else {", "    /* Use iconv() for conversion. */"], "readability/braces"]
["src/nvim/mbyte.c", ["          *d++ = c;", "        else {", "          *d++ = 0xc0 + ((unsigned)c >> 6);"], "readability/braces"]
["src/nvim/memline.c", ["/* for debugging */", "/* #define CHECK(c, s)\tif (c) EMSG(s) */", "#define CHECK(c, s)"], "whitespace/tab"]
["src/nvim/memline.c", ["#ifndef UNIX            /* it's in os/unix_defs.h for Unix */", "# include <time.h>", "#endif"], "build/include_order"]
["src/nvim/memline.c", ["  uint16_t pb_count_max;        /* maximum value for pb_count */", "  PTR_EN pb_pointer[1];         /* list of pointers to blocks (actually longer)", "                                 * followed by empty space until end of page */"], "readability/multiline_comment"]
["src/nvim/memline.c", ["  uint16_t pb_count_max;        /* maximum value for pb_count */", "  PTR_EN pb_pointer[1];         /* list of pointers to blocks (actually longer)", "                                 * followed by empty space until end of page */"], "whitespace/parens"]
["src/nvim/memline.c", ["  linenr_T db_line_count;       /* number of lines in this block */", "  unsigned db_index[1];         /* index for start of line (actually bigger)", "                                 * followed by empty space upto db_txt_start"], "readability/multiline_comment"]
["src/nvim/memline.c", ["#define INDEX_SIZE  (sizeof(unsigned))      /* size of one db_index entry */", "#define HEADER_SIZE (sizeof(DATA_BL) - INDEX_SIZE)  /* size of data block header */", ""], "whitespace/line_length"]
["src/nvim/memline.c", ["  int b0_magic_int;             /* check for byte order of int */", "  short b0_magic_short;         /* check for byte order of short */", "  char_u b0_magic_char;         /* check for last char */"], "runtime/int"]
["src/nvim/memline.c", ["  b0p->b0_magic_int = (int)B0_MAGIC_INT;", "  b0p->b0_magic_short = (short)B0_MAGIC_SHORT;", "  b0p->b0_magic_char = B0_MAGIC_CHAR;"], "runtime/int"]
["src/nvim/memline.c", ["   */", "  hp = ml_new_data(mfp, FALSE, 1);", "  if (hp->bh_bnum != 2) {"], "readability/bool"]
["src/nvim/memline.c", ["{", "  int success = FALSE;", "  memfile_T   *mfp;"], "readability/bool"]
["src/nvim/memline.c", ["      xfree(fname);", "      success = TRUE;", "      break;"], "readability/bool"]
["src/nvim/memline.c", ["    if (vim_rename(mfp->mf_fname, fname) == 0) {", "      success = TRUE;", "      xfree(mfp->mf_fname);"], "readability/bool"]
["src/nvim/memline.c", ["  if (mfp->mf_fname == NULL) {          /* Failed! */", "    need_wait_return = TRUE;            /* call wait_return later */", "    ++no_wait_return;"], "readability/bool"]
["src/nvim/memline.c", [" */", "void ", "check_need_swap ("], "whitespace/end_of_line"]
["src/nvim/memline.c", ["void ", "check_need_swap (", "    int newfile                    /* reading file into new buffer */"], "whitespace/parens"]
["src/nvim/memline.c", ["    if (!bufIsChanged(buf)) {", "      ml_close(buf, TRUE);          /* close all not-modified buffers */", "    }"], "readability/bool"]
["src/nvim/memline.c", ["    EMSG(_(\"E304: ml_upd_block0(): Didn't get block 0??\"));", "  else {", "    if (what == UB_FNAME)"], "readability/braces"]
["src/nvim/memline.c", ["    b0p->b0_fname[0] = NUL;", "  else {", "    char uname[B0_UNAME_SIZE];"], "readability/braces"]
["src/nvim/memline.c", ["    home_replace(NULL, buf->b_ffname, b0p->b0_fname,", "        B0_FNAME_SIZE_CRYPT, TRUE);", "    if (b0p->b0_fname[0] == '~') {"], "readability/bool"]
["src/nvim/memline.c", ["    b0p->b0_flags &= ~B0_HAS_FENC;", "  else {", "    memmove((char *)b0p->b0_fname + size - n,"], "readability/braces"]
["src/nvim/memline.c", ["  int called_from_main;", "  int serious_error = TRUE;", "  long mtime;"], "readability/bool"]
["src/nvim/memline.c", ["", "  recoverymode = TRUE;", "  called_from_main = (curbuf->b_ml.ml_mfp == NULL);"], "readability/bool"]
["src/nvim/memline.c", ["      && ASCII_ISALPHA(fname[len - 1])) {", "    directly = TRUE;", "    fname_used = vim_strsave(fname);     /* make a copy for mf_open() */"], "readability/bool"]
["src/nvim/memline.c", ["  } else {", "    directly = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["    /* count the number of matching swap files */", "    len = recover_names(fname, FALSE, 0, NULL);", "    if (len == 0) {                 /* no swap files found */"], "readability/bool"]
["src/nvim/memline.c", ["      i = 1;", "    else {                          /* several swap files found, choose */", "      /* list the names of the swap files */"], "readability/braces"]
["src/nvim/memline.c", ["      /* list the names of the swap files */", "      (void)recover_names(fname, TRUE, 0, NULL);", "      msg_putchar('\\n');"], "readability/bool"]
["src/nvim/memline.c", ["      MSG_PUTS(_(\"Enter number of swap file to use (0 to quit): \"));", "      i = get_number(FALSE, NULL);", "      if (i < 1 || i > len)"], "readability/bool"]
["src/nvim/memline.c", ["    /* get the swap file name that will be used */", "    (void)recover_names(fname, FALSE, i, &fname_used);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["   */", "  p = vim_strsave(fname_used);   /* save \"fname_used\" for the message:", "                                    mf_open() will consume \"fname_used\"! */"], "readability/multiline_comment"]
["src/nvim/memline.c", ["  p = vim_strsave(fname_used);   /* save \"fname_used\" for the message:", "                                    mf_open() will consume \"fname_used\"! */", "  mfp = mf_open(fname_used, O_RDONLY);"], "whitespace/operators"]
["src/nvim/memline.c", ["    MSG_PUTS_ATTR(_(", "            \"\\nMaybe no changes were made or Vim did not update the swap file.\"),", "        attr | MSG_HIST);"], "whitespace/line_length"]
["src/nvim/memline.c", ["    expand_env(b0p->b0_fname, NameBuff, MAXPATHL);", "    if (setfname(curbuf, NameBuff, NULL, TRUE) == FAIL)", "      goto theend;"], "readability/bool"]
["src/nvim/memline.c", ["", "  home_replace(NULL, mfp->mf_fname, NameBuff, MAXPATHL, TRUE);", "  smsg(_(\"Using swap file \\\"%s\\\"\"), NameBuff);"], "readability/bool"]
["src/nvim/memline.c", ["  else", "    home_replace(NULL, curbuf->b_ffname, NameBuff, MAXPATHL, TRUE);", "  smsg(_(\"Original file \\\"%s\\\"\"), NameBuff);"], "readability/bool"]
["src/nvim/memline.c", ["    for (p = b0p->b0_fname + fnsize; p > b0p->b0_fname && p[-1] != NUL; --p)", "      ;", "    b0_fenc = vim_strnsave(p, (int)(b0p->b0_fname + fnsize - p));"], "whitespace/semicolon"]
["src/nvim/memline.c", ["  while (!(curbuf->b_ml.ml_flags & ML_EMPTY))", "    ml_delete((linenr_T)1, FALSE);", ""], "readability/bool"]
["src/nvim/memline.c", ["  }", "  unchanged(curbuf, TRUE);", ""], "readability/bool"]
["src/nvim/memline.c", ["  if (curbuf->b_ffname == NULL)", "    cannot_open = TRUE;", "  else"], "readability/bool"]
["src/nvim/memline.c", ["  else", "    cannot_open = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["", "  serious_error = FALSE;", "  for (; !got_int; line_breakcheck()) {"], "readability/bool"]
["src/nvim/memline.c", ["      ml_append(lnum++, (char_u *)_(\"???MANY LINES MISSING\"),", "          (colnr_T)0, TRUE);", "    } else {          /* there is a block */"], "readability/bool"]
["src/nvim/memline.c", ["            ml_append(lnum++, (char_u *)_(\"???LINE COUNT WRONG\"),", "                (colnr_T)0, TRUE);", "          }"], "readability/bool"]
["src/nvim/memline.c", ["          ml_append(lnum++, (char_u *)_(\"???EMPTY BLOCK\"),", "              (colnr_T)0, TRUE);", "          ++error;"], "readability/bool"]
["src/nvim/memline.c", ["                      line_count, NULL, 0) == FAIL)", "                cannot_open = TRUE;", "              else"], "readability/bool"]
["src/nvim/memline.c", ["              ml_append(lnum++, (char_u *)_(\"???LINES MISSING\"),", "                  (colnr_T)0, TRUE);", "            }"], "readability/bool"]
["src/nvim/memline.c", ["          ml_append(lnum++, (char_u *)_(\"???BLOCK MISSING\"),", "              (colnr_T)0, TRUE);", "        } else {"], "readability/bool"]
["src/nvim/memline.c", ["           */", "          has_error = FALSE;", "          /*"], "readability/bool"]
["src/nvim/memline.c", ["            ml_append(lnum++,", "                (char_u *)_(\"??? from here until ???END lines may be messed up\"),", "                (colnr_T)0, TRUE);"], "whitespace/line_length"]
["src/nvim/memline.c", ["                (char_u *)_(\"??? from here until ???END lines may be messed up\"),", "                (colnr_T)0, TRUE);", "            ++error;"], "readability/bool"]
["src/nvim/memline.c", ["            ++error;", "            has_error = TRUE;", "            dp->db_txt_end = page_count * mfp->mf_page_size;"], "readability/bool"]
["src/nvim/memline.c", ["                (char_u *)_(", "                    \"??? from here until ???END lines may have been inserted/deleted\"),", "                (colnr_T)0, TRUE);"], "whitespace/line_length"]
["src/nvim/memline.c", ["                    \"??? from here until ???END lines may have been inserted/deleted\"),", "                (colnr_T)0, TRUE);", "            ++error;"], "readability/bool"]
["src/nvim/memline.c", ["            ++error;", "            has_error = TRUE;", "          }"], "readability/bool"]
["src/nvim/memline.c", ["              ++error;", "            } else", "              p = (char_u *)dp + txt_start;"], "readability/braces"]
["src/nvim/memline.c", ["              p = (char_u *)dp + txt_start;", "            ml_append(lnum++, p, (colnr_T)0, TRUE);", "          }"], "readability/bool"]
["src/nvim/memline.c", ["            ml_append(lnum++, (char_u *)_(\"???END\"),", "                (colnr_T)0, TRUE);", "        }"], "readability/bool"]
["src/nvim/memline.c", ["         && !(curbuf->b_ml.ml_flags & ML_EMPTY))", "    ml_delete(curbuf->b_ml.ml_line_count, FALSE);", "  curbuf->b_flags |= BF_RECOVERED;"], "readability/bool"]
["src/nvim/memline.c", ["", "  recoverymode = FALSE;", "  if (got_int)"], "readability/bool"]
["src/nvim/memline.c", ["    EMSG(_(", "            \"E312: Errors detected while recovering; look for lines starting with ???\"));", "    --no_wait_return;"], "whitespace/line_length"]
["src/nvim/memline.c", ["      MSG_PUTS(_(\"and run diff with the original file to check for changes)\"));", "    } else", "      MSG(_(\"Recovery completed. Buffer contents equals file contents.\"));"], "readability/braces"]
["src/nvim/memline.c", ["  xfree(fname_used);", "  recoverymode = FALSE;", "  if (mfp != NULL) {"], "readability/bool"]
["src/nvim/memline.c", ["  }", "  if (buf != NULL) {  //may be NULL if swap file not found.", "    xfree(buf->b_ml.ml_stack);"], "whitespace/comments"]
["src/nvim/memline.c", ["  if (serious_error && called_from_main)", "    ml_close(curbuf, TRUE);", "  else {"], "readability/bool"]
["src/nvim/memline.c", ["    ml_close(curbuf, TRUE);", "  else {", "    apply_autocmds(EVENT_BUFREADPOST, NULL, curbuf->b_fname, FALSE, curbuf);"], "readability/braces"]
["src/nvim/memline.c", ["  else {", "    apply_autocmds(EVENT_BUFREADPOST, NULL, curbuf->b_fname, FALSE, curbuf);", "    apply_autocmds(EVENT_BUFWINENTER, NULL, curbuf->b_fname, FALSE, curbuf);"], "readability/bool"]
["src/nvim/memline.c", ["    apply_autocmds(EVENT_BUFREADPOST, NULL, curbuf->b_fname, FALSE, curbuf);", "    apply_autocmds(EVENT_BUFWINENTER, NULL, curbuf->b_fname, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/memline.c", [" */", "int ", "recover_names ("], "whitespace/end_of_line"]
["src/nvim/memline.c", ["int ", "recover_names (", "    char_u *fname,             /* base for swap file name */"], "whitespace/parens"]
["src/nvim/memline.c", ["    int list,                       /* when TRUE, list the swap file names */", "    int nr,                         /* when non-zero, return nr'th swap file name */", "    char_u **fname_out        /* result when \"nr\" > 0 */"], "whitespace/line_length"]
["src/nvim/memline.c", ["        num_names = 3;", "      } else", "        num_names = recov_file_names(names, fname_res, TRUE);"], "readability/braces"]
["src/nvim/memline.c", ["      } else", "        num_names = recov_file_names(names, fname_res, TRUE);", "    } else {                      /* check directory dir_name */"], "readability/bool"]
["src/nvim/memline.c", ["      if (fname == NULL) {", "        names[0] = (char_u *)concat_fnames((char *)dir_name, \"*.sw?\", TRUE);", "        /* For Unix names starting with a dot are special.  MS-Windows"], "readability/bool"]
["src/nvim/memline.c", ["         * supports this too, on some file systems. */", "        names[1] = (char_u *)concat_fnames((char *)dir_name, \".*.sw?\", TRUE);", "        names[2] = (char_u *)concat_fnames((char *)dir_name, \".sw?\", TRUE);"], "readability/bool"]
["src/nvim/memline.c", ["        names[1] = (char_u *)concat_fnames((char *)dir_name, \".*.sw?\", TRUE);", "        names[2] = (char_u *)concat_fnames((char *)dir_name, \".sw?\", TRUE);", "        num_names = 3;"], "readability/bool"]
["src/nvim/memline.c", ["        if (after_pathsep((char *)dir_name, (char *)p) && p[-1] == p[-2]) {", "          /* Ends with '//', Use Full path for swap name */", "          tail = (char_u *)make_percent_swname((char *)dir_name, (char *)fname_res);"], "readability/multiline_comment"]
["src/nvim/memline.c", ["        if (after_pathsep((char *)dir_name, (char *)p) && p[-1] == p[-2]) {", "          /* Ends with '//', Use Full path for swap name */", "          tail = (char_u *)make_percent_swname((char *)dir_name, (char *)fname_res);"], "whitespace/comments"]
["src/nvim/memline.c", ["        if (after_pathsep((char *)dir_name, (char *)p) && p[-1] == p[-2]) {", "          /* Ends with '//', Use Full path for swap name */", "          tail = (char_u *)make_percent_swname((char *)dir_name, (char *)fname_res);"], "whitespace/comments"]
["src/nvim/memline.c", ["          /* Ends with '//', Use Full path for swap name */", "          tail = (char_u *)make_percent_swname((char *)dir_name, (char *)fname_res);", "        } else {"], "whitespace/line_length"]
["src/nvim/memline.c", ["          tail = path_tail(fname_res);", "          tail = (char_u *)concat_fnames((char *)dir_name, (char *)tail, TRUE);", "        }"], "readability/bool"]
["src/nvim/memline.c", ["        }", "        num_names = recov_file_names(names, tail, FALSE);", "        xfree(tail);"], "readability/bool"]
["src/nvim/memline.c", ["    if (*dirp == NUL && file_count + num_files == 0 && fname != NULL) {", "      char_u *swapname = (char_u *)modname((char *)fname_res, \".swp\", TRUE);", "      if (swapname != NULL) {"], "readability/bool"]
["src/nvim/memline.c", ["      for (int i = 0; i < num_files; ++i)", "        if (path_full_compare(p, files[i], TRUE) & kEqualFiles) {", "          /* Remove the name from files[i].  Move further entries"], "readability/bool"]
["src/nvim/memline.c", ["        }", "      } else", "        MSG_PUTS(_(\"      -- none --\\n\"));"], "readability/braces"]
["src/nvim/memline.c", ["      ui_flush();", "    } else", "      file_count += num_files;"], "readability/braces"]
["src/nvim/memline.c", ["    }", "    d = concat_fnames(dir, s, TRUE);", "    xfree(s);"], "readability/bool"]
["src/nvim/memline.c", ["      MSG_PUTS(_(\"   dated: \"));", "    } else", "#endif"], "readability/braces"]
["src/nvim/memline.c", ["    x = file_info.stat.st_mtim.tv_sec;", "    p = ctime(&x);  // includes '\\n'", "    if (p == NULL)"], "runtime/threadsafe_fn"]
["src/nvim/memline.c", ["            MSG_PUTS(_(\" (still running)\"));", "            process_still_running = TRUE;", "          }"], "readability/bool"]
["src/nvim/memline.c", ["      }", "    } else", "      MSG_PUTS(_(\"         [cannot be read]\"));"], "readability/braces"]
["src/nvim/memline.c", ["    close(fd);", "  } else", "    MSG_PUTS(_(\"         [cannot be opened]\"));"], "readability/braces"]
["src/nvim/memline.c", ["  if (prepend_dot) {", "    names[num_names] = (char_u *)modname((char *)path, \".sw?\", TRUE);", "    if (names[num_names] == NULL)"], "readability/bool"]
["src/nvim/memline.c", ["  // Form the normal swap file name pattern by appending \".sw?\".", "  names[num_names] = (char_u *)concat_fnames((char *)path, \".sw?\", FALSE);", "  if (num_names >= 1) {     /* check if we have the same name twice */"], "readability/bool"]
["src/nvim/memline.c", ["      xfree(names[num_names]);", "  } else", "    ++num_names;"], "readability/braces"]
["src/nvim/memline.c", ["          || os_fileinfo_size(&file_info) != buf->b_orig_size) {", "        ml_preserve(buf, FALSE);", "        did_check_timestamps = FALSE;"], "readability/bool"]
["src/nvim/memline.c", ["        ml_preserve(buf, FALSE);", "        did_check_timestamps = FALSE;", "        need_check_timestamps = TRUE;           /* give message later */"], "readability/bool"]
["src/nvim/memline.c", ["        did_check_timestamps = FALSE;", "        need_check_timestamps = TRUE;           /* give message later */", "      }"], "readability/bool"]
["src/nvim/memline.c", ["   * before. */", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["{", "  return ml_get_buf(curbuf, lnum, FALSE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["{", "  return ml_get_buf(curbuf, pos->lnum, FALSE) + pos->col;", "}"], "readability/bool"]
["src/nvim/memline.c", ["char_u *", "ml_get_buf (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/memline.c", [" */", "int ", "ml_append ("], "whitespace/end_of_line"]
["src/nvim/memline.c", ["int ", "ml_append (", "    linenr_T lnum,                  /* append after this line (can be 0) */"], "whitespace/parens"]
["src/nvim/memline.c", ["    char_u *line,              /* text of the new line */", "    colnr_T len,                    /* length of new line, including NUL, or 0 */", "    int newfile                    /* flag, see above */"], "whitespace/line_length"]
["src/nvim/memline.c", ["  /* When starting up, we might still need to create the memfile */", "  if (curbuf->b_ml.ml_mfp == NULL && open_buffer(FALSE, NULL, 0) == FAIL)", "    return FAIL;"], "readability/bool"]
["src/nvim/memline.c", ["    ml_flush_line(curbuf);", "  return ml_append_int(curbuf, lnum, line, len, newfile, FALSE);", "}"], "readability/bool"]
["src/nvim/memline.c", [" */", "int ", "ml_append_buf ("], "whitespace/end_of_line"]
["src/nvim/memline.c", ["int ", "ml_append_buf (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/memline.c", ["    char_u *line,              /* text of the new line */", "    colnr_T len,                    /* length of new line, including NUL, or 0 */", "    int newfile                    /* flag, see above */"], "whitespace/line_length"]
["src/nvim/memline.c", ["    ml_flush_line(buf);", "  return ml_append_int(buf, lnum, line, len, newfile, FALSE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["", "static int ", "ml_append_int ("], "whitespace/end_of_line"]
["src/nvim/memline.c", ["static int ", "ml_append_int (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/memline.c", ["      dp->db_index[db_idx + 1] = offset - len;", "    } else                                  /* add line at the end */", "      dp->db_index[db_idx + 1] = dp->db_txt_start;"], "readability/braces"]
["src/nvim/memline.c", ["      lines_moved = 0;", "      in_left = TRUE;", "      /* space_needed does not change */"], "readability/bool"]
["src/nvim/memline.c", ["      if (lines_moved == 0)", "        in_left = FALSE;                /* put new line in right block */", "                                        /* space_needed does not change */"], "readability/bool"]
["src/nvim/memline.c", ["                                        /* space_needed does not change */", "      else {", "        data_moved = ((dp->db_index[db_idx]) & DB_INDEX_MASK) -"], "readability/braces"]
["src/nvim/memline.c", ["        if ((int)dp->db_free + total_moved >= space_needed) {", "          in_left = TRUE;               /* put new line in left block */", "          space_needed = total_moved;"], "readability/bool"]
["src/nvim/memline.c", ["        } else {", "          in_left = FALSE;                  /* put new line in right block */", "          space_needed += total_moved;"], "readability/bool"]
["src/nvim/memline.c", ["  /* When starting up, we might still need to create the memfile */", "  if (curbuf->b_ml.ml_mfp == NULL && open_buffer(FALSE, NULL, 0) == FAIL)", "    return FAIL;"], "readability/bool"]
["src/nvim/memline.c", ["", "    i = ml_replace((linenr_T)1, (char_u *)\"\", TRUE);", "    buf->b_ml.ml_flags |= ML_EMPTY;"], "readability/bool"]
["src/nvim/memline.c", ["        mf_free(mfp, hp);", "      else {", "        if (count != idx)               /* move entries after the deleted one */"], "readability/braces"]
["src/nvim/memline.c", ["  int i;", "  static int entered = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["      return;", "    entered = TRUE;", ""], "readability/bool"]
["src/nvim/memline.c", ["      EMSGN(_(\"E320: Cannot find line %\" PRId64), lnum);", "    else {", "      dp = hp->bh_data;"], "readability/braces"]
["src/nvim/memline.c", ["        /* How about handling errors??? */", "        (void)ml_append_int(buf, lnum, new_line, new_len, FALSE,", "            (dp->db_index[idx] & DB_MARKED));"], "readability/bool"]
["src/nvim/memline.c", ["            (dp->db_index[idx] & DB_MARKED));", "        (void)ml_delete_int(buf, lnum, FALSE);", "      }"], "readability/bool"]
["src/nvim/memline.c", ["", "    entered = FALSE;", "  }"], "readability/bool"]
["src/nvim/memline.c", ["        high = ip->ip_high;", "        buf->b_ml.ml_stack_top = top;           /* truncate stack at prev entry */", "        break;"], "whitespace/line_length"]
["src/nvim/memline.c", ["    if (top < 0)", "      buf->b_ml.ml_stack_top = 0;               /* not found, start at the root */", "  } else        /* ML_DELETE or ML_INSERT */"], "whitespace/line_length"]
["src/nvim/memline.c", ["      buf->b_ml.ml_stack_top = 0;               /* not found, start at the root */", "  } else        /* ML_DELETE or ML_INSERT */", "    buf->b_ml.ml_stack_top = 0;         /* start at the root */"], "readability/braces"]
["src/nvim/memline.c", ["", "    dirty = FALSE;", "    for (idx = 0; idx < (int)pp->pb_count; ++idx) {"], "readability/bool"]
["src/nvim/memline.c", ["            pp->pb_pointer[idx].pe_bnum = bnum;", "            dirty = TRUE;", "          }"], "readability/bool"]
["src/nvim/memline.c", ["      pp->pb_pointer[idx].pe_line_count--;", "      dirty = TRUE;", "    } else if (action == ML_INSERT) {"], "readability/bool"]
["src/nvim/memline.c", ["      pp->pb_pointer[idx].pe_line_count++;", "      dirty = TRUE;", "    }"], "readability/bool"]
["src/nvim/memline.c", ["      STRCPY(tmp, buf);", "    else {", "      char_u *tail;"], "readability/braces"]
["src/nvim/memline.c", ["   */", "  return vim_FullName((char *)tmp, (char *)buf, MAXPATHL, TRUE);", "}"], "readability/bool"]
["src/nvim/memline.c", [" */", "char_u *makeswapname(char_u *fname, char_u *ffname, buf_T *buf, char_u *dir_name)", "{"], "whitespace/line_length"]
["src/nvim/memline.c", ["  s = dir_name + STRLEN(dir_name);", "  if (after_pathsep((char *)dir_name, (char *)s) && s[-1] == s[-2]) { /* Ends with '//', Use Full path */", "    r = NULL;"], "readability/multiline_comment"]
["src/nvim/memline.c", ["  s = dir_name + STRLEN(dir_name);", "  if (after_pathsep((char *)dir_name, (char *)s) && s[-1] == s[-2]) { /* Ends with '//', Use Full path */", "    r = NULL;"], "whitespace/line_length"]
["src/nvim/memline.c", ["  s = dir_name + STRLEN(dir_name);", "  if (after_pathsep((char *)dir_name, (char *)s) && s[-1] == s[-2]) { /* Ends with '//', Use Full path */", "    r = NULL;"], "whitespace/comments"]
["src/nvim/memline.c", ["  s = dir_name + STRLEN(dir_name);", "  if (after_pathsep((char *)dir_name, (char *)s) && s[-1] == s[-2]) { /* Ends with '//', Use Full path */", "    r = NULL;"], "whitespace/comments"]
["src/nvim/memline.c", ["    r = NULL;", "    if ((s = (char_u *)make_percent_swname((char *)dir_name, (char *)fname)) != NULL) {", "      r = (char_u *)modname((char *)s, \".swp\", FALSE);"], "whitespace/line_length"]
["src/nvim/memline.c", ["    if ((s = (char_u *)make_percent_swname((char *)dir_name, (char *)fname)) != NULL) {", "      r = (char_u *)modname((char *)s, \".swp\", FALSE);", "      xfree(s);"], "readability/bool"]
["src/nvim/memline.c", ["char_u *", "get_file_in_dir (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/memline.c", ["    if (tail == fname)              /* no path before file name */", "      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);", "    else {"], "readability/bool"]
["src/nvim/memline.c", ["      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);", "    else {", "      save_char = *tail;"], "readability/braces"]
["src/nvim/memline.c", ["      *tail = NUL;", "      t = (char_u *)concat_fnames((char *)fname, (char *)dname + 2, TRUE);", "      *tail = save_char;"], "readability/bool"]
["src/nvim/memline.c", ["      *tail = save_char;", "      retval = (char_u *)concat_fnames((char *)t, (char *)tail, TRUE);", "      xfree(t);"], "readability/bool"]
["src/nvim/memline.c", ["  } else {", "    retval = (char_u *)concat_fnames((char *)dname, (char *)tail, TRUE);", "  }"], "readability/bool"]
["src/nvim/memline.c", [" */", "static void ", "attention_message ("], "whitespace/end_of_line"]
["src/nvim/memline.c", ["static void ", "attention_message (", "    buf_T *buf,           /* buffer being edited */"], "whitespace/parens"]
["src/nvim/memline.c", ["    x = file_info.stat.st_mtim.tv_sec;", "    p = ctime(&x);  // includes '\\n'", "    if (p == NULL)"], "runtime/threadsafe_fn"]
["src/nvim/memline.c", ["  MSG_PUTS(_(", "          \"\\n(1) Another program may be editing the same file.  If this is the case,\\n    be careful not to end up with two different instances of the same\\n    file when making changes.\"));", "  MSG_PUTS(_(\"  Quit, or continue with caution.\\n\"));"], "whitespace/line_length"]
["src/nvim/memline.c", ["  ++allbuf_lock;", "  apply_autocmds(EVENT_SWAPEXISTS, buf->b_fname, NULL, FALSE, NULL);", "  --allbuf_lock;"], "readability/bool"]
["src/nvim/memline.c", ["        struct block0 b0;", "        int differ = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["                    char_to_long(b0.b0_ino))) {", "                  differ = TRUE;", "                }"], "readability/bool"]
["src/nvim/memline.c", ["                  char_to_long(b0.b0_ino))) {", "                differ = TRUE;", "              }"], "readability/bool"]
["src/nvim/memline.c", ["        * for the current file, and the buffer was not recovered. */", "        if (differ == FALSE && !(curbuf->b_flags & BF_RECOVERED)", "            && vim_strchr(p_shm, SHM_ATTENTION) == NULL) {"], "readability/bool"]
["src/nvim/memline.c", ["#ifdef UNIX", "          process_still_running = FALSE;", "#endif"], "readability/bool"]
["src/nvim/memline.c", ["             * interrupt loading a file. */", "            got_int = FALSE;", "          }"], "readability/bool"]
["src/nvim/memline.c", ["                (char_u *)_(", "                    \"&Open Read-Only\\n&Edit anyway\\n&Recover\\n&Delete it\\n&Quit\\n&Abort\"),", "                1, NULL, FALSE);"], "whitespace/line_length"]
["src/nvim/memline.c", ["                    \"&Open Read-Only\\n&Edit anyway\\n&Recover\\n&Delete it\\n&Quit\\n&Abort\"),", "                1, NULL, FALSE);", ""], "readability/bool"]
["src/nvim/memline.c", ["            case 1:", "              buf->b_p_ro = TRUE;", "              break;"], "readability/bool"]
["src/nvim/memline.c", ["              swap_exists_action = SEA_QUIT;", "              got_int = TRUE;", "              break;"], "readability/bool"]
["src/nvim/memline.c", ["              break;", "          } else", "          {"], "readability/braces"]
["src/nvim/memline.c", ["              /* call wait_return() later */", "              need_wait_return = TRUE;", "          }"], "readability/bool"]
["src/nvim/memline.c", ["          }", "", "        }"], "whitespace/blank_line"]
["src/nvim/memline.c", ["         || b0p->b0_magic_int != (int)B0_MAGIC_INT", "         || b0p->b0_magic_short != (short)B0_MAGIC_SHORT", "         || b0p->b0_magic_char != B0_MAGIC_CHAR;"], "runtime/int"]
["src/nvim/memline.c", ["static int", "fnamecmp_ino (", "    char_u *fname_c,               /* current file name */"], "whitespace/parens"]
["src/nvim/memline.c", ["   */", "  retval_c = vim_FullName((char *)fname_c, (char *)buf_c, MAXPATHL, TRUE);", "  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);"], "readability/bool"]
["src/nvim/memline.c", ["  retval_c = vim_FullName((char *)fname_c, (char *)buf_c, MAXPATHL, TRUE);", "  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);", "  if (retval_c == OK && retval_s == OK)"], "readability/bool"]
["src/nvim/memline.c", ["  if (ino_s == 0 && ino_c == 0 && retval_c == FAIL && retval_s == FAIL)", "    return FALSE;", "  return TRUE;"], "readability/bool"]
["src/nvim/memline.c", ["    return FALSE;", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/memline.c", ["    curwin->w_cursor.coladd = 0;", "    curwin->w_set_curswant = TRUE;", "  }"], "readability/bool"]
["src/nvim/memory.c", ["// marker so line numbers and indices both start at 1", " // Various routines dealing with allocation and deallocation of memory.", ""], "whitespace/indent"]
["src/nvim/memory.c", ["///", "/// WARNING: If copying takes place between objects that overlap, the behavior is", "/// undefined."], "whitespace/line_length"]
["src/nvim/memory.c", ["///", "/// WARNING: If copying takes place between objects that overlap, the behavior is", "/// undefined."], "whitespace/line_length"]
["src/nvim/menu.c", [" */", "void ", "ex_menu ("], "whitespace/end_of_line"]
["src/nvim/menu.c", ["void ", "ex_menu (", "    exarg_T *eap                   /* Ex command arguments */"], "whitespace/parens"]
["src/nvim/menu.c", ["  long pri_tab[MENUDEPTH + 1];", "  int enable = MAYBE;               /* TRUE for \"menu enable\", FALSE for \"menu", "                                     * disable */"], "readability/multiline_comment"]
["src/nvim/menu.c", ["  long pri_tab[MENUDEPTH + 1];", "  int enable = MAYBE;               /* TRUE for \"menu enable\", FALSE for \"menu", "                                     * disable */"], "readability/multiline_string"]
["src/nvim/menu.c", ["  long pri_tab[MENUDEPTH + 1];", "  int enable = MAYBE;               /* TRUE for \"menu enable\", FALSE for \"menu", "                                     * disable */"], "readability/bool"]
["src/nvim/menu.c", ["    i = 1;", "  } else", "    i = 0;"], "readability/braces"]
["src/nvim/menu.c", ["  if (STRNCMP(arg, \"enable\", 6) == 0 && ascii_iswhite(arg[6])) {", "    enable = TRUE;", "    arg = skipwhite(arg + 6);"], "readability/bool"]
["src/nvim/menu.c", ["  } else if (STRNCMP(arg, \"disable\", 7) == 0 && ascii_iswhite(arg[7])) {", "    enable = FALSE;", "    arg = skipwhite(arg + 7);"], "readability/bool"]
["src/nvim/menu.c", ["          p = popup_mode_name(menu_path, i);", "          remove_menu(&root_menu, p, MENU_ALL_MODES, TRUE);", "          xfree(p);"], "readability/bool"]
["src/nvim/menu.c", ["    /* Careful: remove_menu() changes menu_path */", "    remove_menu(&root_menu, menu_path, modes, FALSE);", "  } else {"], "readability/bool"]
["src/nvim/menu.c", ["      map_buf = NULL;", "    } else if (modes & MENU_TIP_MODE)", "      map_buf = NULL;           /* Menu tips are plain text. */"], "readability/braces"]
["src/nvim/menu.c", ["    else", "      map_to = replace_termcodes(map_to, &map_buf, FALSE, TRUE, special);", "    menuarg.modes = modes;"], "readability/bool"]
["src/nvim/menu.c", ["    add_menu_path(menu_path, &menuarg, pri_tab, map_to", "        );", ""], "whitespace/parens"]
["src/nvim/menu.c", ["theend:", "  ;", "}"], "whitespace/semicolon"]
["src/nvim/menu.c", [" */", "static int ", "add_menu_path ("], "whitespace/end_of_line"]
["src/nvim/menu.c", ["static int ", "add_menu_path (", "    char_u *menu_path,"], "whitespace/parens"]
["src/nvim/menu.c", ["    char_u *menu_path,", "    vimmenu_T *menuarg,           /* passes modes, iconfile, iconidx,", "                                   icon_builtin, silent[0], noremap[0] */"], "readability/multiline_comment"]
["src/nvim/menu.c", ["      name = map_to;", "    } else", "      en_name = NULL;"], "readability/braces"]
["src/nvim/menu.c", ["        if (c != 0) {", "          menu->strings[i] = xmalloc(STRLEN(call_data) + 5 );", "          menu->strings[i][0] = c;"], "whitespace/parens"]
["src/nvim/menu.c", ["            STRCPY(menu->strings[i] + 1, call_data);", "          else {", "            menu->strings[i][1] = d;"], "readability/braces"]
["src/nvim/menu.c", ["          }", "        } else", "          menu->strings[i] = p;"], "readability/braces"]
["src/nvim/menu.c", ["    for (; *menup != NULL && *menup != parent; menup = &((*menup)->next))", "      ;", "    if (*menup == NULL)     /* safety check */"], "whitespace/semicolon"]
["src/nvim/menu.c", [" */", "static int menu_nable_recurse(vimmenu_T *menu, char_u *name, int modes, int enable)", "{"], "whitespace/line_length"]
["src/nvim/menu.c", ["          return FAIL;", "      } else if (enable)", "        menu->enabled |= modes;"], "readability/braces"]
["src/nvim/menu.c", [" */", "static int ", "remove_menu ("], "whitespace/end_of_line"]
["src/nvim/menu.c", ["static int ", "remove_menu (", "    vimmenu_T **menup,"], "whitespace/parens"]
["src/nvim/menu.c", ["        menup = &menu->next;", "    } else", "      menup = &menu->next;"], "readability/braces"]
["src/nvim/menu.c", ["  xfree(menu);", "", "}"], "whitespace/blank_line"]
["src/nvim/menu.c", ["        else", "          msg_outtrans_special(menu->strings[bit], FALSE);", "      }"], "readability/bool"]
["src/nvim/menu.c", ["      depth--;", "    } else", "      menu = menu->children;"], "readability/braces"]
["src/nvim/menu.c", [" */", "char_u *set_context_in_menu_cmd(expand_T *xp, char_u *cmd, char_u *arg, int forceit)", "{"], "whitespace/line_length"]
["src/nvim/menu.c", ["    expand_menu = menu;", "  } else                        /* We're in the mapping part */", "    xp->xp_context = EXPAND_NOTHING;"], "readability/braces"]
["src/nvim/menu.c", ["  char_u              *str;", "  static int should_advance = FALSE;", ""], "readability/bool"]
["src/nvim/menu.c", ["    menu = expand_menu;", "    should_advance = FALSE;", "  }"], "readability/bool"]
["src/nvim/menu.c", ["      str = menu->en_dname;", "    else {", "      str = menu->dname;"], "readability/braces"]
["src/nvim/menu.c", ["      if (menu->en_dname == NULL)", "        should_advance = TRUE;", "    }"], "readability/bool"]
["src/nvim/menu.c", ["    }", "  else", "    str = (char_u *)\"\";"], "whitespace/newline"]
["src/nvim/menu.c", ["  char_u              *str;", "  static int should_advance = FALSE;", ""], "readability/bool"]
["src/nvim/menu.c", ["    menu = expand_menu;", "    should_advance = FALSE;", "  }"], "readability/bool"]
["src/nvim/menu.c", ["  while (menu != NULL", "         && (   menu_is_hidden(menu->dname)", "                || (expand_emenu && menu_is_separator(menu->dname))"], "whitespace/parens"]
["src/nvim/menu.c", ["                || menu->dname[STRLEN(menu->dname) - 1] == '.'", "                ))", "    menu = menu->next;"], "whitespace/parens"]
["src/nvim/menu.c", ["        STRLCPY(tbuffer, menu->en_dname, TBUFFER_LEN - 1);", "      else {", "        STRLCPY(tbuffer, menu->dname,  TBUFFER_LEN - 1);"], "readability/braces"]
["src/nvim/menu.c", ["        if (menu->en_dname == NULL)", "          should_advance = TRUE;", "      }"], "readability/bool"]
["src/nvim/menu.c", ["        str = menu->en_dname;", "      else {", "        str = menu->dname;"], "readability/braces"]
["src/nvim/menu.c", ["        if (menu->en_dname == NULL)", "          should_advance = TRUE;", "      }"], "readability/bool"]
["src/nvim/menu.c", ["    }", "  } else", "    str = (char_u *)\"\";"], "readability/braces"]
["src/nvim/menu.c", ["          || menu_namecmp(name, menu->en_dname)))", "    return TRUE;", "  return menu_namecmp(name, menu->name) || menu_namecmp(name, menu->dname);"], "readability/bool"]
["src/nvim/menu.c", [" */", "static int ", "get_menu_cmd_modes ("], "whitespace/end_of_line"]
["src/nvim/menu.c", ["static int ", "get_menu_cmd_modes (", "    char_u *cmd,"], "whitespace/parens"]
["src/nvim/menu.c", ["    text = vim_strnsave(str, (size_t)(p - str));", "  } else", "    text = vim_strsave(str);"], "readability/braces"]
["src/nvim/menu.c", ["    /* Activate visual mode */", "    VIsual_active = TRUE;", "    VIsual_reselect = TRUE;"], "readability/bool"]
["src/nvim/menu.c", ["    VIsual_active = TRUE;", "    VIsual_reselect = TRUE;", "    check_cursor();"], "readability/bool"]
["src/nvim/menu.c", ["      ins_typebuf(menu->strings[idx], menu->noremap[idx], 0,", "          TRUE, menu->silent[idx]);", "  } else"], "readability/bool"]
["src/nvim/menu.c", ["          TRUE, menu->silent[idx]);", "  } else", "    EMSG2(_(\"E335: Menu not defined for %s mode\"), mode);"], "readability/braces"]
["src/nvim/menu.c", ["      EMSG(_(e_invarg));", "    else {", "      from = vim_strsave(from);"], "readability/braces"]
["src/nvim/message.c", ["", "static int confirm_msg_used = FALSE;            /* displaying confirm_msg */", "#ifdef INCLUDE_GENERATED_DECLARATIONS"], "readability/bool"]
["src/nvim/message.c", ["static FILE *verbose_fd = NULL;", "static int verbose_did_open = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["{", "  return msg_attr_keep(s, 0, FALSE);", "}"], "readability/bool"]
["src/nvim/message.c", ["  verbose_enter();", "  n = msg_attr_keep(s, 0, FALSE);", "  verbose_leave();"], "readability/bool"]
["src/nvim/message.c", ["{", "  return msg_attr_keep(s, attr, FALSE);", "}"], "readability/bool"]
["src/nvim/message.c", ["int", "msg_attr_keep (", "    char_u *s,"], "whitespace/parens"]
["src/nvim/message.c", ["  if (entered >= 3)", "    return TRUE;", "  ++entered;"], "readability/bool"]
["src/nvim/message.c", ["  msg_start();", "  buf = msg_strtrunc(s, FALSE);", "  if (buf != NULL)"], "readability/bool"]
["src/nvim/message.c", ["char_u *", "msg_strtrunc (", "    char_u *s,"], "whitespace/parens"]
["src/nvim/message.c", ["        half = half - (*mb_head_off)(s, s + half - 1) - 1;", "      while (utf_iscomposing(utf_ptr2char(s + half)) && half > 0);", "      n = ptr2cells(s + half);"], "whitespace/empty_loop_body"]
["src/nvim/message.c", ["      return STRCMP(sourcing_name, last_sourcing_name) != 0;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["    Buf = xmalloc(STRLEN(sourcing_name) + STRLEN(p));", "    sprintf((char *)Buf, (char *)p, sourcing_name);", "    return Buf;"], "runtime/printf"]
["src/nvim/message.c", ["    Buf = xmalloc(STRLEN(p) + 20);", "    sprintf((char *)Buf, (char *)p, (long)sourcing_lnum);", "    return Buf;"], "runtime/printf"]
["src/nvim/message.c", ["      )", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/message.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["  char_u      *p;", "  int ignore = FALSE;", "  int severe;"], "readability/bool"]
["src/nvim/message.c", ["  if (emsg_not_now())", "    return TRUE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "  called_emsg = TRUE;", "  ex_exitval = 1;"], "readability/bool"]
["src/nvim/message.c", ["  severe = emsg_severe;", "  emsg_severe = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["     */", "    if (cause_errthrow(s, severe, &ignore) == TRUE) {", "      if (!ignore)"], "readability/bool"]
["src/nvim/message.c", ["      if (!ignore)", "        did_emsg = TRUE;", "      return TRUE;"], "readability/bool"]
["src/nvim/message.c", ["        did_emsg = TRUE;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/message.c", ["      redir_write(s, -1);", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/message.c", ["    msg_silent = 0;", "    cmd_silent = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["    else", "      flush_buffers(FALSE);             /* flush internal buffers */", "    did_emsg = TRUE;                    /* flag for DoOneCmd() */"], "readability/bool"]
["src/nvim/message.c", ["      flush_buffers(FALSE);             /* flush internal buffers */", "    did_emsg = TRUE;                    /* flag for DoOneCmd() */", "  }"], "readability/bool"]
["src/nvim/message.c", ["", "  emsg_on_display = TRUE;       /* remember there is an error message */", "  ++msg_scroll;                 /* don't overwrite a previous message */"], "readability/bool"]
["src/nvim/message.c", ["  if (msg_scrolled != 0)", "    need_wait_return = TRUE;        /* needed in case emsg() is called after", "                                     * wait_return has reset need_wait_return"], "readability/multiline_comment"]
["src/nvim/message.c", ["  if (msg_scrolled != 0)", "    need_wait_return = TRUE;        /* needed in case emsg() is called after", "                                     * wait_return has reset need_wait_return"], "readability/bool"]
["src/nvim/message.c", ["                                     * wait_return has reset need_wait_return", "                                     * and a redraw is expected because", "                                     * msg_scrolled is non-zero */"], "readability/alt_tokens"]
["src/nvim/message.c", ["   */", "  msg_nowait = FALSE;                   /* wait for this msg */", "  return msg_attr(s, attr);"], "readability/bool"]
["src/nvim/message.c", ["  if (emsg_not_now()) {", "    return TRUE;                // no error messages at the moment", "  }"], "readability/bool"]
["src/nvim/message.c", ["  if (emsg_not_now()) {", "    return TRUE;                // no error messages at the moment", "  }"], "readability/bool"]
["src/nvim/message.c", ["  if (emsg_not_now()) {", "    return TRUE;                // no error messages at the moment", "  }"], "readability/bool"]
["src/nvim/message.c", ["", "  msg_hist_off = TRUE;", "  n = msg_attr(s, attr);"], "readability/bool"]
["src/nvim/message.c", ["  n = msg_attr(s, attr);", "  msg_hist_off = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["static void", "add_msg_hist (", "    char_u *s,"], "whitespace/parens"]
["src/nvim/message.c", ["", "  msg_hist_off = TRUE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "  msg_hist_off = FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["{", "  need_wait_return = FALSE;", "  emsg_on_display = FALSE;"], "readability/bool"]
["src/nvim/message.c", ["  need_wait_return = FALSE;", "  emsg_on_display = FALSE;", "  cmdline_row = msg_row;"], "readability/bool"]
["src/nvim/message.c", ["", "  if (redraw == TRUE)", "    must_redraw = CLEAR;"], "readability/bool"]
["src/nvim/message.c", ["    return;", "  need_wait_return = TRUE;", "  if (no_wait_return) {"], "readability/bool"]
["src/nvim/message.c", ["", "  redir_off = TRUE;             /* don't redirect this message */", "  oldState = State;"], "readability/bool"]
["src/nvim/message.c", ["    c = CAR;                    /* just pretend CR was hit */", "    quit_more = FALSE;", "    got_int = FALSE;"], "readability/bool"]
["src/nvim/message.c", ["    quit_more = FALSE;", "    got_int = FALSE;", "  } else if (exmode_active) {"], "readability/bool"]
["src/nvim/message.c", ["    c = CAR;                    /* no need for a return in ex mode */", "    got_int = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/message.c", ["    if (need_check_timestamps)", "      check_timestamps(FALSE);", ""], "readability/bool"]
["src/nvim/message.c", ["      save_scriptout = scriptout;", "      Recording = FALSE;", "      scriptout = NULL;"], "readability/bool"]
["src/nvim/message.c", ["      if (had_got_int && !global_busy)", "        got_int = FALSE;", "      --no_mapping;"], "readability/bool"]
["src/nvim/message.c", ["            do_more_prompt(c);", "          else {", "            msg_didout = FALSE;"], "readability/braces"]
["src/nvim/message.c", ["          else {", "            msg_didout = FALSE;", "            c = K_IGNORE;"], "readability/bool"]
["src/nvim/message.c", ["            c = CAR;                            /* just pretend CR was hit */", "            quit_more = FALSE;", "            got_int = FALSE;"], "readability/bool"]
["src/nvim/message.c", ["            quit_more = FALSE;", "            got_int = FALSE;", "          } else if (c != K_IGNORE) {"], "readability/bool"]
["src/nvim/message.c", ["          }", "        } else if (msg_scrolled > Rows - 2", "                   && (c == 'j' || c == 'd' || c == 'f'"], "readability/braces"]
["src/nvim/message.c", ["                     || c == K_X2MOUSE))", "             );", "    os_breakcheck();"], "whitespace/parens"]
["src/nvim/message.c", ["      ins_char_typebuf(c);", "      do_redraw = TRUE;             /* need a redraw even though there is", "                                       typeahead */"], "readability/multiline_comment"]
["src/nvim/message.c", ["      ins_char_typebuf(c);", "      do_redraw = TRUE;             /* need a redraw even though there is", "                                       typeahead */"], "readability/bool"]
["src/nvim/message.c", ["  }", "  redir_off = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["      cmdline_row = msg_row;", "    skip_redraw = TRUE;             /* skip redraw once */", "    do_redraw = FALSE;"], "readability/bool"]
["src/nvim/message.c", ["    skip_redraw = TRUE;             /* skip redraw once */", "    do_redraw = FALSE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  msg_check();", "  need_wait_return = FALSE;", "  did_wait_return = TRUE;"], "readability/bool"]
["src/nvim/message.c", ["  need_wait_return = FALSE;", "  did_wait_return = TRUE;", "  emsg_on_display = FALSE;      /* can delete error message now */"], "readability/bool"]
["src/nvim/message.c", ["  did_wait_return = TRUE;", "  emsg_on_display = FALSE;      /* can delete error message now */", "  lines_left = -1;              /* reset lines_left at next msg_start() */"], "readability/bool"]
["src/nvim/message.c", ["  } else if (!skip_redraw", "             && (redraw == TRUE || (msg_scrolled != 0 && redraw != -1))) {", "    redraw_later(VALID);"], "readability/bool"]
["src/nvim/message.c", ["", "  p_more = FALSE;       /* don't want see this message when scrolling back */", "  if (msg_didout)       /* start on a new line */"], "readability/bool"]
["src/nvim/message.c", ["    keep_msg = NULL;", "  keep_msg_more = FALSE;", "  keep_msg_attr = attr;"], "readability/bool"]
["src/nvim/message.c", ["{", "  int did_return = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["     * any text from the command. */", "    need_clr_eos = FALSE;", "    msg_clr_eos();"], "readability/bool"]
["src/nvim/message.c", ["    msg_putchar('\\n');", "    did_return = TRUE;", "    if (exmode_active != EXMODE_NORMAL)"], "readability/bool"]
["src/nvim/message.c", ["  if (msg_silent == 0) {", "    msg_didout = FALSE;                     /* no output on current line yet */", "  }"], "readability/bool"]
["src/nvim/message.c", ["  lines_left = cmdline_row;", "  msg_didany = FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "  sprintf((char *)buf, \"%\" PRId64, (int64_t)n);", "  msg_puts(buf);"], "runtime/printf"]
["src/nvim/message.c", ["        retval += (*mb_ptr2cells)(str);", "      else {", "        /* unprintable multi-byte char: print the printable chars so"], "readability/braces"]
["src/nvim/message.c", ["        retval += (int)STRLEN(s);", "      } else", "        ++retval;"], "readability/braces"]
["src/nvim/message.c", ["int", "msg_outtrans_special (", "    char_u *strstart,"], "whitespace/parens"]
["src/nvim/message.c", ["      ++str;", "    } else", "      string = str2special(&str, from);"], "readability/braces"]
["src/nvim/message.c", ["char_u *", "str2special_save (", "    char_u *str,"], "whitespace/parens"]
["src/nvim/message.c", ["char_u *", "str2special (", "    char_u **sp,"], "whitespace/parens"]
["src/nvim/message.c", ["  int modifiers = 0;", "  int special = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["    if (IS_SPECIAL(c) || modifiers)     /* special key */", "      special = TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["    *sp = str + len;", "  } else", "    *sp = str + 1;"], "readability/braces"]
["src/nvim/message.c", ["  while (*sp) {", "    s = str2special(&sp, FALSE);", "    if ((int)(STRLEN(s) + STRLEN(buf)) < len)"], "readability/bool"]
["src/nvim/message.c", ["  if (curwin->w_p_list)", "    list = TRUE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "  msg_didout = TRUE;            /* remember that line is not empty */", "  cw = (*mb_ptr2cells)(s);"], "readability/bool"]
["src/nvim/message.c", ["  if (msg_scrolled != 0 && !msg_scrolled_ign)", "    need_wait_return = TRUE;", "  msg_didany = TRUE;            /* remember that something was outputted */"], "readability/bool"]
["src/nvim/message.c", ["    need_wait_return = TRUE;", "  msg_didany = TRUE;            /* remember that something was outputted */", ""], "readability/bool"]
["src/nvim/message.c", ["  else", "    msg_puts_display(str, maxlen, attr, FALSE);", "}"], "readability/bool"]
["src/nvim/message.c", ["", "  did_wait_return = FALSE;", "  while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL) {"], "readability/bool"]
["src/nvim/message.c", ["                                               || (*s == TAB && msg_col +", "                                                   t_col >= ((Columns - 1) & ~7))", "                                               || (has_mbyte &&"], "whitespace/line_length"]
["src/nvim/message.c", ["                                                   Columns - 2)", "                                              )))) {", "      /*"], "whitespace/parens"]
["src/nvim/message.c", ["          s = screen_puts_mbyte(s, l, attr);", "        } else", "          msg_screen_putchar(*s++, attr);"], "readability/braces"]
["src/nvim/message.c", ["          msg_screen_putchar(*s++, attr);", "        did_last_char = TRUE;", "      } else"], "readability/bool"]
["src/nvim/message.c", ["        did_last_char = TRUE;", "      } else", "        did_last_char = FALSE;"], "readability/braces"]
["src/nvim/message.c", ["      } else", "        did_last_char = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["        /* store text for scrolling back */", "        store_sb_text(&sb_str, s, attr, &sb_col, TRUE);", ""], "readability/bool"]
["src/nvim/message.c", ["      inc_msg_scrolled();", "      need_wait_return = TRUE;       /* may need wait_return in main() */", "      if (must_redraw < VALID)"], "readability/bool"]
["src/nvim/message.c", ["        must_redraw = VALID;", "      redraw_cmdline = TRUE;", "      if (cmdline_row > 0 && !exmode_active)"], "readability/bool"]
["src/nvim/message.c", ["               && msg_col + t_col >= Columns - 1)", "    ;", "    if (t_col > 0 && (wrap || *s == '\\r' || *s == '\\b'"], "whitespace/semicolon"]
["src/nvim/message.c", ["      /* store text for scrolling back */", "      store_sb_text(&sb_str, s, attr, &sb_col, TRUE);", ""], "readability/bool"]
["src/nvim/message.c", ["    if (*s == '\\n') {               /* go to next line */", "      msg_didout = FALSE;           /* remember that line is empty */", "      if (cmdmsg_rl)"], "readability/bool"]
["src/nvim/message.c", ["  if (p_more && !recurse)", "    store_sb_text(&sb_str, s, attr, &sb_col, FALSE);", ""], "readability/bool"]
["src/nvim/message.c", ["      p = (char_u *)_(\"Unknown\");", "    else {", "      len = (int)STRLEN(p) + 40;"], "readability/braces"]
["src/nvim/message.c", ["", "static int do_clear_sb_text = FALSE;    /* clear text on next msg */", ""], "readability/bool"]
["src/nvim/message.c", ["static void", "store_sb_text (", "    char_u **sb_str,           /* start of string */"], "whitespace/parens"]
["src/nvim/message.c", ["    clear_sb_text();", "    do_clear_sb_text = FALSE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["    mp->sb_next = NULL;", "  } else if (finish && last_msgchunk != NULL)", "    last_msgchunk->sb_eol = TRUE;"], "readability/braces"]
["src/nvim/message.c", ["  } else if (finish && last_msgchunk != NULL)", "    last_msgchunk->sb_eol = TRUE;", ""], "readability/bool"]
["src/nvim/message.c", ["{", "  do_clear_sb_text = TRUE;", "}"], "readability/bool"]
["src/nvim/message.c", ["    do_more_prompt('G');", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/message.c", ["  if (last_msgchunk != NULL)", "    last_msgchunk->sb_eol = TRUE;", "}"], "readability/bool"]
["src/nvim/message.c", ["      ++p;", "    msg_puts_display(p, -1, mp->sb_attr, TRUE);", "    if (mp->sb_eol || mp->sb_next == NULL)"], "readability/bool"]
["src/nvim/message.c", ["  /* output postponed text */", "  msg_didout = TRUE;            /* remember that line is not empty */", "  screen_puts_len(t_s, (int)(s - t_s), msg_row, msg_col, attr);"], "readability/bool"]
["src/nvim/message.c", ["  }", "  msg_didout = TRUE;        /* assume that line is not empty */", ""], "readability/bool"]
["src/nvim/message.c", ["  msg_didout = TRUE;        /* assume that line is not empty */", "", "}"], "whitespace/blank_line"]
["src/nvim/message.c", ["  int c;", "  int retval = FALSE;", "  int toscroll;"], "readability/bool"]
["src/nvim/message.c", ["  if (typed_char == NUL)", "    msg_moremsg(FALSE);", "  for (;; ) {"], "readability/bool"]
["src/nvim/message.c", ["      used_typed_char = NUL;", "    } else", "      c = get_keystroke();"], "readability/braces"]
["src/nvim/message.c", ["        cmdline_row = Rows - 1;                 /* put ':' on this line */", "        skip_redraw = TRUE;                     /* skip redraw once */", "        need_wait_return = FALSE;               /* don't wait in main() */"], "readability/bool"]
["src/nvim/message.c", ["        skip_redraw = TRUE;                     /* skip redraw once */", "        need_wait_return = FALSE;               /* don't wait in main() */", "      }"], "readability/bool"]
["src/nvim/message.c", ["        /* Jump to the choices of the dialog. */", "        retval = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/message.c", ["      } else {", "        got_int = TRUE;", "        quit_more = TRUE;"], "readability/bool"]
["src/nvim/message.c", ["        got_int = TRUE;", "        quit_more = TRUE;", "      }"], "readability/bool"]
["src/nvim/message.c", ["    default:                    /* no valid response */", "      msg_moremsg(TRUE);", "      continue;"], "readability/bool"]
["src/nvim/message.c", ["            (int)Columns, ' ', ' ', 0);", "        msg_moremsg(FALSE);", "        continue;"], "readability/bool"]
["src/nvim/message.c", ["    msg_col = 0;", "  } else if (cmdmsg_rl)", "    msg_col = Columns - 1;"], "readability/braces"]
["src/nvim/message.c", ["  /* avoid a delay for a message that isn't there */", "  emsg_on_display = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["{", "  msg_didout = TRUE;            /* remember that line is not empty */", "  screen_putchar(c, msg_row, msg_col, attr);"], "readability/bool"]
["src/nvim/message.c", ["  if (State == ASKMORE) {", "    msg_moremsg(TRUE);          /* display --more-- message again */", "    msg_row = Rows - 1;"], "readability/bool"]
["src/nvim/message.c", ["       * FocusGained autocmd exists but didn't draw anything. */", "      msg_didout = FALSE;", "      msg_col = 0;"], "readability/bool"]
["src/nvim/message.c", ["  if (!exiting && need_wait_return && !(State & CMDLINE)) {", "    wait_return(FALSE);", "    return FALSE;"], "readability/bool"]
["src/nvim/message.c", ["    wait_return(FALSE);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  ui_flush();", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/message.c", ["  if (msg_row == Rows - 1 && msg_col >= sc_col) {", "    need_wait_return = TRUE;", "    redraw_cmdline = TRUE;"], "readability/bool"]
["src/nvim/message.c", ["    need_wait_return = TRUE;", "    redraw_cmdline = TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["        if (redir_reg)", "          write_reg_contents(redir_reg, (char_u *)\" \", -1, TRUE);", "        else if (redir_vname)"], "readability/bool"]
["src/nvim/message.c", ["    if (redir_reg)", "      write_reg_contents(redir_reg, s, maxlen, TRUE);", "    if (redir_vname)"], "readability/bool"]
["src/nvim/message.c", ["         || redir_reg || redir_vname", "  ;", "}"], "whitespace/semicolon"]
["src/nvim/message.c", ["    /* always scroll up, don't overwrite */", "    msg_scroll = TRUE;", "}"], "readability/bool"]
["src/nvim/message.c", ["      msg_silent = 0;", "  } else", "    cmdline_row = msg_row;"], "readability/braces"]
["src/nvim/message.c", ["  }", "  verbose_did_open = FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["    /* Only give the error message once. */", "    verbose_did_open = TRUE;", ""], "readability/bool"]
["src/nvim/message.c", ["    set_keep_msg(message, keep_msg_attr);", "  msg_didout = FALSE;       /* overwrite this message */", "  msg_nowait = TRUE;        /* don't wait for this message */"], "readability/bool"]
["src/nvim/message.c", ["  msg_didout = FALSE;       /* overwrite this message */", "  msg_nowait = TRUE;        /* don't wait for this message */", "  msg_col = 0;"], "readability/bool"]
["src/nvim/message.c", ["int", "do_dialog (", "    int type,"], "whitespace/parens"]
["src/nvim/message.c", ["    int dfltbutton,", "    char_u *textfield,          /* IObuff for inputdialog(), NULL", "                                           otherwise */"], "readability/multiline_comment"]
["src/nvim/message.c", ["                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */"], "readability/multiline_comment"]
["src/nvim/message.c", ["                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */"], "whitespace/line_length"]
["src/nvim/message.c", ["                                           otherwise */", "    int ex_cmd                 /* when TRUE pressing : accepts default and starts", "                               Ex command */"], "readability/bool"]
["src/nvim/message.c", ["          i += (*mb_ptr2len)(hotkeys + i) - 1;", "        } else if (hotkeys[i] == c)", "          break;"], "readability/braces"]
["src/nvim/message.c", ["static int", "copy_char (", "    char_u *from,"], "whitespace/parens"]
["src/nvim/message.c", [" */", "static char_u *msg_show_console_dialog(char_u *message, char_u *buttons, int dfltbutton)", "  FUNC_ATTR_NONNULL_RET"], "whitespace/line_length"]
["src/nvim/message.c", ["///                   has a hotkey", "/// @param[out] hotkeys_ptr Pointer to the memory location where hotkeys will be copied", "static void copy_hotkeys_and_msg(const char_u *message, char_u *buttons,"], "whitespace/line_length"]
["src/nvim/message.c", ["static void copy_hotkeys_and_msg(const char_u *message, char_u *buttons,", "                                 int default_button_idx, const bool has_hotkey[],", "                                 char_u *hotkeys_ptr)"], "whitespace/line_length"]
["src/nvim/message.c", ["  // terminated to avoid reading past the end.", "  hotkeys_ptr[copy_char(buttons, hotkeys_ptr, TRUE)] = NUL;", ""], "readability/bool"]
["src/nvim/message.c", ["      hotkeys_ptr += (has_mbyte) ? STRLEN(hotkeys_ptr): 1;", "      hotkeys_ptr[copy_char(r + 1, hotkeys_ptr, TRUE)] = NUL;", ""], "readability/bool"]
["src/nvim/message.c", ["        *msgp++ = (default_button_idx == 1) ? '[' : '(';", "        msgp += copy_char(r, msgp, FALSE);", "        *msgp++ = (default_button_idx == 1) ? ']' : ')';"], "readability/bool"]
["src/nvim/message.c", ["        // redefine hotkey", "        hotkeys_ptr[copy_char(r, hotkeys_ptr, TRUE)] = NUL;", "      }"], "readability/bool"]
["src/nvim/message.c", ["      // everything else copy literally", "      msgp += copy_char(r, msgp, FALSE);", "    }"], "readability/bool"]
["src/nvim/message.c", ["          message,", "          (char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)", "    return VIM_YES;"], "readability/bool"]
["src/nvim/message.c", ["              message,", "              (char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE)) {", "  case 1: return VIM_YES;"], "readability/bool"]
["src/nvim/message.c", ["", "int vim_dialog_yesnoallcancel(int type, char_u *title, char_u *message, int dflt)", "{"], "whitespace/line_length"]
["src/nvim/message.c", ["              (char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),", "              dflt, NULL, FALSE)) {", "  case 1: return VIM_YES;"], "readability/bool"]
["src/nvim/message.c", ["  long n = 0;", "  int err = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["    EMSG(_(e_printf));", "  else {", "    ++*idxp;"], "readability/braces"]
["src/nvim/message.c", ["    EMSG(_(e_printf));", "  else {", "    ++*idxp;"], "readability/braces"]
["src/nvim/message.c", ["    EMSG(_(e_printf));", "  else {", "    ++*idxp;"], "readability/braces"]
["src/nvim/message.c", ["          min_field_width = j;", "        else {", "          min_field_width = -j;"], "readability/braces"]
["src/nvim/message.c", ["            precision = j;", "          else {", "            precision_specified = 0;"], "readability/braces"]
["src/nvim/message.c", ["        p++;", "        if (length_modifier == 'l' && *p == 'l') { // ll, encoded as 2", "          length_modifier = '2';"], "whitespace/comments"]
["src/nvim/message.c", ["          // make sure not to address string beyond the specified precision", "          else if (!precision_specified)", "            str_arg_l = strlen(str_arg);"], "whitespace/newline"]
["src/nvim/message.c", ["            str_arg_l = 0;", "          else {", "            // memchr on HP does not like n > 2^31"], "readability/braces"]
["src/nvim/message.c", ["        // only defined for length modifier ll", "        long long int long_long_arg = 0;", "        unsigned long long int ulong_long_arg = 0;"], "runtime/int"]
["src/nvim/message.c", ["        long long int long_long_arg = 0;", "        unsigned long long int ulong_long_arg = 0;", ""], "runtime/int"]
["src/nvim/message.c", ["            long_long_arg = tvs ? tv_nr(tvs, &arg_idx)", "                                : va_arg(ap, long long int);", "            if (long_long_arg > 0)"], "runtime/int"]
["src/nvim/message.c", ["          case '2':", "            ulong_long_arg = tvs ? (unsigned long long)tv_nr(tvs, &arg_idx)", "                                 : va_arg(ap, unsigned long long int);"], "runtime/int"]
["src/nvim/message.c", ["            ulong_long_arg = tvs ? (unsigned long long)tv_nr(tvs, &arg_idx)", "                                 : va_arg(ap, unsigned long long int);", "            if (ulong_long_arg) arg_sign = 1;"], "runtime/int"]
["src/nvim/message.c", ["        } else if (alternate_form) {", "          if (arg_sign != 0 && (fmt_spec == 'x' || fmt_spec == 'X') ) {", "            tmp[str_arg_l++] = '0';"], "whitespace/parens"]
["src/nvim/message.c", ["          if (!length_modifier)", "            ;", "          else if (length_modifier == '2') {"], "whitespace/semicolon"]
["src/nvim/message.c", ["            f[f_l++] = 'l';", "          } else", "            f[f_l++] = length_modifier;"], "readability/braces"]
["src/nvim/message.c", ["          if (fmt_spec == 'p')", "            str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);", "          else if (fmt_spec == 'd') {"], "runtime/printf"]
["src/nvim/message.c", ["            case '\\0':", "            case 'h': str_arg_l += sprintf(tmp + str_arg_l, f, int_arg);", "                      break;"], "runtime/printf"]
["src/nvim/message.c", ["                      break;", "            case 'l': str_arg_l += sprintf(tmp + str_arg_l, f, long_arg);", "                      break;"], "runtime/printf"]
["src/nvim/message.c", ["                      break;", "            case '2': str_arg_l += sprintf(tmp + str_arg_l, f, long_long_arg);", "                      break;"], "runtime/printf"]
["src/nvim/message.c", ["            case '\\0':", "            case 'h': str_arg_l += sprintf(tmp + str_arg_l, f, uint_arg);", "                      break;"], "runtime/printf"]
["src/nvim/message.c", ["                      break;", "            case 'l': str_arg_l += sprintf(tmp + str_arg_l, f, ulong_arg);", "                      break;"], "runtime/printf"]
["src/nvim/message.c", ["                      break;", "            case '2': str_arg_l += sprintf(tmp + str_arg_l, f, ulong_long_arg);", "                      break;"], "runtime/printf"]
["src/nvim/message.c", ["                      break;", "            case 'z': str_arg_l += sprintf(tmp + str_arg_l, f, size_t_arg);", "                      break;"], "runtime/printf"]
["src/nvim/message.c", ["        int l;", "        int remove_trailing_zeroes = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["            fmt_spec = fmt_spec == 'g' ? 'e' : 'E';", "          remove_trailing_zeroes = TRUE;", "        }"], "readability/bool"]
["src/nvim/message.c", ["          // avoid a buffer overflow", "          strcpy(tmp, \"inf\");", "          str_arg_l = 3;"], "runtime/printf"]
["src/nvim/message.c", ["              precision = max_prec;", "            l += sprintf(format + 1, \".%d\", (int)precision);", "          }"], "runtime/printf"]
["src/nvim/message.c", ["          format[l + 1] = NUL;", "          str_arg_l = sprintf(tmp, format, f);", ""], "runtime/printf"]
["src/nvim/message.c", ["              tp = tmp + str_arg_l - 1;", "            else {", "              tp = (char *)vim_strchr((char_u *)tmp,"], "readability/braces"]
["src/nvim/misc1.c", [" */", "int ", "open_line ("], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["int ", "open_line (", "    int dir,                        /* FORWARD or BACKWARD */"], "whitespace/parens"]
["src/nvim/misc1.c", ["  int n;", "  int trunc_line = FALSE;               /* truncate current line afterwards */", "  int retval = FALSE;                   /* return value, default is FAIL */"], "readability/bool"]
["src/nvim/misc1.c", ["  int trunc_line = FALSE;               /* truncate current line afterwards */", "  int retval = FALSE;                   /* return value, default is FAIL */", "  int extra_len = 0;                    /* length of p_extra string */"], "readability/bool"]
["src/nvim/misc1.c", ["               && !curbuf->b_p_cin", "               );", "  int no_si = FALSE;                    /* reset did_si afterwards */"], "whitespace/parens"]
["src/nvim/misc1.c", ["               );", "  int no_si = FALSE;                    /* reset did_si afterwards */", "  int first_char = NUL;                 /* init for GCC */"], "readability/bool"]
["src/nvim/misc1.c", ["  u_clearline();                /* cannot do \"U\" command when adding lines */", "  did_si = FALSE;", "  ai_col = 0;"], "readability/bool"]
["src/nvim/misc1.c", ["  if (dir == FORWARD && did_ai)", "    trunc_line = TRUE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["     */", "    newindent = get_indent_str(saved_line, (int)curbuf->b_p_ts, FALSE);", "    if (newindent == 0 && !(flags & OPENLINE_COM_LIST))"], "readability/bool"]
["src/nvim/misc1.c", ["      if (flags & OPENLINE_DO_COM)", "        lead_len = get_leader_len(ptr, NULL, FALSE, TRUE);", "      else"], "readability/bool"]
["src/nvim/misc1.c", ["        if (flags & OPENLINE_DO_COM)", "          lead_len = get_leader_len(ptr, NULL, FALSE, TRUE);", "        else"], "readability/bool"]
["src/nvim/misc1.c", ["          if (last_char == '{') {", "            did_si = TRUE;              /* do indent */", "            no_si = TRUE;               /* don't delete it when '{' typed */"], "readability/bool"]
["src/nvim/misc1.c", ["            did_si = TRUE;              /* do indent */", "            no_si = TRUE;               /* don't delete it when '{' typed */", "          }"], "readability/bool"]
["src/nvim/misc1.c", ["           */", "          else if (last_char != ';' && last_char != '}'", "                   && cin_is_cinword(ptr))"], "whitespace/newline"]
["src/nvim/misc1.c", ["                   && cin_is_cinword(ptr))", "            did_si = TRUE;", "        }"], "readability/bool"]
["src/nvim/misc1.c", ["          ptr[0] == '#') {", "          int was_backslashed = FALSE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["            if (*ptr && ptr[STRLEN(ptr) - 1] == '\\\\')", "              was_backslashed = TRUE;", "            else"], "readability/bool"]
["src/nvim/misc1.c", ["            else", "              was_backslashed = FALSE;", "            ptr = ml_get(++curwin->w_cursor.lnum);"], "readability/bool"]
["src/nvim/misc1.c", ["        if (*p == '}')              /* if line starts with '}': do indent */", "          did_si = TRUE;", "        else                        /* can delete indent when '{' typed */"], "readability/bool"]
["src/nvim/misc1.c", ["        else                        /* can delete indent when '{' typed */", "          can_si_back = TRUE;", "      }"], "readability/bool"]
["src/nvim/misc1.c", ["    if (do_si)", "      can_si = TRUE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["", "    did_ai = TRUE;", "  }"], "readability/bool"]
["src/nvim/misc1.c", ["  if (flags & OPENLINE_DO_COM)", "    lead_len = get_leader_len(saved_line, &lead_flags, dir == BACKWARD, TRUE);", "  else"], "readability/bool"]
["src/nvim/misc1.c", ["    char_u  *comment_end = NULL;            /* where lead_end has been found */", "    int extra_space = FALSE;                /* append extra space */", "    int current_flag;"], "readability/bool"]
["src/nvim/misc1.c", ["    int current_flag;", "    int require_blank = FALSE;              /* requires blank after middle */", "    char_u  *p2;"], "readability/bool"]
["src/nvim/misc1.c", ["      if (*p == COM_BLANK) {", "        require_blank = TRUE;", "        continue;"], "readability/bool"]
["src/nvim/misc1.c", ["          (void)copy_option_part(&p, lead_middle, COM_MAX_LEN, \",\");", "          require_blank = FALSE;", "        }"], "readability/bool"]
["src/nvim/misc1.c", ["          if (*p == COM_BLANK)", "            require_blank = TRUE;", "          ++p;"], "readability/bool"]
["src/nvim/misc1.c", ["                  || require_blank))", "            extra_space = TRUE;", "        }"], "readability/bool"]
["src/nvim/misc1.c", ["             && lead_repl[-1] != ':'; --lead_repl)", "          ;", "        lead_repl_len = (int)(p - lead_repl);"], "whitespace/semicolon"]
["src/nvim/misc1.c", ["         * the comment-end */", "        extra_space = TRUE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["          lead_len = 0;", "        else {", "          lead_repl = (char_u *)\"\";"], "readability/braces"]
["src/nvim/misc1.c", ["               && ascii_iswhite(*p); --p)", "            ;", "          ++p;"], "whitespace/semicolon"]
["src/nvim/misc1.c", ["              *p = ' ';", "            } else if (!ascii_iswhite(*p))", "              *p = ' ';"], "readability/braces"]
["src/nvim/misc1.c", ["            )", "          newindent = get_indent_str(leader, (int)curbuf->b_p_ts, FALSE);", ""], "readability/bool"]
["src/nvim/misc1.c", ["          newindent = 0;", "        } else", "          newindent += off;"], "readability/braces"]
["src/nvim/misc1.c", ["        if (lead_len > 0 && ascii_iswhite(leader[lead_len - 1]))", "          extra_space = FALSE;", "        leader[lead_len] = NUL;"], "readability/bool"]
["src/nvim/misc1.c", ["", "      did_si = can_si = FALSE;", "    } else if (comment_end != NULL) {"], "readability/bool"]
["src/nvim/misc1.c", ["           || do_si", "          )) {", "        old_cursor = curwin->w_cursor;"], "whitespace/parens"]
["src/nvim/misc1.c", ["    if (*p_extra != NUL)", "      did_ai = FALSE;               /* append some text, don't truncate now */", ""], "readability/bool"]
["src/nvim/misc1.c", ["    p_extra = leader;", "    did_ai = TRUE;          /* So truncating blanks works with comments */", "    less_cols -= lead_len;"], "readability/bool"]
["src/nvim/misc1.c", ["    less_cols -= lead_len;", "  } else", "    end_comment_pending = NUL;      /* turns out there was no leader */"], "readability/braces"]
["src/nvim/misc1.c", ["  if (!(State & VREPLACE_FLAG) || old_cursor.lnum >= orig_line_count) {", "    if (ml_append(curwin->w_cursor.lnum, p_extra, (colnr_T)0, FALSE)", "        == FAIL)"], "readability/bool"]
["src/nvim/misc1.c", ["    mark_adjust(curwin->w_cursor.lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);", "    did_append = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/misc1.c", ["    }", "    ml_replace(curwin->w_cursor.lnum, p_extra, TRUE);", "    changed_bytes(curwin->w_cursor.lnum, 0);"], "readability/bool"]
["src/nvim/misc1.c", ["    curwin->w_cursor.lnum--;", "    did_append = FALSE;", "  }"], "readability/bool"]
["src/nvim/misc1.c", ["       */", "      curbuf->b_p_pi = TRUE;", "    } else"], "readability/bool"]
["src/nvim/misc1.c", ["      curbuf->b_p_pi = TRUE;", "    } else", "      (void)set_indent(newindent, SIN_INSERT);"], "readability/braces"]
["src/nvim/misc1.c", ["    if (no_si)", "      did_si = FALSE;", "  }"], "readability/bool"]
["src/nvim/misc1.c", ["        truncate_spaces(saved_line);", "      ml_replace(curwin->w_cursor.lnum, saved_line, FALSE);", "      saved_line = NULL;"], "readability/bool"]
["src/nvim/misc1.c", ["            curwin->w_cursor.lnum + 1, 1L);", "        did_append = FALSE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["              1L, (long)-less_cols);", "      } else", "        changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);"], "readability/braces"]
["src/nvim/misc1.c", ["    State = INSERT;", "  } else", "    vreplace_mode = 0;"], "readability/braces"]
["src/nvim/misc1.c", ["    /* Put back original line */", "    ml_replace(curwin->w_cursor.lnum, next_line, FALSE);", ""], "readability/bool"]
["src/nvim/misc1.c", ["", "  retval = TRUE;                /* success! */", "theend:"], "readability/bool"]
["src/nvim/misc1.c", ["  return retval;", "}", ""], "readability/fn_size"]
["src/nvim/misc1.c", [" */", "int get_leader_len(char_u *line, char_u **flags, int backward, int include_space)", "{"], "whitespace/line_length"]
["src/nvim/misc1.c", ["  int result;", "  int got_com = FALSE;", "  int found_one;"], "readability/bool"]
["src/nvim/misc1.c", ["     */", "    found_one = FALSE;", "    for (list = curbuf->b_p_com; *list; ) {"], "readability/bool"]
["src/nvim/misc1.c", ["      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        ;", "      if (string[j] != NUL)"], "whitespace/semicolon"]
["src/nvim/misc1.c", ["        i += j;", "      found_one = TRUE;", "      break;"], "readability/bool"]
["src/nvim/misc1.c", ["      i += middle_match_len;", "      found_one = TRUE;", "    }"], "readability/bool"]
["src/nvim/misc1.c", ["    /* If this comment doesn't nest, stop here. */", "    got_com = TRUE;", "    if (vim_strchr(part_buf, COM_NEST) == NULL)"], "readability/bool"]
["src/nvim/misc1.c", ["     */", "    found_one = FALSE;", "    for (list = curbuf->b_p_com; *list; ) {"], "readability/bool"]
["src/nvim/misc1.c", ["      string = vim_strchr(part_buf, ':');", "      if (string == NULL) {     /* If everything is fine, this cannot actually", "                                 * happen. */"], "readability/multiline_comment"]
["src/nvim/misc1.c", ["      for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)", "        /* do nothing */;", "      if (string[j] != NUL)"], "whitespace/semicolon"]
["src/nvim/misc1.c", ["       */", "      found_one = TRUE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["{", "  return plines_win(curwin, lnum, TRUE);", "}"], "readability/bool"]
["src/nvim/misc1.c", ["", "int ", "plines_win ("], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["int ", "plines_win (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/misc1.c", ["{", "  return plines_win_nofill(curwin, lnum, TRUE);", "}"], "readability/bool"]
["src/nvim/misc1.c", ["", "int ", "plines_win_nofill ("], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["int ", "plines_win_nofill (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/misc1.c", ["  /* NOTE: Caller must handle lines that are MAYBE folded. */", "  if (lineFolded(wp, lnum) == TRUE)", "    return 1;"], "readability/bool"]
["src/nvim/misc1.c", ["", "  s = ml_get_buf(wp->w_buffer, lnum, FALSE);", "  if (*s == NUL)                /* empty line */"], "readability/bool"]
["src/nvim/misc1.c", ["", "  line = s = ml_get_buf(wp->w_buffer, lnum, FALSE);", ""], "readability/bool"]
["src/nvim/misc1.c", ["      if (first == wp->w_topline)", "        count += plines_win_nofill(wp, first, TRUE) + wp->w_topfill;", "      else"], "readability/bool"]
["src/nvim/misc1.c", ["      else", "        count += plines_win(wp, first, TRUE);", "      ++first;"], "readability/bool"]
["src/nvim/misc1.c", ["    }", "  else", "    for (i = 0; i < len; ++i)"], "whitespace/newline"]
["src/nvim/misc1.c", ["      if (old_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL)", "        curwin->w_p_list = FALSE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["  /* Replace the line in the buffer. */", "  ml_replace(lnum, newp, FALSE);", ""], "readability/bool"]
["src/nvim/misc1.c", ["  memmove(newp + col + newlen, oldp + col, (size_t)(oldlen - col + 1));", "  ml_replace(lnum, newp, FALSE);", "  changed_bytes(lnum, col);"], "readability/bool"]
["src/nvim/misc1.c", ["  }", "  return del_bytes(1L, fixpos, TRUE);", "}"], "readability/bool"]
["src/nvim/misc1.c", ["  }", "  return del_bytes(bytes, fixpos, TRUE);", "}"], "readability/bool"]
["src/nvim/misc1.c", [" */", "int ", "del_bytes ("], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["int ", "del_bytes (", "    long count,"], "whitespace/parens"]
["src/nvim/misc1.c", ["    newp = oldp;                            /* use same allocated memory */", "  else {                                    /* need to allocate a new line */", "    newp = xmalloc(oldlen + 1 - count);"], "readability/braces"]
["src/nvim/misc1.c", ["  if (!was_alloced)", "    ml_replace(lnum, newp, FALSE);", ""], "readability/bool"]
["src/nvim/misc1.c", ["void", "truncate_line (", "    int fixpos                 /* if TRUE fix the cursor position when done */"], "whitespace/parens"]
["src/nvim/misc1.c", ["", "  ml_replace(lnum, newp, FALSE);", ""], "readability/bool"]
["src/nvim/misc1.c", [" */", "void ", "del_lines ("], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["void ", "del_lines (", "    long nlines,                    /* number of lines to delete */"], "whitespace/parens"]
["src/nvim/misc1.c", ["", "    ml_delete(first, TRUE);", "    ++n;"], "readability/bool"]
["src/nvim/misc1.c", ["{", "", "  if (!curbuf->b_changed) {"], "whitespace/blank_line"]
["src/nvim/misc1.c", ["        os_delay(2000L, true);", "        wait_return(TRUE);", "        msg_scroll = save_msg_scroll;"], "readability/bool"]
["src/nvim/misc1.c", ["  check_status(curbuf);", "  redraw_tabline = TRUE;", "  need_maketitle = TRUE;            /* set window title later */"], "readability/bool"]
["src/nvim/misc1.c", ["  redraw_tabline = TRUE;", "  need_maketitle = TRUE;            /* set window title later */", "}"], "readability/bool"]
["src/nvim/misc1.c", [" */", "void ", "changed_lines ("], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["void ", "changed_lines (", "    linenr_T lnum,              /* first line with change */"], "whitespace/parens"]
["src/nvim/misc1.c", ["    linenr_T lnume,             /* line below last changed line */", "    long xtra                  /* number of extra lines (negative when deleting) */", ")"], "whitespace/line_length"]
["src/nvim/misc1.c", ["", "static void ", "changed_lines_buf ("], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["static void ", "changed_lines_buf (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/misc1.c", ["    linenr_T lnume,             /* line below last changed line */", "    long xtra                  /* number of extra lines (negative when deleting) */", ")"], "whitespace/line_length"]
["src/nvim/misc1.c", [" */", "static void changed_common(linenr_T lnum, colnr_T col, linenr_T lnume, long xtra)", "{"], "whitespace/line_length"]
["src/nvim/misc1.c", ["      if (curbuf->b_changelistlen == 0)", "        add = TRUE;", "      else {"], "readability/bool"]
["src/nvim/misc1.c", ["        add = TRUE;", "      else {", "        /* Don't create a new entry when the line number is the same"], "readability/braces"]
["src/nvim/misc1.c", ["        if (p->lnum != lnum)", "          add = TRUE;", "        else {"], "readability/bool"]
["src/nvim/misc1.c", ["          add = TRUE;", "        else {", "          cols = comp_textwidth(FALSE);"], "readability/braces"]
["src/nvim/misc1.c", ["        else {", "          cols = comp_textwidth(FALSE);", "          if (cols == 0)"], "readability/bool"]
["src/nvim/misc1.c", ["              /* line included in change */", "              wp->w_lines[i].wl_valid = FALSE;", "            } else if (xtra != 0) {"], "readability/bool"]
["src/nvim/misc1.c", ["             * may need to be redrawn */", "            wp->w_lines[i].wl_valid = FALSE;", "          }"], "readability/bool"]
["src/nvim/misc1.c", [" */", "void ", "unchanged ("], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["void ", "unchanged (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/misc1.c", ["    check_status(buf);", "    redraw_tabline = TRUE;", "    need_maketitle = TRUE;          /* set window title later */"], "readability/bool"]
["src/nvim/misc1.c", ["    redraw_tabline = TRUE;", "    need_maketitle = TRUE;          /* set window title later */", "  }"], "readability/bool"]
["src/nvim/misc1.c", ["    if (wp->w_buffer == buf && wp->w_status_height) {", "      wp->w_redr_status = TRUE;", "      if (must_redraw < VALID) {"], "readability/bool"]
["src/nvim/misc1.c", [" */", "void ", "change_warning ("], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["void ", "change_warning (", "    int col                        /* column for message; non-zero when in insert"], "whitespace/parens"]
["src/nvim/misc1.c", ["change_warning (", "    int col                        /* column for message; non-zero when in insert", "                                   mode and 'showmode' is on */"], "readability/multiline_comment"]
["src/nvim/misc1.c", ["change_warning (", "    int col                        /* column for message; non-zero when in insert", "                                   mode and 'showmode' is on */"], "whitespace/line_length"]
["src/nvim/misc1.c", ["    ++curbuf_lock;", "    apply_autocmds(EVENT_FILECHANGEDRO, NULL, NULL, FALSE, curbuf);", "    --curbuf_lock;"], "readability/bool"]
["src/nvim/misc1.c", ["    curbuf->b_did_warn = true;", "    redraw_cmdline = FALSE;     /* don't redraw and erase the message */", "    if (msg_row < Rows - 1)"], "readability/bool"]
["src/nvim/misc1.c", ["", "  mapped_ctrl_c = FALSE;        /* mappings are not used here */", "  for (;; ) {"], "readability/bool"]
["src/nvim/misc1.c", ["      /* Replace zero and CSI by a special key code. */", "      n = fix_input_buffer(buf + len, n, FALSE);", "      len += n;"], "readability/bool"]
["src/nvim/misc1.c", ["      waited = 0;", "    } else if (len > 0)", "      ++waited;             /* keep track of the waiting time */"], "readability/braces"]
["src/nvim/misc1.c", [" */", "int ", "get_number ("], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["int ", "get_number (", "    int colon,                              /* allow colon to abort */"], "whitespace/parens"]
["src/nvim/misc1.c", ["  if (mouse_used != NULL)", "    *mouse_used = FALSE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["    } else if (mouse_used != NULL && c == K_LEFTMOUSE) {", "      *mouse_used = TRUE;", "      n = mouse_row + 1;"], "readability/bool"]
["src/nvim/misc1.c", ["        cmdline_row = msg_row;", "      skip_redraw = TRUE;           /* skip redraw once */", "      do_redraw = FALSE;"], "readability/bool"]
["src/nvim/misc1.c", ["      skip_redraw = TRUE;           /* skip redraw once */", "      do_redraw = FALSE;", "      break;"], "readability/bool"]
["src/nvim/misc1.c", ["      break;", "    } else if (c == CAR || c == NL || c == Ctrl_C || c == ESC)", "      break;"], "readability/braces"]
["src/nvim/misc1.c", ["  if (mouse_used != NULL)", "    MSG_PUTS(_(\"Type number and <Enter> or click with mouse (empty cancels): \"));", "  else"], "whitespace/line_length"]
["src/nvim/misc1.c", ["", "  i = get_number(TRUE, mouse_used);", "  if (KeyTyped) {"], "readability/bool"]
["src/nvim/misc1.c", ["    cmdline_row = msg_row - 1;", "    need_wait_return = FALSE;", "    msg_didany = FALSE;"], "readability/bool"]
["src/nvim/misc1.c", ["    need_wait_return = FALSE;", "    msg_didany = FALSE;", "    msg_didout = FALSE;"], "readability/bool"]
["src/nvim/misc1.c", ["    msg_didany = FALSE;", "    msg_didout = FALSE;", "  } else"], "readability/bool"]
["src/nvim/misc1.c", ["    msg_didout = FALSE;", "  } else", "    cmdline_row = save_cmdline_row;"], "readability/braces"]
["src/nvim/misc1.c", ["      set_keep_msg(msg_buf, 0);", "      keep_msg_more = TRUE;", "    }"], "readability/bool"]
["src/nvim/misc1.c", ["{", "  static int lazy_init_done = FALSE;", ""], "readability/bool"]
["src/nvim/misc1.c", ["", "  lazy_init_done = TRUE;", "  "], "readability/bool"]
["src/nvim/misc1.c", ["  lazy_init_done = TRUE;", "  ", "  os_get_usernames(&ga_users);"], "whitespace/end_of_line"]
["src/nvim/misc1.c", ["  if (really_exiting) {", "    stream_set_blocking(input_global_fd(), true);  //normalize stream (#2598)", "    exit(2);"], "whitespace/comments"]
["src/nvim/misc1.c", ["char_u *", "get_cmd_output (", "    char_u *cmd,"], "whitespace/parens"]
["src/nvim/misc2.c", [" */", "size_t copy_option_part(char_u **option, char_u *buf, size_t maxlen, char *sep_chars)", "{"], "whitespace/line_length"]
["src/nvim/misc2.c", [" */", "int ", "get_fileformat_force ("], "whitespace/end_of_line"]
["src/nvim/misc2.c", ["int ", "get_fileformat_force (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/misc2.c", ["    c = eap->cmd[eap->force_ff];", "  else {", "    if ((eap != NULL && eap->force_bin != 0)"], "readability/braces"]
["src/nvim/misc2.c", ["  check_status(curbuf);", "  redraw_tabline = TRUE;", "  need_maketitle = TRUE;  // Set window title later."], "readability/bool"]
["src/nvim/misc2.c", ["  redraw_tabline = TRUE;", "  need_maketitle = TRUE;  // Set window title later.", "}"], "readability/bool"]
["src/nvim/misc2.c", ["      retval = os_call_shell(cmd, opts, extra_shell_arg);", "    else {", "      char_u *ecmd = cmd;"], "readability/braces"]
["src/nvim/misc2.c", ["      if (*p_sxe != NUL && STRCMP(p_sxq, \"(\") == 0) {", "        ecmd = vim_strsave_escaped_ext(cmd, p_sxe, '^', FALSE);", "      }"], "readability/bool"]
["src/nvim/misc2.c", ["      return VISUAL;", "    } else if (finish_op)", "      return OP_PENDING;"], "readability/braces"]
["src/nvim/move.c", ["   */", "  else {", "    if (curwin->w_topline > 1) {"], "whitespace/newline"]
["src/nvim/move.c", ["   */", "  else {", "    if (curwin->w_topline > 1) {"], "readability/braces"]
["src/nvim/move.c", ["        }", "      } else", "        n = curwin->w_topline + p_so - curwin->w_cursor.lnum;"], "readability/braces"]
["src/nvim/move.c", ["             || hasAnyFolding(curwin)", "             )) {", "          lineoff_T loff;"], "whitespace/parens"]
["src/nvim/move.c", ["          }", "        } else", "          line_count = curwin->w_cursor.lnum - curwin->w_botline"], "readability/braces"]
["src/nvim/move.c", ["      redraw_later(NOT_VALID);", "    } else", "      redraw_later(VALID);"], "readability/braces"]
["src/nvim/move.c", ["         + (wp->w_buffer->b_signlist != NULL ? 2 : 0)", "  ;", "}"], "whitespace/semicolon"]
["src/nvim/move.c", ["   * If scrolling is off, curwin->w_leftcol is assumed to be 0 */", "  else if (may_scroll", "           && !curwin->w_cline_folded"], "whitespace/newline"]
["src/nvim/move.c", ["        new_leftcol = curwin->w_wcol - extra - textwidth / 2;", "      else {", "        if (diff < p_ss) {"], "readability/braces"]
["src/nvim/move.c", ["    curwin->w_wcol -= curwin->w_leftcol;", "  } else if (curwin->w_wcol > (int)curwin->w_leftcol)", "    curwin->w_wcol -= curwin->w_leftcol;"], "readability/braces"]
["src/nvim/move.c", ["    }", "    else", "      n = p_lines;"], "whitespace/newline"]
["src/nvim/move.c", [" */", "void ", "scrolldown ("], "whitespace/end_of_line"]
["src/nvim/move.c", ["void ", "scrolldown (", "    long line_count,"], "whitespace/parens"]
["src/nvim/move.c", ["        curwin->w_topline = first;", "      } else", "        done += plines_nofill(curwin->w_topline);"], "readability/braces"]
["src/nvim/move.c", ["        curwin->w_cursor.lnum = first - 1;", "    } else", "      wrow -= plines(curwin->w_cursor.lnum--);"], "readability/braces"]
["src/nvim/move.c", [" */", "void ", "scrollup ("], "whitespace/end_of_line"]
["src/nvim/move.c", ["void ", "scrollup (", "    long line_count,"], "whitespace/parens"]
["src/nvim/move.c", ["        --curwin->w_topfill;", "      else {", "        if (byfold)"], "readability/braces"]
["src/nvim/move.c", [" */", "void ", "check_topfill ("], "whitespace/end_of_line"]
["src/nvim/move.c", ["void ", "check_topfill (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/move.c", ["    curwin->w_topfill = 0;", "  else {", "    curwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);"], "readability/braces"]
["src/nvim/move.c", ["      --curwin->w_topfill;", "    else {", "      (void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);"], "readability/braces"]
["src/nvim/move.c", ["      lp->height = 1;", "    else {", "      lp->height = plines_nofill(lp->lnum);"], "readability/braces"]
["src/nvim/move.c", ["      lp->height = 1;", "    else {", "      lp->height = plines_nofill(lp->lnum);"], "readability/braces"]
["src/nvim/move.c", ["    wp->w_empty_rows = 0;       /* single line that doesn't fit */", "  else {", "    wp->w_empty_rows = wp->w_height - used;"], "readability/braces"]
["src/nvim/move.c", ["        wp->w_empty_rows -= wp->w_filler_rows;", "      else {", "        wp->w_filler_rows = wp->w_empty_rows;"], "readability/braces"]
["src/nvim/move.c", ["      curwin->w_valid &= ~(VALID_WROW|VALID_CROW);", "  } else", "    validate_botline();"], "readability/braces"]
["src/nvim/move.c", ["  /* scroll minimal number of lines */", "  else {", "    line_count = 0;"], "readability/braces"]
["src/nvim/move.c", ["    curwin->w_cursor.lnum = botline;", "  else {", "    if (cln < topline && curwin->w_topline > 1) {"], "readability/braces"]
["src/nvim/move.c", ["           diff_check_fill(curwin, curwin->w_topline)", "           )) {", "      beep_flush();"], "whitespace/parens"]
["src/nvim/move.c", ["        curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);", "      else {", "        room += i;"], "readability/braces"]
["src/nvim/move.c", ["        }", "      } else", "        curwin->w_cursor.lnum += n;"], "readability/braces"]
["src/nvim/move.c", ["        }", "      } else", "        curwin->w_cursor.lnum -= n;"], "readability/braces"]
["src/nvim/normal.c", ["#include \"nvim/ui.h\"", "#include \"nvim/mouse.h\"", "#include \"nvim/undo.h\""], "build/include"]
["src/nvim/normal.c", ["  uint16_t cmd_flags;           /* NV_ flags */", "  short cmd_arg;                /* value for ca.arg */", "} nv_cmds[] ="], "runtime/int"]
["src/nvim/normal.c", ["/* Sorted index of commands in nv_cmds[]. */", "static short nv_cmd_idx[NV_CMDS_SIZE];", ""], "runtime/int"]
["src/nvim/normal.c", ["  /* The commands are sorted on absolute value. */", "  c1 = nv_cmds[*(const short *)s1].cmd_char;", "  c2 = nv_cmds[*(const short *)s2].cmd_char;"], "runtime/int"]
["src/nvim/normal.c", ["  c1 = nv_cmds[*(const short *)s1].cmd_char;", "  c2 = nv_cmds[*(const short *)s2].cmd_char;", "  if (c1 < 0)"], "runtime/int"]
["src/nvim/normal.c", ["  /* Fill the index table with a one to one relation. */", "  for (short int i = 0; i < (short int)NV_CMDS_SIZE; ++i) {", "    nv_cmd_idx[i] = i;"], "runtime/int"]
["src/nvim/normal.c", ["  /* Sort the commands by the command character.  */", "  qsort(&nv_cmd_idx, NV_CMDS_SIZE, sizeof(short), nv_compare);", ""], "runtime/int"]
["src/nvim/normal.c", ["  /* Find the first entry that can't be indexed by the command character. */", "  short int i;", "  for (i = 0; i < (short int)NV_CMDS_SIZE; ++i) {"], "runtime/int"]
["src/nvim/normal.c", ["  short int i;", "  for (i = 0; i < (short int)NV_CMDS_SIZE; ++i) {", "    if (i != nv_cmds[nv_cmd_idx[i]].cmd_char) {"], "runtime/int"]
["src/nvim/normal.c", ["       || VIsual_active", "       ) && oap->op_type != OP_NOP) {", "    // Avoid a problem with unwanted linebreaks in block mode"], "whitespace/parens"]
["src/nvim/normal.c", ["          ResetRedobuff();", "        else {", "          AppendToRedobuffLit(repeat_cmdline, -1);"], "readability/braces"]
["src/nvim/normal.c", ["              curwin->w_virtcol + redo_VIsual_vcol - 1;", "          } else", "            curwin->w_curswant = redo_VIsual_vcol;"], "readability/braces"]
["src/nvim/normal.c", ["       * charwise selections. */", "      else if (VIsual_mode == 'v') {", "        include_line_break ="], "whitespace/newline"]
["src/nvim/normal.c", ["          }", "        } else if (redo_VIsual_busy)", "          oap->end_vcol = oap->start_vcol + redo_VIsual_vcol - 1;"], "readability/braces"]
["src/nvim/normal.c", ["          resel_VIsual_vcol = MAXCOL;", "        else {", "          if (VIsual_mode != Ctrl_V)"], "readability/braces"]
["src/nvim/normal.c", ["            resel_VIsual_vcol = oap->end_vcol - oap->start_vcol + 1;", "          } else", "            resel_VIsual_vcol = oap->end_vcol;"], "readability/braces"]
["src/nvim/normal.c", ["        oap->motion_type = MLINE;", "      else {", "        oap->motion_type = MCHAR;"], "readability/braces"]
["src/nvim/normal.c", ["                  && !(virtual_op && oap->start.coladd != oap->end.coladd)", "                  );", "    /*"], "whitespace/parens"]
["src/nvim/normal.c", ["                           || oap->op_type == OP_FOLD", "                           )) {", "      curwin->w_p_lbr = lbr_saved;"], "whitespace/parens"]
["src/nvim/normal.c", ["        oap->motion_type = MLINE;", "      else {", "        oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));"], "readability/braces"]
["src/nvim/normal.c", ["      }", "    } else", "      oap->end_adjusted = false;"], "readability/braces"]
["src/nvim/normal.c", ["        beep_flush();", "      else {", "        do_join(oap->line_count, oap->op_type == OP_JOIN, true, true, true);"], "readability/braces"]
["src/nvim/normal.c", ["        CancelRedo();", "      } else", "        op_tilde(oap);"], "readability/braces"]
["src/nvim/normal.c", ["    stuffReadbuff((char_u *)\"'<,'>\");", "  else {", "    /*"], "readability/braces"]
["src/nvim/normal.c", ["        stuffnumReadbuff(oap->line_count - 1);", "      } else", "        stuffnumReadbuff((long)oap->end.lnum);"], "readability/braces"]
["src/nvim/normal.c", ["    EMSG(_(\"E774: 'operatorfunc' is empty\"));", "  else {", "    /* Set '[ and '] marks to text to be operated on. */"], "readability/braces"]
["src/nvim/normal.c", ["bool", "do_mouse (", "    oparg_T *oap,               /* operator argument, can be NULL */"], "whitespace/parens"]
["src/nvim/normal.c", ["    long count,", "    bool fixindent                  /* PUT_FIXINDENT if fixing indent necessary */", ")"], "whitespace/line_length"]
["src/nvim/normal.c", ["    got_click = true;", "  else {", "    if (!got_click)                     /* didn't get click, ignore */"], "readability/braces"]
["src/nvim/normal.c", ["       */", "    } else if ((State & INSERT) == 0)", "      return false;"], "readability/braces"]
["src/nvim/normal.c", ["        insert_reg(regname, true);", "      else {", "        if (regname == 0 && eval_has_provider(\"clipboard\")) {"], "readability/braces"]
["src/nvim/normal.c", ["          insert_reg(regname, true);", "        else {", "          do_put(regname, NULL, BACKWARD, 1L, fixindent | PUT_CURSEND);"], "readability/braces"]
["src/nvim/normal.c", ["            tabpage_close(false);", "        } else if (tp != NULL)", "          tabpage_close_other(tp, false);"], "readability/braces"]
["src/nvim/normal.c", ["          jump_flags |= MOUSE_MAY_STOP_VIS;", "      } else if (mouse_has(MOUSE_VISUAL))", "        jump_flags |= MOUSE_MAY_VIS;"], "readability/braces"]
["src/nvim/normal.c", ["        VIsual = start_visual;", "      else {", "        /* In the same line, compare column number */"], "readability/braces"]
["src/nvim/normal.c", ["        /* In different lines, compare line number */", "        else {", "          diff = (curwin->w_cursor.lnum - start_visual.lnum) -"], "whitespace/newline"]
["src/nvim/normal.c", ["        /* In different lines, compare line number */", "        else {", "          diff = (curwin->w_cursor.lnum - start_visual.lnum) -"], "readability/braces"]
["src/nvim/normal.c", ["            VIsual = end_visual;", "          else {                                /* in the middle line */", "            if (curwin->w_cursor.col <"], "readability/braces"]
["src/nvim/normal.c", ["   */", "  else if ((State & INSERT) && VIsual_active)", "    stuffcharReadbuff(Ctrl_O);"], "whitespace/newline"]
["src/nvim/normal.c", ["        dir = FORWARD;", "    } else if (mouse_past_eol)", "      dir = FORWARD;"], "readability/braces"]
["src/nvim/normal.c", ["   */", "  else if (((mod_mask & MOD_MASK_CTRL)", "            || (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)"], "whitespace/newline"]
["src/nvim/normal.c", ["   */", "  else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help", "                                          && (mod_mask &"], "whitespace/newline"]
["src/nvim/normal.c", ["   */", "  else if ((mod_mask & MOD_MASK_SHIFT)) {", "    if (State & INSERT"], "whitespace/newline"]
["src/nvim/normal.c", ["  /* Handle double clicks, unless on status line */", "  else if (in_status_line) {", "  } else if (in_sep_line) {"], "whitespace/newline"]
["src/nvim/normal.c", ["        orig_cursor = VIsual;", "      else {", "        check_visual_highlight();"], "readability/braces"]
["src/nvim/normal.c", ["          VIsual_mode = 'v';", "      } else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)", "        VIsual_mode = 'V';"], "readability/braces"]
["src/nvim/normal.c", ["{", "", "  VIsual_active = false;"], "whitespace/blank_line"]
["src/nvim/normal.c", ["      }", "    } else", "      while (ptr[col] != NUL"], "readability/braces"]
["src/nvim/normal.c", ["                         || !vim_iswordc(ptr[col - 1]))))", "                 ))", "        --col;"], "whitespace/parens"]
["src/nvim/normal.c", ["                : mb_get_class(ptr + col) != 0)", "               ))", "      col += (*mb_ptr2len)(ptr + col);"], "whitespace/parens"]
["src/nvim/normal.c", ["      col += (*mb_ptr2len)(ptr + col);", "  } else", "    while ((i == 0 ? vim_iswordc(ptr[col])"], "readability/braces"]
["src/nvim/normal.c", [" */", "static void prep_redo(int regname, long num, int cmd1, int cmd2, int cmd3, int cmd4, int cmd5)", "{"], "whitespace/line_length"]
["src/nvim/normal.c", ["      p_sbr = saved_sbr;", "      sprintf((char *)showcmd_buf, \"%\" PRId64 \"x%\" PRId64,", "              (int64_t)lines, (int64_t)(rightcol - leftcol + 1));"], "runtime/printf"]
["src/nvim/normal.c", ["              (int64_t)lines, (int64_t)(rightcol - leftcol + 1));", "    } else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)", "      sprintf((char *)showcmd_buf, \"%\" PRId64, (int64_t)lines);"], "readability/braces"]
["src/nvim/normal.c", ["    } else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)", "      sprintf((char *)showcmd_buf, \"%\" PRId64, (int64_t)lines);", "    else {"], "runtime/printf"]
["src/nvim/normal.c", ["      sprintf((char *)showcmd_buf, \"%\" PRId64, (int64_t)lines);", "    else {", "      char_u  *s, *e;"], "readability/braces"]
["src/nvim/normal.c", ["      if (bytes == chars)", "        sprintf((char *)showcmd_buf, \"%d\", chars);", "      else"], "runtime/printf"]
["src/nvim/normal.c", ["      else", "        sprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);", "    }"], "runtime/printf"]
["src/nvim/normal.c", ["    showcmd_is_clear = true;", "  else {", "    screen_puts(showcmd_buf, (int)Rows - 1, sc_col, 0);"], "readability/braces"]
["src/nvim/normal.c", ["        goto_tabpage((int)cap->count0);", "    } else", "      (void)onepage(cap->arg, cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["static void", "nv_gd (", "    oparg_T *oap,"], "whitespace/parens"]
["src/nvim/normal.c", ["bool", "find_decl (", "    char_u *ptr,"], "whitespace/parens"]
["src/nvim/normal.c", ["  assert(len <= INT_MAX);", "  sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",", "          (int)len, ptr);"], "runtime/printf"]
["src/nvim/normal.c", ["        curwin->w_curswant = 0;", "      else {", "        curwin->w_curswant = width1 - 1;"], "readability/braces"]
["src/nvim/normal.c", ["          curwin->w_curswant -= width2;", "        else {", "          /* to previous line */"], "readability/braces"]
["src/nvim/normal.c", ["          curwin->w_curswant += width2;", "        else {", "          /* to next line */"], "readability/braces"]
["src/nvim/normal.c", ["  /* \"z^\", \"z-\" and \"zb\": put cursor at bottom of screen */", "  case '^':     /* Strange Vi behavior: <count>z^ finds line at top of window", "                 * when <count> is at bottom of window, and puts that one at"], "readability/multiline_comment"]
["src/nvim/normal.c", ["  case '^':     /* Strange Vi behavior: <count>z^ finds line at top of window", "                 * when <count> is at bottom of window, and puts that one at", "                 * bottom of window. */"], "readability/alt_tokens"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = curwin->w_topline;", "    } else if (curwin->w_topline == 1)", "      curwin->w_cursor.lnum = 1;"], "readability/braces"]
["src/nvim/normal.c", ["      }", "  } else", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["      changed_window_setting();", "  } else if (foldmethodIsMarker(curwin))", "      deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,"], "readability/braces"]
["src/nvim/normal.c", ["      openFold(curwin->w_cursor.lnum, cap->count1);", "    else {", "      closeFold(curwin->w_cursor.lnum, cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["      openFoldRecurse(curwin->w_cursor.lnum);", "    else {", "      closeFoldRecurse(curwin->w_cursor.lnum);"], "readability/braces"]
["src/nvim/normal.c", ["    nv_operator(cap);", "  else {", "    if (cap->oap->op_type != OP_NOP) {"], "readability/braces"]
["src/nvim/normal.c", ["                 || did_emsg", "                 ))", "      /* The start of the operator has become invalid by the Ex command."], "whitespace/parens"]
["src/nvim/normal.c", ["    showmode();", "  } else if (!checkclearop(cap->oap))", "    /* print full name if count given or :cd used */"], "readability/braces"]
["src/nvim/normal.c", ["    v_visop(cap);", "  } else", "    nv_left(cap);"], "readability/braces"]
["src/nvim/normal.c", ["      STRCPY(buf, \"he! \");", "    else {", "      if (g_cmd)"], "readability/braces"]
["src/nvim/normal.c", ["        aux_ptr = (char_u *)\"\\\\|\\\"\\n[\";", "    } else", "      aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";"], "readability/braces"]
["src/nvim/normal.c", ["bool", "get_visual_text (", "    cmdarg_T *cap,"], "whitespace/parens"]
["src/nvim/normal.c", ["      curwin->w_cursor.lnum = 1;", "    else {", "      if (hasAnyFolding(curwin)) {"], "readability/braces"]
["src/nvim/normal.c", ["        }", "      } else", "        curwin->w_cursor.lnum -= cap->count1 - 1;"], "readability/braces"]
["src/nvim/normal.c", ["          cap->oap->inclusive = true;", "        else {", "          ++curwin->w_cursor.lnum;"], "readability/braces"]
["src/nvim/normal.c", ["        oneright();", "      else {", "        if (has_mbyte)"], "readability/braces"]
["src/nvim/normal.c", ["      /* Only beep and flush if not moved at all */", "      else if (cap->oap->op_type == OP_NOP && n == cap->count1)", "        beep_flush();"], "whitespace/newline"]
["src/nvim/normal.c", ["    nv_page(cap);", "  } else", "  /* In a quickfix window a <CR> jumps to the error under the cursor. */"], "readability/braces"]
["src/nvim/normal.c", ["      do_cmdline_cmd(\".ll\");          /* location list window */", "  else {", "    /* In the cmdline window a <CR> executes the command. */"], "readability/braces"]
["src/nvim/normal.c", ["      cmdwin_result = CAR;", "    else {", "      cap->oap->motion_type = MLINE;"], "readability/braces"]
["src/nvim/normal.c", ["    xfree(ptr);", "  } else", "    clearop(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    clearop(cap->oap);", "  else {", "    if (i == 2)"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    curwin->w_set_curswant = true;"], "readability/braces"]
["src/nvim/normal.c", ["      curwin->w_cursor.coladd = ecol - scol;", "    } else", "      curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/normal.c", ["  old_pos = curwin->w_cursor;", "  curwin->w_cursor.coladd = 0;              /* TODO: don't do this for an error. */", ""], "whitespace/line_length"]
["src/nvim/normal.c", ["      clearop(cap->oap);", "    else {", "      find_pattern_in_path(ptr, 0, len, true,"], "readability/braces"]
["src/nvim/normal.c", ["    }", "  } else", "  /*"], "readability/braces"]
["src/nvim/normal.c", ["            clearopbeep(cap->oap);", "        } else", "          pos = &new_pos;               /* use last one found */"], "readability/braces"]
["src/nvim/normal.c", ["          --n;", "      } else", "        pos = NULL;"], "readability/braces"]
["src/nvim/normal.c", ["             * class and we're inside now.  Just go on. */", "            else if (new_pos.lnum == 0) {", "              new_pos = curwin->w_cursor;"], "whitespace/newline"]
["src/nvim/normal.c", ["            /* found start/end of other method: go to match */", "            else if ((pos = findmatchlimit(cap->oap, findc,", "                          (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,"], "whitespace/newline"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == '[' || cap->nchar == ']') {", "    if (cap->nchar == cap->cmdchar)                 /* \"]]\" or \"[[\" */"], "whitespace/newline"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      if (cap->oap->op_type == OP_NOP)"], "readability/braces"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == 'p' || cap->nchar == 'P') {", "    if (!checkclearop(cap->oap)) {"], "whitespace/newline"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == '\\'' || cap->nchar == '`') {", "    pos = &curwin->w_cursor;"], "whitespace/newline"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE) {", "    (void)do_mouse(cap->oap, cap->nchar,"], "whitespace/newline"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == 'z') {", "    if (foldMoveTo(false, cap->cmdchar == ']' ? FORWARD : BACKWARD,"], "whitespace/newline"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == 'c') {", "    if (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,"], "whitespace/newline"]
["src/nvim/normal.c", ["   */", "  else if (cap->nchar == 's' || cap->nchar == 'S') {", "    setpcmark();"], "whitespace/newline"]
["src/nvim/normal.c", ["  /* Not a valid cap->nchar. */", "  else", "    clearopbeep(cap->oap);"], "whitespace/newline"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      cap->oap->motion_type = MLINE;"], "readability/braces"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      setpcmark();"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    /* Don't leave the cursor on the NUL past end of line. */"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    curwin->w_cursor.coladd = 0;"], "readability/braces"]
["src/nvim/normal.c", ["    nv_operator(cap);", "  } else", "    nv_kundo(cap);"], "readability/braces"]
["src/nvim/normal.c", ["      had_ctrl_v = NUL;", "  } else", "    had_ctrl_v = NUL;"], "readability/braces"]
["src/nvim/normal.c", ["      curwin->w_cursor.col -= (colnr_T)cap->count1;", "    } else if (gchar_cursor() == TAB)", "      coladvance_force(getviscol());"], "readability/braces"]
["src/nvim/normal.c", ["            ++curwin->w_cursor.col;", "        } else", "          ins_char(cap->nchar);"], "readability/braces"]
["src/nvim/normal.c", ["        }", "      } else", "        break;"], "readability/braces"]
["src/nvim/normal.c", ["    clearop(cap->oap);", "  else {", "    if (cap->cmdchar == '\\''"], "readability/braces"]
["src/nvim/normal.c", ["      VIsual_mode = 'V';", "    } else if (cap->cmdchar == 'C' || cap->cmdchar == 'D')", "      curwin->w_curswant = MAXCOL;"], "readability/braces"]
["src/nvim/normal.c", ["    nv_operator(cap);", "  } else", "    nv_optrans(cap);"], "readability/braces"]
["src/nvim/normal.c", ["      beginline(BL_WHITE | BL_FIX);", "    } else", "      check_cursor();"], "readability/braces"]
["src/nvim/normal.c", ["      check_cursor();", "  } else", "    nv_cursormark(cap, cap->arg, pos);"], "readability/braces"]
["src/nvim/normal.c", ["      check_cursor();", "    } else if (pos != NULL)                 /* can jump */", "      nv_cursormark(cap, false, pos);"], "readability/braces"]
["src/nvim/normal.c", ["        EMSG(_(\"E663: At end of changelist\"));", "    } else", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    set_reg_var(cap->oap->regname);", "  } else", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["      end_visual_mode();", "    else {                                  /* toggle char/block mode */", "                                            /*\t   or char/line mode */"], "readability/braces"]
["src/nvim/normal.c", ["    else {                                  /* toggle char/block mode */", "                                            /*\t   or char/line mode */", "      VIsual_mode = cap->cmdchar;"], "whitespace/tab"]
["src/nvim/normal.c", ["                                + resel_VIsual_vcol * (int)cap->count0 - 1);", "        } else", "          curwin->w_curswant = resel_VIsual_vcol;"], "readability/braces"]
["src/nvim/normal.c", ["        coladvance(curwin->w_curswant);", "      } else", "        curwin->w_set_curswant = true;"], "readability/braces"]
["src/nvim/normal.c", ["      beep_flush();", "    else {", "      /* set w_cursor to the start of the Visual area, tpos to the end */"], "readability/braces"]
["src/nvim/normal.c", ["      i = cursor_down(cap->count1, oap->op_type == OP_NOP);", "    } else", "      i = nv_screengo(oap, FORWARD, cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["      i = cursor_up(cap->count1, oap->op_type == OP_NOP);", "    } else", "      i = nv_screengo(oap, BACKWARD, cap->count1);"], "readability/braces"]
["src/nvim/normal.c", ["        i = (curwin->w_virtcol - width1) / width2 * width2 + width1;", "    } else", "      i = curwin->w_leftcol;"], "readability/braces"]
["src/nvim/normal.c", ["        i = gchar_cursor();", "      while (ascii_iswhite(i) && oneright());", "    }"], "whitespace/empty_loop_body"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);", "    else {", "      char_u  *ptr = get_cursor_line_ptr();"], "readability/braces"]
["src/nvim/normal.c", ["        }", "      } else if (nv_screengo(oap, FORWARD, cap->count1 - 1) == false)", "        clearopbeep(oap);"], "readability/braces"]
["src/nvim/normal.c", ["    set_vim_var_string(VV_OP, NULL, 0);", "  else {", "    int opchar0 = get_op_char(optype);"], "readability/braces"]
["src/nvim/normal.c", ["", "    int opchar1 = get_extra_op_char(optype); ", "    assert(opchar1 >= 0 && opchar1 <= UCHAR_MAX);"], "whitespace/end_of_line"]
["src/nvim/normal.c", ["    nv_goto(cap);", "  else {", "    cap->count0 = 1;"], "readability/braces"]
["src/nvim/normal.c", ["  }", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "readability/multiline_comment"]
["src/nvim/normal.c", ["  }", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "whitespace/parens"]
["src/nvim/normal.c", ["    curwin->w_curswant = (colnr_T)(cap->count0 - 1);", "  } else", "    curwin->w_curswant = 0;"], "readability/braces"]
["src/nvim/normal.c", ["    clearopbeep(cap->oap);", "  else {", "    adjust_for_sel(cap);"], "readability/braces"]
["src/nvim/normal.c", ["    foldOpenCursor();", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "readability/multiline_comment"]
["src/nvim/normal.c", ["    foldOpenCursor();", "  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a", "                               one-character line). */"], "whitespace/parens"]
["src/nvim/normal.c", ["      restart_edit = 'a';", "  } else", "    clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["               || VIsual_active", "               )) {", "    nv_object(cap);"], "whitespace/parens"]
["src/nvim/normal.c", ["        State = save_State;", "      } else", "        curwin->w_cursor.col += (colnr_T)STRLEN(get_cursor_pos_ptr());"], "readability/braces"]
["src/nvim/normal.c", ["static void", "invoke_edit (", "    cmdarg_T *cap,"], "whitespace/parens"]
["src/nvim/normal.c", ["      stuffcharReadbuff(K_CMDWIN);", "    } else", "    /* (stop) recording into a named register, unless executing a"], "readability/braces"]
["src/nvim/normal.c", ["      clearopbeep(cap->oap);        /* beyond last line */", "    else {", "      prep_redo(cap->oap->regname, cap->count0,"], "readability/braces"]
["src/nvim/normal.c", ["      nv_diffgetput(true, (size_t)cap->opcount);", "    } else", "      clearopbeep(cap->oap);"], "readability/braces"]
["src/nvim/normal.c", ["    nv_diffgetput(false, (size_t)cap->opcount);", "  } else if (VIsual_active) /* switch start and end of visual */", "    v_swap_corners(cap->cmdchar);"], "readability/braces"]
["src/nvim/ops.c", ["{", "  {NUL, NUL, FALSE},    /* OP_NOP */", "  {'d', NUL, FALSE},    /* OP_DELETE */"], "readability/bool"]
["src/nvim/ops.c", ["  {NUL, NUL, FALSE},    /* OP_NOP */", "  {'d', NUL, FALSE},    /* OP_DELETE */", "  {'y', NUL, FALSE},    /* OP_YANK */"], "readability/bool"]
["src/nvim/ops.c", ["  {'d', NUL, FALSE},    /* OP_DELETE */", "  {'y', NUL, FALSE},    /* OP_YANK */", "  {'c', NUL, FALSE},    /* OP_CHANGE */"], "readability/bool"]
["src/nvim/ops.c", ["  {'y', NUL, FALSE},    /* OP_YANK */", "  {'c', NUL, FALSE},    /* OP_CHANGE */", "  {'<', NUL, TRUE},     /* OP_LSHIFT */"], "readability/bool"]
["src/nvim/ops.c", ["  {'c', NUL, FALSE},    /* OP_CHANGE */", "  {'<', NUL, TRUE},     /* OP_LSHIFT */", "  {'>', NUL, TRUE},     /* OP_RSHIFT */"], "readability/bool"]
["src/nvim/ops.c", ["  {'<', NUL, TRUE},     /* OP_LSHIFT */", "  {'>', NUL, TRUE},     /* OP_RSHIFT */", "  {'!', NUL, TRUE},     /* OP_FILTER */"], "readability/bool"]
["src/nvim/ops.c", ["  {'>', NUL, TRUE},     /* OP_RSHIFT */", "  {'!', NUL, TRUE},     /* OP_FILTER */", "  {'g', '~', FALSE},    /* OP_TILDE */"], "readability/bool"]
["src/nvim/ops.c", ["  {'!', NUL, TRUE},     /* OP_FILTER */", "  {'g', '~', FALSE},    /* OP_TILDE */", "  {'=', NUL, TRUE},     /* OP_INDENT */"], "readability/bool"]
["src/nvim/ops.c", ["  {'g', '~', FALSE},    /* OP_TILDE */", "  {'=', NUL, TRUE},     /* OP_INDENT */", "  {'g', 'q', TRUE},     /* OP_FORMAT */"], "readability/bool"]
["src/nvim/ops.c", ["  {'=', NUL, TRUE},     /* OP_INDENT */", "  {'g', 'q', TRUE},     /* OP_FORMAT */", "  {':', NUL, TRUE},     /* OP_COLON */"], "readability/bool"]
["src/nvim/ops.c", ["  {'g', 'q', TRUE},     /* OP_FORMAT */", "  {':', NUL, TRUE},     /* OP_COLON */", "  {'g', 'U', FALSE},    /* OP_UPPER */"], "readability/bool"]
["src/nvim/ops.c", ["  {':', NUL, TRUE},     /* OP_COLON */", "  {'g', 'U', FALSE},    /* OP_UPPER */", "  {'g', 'u', FALSE},    /* OP_LOWER */"], "readability/bool"]
["src/nvim/ops.c", ["  {'g', 'U', FALSE},    /* OP_UPPER */", "  {'g', 'u', FALSE},    /* OP_LOWER */", "  {'J', NUL, TRUE},     /* DO_JOIN */"], "readability/bool"]
["src/nvim/ops.c", ["  {'g', 'u', FALSE},    /* OP_LOWER */", "  {'J', NUL, TRUE},     /* DO_JOIN */", "  {'g', 'J', TRUE},     /* DO_JOIN_NS */"], "readability/bool"]
["src/nvim/ops.c", ["  {'J', NUL, TRUE},     /* DO_JOIN */", "  {'g', 'J', TRUE},     /* DO_JOIN_NS */", "  {'g', '?', FALSE},    /* OP_ROT13 */"], "readability/bool"]
["src/nvim/ops.c", ["  {'g', 'J', TRUE},     /* DO_JOIN_NS */", "  {'g', '?', FALSE},    /* OP_ROT13 */", "  {'r', NUL, FALSE},    /* OP_REPLACE */"], "readability/bool"]
["src/nvim/ops.c", ["  {'g', '?', FALSE},    /* OP_ROT13 */", "  {'r', NUL, FALSE},    /* OP_REPLACE */", "  {'I', NUL, FALSE},    /* OP_INSERT */"], "readability/bool"]
["src/nvim/ops.c", ["  {'r', NUL, FALSE},    /* OP_REPLACE */", "  {'I', NUL, FALSE},    /* OP_INSERT */", "  {'A', NUL, FALSE},    /* OP_APPEND */"], "readability/bool"]
["src/nvim/ops.c", ["  {'I', NUL, FALSE},    /* OP_INSERT */", "  {'A', NUL, FALSE},    /* OP_APPEND */", "  {'z', 'f', TRUE},     /* OP_FOLD */"], "readability/bool"]
["src/nvim/ops.c", ["  {'A', NUL, FALSE},    /* OP_APPEND */", "  {'z', 'f', TRUE},     /* OP_FOLD */", "  {'z', 'o', TRUE},     /* OP_FOLDOPEN */"], "readability/bool"]
["src/nvim/ops.c", ["  {'z', 'f', TRUE},     /* OP_FOLD */", "  {'z', 'o', TRUE},     /* OP_FOLDOPEN */", "  {'z', 'O', TRUE},     /* OP_FOLDOPENREC */"], "readability/bool"]
["src/nvim/ops.c", ["  {'z', 'o', TRUE},     /* OP_FOLDOPEN */", "  {'z', 'O', TRUE},     /* OP_FOLDOPENREC */", "  {'z', 'c', TRUE},     /* OP_FOLDCLOSE */"], "readability/bool"]
["src/nvim/ops.c", ["  {'z', 'O', TRUE},     /* OP_FOLDOPENREC */", "  {'z', 'c', TRUE},     /* OP_FOLDCLOSE */", "  {'z', 'C', TRUE},     /* OP_FOLDCLOSEREC */"], "readability/bool"]
["src/nvim/ops.c", ["  {'z', 'c', TRUE},     /* OP_FOLDCLOSE */", "  {'z', 'C', TRUE},     /* OP_FOLDCLOSEREC */", "  {'z', 'd', TRUE},     /* OP_FOLDDEL */"], "readability/bool"]
["src/nvim/ops.c", ["  {'z', 'C', TRUE},     /* OP_FOLDCLOSEREC */", "  {'z', 'd', TRUE},     /* OP_FOLDDEL */", "  {'z', 'D', TRUE},     /* OP_FOLDDELREC */"], "readability/bool"]
["src/nvim/ops.c", ["  {'z', 'd', TRUE},     /* OP_FOLDDEL */", "  {'z', 'D', TRUE},     /* OP_FOLDDELREC */", "  {'g', 'w', TRUE},     /* OP_FORMAT2 */"], "readability/bool"]
["src/nvim/ops.c", ["  {'z', 'D', TRUE},     /* OP_FOLDDELREC */", "  {'g', 'w', TRUE},     /* OP_FORMAT2 */", "  {'g', '@', FALSE},    /* OP_FUNCTION */"], "readability/bool"]
["src/nvim/ops.c", ["  {'g', 'w', TRUE},     /* OP_FORMAT2 */", "  {'g', '@', FALSE},    /* OP_FUNCTION */", "};"], "readability/bool"]
["src/nvim/ops.c", ["    if (first_char != '#' || !preprocs_left()) {", "      shift_line(oap->op_type == OP_LSHIFT, p_sr, amount, FALSE);", "    }"], "readability/bool"]
["src/nvim/ops.c", ["    beginline(BL_SOL | BL_FIX);       /* shift_line() may have set cursor.col */", "  } else", "    --curwin->w_cursor.lnum;            /* put cursor on last line, for \":>\" */"], "readability/braces"]
["src/nvim/ops.c", ["      if (amount == 1)", "        sprintf((char *)IObuff, _(\"1 line %sed 1 time\"), s);", "      else"], "runtime/printf"]
["src/nvim/ops.c", ["      else", "        sprintf((char *)IObuff, _(\"1 line %sed %d times\"), s, amount);", "    } else {"], "runtime/printf"]
["src/nvim/ops.c", ["      if (amount == 1)", "        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed 1 time\"),", "            (int64_t)oap->line_count, s);"], "runtime/printf"]
["src/nvim/ops.c", ["      else", "        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed %d times\"),", "            (int64_t)oap->line_count, s, amount);"], "runtime/printf"]
["src/nvim/ops.c", [" */", "void ", "shift_line ("], "whitespace/end_of_line"]
["src/nvim/ops.c", ["void ", "shift_line (", "    int left,"], "whitespace/parens"]
["src/nvim/ops.c", ["        i = 0;", "    } else", "      i += amount;"], "readability/braces"]
["src/nvim/ops.c", ["        count = 0;", "    } else", "      count += p_sw * amount;"], "readability/braces"]
["src/nvim/ops.c", ["  if (State & VREPLACE_FLAG)", "    change_indent(INDENT_SET, count, FALSE, NUL, call_changed_bytes);", "  else"], "readability/bool"]
["src/nvim/ops.c", ["  State = INSERT;               /* don't want REPLACE for State */", "  block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);", "  if (bd.is_short)"], "readability/bool"]
["src/nvim/ops.c", ["    for (; ascii_iswhite(*bd.textstart); ) {", "      // TODO: is passing bd.textstart for start of the line OK?", "      incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart, (colnr_T)(bd.start_vcol));"], "readability/todo"]
["src/nvim/ops.c", ["      // TODO: is passing bd.textstart for start of the line OK?", "      incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart, (colnr_T)(bd.start_vcol));", "      total += incr;"], "whitespace/line_length"]
["src/nvim/ops.c", ["  } else { /* left */", "    colnr_T destination_col;            /* column to which text in block will", "                                           be shifted */"], "readability/multiline_comment"]
["src/nvim/ops.c", ["                                           be shifted */", "    char_u      *verbatim_copy_end;     /* end of the part of the line which is", "                                           copied verbatim */"], "readability/multiline_comment"]
["src/nvim/ops.c", ["                                           copied verbatim */", "    colnr_T verbatim_copy_width;        /* the (displayed) width of this part", "                                           of line */"], "readability/multiline_comment"]
["src/nvim/ops.c", ["                                           copied verbatim */", "    colnr_T verbatim_copy_width;        /* the (displayed) width of this part", "                                           of line */"], "whitespace/parens"]
["src/nvim/ops.c", ["    unsigned fill;                      /* nr of spaces that replace a TAB */", "    unsigned new_line_len;              /* the length of the line after the", "                                           block shift */"], "readability/multiline_comment"]
["src/nvim/ops.c", ["", "      // TODO: is passing verbatim_copy_end for start of the line OK?", "      incr = lbr_chartabsize(line, verbatim_copy_end, verbatim_copy_width);"], "readability/todo"]
["src/nvim/ops.c", ["  /* replace the line */", "  ml_replace(curwin->w_cursor.lnum, newp, FALSE);", "  changed_bytes(curwin->w_cursor.lnum, (colnr_T)bd.textcol);"], "readability/bool"]
["src/nvim/ops.c", [" */", "static void block_insert(oparg_T *oap, char_u *s, int b_insert, struct block_def *bdp)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["  for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++) {", "    block_prep(oap, bdp, lnum, TRUE);", "    if (bdp->is_short && b_insert)"], "readability/bool"]
["src/nvim/ops.c", ["", "    ml_replace(lnum, newp, FALSE);", ""], "readability/bool"]
["src/nvim/ops.c", ["  ++nested;", "  rv = eval_to_string(expr_copy, NULL, TRUE);", "  --nested;"], "readability/bool"]
["src/nvim/ops.c", ["  if (regname != 0 && !valid_yank_reg(regname, false))", "    return FALSE;", "  if (regname == '_')           /* black hole is always empty */"], "readability/bool"]
["src/nvim/ops.c", ["  if (regname == '_')           /* black hole is always empty */", "    return FALSE;", "  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);"], "readability/bool"]
["src/nvim/ops.c", ["", "  if (Recording == FALSE) {         /* start recording */", "    /* registers 0-9, a-z and \" are allowed */"], "readability/bool"]
["src/nvim/ops.c", ["      retval = FAIL;", "    else {", "      Recording = TRUE;"], "readability/braces"]
["src/nvim/ops.c", ["    else {", "      Recording = TRUE;", "      showmode();"], "readability/bool"]
["src/nvim/ops.c", ["     */", "    Recording = FALSE;", "    MSG(\"\");"], "readability/bool"]
["src/nvim/ops.c", ["      retval = FAIL;", "    else {", "      /* Remove escaping for CSI and K_SPECIAL in multi-byte chars. */"], "readability/braces"]
["src/nvim/ops.c", [" */", "int ", "do_execreg ("], "whitespace/end_of_line"]
["src/nvim/ops.c", ["int ", "do_execreg (", "    int regname,"], "whitespace/parens"]
["src/nvim/ops.c", ["        (char_u *)", "        \"\\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\",", "        Ctrl_V, FALSE);"], "whitespace/line_length"]
["src/nvim/ops.c", ["        \"\\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\",", "        Ctrl_V, FALSE);", "    /* When in Visual mode \"'<,'>\" will be prepended to the command."], "readability/bool"]
["src/nvim/ops.c", ["    if (VIsual_active && STRNCMP(p, \"'<,'>\", 5) == 0)", "      retval = put_in_typebuf(p + 5, TRUE, TRUE, silent);", "    else"], "readability/bool"]
["src/nvim/ops.c", ["    else", "      retval = put_in_typebuf(p, TRUE, TRUE, silent);", "    xfree(p);"], "readability/bool"]
["src/nvim/ops.c", ["      return FAIL;", "    retval = put_in_typebuf(p, TRUE, colon, silent);", "    xfree(p);"], "readability/bool"]
["src/nvim/ops.c", ["    }", "    retval = put_in_typebuf(p, FALSE, colon, silent);", "    xfree(p);"], "readability/bool"]
["src/nvim/ops.c", ["          || addcr) {", "        if (ins_typebuf((char_u *)\"\\n\", remap, 0, TRUE, silent) == FAIL)", "          return FAIL;"], "readability/bool"]
["src/nvim/ops.c", ["      escaped = vim_strsave_escape_csi(reg->y_array[i]);", "      retval = ins_typebuf(escaped, remap, 0, TRUE, silent);", "      xfree(escaped);"], "readability/bool"]
["src/nvim/ops.c", ["        return FAIL;", "      if (colon && ins_typebuf((char_u *)\":\", remap, 0, TRUE, silent)", "          == FAIL)"], "readability/bool"]
["src/nvim/ops.c", ["    }", "    Exec_reg = TRUE;            /* disable the 'q' command */", "  }"], "readability/bool"]
["src/nvim/ops.c", ["    }", "    if (ins_typebuf(buf, REMAP_NONE, 0, TRUE, silent) == OK)", "      restart_edit = NUL;"], "readability/bool"]
["src/nvim/ops.c", [" */", "static int ", "put_in_typebuf ("], "whitespace/end_of_line"]
["src/nvim/ops.c", ["static int ", "put_in_typebuf (", "    char_u *s,"], "whitespace/parens"]
["src/nvim/ops.c", ["  if (colon)", "    retval = ins_typebuf((char_u *)\"\\n\", REMAP_NONE, 0, TRUE, silent);", "  if (retval == OK) {"], "readability/bool"]
["src/nvim/ops.c", ["      retval = ins_typebuf(p, esc ? REMAP_NONE : REMAP_YES,", "          0, TRUE, silent);", "    if (esc)"], "readability/bool"]
["src/nvim/ops.c", ["  if (colon && retval == OK)", "    retval = ins_typebuf((char_u *)\":\", REMAP_NONE, 0, TRUE, silent);", "  return retval;"], "readability/bool"]
["src/nvim/ops.c", [" */", "int ", "insert_reg ("], "whitespace/end_of_line"]
["src/nvim/ops.c", ["int ", "insert_reg (", "    int regname,"], "whitespace/parens"]
["src/nvim/ops.c", ["  if (regname == '.')                   /* insert last inserted text */", "    retval = stuff_inserted(NUL, 1L, TRUE);", "  else if (get_spec_reg(regname, &arg, &allocated, TRUE)) {"], "readability/bool"]
["src/nvim/ops.c", ["    retval = stuff_inserted(NUL, 1L, TRUE);", "  else if (get_spec_reg(regname, &arg, &allocated, TRUE)) {", "    if (arg == NULL)"], "readability/bool"]
["src/nvim/ops.c", ["      retval = FAIL;", "    else {", "      for (i = 0; i < reg->y_size; i++) {"], "readability/braces"]
["src/nvim/ops.c", [" */", "int ", "get_spec_reg ("], "whitespace/end_of_line"]
["src/nvim/ops.c", ["int ", "get_spec_reg (", "    int regname,"], "whitespace/parens"]
["src/nvim/ops.c", ["  *argp = NULL;", "  *allocated = FALSE;", "  switch (regname) {"], "readability/bool"]
["src/nvim/ops.c", ["    *argp = curbuf->b_fname;", "    return TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["    *argp = getaltfname(errmsg);                /* may give emsg if not set */", "    return TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["    *argp = get_expr_line();", "    *allocated = TRUE;", "    return TRUE;"], "readability/bool"]
["src/nvim/ops.c", ["    *allocated = TRUE;", "    return TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["    *argp = last_cmdline;", "    return TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["    *argp = last_search_pat();", "    return TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["    *argp = get_last_insert_save();", "    *allocated = TRUE;", "    if (*argp == NULL && errmsg)"], "readability/bool"]
["src/nvim/ops.c", ["      EMSG(_(e_noinstext));", "    return TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["    if (!errmsg)", "      return FALSE;", "    *argp = file_name_at_cursor(FNAME_MESS | FNAME_HYP"], "readability/bool"]
["src/nvim/ops.c", ["        | (regname == Ctrl_P ? FNAME_EXP : 0), 1L, NULL);", "    *allocated = TRUE;", "    return TRUE;"], "readability/bool"]
["src/nvim/ops.c", ["    *allocated = TRUE;", "    return TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["    if (!errmsg)", "      return FALSE;", "    cnt = find_ident_under_cursor(argp, (regname == Ctrl_W"], "readability/bool"]
["src/nvim/ops.c", ["    *argp = cnt ? vim_strnsave(*argp, cnt) : NULL;", "    *allocated = TRUE;", "    return TRUE;"], "readability/bool"]
["src/nvim/ops.c", ["    *allocated = TRUE;", "    return TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["    *argp = (char_u *)\"\";", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ops.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ops.c", [" */", "int ", "cmdline_paste_reg ("], "whitespace/end_of_line"]
["src/nvim/ops.c", ["int ", "cmdline_paste_reg (", "    int regname,"], "whitespace/parens"]
["src/nvim/ops.c", ["", "  /* Nothing to delete, return here.\tDo prepare undo, for op_change(). */", "  if (oap->empty)"], "whitespace/tab"]
["src/nvim/ops.c", ["    if (oap->regname != 0) {", "      //yank without message", "      if (!op_yank(oap, false)) {"], "whitespace/comments"]
["src/nvim/ops.c", ["", "    if(oap->regname == 0) {", "      set_clipboard(0, reg);"], "whitespace/parens"]
["src/nvim/ops.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/ops.c", ["    for (lnum = curwin->w_cursor.lnum; lnum <= oap->end.lnum; ++lnum) {", "      block_prep(oap, &bd, lnum, TRUE);", "      if (bd.textlen == 0)              /* nothing to delete */"], "readability/bool"]
["src/nvim/ops.c", ["      /* replace the line */", "      ml_replace(lnum, newp, FALSE);", "    }"], "readability/bool"]
["src/nvim/ops.c", ["        ++curwin->w_cursor.lnum;", "        del_lines(oap->line_count - 1, TRUE);", "        curwin->w_cursor.lnum = lnum;"], "readability/bool"]
["src/nvim/ops.c", ["        beginline(BL_WHITE);                /* cursor on first non-white */", "        did_ai = TRUE;                      /* delete the indent when ESC hit */", "        ai_col = curwin->w_cursor.col;"], "readability/bool"]
["src/nvim/ops.c", ["        ai_col = curwin->w_cursor.col;", "      } else", "        beginline(0);                       /* cursor in column 0 */"], "readability/braces"]
["src/nvim/ops.c", ["        beginline(0);                       /* cursor in column 0 */", "      truncate_line(FALSE);         /* delete the rest of the line */", "                                    /* leave cursor past last char in line */"], "readability/bool"]
["src/nvim/ops.c", ["    } else {", "      del_lines(oap->line_count, TRUE);", "      beginline(BL_WHITE | BL_FIX);"], "readability/bool"]
["src/nvim/ops.c", ["        /* Special case: gH<Del> deletes the last line. */", "        del_lines(1L, FALSE);", "      } else {"], "readability/bool"]
["src/nvim/ops.c", ["            && !oap->is_VIsual", "            );", "      }"], "whitespace/parens"]
["src/nvim/ops.c", ["      delete_last_line = (oap->end.lnum == curbuf->b_ml.ml_line_count);", "      truncate_line(TRUE);              /* delete from cursor to end of line */", ""], "readability/bool"]
["src/nvim/ops.c", ["      ++curwin->w_cursor.lnum;", "      del_lines(oap->line_count - 2, FALSE);", ""], "readability/bool"]
["src/nvim/ops.c", ["        /* Special case: gH<Del> deletes the last line. */", "        del_lines(1L, FALSE);", "        curwin->w_cursor = curpos;              /* restore curwin->w_cursor */"], "readability/bool"]
["src/nvim/ops.c", ["            && !oap->is_VIsual", "            );", "        curwin->w_cursor = curpos;              /* restore curwin->w_cursor */"], "whitespace/parens"]
["src/nvim/ops.c", ["      if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {", "        do_join(2, FALSE, FALSE, FALSE, false);", "      }"], "readability/bool"]
["src/nvim/ops.c", ["    curbuf->b_op_end.col = oap->start.col;", "  } else", "    curbuf->b_op_end = oap->start;"], "readability/braces"]
["src/nvim/ops.c", ["{", "    *(ml_get_buf(curbuf, lp.lnum, TRUE) + lp.col) = c;;", "}"], "whitespace/newline"]
["src/nvim/ops.c", ["{", "    *(ml_get_buf(curbuf, lp.lnum, TRUE) + lp.col) = c;;", "}"], "readability/bool"]
["src/nvim/ops.c", ["      curwin->w_cursor.col = 0;        /* make sure cursor position is valid */", "      block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);", "      if (bd.textlen == 0 && (!virtual_op || bd.is_MAX))"], "readability/bool"]
["src/nvim/ops.c", ["        n = bd.startspaces;", "      } else", "        /* allow for pre spaces */"], "readability/braces"]
["src/nvim/ops.c", ["            n += (*mb_char2bytes)(c, newp + n);", "        } else", "          memset(newp + STRLEN(newp), c, (size_t)numc);"], "readability/braces"]
["src/nvim/ops.c", ["      /* replace the line */", "      ml_replace(curwin->w_cursor.lnum, newp, FALSE);", "      if (after_p != NULL) {"], "readability/bool"]
["src/nvim/ops.c", ["      if (after_p != NULL) {", "        ml_append(curwin->w_cursor.lnum++, after_p, 0, FALSE);", "        appended_lines_mark(curwin->w_cursor.lnum, 1L);"], "readability/bool"]
["src/nvim/ops.c", ["        --oap->end.col;", "    } else if (!oap->inclusive)", "      dec(&(oap->end));"], "readability/braces"]
["src/nvim/ops.c", ["  struct block_def bd;", "  int did_change = FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "      block_prep(oap, &bd, pos.lnum, FALSE);", "      pos.col = bd.textcol;"], "readability/bool"]
["src/nvim/ops.c", ["      did_change |= one_change;", "", "    }"], "whitespace/blank_line"]
["src/nvim/ops.c", ["        --oap->end.col;", "    } else if (!oap->inclusive)", "      dec(&(oap->end));"], "readability/braces"]
["src/nvim/ops.c", ["  if (c >= 0x80 && op_type == OP_ROT13)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["    curwin->w_cursor = *pos;", "    del_char(FALSE);", "    ins_char('S');"], "readability/bool"]
["src/nvim/ops.c", ["  if (enc_dbcs != 0 && c >= 0x100)      /* No lower/uppercase letter */", "    return FALSE;", "  nc = c;"], "readability/bool"]
["src/nvim/ops.c", ["      /* don't use del_char(), it also removes composing chars */", "      del_bytes(utf_ptr2len(get_cursor_pos_ptr()), FALSE, FALSE);", "      ins_char(nc);"], "readability/bool"]
["src/nvim/ops.c", ["      curwin->w_cursor = sp;", "    } else", "      pchar(*pos, nc);"], "readability/braces"]
["src/nvim/ops.c", ["      pchar(*pos, nc);", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ops.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ops.c", ["    /* Get the info about the block before entering the text */", "    block_prep(oap, &bd, oap->start.lnum, TRUE);", "    firstline = ml_get(oap->start.lnum) + bd.textcol;"], "readability/bool"]
["src/nvim/ops.c", ["      /* Move the cursor to the character right of the block. */", "      curwin->w_set_curswant = TRUE;", "      while (*get_cursor_pos_ptr() != NUL"], "readability/bool"]
["src/nvim/ops.c", ["", "  edit(NUL, FALSE, (linenr_T)count1);", ""], "readability/bool"]
["src/nvim/ops.c", ["     */", "    block_prep(oap, &bd2, oap->start.lnum, TRUE);", "    if (!bd.is_MAX || bd2.textlen < bd.textlen) {"], "readability/bool"]
["src/nvim/ops.c", ["        )", "      can_si = TRUE;            /* It's like opening a new line, do si */", "  }"], "readability/bool"]
["src/nvim/ops.c", ["    if (u_save_cursor() == FAIL)", "      return FALSE;", "  } else if (op_delete(oap) == FAIL)"], "readability/bool"]
["src/nvim/ops.c", ["      return FALSE;", "  } else if (op_delete(oap) == FAIL)", "    return FALSE;"], "readability/braces"]
["src/nvim/ops.c", ["  } else if (op_delete(oap) == FAIL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  retval = edit(NUL, FALSE, (linenr_T)1);", ""], "readability/bool"]
["src/nvim/ops.c", ["           linenr++) {", "        block_prep(oap, &bd, linenr, TRUE);", "        if (!bd.is_short || virtual_op) {"], "readability/bool"]
["src/nvim/ops.c", ["            (void)getvpos(&vpos, oap->start_vcol);", "          } else", "            vpos.coladd = 0;"], "readability/braces"]
["src/nvim/ops.c", ["          oldp = ml_get(linenr);", "          newp = (char_u *) xmalloc((size_t)(STRLEN(oldp) + vpos.coladd + ins_len + 1));", "          /* copy up to block start */"], "whitespace/line_length"]
["src/nvim/ops.c", ["          STRMOVE(newp + offset, oldp);", "          ml_replace(linenr, newp, FALSE);", "        }"], "readability/bool"]
["src/nvim/ops.c", ["", " /// Free contents of yankreg `reg`.", " /// Called for normal freeing and in case of error."], "whitespace/indent"]
["src/nvim/ops.c", [" /// Free contents of yankreg `reg`.", " /// Called for normal freeing and in case of error.", " /// `reg` must not be NULL (but `reg->y_array` might be)"], "whitespace/indent"]
["src/nvim/ops.c", [" /// Called for normal freeing and in case of error.", " /// `reg` must not be NULL (but `reg->y_array` might be)", "void free_register(yankreg_T *reg)"], "whitespace/indent"]
["src/nvim/ops.c", ["  if (oap->regname == '_') {", "    return true; // black hole: nothing to do", "  }"], "whitespace/comments"]
["src/nvim/ops.c", ["    case MBLOCK:", "      block_prep(oap, &bd, lnum, FALSE);", "      yank_copy_line(reg, &bd, y_idx);"], "readability/bool"]
["src/nvim/ops.c", ["      colnr_T startcol = 0, endcol = MAXCOL;", "      int is_oneChar = FALSE;", "      colnr_T cs, ce;"], "readability/bool"]
["src/nvim/ops.c", ["                                   && (*mb_head_off)(p, p + endcol) == 0", "                                   )) {", "            if (oap->start.lnum == oap->end.lnum"], "whitespace/parens"]
["src/nvim/ops.c", ["              /* Special case: inside a single char */", "              is_oneChar = TRUE;", "              bd.startspaces = oap->end.coladd"], "readability/bool"]
["src/nvim/ops.c", ["        bd.textlen = 0;", "      else {", "        bd.textlen = endcol - startcol + oap->inclusive;"], "readability/braces"]
["src/nvim/ops.c", ["      y_idx = 1;", "    } else", "      y_idx = 0;"], "readability/braces"]
["src/nvim/ops.c", ["          MSG(_(\"1 line yanked\"));", "      } else if (oap->block_mode)", "        smsg(_(\"block of %\" PRId64 \" lines yanked\"),"], "readability/braces"]
["src/nvim/ops.c", ["  int indent_diff = 0;                  /* init for gcc */", "  int first_indent = TRUE;", "  int lendiff = 0;"], "readability/bool"]
["src/nvim/ops.c", ["  char_u      *insert_string = NULL;", "  int allocated = FALSE;", "  long cnt;"], "readability/bool"]
["src/nvim/ops.c", ["    (void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :", "                          (count == -1 ? 'O' : 'i')), count, FALSE);", "    /* Putting the text is done later, so can't really move the cursor to"], "readability/bool"]
["src/nvim/ops.c", ["   */", "  if (get_spec_reg(regname, &insert_string, &allocated, TRUE)) {", "    if (insert_string == NULL)"], "readability/bool"]
["src/nvim/ops.c", ["      ptr = vim_strsave(get_cursor_pos_ptr());", "      ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);", "      xfree(ptr);"], "readability/bool"]
["src/nvim/ops.c", ["      ptr = vim_strnsave(get_cursor_line_ptr(), curwin->w_cursor.col);", "      ml_replace(curwin->w_cursor.lnum, ptr, FALSE);", "      ++nr_lines;"], "readability/bool"]
["src/nvim/ops.c", ["    curbuf->b_op_start = curwin->w_cursor;      /* for mark_adjust() */", "  } else if (u_save_cursor() == FAIL)", "    goto end;"], "readability/braces"]
["src/nvim/ops.c", ["        curwin->w_cursor.coladd = 0;", "    } else if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)", "      coladvance_force(getviscol() + (dir == FORWARD));"], "readability/braces"]
["src/nvim/ops.c", ["      ++col;", "    } else", "      getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);"], "readability/braces"]
["src/nvim/ops.c", ["        if (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",", "                (colnr_T)1, FALSE) == FAIL)", "          break;"], "readability/bool"]
["src/nvim/ops.c", ["          (size_t)(oldlen - bd.textcol - delcount + 1));", "      ml_replace(curwin->w_cursor.lnum, newp, FALSE);", ""], "readability/bool"]
["src/nvim/ops.c", ["        curwin->w_cursor.col = len;", "    } else", "      curwin->w_cursor.lnum = lnum;"], "readability/braces"]
["src/nvim/ops.c", ["     */", "    else if (dir == BACKWARD)", "      --lnum;"], "whitespace/newline"]
["src/nvim/ops.c", ["          STRMOVE(ptr, oldp + col);", "          ml_replace(lnum, newp, FALSE);", "          /* Place cursor on last putted char. */"], "readability/bool"]
["src/nvim/ops.c", ["          /* insert second line */", "          ml_append(lnum, newp, (colnr_T)0, FALSE);", "          xfree(newp);"], "readability/bool"]
["src/nvim/ops.c", ["          memmove(newp + col, y_array[0], (size_t)(yanklen + 1));", "          ml_replace(lnum, newp, FALSE);", ""], "readability/bool"]
["src/nvim/ops.c", ["          if ((y_type != MCHAR || i < y_size - 1)", "              && ml_append(lnum, y_array[i], (colnr_T)0, FALSE)", "              == FAIL)"], "readability/bool"]
["src/nvim/ops.c", ["              indent = orig_indent;", "              first_indent = FALSE;", "            } else if ((indent = get_indent() + indent_diff) < 0)"], "readability/bool"]
["src/nvim/ops.c", ["              first_indent = FALSE;", "            } else if ((indent = get_indent() + indent_diff) < 0)", "              indent = 0;"], "readability/braces"]
["src/nvim/ops.c", ["        beginline(BL_WHITE | BL_FIX);", "      } else            /* put cursor on first inserted character */", "        curwin->w_cursor = new_cursor;"], "readability/braces"]
["src/nvim/ops.c", ["  msgmore(nr_lines);", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  VIsual_active = FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["    (curbuf->b_p_si && !curbuf->b_p_cin) ||", "    (curbuf->b_p_cin && in_cinkeys('#', ' ', TRUE)", "     && curbuf->b_ind_hash_comment == 0)"], "readability/bool"]
["src/nvim/ops.c", ["     && curbuf->b_ind_hash_comment == 0)", "  ;", "}"], "whitespace/semicolon"]
["src/nvim/ops.c", ["    return '+';", "  else {", "    return num + 'a' - 10;"], "readability/braces"]
["src/nvim/ops.c", ["        yb = &(y_regs[0]);", "    } else", "      yb = &(y_regs[i]);"], "readability/braces"]
["src/nvim/ops.c", ["        || (redir_reg == '\"' && yb == y_previous))", "      continue;             /* do not list register being written to, the", "                             * pointer can be freed */"], "readability/multiline_comment"]
["src/nvim/ops.c", ["    MSG_PUTS(\"\\n\\\".   \");", "    dis_msg(p, TRUE);", "  }"], "readability/bool"]
["src/nvim/ops.c", ["    MSG_PUTS(\"\\n\\\":   \");", "    dis_msg(last_cmdline, FALSE);", "  }"], "readability/bool"]
["src/nvim/ops.c", ["    MSG_PUTS(\"\\n\\\"%   \");", "    dis_msg(curbuf->b_fname, FALSE);", "  }"], "readability/bool"]
["src/nvim/ops.c", ["      MSG_PUTS(\"\\n\\\"#   \");", "      dis_msg(fname, FALSE);", "    }"], "readability/bool"]
["src/nvim/ops.c", ["    MSG_PUTS(\"\\n\\\"/   \");", "    dis_msg(last_search_pat(), FALSE);", "  }"], "readability/bool"]
["src/nvim/ops.c", ["    MSG_PUTS(\"\\n\\\"=   \");", "    dis_msg(expr_line, FALSE);", "  }"], "readability/bool"]
["src/nvim/ops.c", [" */", "static void ", "dis_msg ("], "whitespace/end_of_line"]
["src/nvim/ops.c", ["static void ", "dis_msg (", "    char_u *p,"], "whitespace/parens"]
["src/nvim/ops.c", ["      p += l;", "    } else", "      msg_outtrans_len(p++, 1);"], "readability/braces"]
["src/nvim/ops.c", [" */", "static char_u *skip_comment(char_u *line, int process, int include_space, int *is_comment)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["", "  *is_comment = FALSE;", "  if (leader_offset != -1) {"], "readability/bool"]
["src/nvim/ops.c", ["    if (*comment_flags != COM_END)", "      *is_comment = TRUE;", "  }"], "readability/bool"]
["src/nvim/ops.c", ["", "  if (process == FALSE)", "    return line;"], "readability/bool"]
["src/nvim/ops.c", ["", "  lead_len = get_leader_len(line, &comment_flags, FALSE, include_space);", ""], "readability/bool"]
["src/nvim/ops.c", ["  int         *comments = NULL;", "  int remove_comments = (use_formatoptions == TRUE)", "                        && has_format_option(FO_REMOVE_COMS);"], "readability/bool"]
["src/nvim/ops.c", ["      if (t > 0 && prev_was_comment) {", "", "        char_u *new_curr = skip_comment(curr, TRUE, insert_space,"], "whitespace/blank_line"]
["src/nvim/ops.c", ["", "        char_u *new_curr = skip_comment(curr, TRUE, insert_space,", "            &prev_was_comment);"], "readability/bool"]
["src/nvim/ops.c", ["        curr = new_curr;", "      } else", "        curr = skip_comment(curr, FALSE, insert_space,"], "readability/braces"]
["src/nvim/ops.c", ["      } else", "        curr = skip_comment(curr, FALSE, insert_space,", "            &prev_was_comment);"], "readability/bool"]
["src/nvim/ops.c", ["  }", "  ml_replace(curwin->w_cursor.lnum, newp, FALSE);", ""], "readability/bool"]
["src/nvim/ops.c", ["  ++curwin->w_cursor.lnum;", "  del_lines(count - 1, FALSE);", "  curwin->w_cursor.lnum = t;"], "readability/bool"]
["src/nvim/ops.c", ["  curwin->w_cursor.coladd = 0;", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", [" */", "static int same_leader(linenr_T lnum, int leader1_len, char_u *leader1_flags, int leader2_len, char_u *leader2_flags)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["      if (*p == COM_END)", "        return FALSE;", "      if (*p == COM_START) {"], "readability/bool"]
["src/nvim/ops.c", ["        if (*(ml_get(lnum) + leader1_len) == NUL)", "          return FALSE;", "        if (leader2_flags == NULL || leader2_len == 0)"], "readability/bool"]
["src/nvim/ops.c", ["        if (leader2_flags == NULL || leader2_len == 0)", "          return FALSE;", "        for (p = leader2_flags; *p && *p != ':'; ++p)"], "readability/bool"]
["src/nvim/ops.c", ["          if (*p == COM_MIDDLE)", "            return TRUE;", "        return FALSE;"], "readability/bool"]
["src/nvim/ops.c", ["            return TRUE;", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/ops.c", ["  for (idx1 = 0; ascii_iswhite(line1[idx1]); ++idx1)", "    ;", "  line2 = ml_get(lnum + 1);"], "whitespace/semicolon"]
["src/nvim/ops.c", ["        break;", "    } else", "      while (ascii_iswhite(line1[idx1]))"], "readability/braces"]
["src/nvim/ops.c", [" */", "void ", "op_format ("], "whitespace/end_of_line"]
["src/nvim/ops.c", ["void ", "op_format (", "    oparg_T *oap,"], "whitespace/parens"]
["src/nvim/ops.c", ["     * internal formatting. */", "    op_format(oap, FALSE);", "}"], "readability/bool"]
["src/nvim/ops.c", ["", "int ", "fex_format ("], "whitespace/end_of_line"]
["src/nvim/ops.c", ["int ", "fex_format (", "    linenr_T lnum,"], "whitespace/parens"]
["src/nvim/ops.c", [" */", "void ", "format_lines ("], "whitespace/end_of_line"]
["src/nvim/ops.c", ["void ", "format_lines (", "    linenr_T line_count,"], "whitespace/parens"]
["src/nvim/ops.c", ["  int is_end_par;                       /* at end of paragraph */", "  int prev_is_end_par = FALSE;          /* prev. line not part of parag. */", "  int next_is_start_par = FALSE;"], "readability/bool"]
["src/nvim/ops.c", ["  int prev_is_end_par = FALSE;          /* prev. line not part of parag. */", "  int next_is_start_par = FALSE;", "  int leader_len = 0;                   /* leader len of current line */"], "readability/bool"]
["src/nvim/ops.c", ["  int do_comments_list = 0;             /* format comments with 'n' or '2' */", "  int advance = TRUE;", "  int second_indent = -1;               /* indent for second line (comment"], "readability/bool"]
["src/nvim/ops.c", ["  int advance = TRUE;", "  int second_indent = -1;               /* indent for second line (comment", "                                         * aware) */"], "readability/multiline_comment"]
["src/nvim/ops.c", ["  int do_trail_white;", "  int first_par_line = TRUE;", "  int smd_save;"], "readability/bool"]
["src/nvim/ops.c", ["  long count;", "  int need_set_indent = TRUE;           /* set indent of next paragraph */", "  int force_format = FALSE;"], "readability/bool"]
["src/nvim/ops.c", ["  int need_set_indent = TRUE;           /* set indent of next paragraph */", "  int force_format = FALSE;", "  int old_State = State;"], "readability/bool"]
["src/nvim/ops.c", ["  /* length of a line to force formatting: 3 * 'tw' */", "  max_len = comp_textwidth(TRUE) * 3;", ""], "readability/bool"]
["src/nvim/ops.c", ["        , &leader_len, &leader_flags, do_comments", "        );", "  else"], "whitespace/parens"]
["src/nvim/ops.c", ["  else", "    is_not_par = TRUE;", "  next_is_not_par = fmt_check_par(curwin->w_cursor.lnum"], "readability/bool"]
["src/nvim/ops.c", ["      , &next_leader_len, &next_leader_flags, do_comments", "      );", "  is_end_par = (is_not_par || next_is_not_par);"], "whitespace/parens"]
["src/nvim/ops.c", ["    if (count == 1 || curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count) {", "      next_is_not_par = TRUE;", "      next_leader_len = 0;"], "readability/bool"]
["src/nvim/ops.c", ["          , &next_leader_len, &next_leader_flags, do_comments", "          );", "      if (do_number_indent)"], "whitespace/parens"]
["src/nvim/ops.c", ["    }", "    advance = TRUE;", "    is_end_par = (is_not_par || next_is_not_par || next_is_start_par);"], "readability/bool"]
["src/nvim/ops.c", ["          )", "        is_end_par = TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["        smd_save = p_smd;", "        p_smd = FALSE;", "        insertchar(NUL, INSCHAR_FORMAT"], "readability/bool"]
["src/nvim/ops.c", ["            break;", "          first_par_line = TRUE;", "        }"], "readability/bool"]
["src/nvim/ops.c", ["        }", "        force_format = FALSE;", "      }"], "readability/bool"]
["src/nvim/ops.c", ["      if (!is_end_par) {", "        advance = FALSE;", "        curwin->w_cursor.lnum++;"], "readability/bool"]
["src/nvim/ops.c", ["        if (next_leader_len > 0) {", "          (void)del_bytes((long)next_leader_len, FALSE, FALSE);", "          mark_col_adjust(curwin->w_cursor.lnum, (colnr_T)0, 0L,"], "readability/bool"]
["src/nvim/ops.c", ["          if (indent > 0) {", "            (void)del_bytes(indent, FALSE, FALSE);", "            mark_col_adjust(curwin->w_cursor.lnum,"], "readability/bool"]
["src/nvim/ops.c", ["        curwin->w_cursor.lnum--;", "        if (do_join(2, TRUE, FALSE, FALSE, false) == FAIL) {", "          beep_flush();"], "readability/bool"]
["src/nvim/ops.c", ["        }", "        first_par_line = FALSE;", "        /* If the line is getting long, format it next time */"], "readability/bool"]
["src/nvim/ops.c", ["        if (STRLEN(get_cursor_line_ptr()) > (size_t)max_len)", "          force_format = TRUE;", "        else"], "readability/bool"]
["src/nvim/ops.c", ["        else", "          force_format = FALSE;", "      }"], "readability/bool"]
["src/nvim/ops.c", ["  if (*s == NUL)", "    return FALSE;", "  l = STRLEN(s) - 1;"], "readability/bool"]
["src/nvim/ops.c", [" */", "static int fmt_check_par(linenr_T lnum, int *leader_len, char_u **leader_flags, int do_comments)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["  if (do_comments)", "    *leader_len = get_leader_len(ptr, leader_flags, FALSE, TRUE);", "  else"], "readability/bool"]
["src/nvim/ops.c", ["         || (*leader_len > 0 && *flags == COM_END)", "         || startPS(lnum, NUL, FALSE);", "}"], "readability/bool"]
["src/nvim/ops.c", ["  if (lnum <= 1)", "    return TRUE;                /* start of the file */", ""], "readability/bool"]
["src/nvim/ops.c", ["  if (*p == NUL)", "    return TRUE;                /* after empty line */", ""], "readability/bool"]
["src/nvim/ops.c", ["          , &leader_len, &leader_flags, do_comments", "          ))", "    return TRUE;                /* after non-paragraph line */"], "whitespace/parens"]
["src/nvim/ops.c", ["          ))", "    return TRUE;                /* after non-paragraph line */", ""], "readability/bool"]
["src/nvim/ops.c", ["          , &next_leader_len, &next_leader_flags, do_comments", "          ))", "    return TRUE;                /* \"lnum\" is not a paragraph line */"], "whitespace/parens"]
["src/nvim/ops.c", ["          ))", "    return TRUE;                /* \"lnum\" is not a paragraph line */", ""], "readability/bool"]
["src/nvim/ops.c", ["  if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1))", "    return TRUE;                /* missing trailing space in previous line. */", ""], "readability/bool"]
["src/nvim/ops.c", ["  if (has_format_option(FO_Q_NUMBER) && (get_number_indent(lnum) > 0))", "    return TRUE;                /* numbered item starts in \"lnum\". */", ""], "readability/bool"]
["src/nvim/ops.c", ["          next_leader_len, next_leader_flags))", "    return TRUE;                /* change of comment leader. */", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ops.c", [" */", "static void block_prep(oparg_T *oap, struct block_def *bdp, linenr_T lnum, int is_del)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["  bdp->end_vcol = 0;", "  bdp->is_short = FALSE;", "  bdp->is_oneChar = FALSE;"], "readability/bool"]
["src/nvim/ops.c", ["  bdp->is_short = FALSE;", "  bdp->is_oneChar = FALSE;", "  bdp->pre_whitesp = 0;"], "readability/bool"]
["src/nvim/ops.c", ["    bdp->end_vcol = bdp->start_vcol;", "    bdp->is_short = TRUE;", "    if (!is_del || oap->op_type == OP_APPEND)"], "readability/bool"]
["src/nvim/ops.c", ["    if (bdp->end_vcol > oap->end_vcol) {        /* it's all in one character */", "      bdp->is_oneChar = TRUE;", "      if (oap->op_type == OP_INSERT)"], "readability/bool"]
["src/nvim/ops.c", ["              || oap->op_type == OP_REPLACE)) {         /* line too short */", "        bdp->is_short = TRUE;", "        /* Alternative: include spaces to fill up the block."], "readability/bool"]
["src/nvim/ops.c", ["  for (j = 0; j < i; j++, i--) {", "    c = s[i]; s[i] = s[j]; s[j] = c;", "  }"], "whitespace/newline"]
["src/nvim/ops.c", ["  int hex;                      /* 'X' or 'x': hex; '0': octal */", "  static int hexupper = FALSE;          /* 0xABC */", "  unsigned long n, oldn;"], "readability/bool"]
["src/nvim/ops.c", ["          firstdigit = 'a';", "      } else", "        firstdigit -= Prenum1;"], "readability/braces"]
["src/nvim/ops.c", ["          firstdigit = 'z';", "      } else", "        firstdigit += Prenum1;"], "readability/braces"]
["src/nvim/ops.c", ["    curwin->w_cursor.col = col;", "    (void)del_char(FALSE);", "    ins_char(firstdigit);"], "readability/bool"]
["src/nvim/ops.c", ["  } else {", "    negative = FALSE;", "    if (col > 0 && ptr[col - 1] == '-') {           /* negative number */"], "readability/bool"]
["src/nvim/ops.c", ["      --col;", "      negative = TRUE;", "    }"], "readability/bool"]
["src/nvim/ops.c", ["      --length;", "      negative = FALSE;", "    }"], "readability/bool"]
["src/nvim/ops.c", ["    /* add or subtract */", "    subtract = FALSE;", "    if (command == Ctrl_X)"], "readability/bool"]
["src/nvim/ops.c", ["    if (command == Ctrl_X)", "      subtract ^= TRUE;", "    if (negative)"], "readability/bool"]
["src/nvim/ops.c", ["    if (negative)", "      subtract ^= TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["          n = 1 + (n ^ (unsigned long)-1);", "          negative ^= TRUE;", "        }"], "readability/bool"]
["src/nvim/ops.c", ["          n = (n ^ (unsigned long)-1);", "          negative ^= TRUE;", "        }"], "readability/bool"]
["src/nvim/ops.c", ["      if (n == 0)", "        negative = FALSE;", "    }"], "readability/bool"]
["src/nvim/ops.c", ["        if (isupper(c))", "          hexupper = TRUE;", "        else"], "readability/bool"]
["src/nvim/ops.c", ["        else", "          hexupper = FALSE;", "      }"], "readability/bool"]
["src/nvim/ops.c", ["      /* del_char() will mark line needing displaying */", "      (void)del_char(FALSE);", "      c = gchar_cursor();"], "readability/bool"]
["src/nvim/ops.c", ["    if (hex == 0)", "      sprintf((char *)buf2, \"%\" PRIu64, (uint64_t)n);", "    else if (hex == '0')"], "runtime/printf"]
["src/nvim/ops.c", ["    else if (hex == '0')", "      sprintf((char *)buf2, \"%\" PRIo64, (uint64_t)n);", "    else if (hex && hexupper)"], "runtime/printf"]
["src/nvim/ops.c", ["    else if (hex && hexupper)", "      sprintf((char *)buf2, \"%\" PRIX64, (uint64_t)n);", "    else"], "runtime/printf"]
["src/nvim/ops.c", ["    else", "      sprintf((char *)buf2, \"%\" PRIx64, (uint64_t)n);", "    length -= (int)STRLEN(buf2);"], "runtime/printf"]
["src/nvim/ops.c", ["  --curwin->w_cursor.col;", "  curwin->w_set_curswant = TRUE;", "  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);"], "readability/bool"]
["src/nvim/ops.c", ["  curwin->w_set_curswant = TRUE;", "  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);", "  RLADDSUBFIX(ptr);"], "readability/bool"]
["src/nvim/ops.c", ["  int allocated;", "  if (get_spec_reg(regname, &retval, &allocated, FALSE)) {", "    if (retval == NULL)"], "readability/bool"]
["src/nvim/ops.c", ["", "static yankreg_T *init_write_reg(int name, yankreg_T **old_y_previous, bool must_append)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["", "static void finish_write_reg(int name, yankreg_T *reg, yankreg_T *old_y_previous)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["  if (name == '/') {", "    set_last_search_pat(str, RE_SEARCH, TRUE, TRUE);", "    return;"], "readability/bool"]
["src/nvim/ops.c", [" */", "static long line_count_info(char_u *line, long *wc, long *cc, long limit, int eol_size)", "{"], "whitespace/line_length"]
["src/nvim/ops.c", ["      }", "    } else if (!ascii_isspace(line[i]))", "      is_word = 1;"], "readability/braces"]
["src/nvim/ops.c", ["            (int64_t)(oparg.end_vcol - oparg.start_vcol + 1));", "      } else", "        buf1[0] = NUL;"], "readability/braces"]
["src/nvim/ops.c", ["    if (byte_count > 0)", "      sprintf((char *)IObuff + STRLEN(IObuff), _(\"(+%\" PRId64 \" for BOM)\"),", "          (int64_t)byte_count);"], "runtime/printf"]
["src/nvim/ops.c", ["///", "/// @returns the name of of a clipboard register that should be used, or `NUL` if none.", "int get_default_register_name(void)"], "whitespace/line_length"]
["src/nvim/ops.c", ["/// Determine if register `*name` should be used as a clipboard.", "/// In an unnammed operation, `*name` is `NUL` and will be adjusted to `'*'/'+'` if", "/// `clipboard=unnamed[plus]` is set."], "whitespace/line_length"]
["src/nvim/ops.c", ["  if (*name == '*' || *name == '+') {", "    if(!eval_has_provider(\"clipboard\")) {", "      if (!quiet) {"], "whitespace/parens"]
["src/nvim/ops.c", ["  } else if ((*name == NUL) && (cb_flags & CB_UNNAMEDMASK)) {", "    if(!eval_has_provider(\"clipboard\")) {", "      if (!quiet && !clipboard_didwarn_unnamed) {"], "whitespace/parens"]
["src/nvim/ops.c", ["      if (!quiet && !clipboard_didwarn_unnamed) {", "        msg((char_u*)\"clipboard: provider not available, ignoring clipboard=unnamed[plus]\");", "        clipboard_didwarn_unnamed = true;"], "whitespace/line_length"]
["src/nvim/ops.c", ["    }", "    return target; // unnamed register", "  }"], "whitespace/comments"]
["src/nvim/option.c", ["#include <string.h>", "#include <stdint.h>", "#include <stdlib.h>"], "build/include"]
["src/nvim/option.c", ["  uint32_t flags;               /* see below */", "  char_u      *var;             /* global option: pointer to variable;", "                                * window-local option: VAR_WIN;"], "readability/multiline_comment"]
["src/nvim/option.c", ["  uint32_t flags;               /* see below */", "  char_u      *var;             /* global option: pointer to variable;", "                                * window-local option: VAR_WIN;"], "whitespace/newline"]
["src/nvim/option.c", ["                                * buffer-local option: global value */", "  idopt_T indir;                /* global option: PV_NONE;", "                                 * local option: indirect option index */"], "readability/multiline_comment"]
["src/nvim/option.c", ["                                * buffer-local option: global value */", "  idopt_T indir;                /* global option: PV_NONE;", "                                 * local option: indirect option index */"], "whitespace/newline"]
["src/nvim/option.c", ["#define P_STRING        0x04U    /* the option is a string */", "#define P_ALLOCED       0x08U    /* the string option is in allocated memory,", "                                    must use free_string_option() when"], "readability/multiline_comment"]
["src/nvim/option.c", ["                                    the same. */", "#define P_EXPAND        0x10U    /* environment expansion.  NOTE: P_EXPAND can", "                                    never be used for local or hidden options */"], "readability/multiline_comment"]
["src/nvim/option.c", ["#define P_NODEFAULT     0x40U    /* don't set to default value */", "#define P_DEF_ALLOCED   0x80U    /* default value is in allocated memory, must", "                                    use free() when assigning new value */"], "readability/multiline_comment"]
["src/nvim/option.c", ["#define P_DEF_ALLOCED   0x80U    /* default value is in allocated memory, must", "                                    use free() when assigning new value */", "#define P_WAS_SET       0x100U   /* option has been set/reset */"], "runtime/memory_fn"]
["src/nvim/option.c", ["#define P_INSECURE     0x400000U /* option was set from a modeline */", "#define P_PRI_MKRC     0x800000U /* priority for :mkvimrc (setting option has", "                                    side effects) */"], "readability/multiline_comment"]
["src/nvim/option.c", ["#define P_NO_ML       0x1000000U /* not allowed in modeline */", "#define P_CURSWANT    0x2000000U /* update curswant required; not needed when", "                                  * there is a redraw flag */"], "readability/multiline_comment"]
["src/nvim/option.c", ["{\"nofile\", \"nowrite\", \"quickfix\", \"help\", \"acwrite\", \"terminal\", NULL};", "static char *(p_bufhidden_values[]) = {\"hide\", \"unload\", \"delete\", \"wipe\", NULL};", "static char *(p_bs_values[]) = {\"indent\", \"eol\", \"start\", NULL};"], "whitespace/line_length"]
["src/nvim/option.c", ["  /* Be nocompatible */", "  p_cp = FALSE;", ""], "readability/bool"]
["src/nvim/option.c", ["      }", "      else", "# endif"], "whitespace/newline"]
["src/nvim/option.c", ["      }", "      if(mustfree) {", "        xfree(p);"], "whitespace/parens"]
["src/nvim/option.c", ["            buf[j++] = ',';", "          else {", "            if (cdpath[i] == ' ' || cdpath[i] == ',')"], "readability/braces"]
["src/nvim/option.c", ["          options[opt_idx].flags |= P_DEF_ALLOCED;", "        } else", "          xfree(buf);           /* cannot happen */"], "readability/braces"]
["src/nvim/option.c", [" */", "static void ", "set_option_default ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["static void ", "set_option_default (", "    int opt_idx,"], "whitespace/parens"]
["src/nvim/option.c", ["            options[opt_idx].def_val[dvi], opt_flags, 0);", "      else {", "        if ((opt_flags & OPT_FREE) && (flags & P_ALLOCED))"], "readability/braces"]
["src/nvim/option.c", ["        win_comp_scroll(curwin);", "      else {", "        *(long *)varp = (long)options[opt_idx].def_val[dvi];"], "readability/braces"]
["src/nvim/option.c", ["      if (options[opt_idx].indir == PV_ML && getuid() == ROOT_UID)", "        *(int *)varp = FALSE;", "#endif"], "readability/bool"]
["src/nvim/option.c", [" */", "static void ", "set_options_default ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["static void ", "set_options_default (", "    int opt_flags                  /* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */"], "whitespace/parens"]
["src/nvim/option.c", ["        free_string_option(options[i].def_val[VI_DEFAULT]);", "    } else if (options[i].var != VAR_WIN", "               && (options[i].flags & P_STRING))"], "readability/braces"]
["src/nvim/option.c", ["  if (idx_srr < 0)", "    do_srr = FALSE;", "  else"], "readability/bool"]
["src/nvim/option.c", ["  if (idx_sp < 0)", "    do_sp = FALSE;", "  else"], "readability/bool"]
["src/nvim/option.c", [" */", "int ", "do_set ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["int ", "do_set (", "    char_u *arg,               /* option string (may be written to!) */"], "whitespace/parens"]
["src/nvim/option.c", ["  char_u      *varp = NULL;         /* pointer to variable for current option */", "  int did_show = FALSE;             /* already showed one value */", "  int adding;                       /* \"opt+=arg\" */"], "readability/bool"]
["src/nvim/option.c", ["    showoptions(0, opt_flags);", "    did_show = TRUE;", "    goto theend;"], "readability/bool"]
["src/nvim/option.c", ["        showoptions(1, opt_flags);", "        did_show = TRUE;", "      }"], "readability/bool"]
["src/nvim/option.c", ["                   7) == 0 && !(opt_flags & OPT_MODELINE)) {", "      did_show = TRUE;", "      arg += 7;"], "readability/bool"]
["src/nvim/option.c", ["          len = 5;", "        else {", "          len = 1;"], "readability/braces"]
["src/nvim/option.c", ["", "      adding = FALSE;", "      prepending = FALSE;"], "readability/bool"]
["src/nvim/option.c", ["      adding = FALSE;", "      prepending = FALSE;", "      removing = FALSE;"], "readability/bool"]
["src/nvim/option.c", ["      prepending = FALSE;", "      removing = FALSE;", "      if (arg[len] != NUL && arg[len + 1] == '=') {"], "readability/bool"]
["src/nvim/option.c", ["        if (arg[len] == '+') {", "          adding = TRUE;                        /* \"+=\" */", "          ++len;"], "readability/bool"]
["src/nvim/option.c", ["        } else if (arg[len] == '^') {", "          prepending = TRUE;                    /* \"^=\" */", "          ++len;"], "readability/bool"]
["src/nvim/option.c", ["        } else if (arg[len] == '-') {", "          removing = TRUE;                      /* \"-=\" */", "          ++len;"], "readability/bool"]
["src/nvim/option.c", ["          if (arg[3] == 'm') {          /* \"opt&vim\": set to Vim default */", "            cp_val = FALSE;", "            arg += 3;"], "readability/bool"]
["src/nvim/option.c", ["          } else {                    /* \"opt&vi\": set to Vi default */", "            cp_val = TRUE;", "            arg += 2;"], "readability/bool"]
["src/nvim/option.c", ["          msg_putchar('\\n');                /* cursor below last one */", "        else {", "          gotocmdline(TRUE);                /* cursor at status line */"], "readability/braces"]
["src/nvim/option.c", ["        else {", "          gotocmdline(TRUE);                /* cursor at status line */", "          did_show = TRUE;                  /* remember that we did a line */"], "readability/bool"]
["src/nvim/option.c", ["          gotocmdline(TRUE);                /* cursor at status line */", "          did_show = TRUE;                  /* remember that we did a line */", "        }"], "readability/bool"]
["src/nvim/option.c", ["            int bs;", "            int new_value_alloced;                      /* new string option", "                                                           was allocated */"], "readability/multiline_comment"]
["src/nvim/option.c", ["                newval = empty_option;", "              else {", "                s = option_expand(opt_idx, newval);"], "readability/braces"]
["src/nvim/option.c", ["              }", "              new_value_alloced = TRUE;", "            } else if (nextchar == '<') {             /* set to global val */"], "readability/bool"]
["src/nvim/option.c", ["                      &(options[opt_idx]), OPT_GLOBAL));", "              new_value_alloced = TRUE;", "            } else {"], "readability/bool"]
["src/nvim/option.c", ["               */", "              else if (varp == (char_u *)&p_bs", "                       && ascii_isdigit(**(char_u **)varp)) {"], "whitespace/newline"]
["src/nvim/option.c", ["               */", "              else if (varp == (char_u *)&p_ww", "                       && ascii_isdigit(*arg)) {"], "whitespace/newline"]
["src/nvim/option.c", ["               */", "              else if (  *arg == '>'", "                         && (varp == (char_u *)&p_dir"], "whitespace/newline"]
["src/nvim/option.c", ["                  s += i;", "                } else", "                  *s++ = *arg++;"], "readability/braces"]
["src/nvim/option.c", ["                if ((adding || prepending) && *s) {", "                  prepending = FALSE;", "                  adding = FALSE;"], "readability/bool"]
["src/nvim/option.c", ["                  prepending = FALSE;", "                  adding = FALSE;", "                  STRCPY(newval, origval);"], "readability/bool"]
["src/nvim/option.c", ["                arg = save_arg;", "              new_value_alloced = TRUE;", "            }"], "readability/bool"]
["src/nvim/option.c", ["    /* After displaying option values in silent mode. */", "    silent_mode = FALSE;", "    info_message = TRUE;        /* use mch_msg(), not mch_errmsg() */"], "readability/bool"]
["src/nvim/option.c", ["    silent_mode = FALSE;", "    info_message = TRUE;        /* use mch_msg(), not mch_errmsg() */", "    msg_putchar('\\n');"], "readability/bool"]
["src/nvim/option.c", ["    ui_flush();", "    silent_mode = TRUE;", "    info_message = FALSE;       /* use mch_msg(), not mch_errmsg() */"], "readability/bool"]
["src/nvim/option.c", ["    silent_mode = TRUE;", "    info_message = FALSE;       /* use mch_msg(), not mch_errmsg() */", "  }"], "readability/bool"]
["src/nvim/option.c", ["  return OK;", "}", ""], "readability/fn_size"]
["src/nvim/option.c", [" */", "static void ", "did_set_option ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["static void ", "did_set_option (", "    int opt_idx,"], "whitespace/parens"]
["src/nvim/option.c", ["    return (char_u *)\"\";", "  sprintf((char *)errbuf, _(\"E539: Illegal character <%s>\"),", "      (char *)transchar(c));"], "runtime/printf"]
["src/nvim/option.c", ["    cedit_key = -1;", "  else {", "    n = string_to_key(p_cedit);"], "readability/braces"]
["src/nvim/option.c", [" */", "static void ", "did_set_title ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["static void ", "did_set_title (", "    int icon                   /* Did set icon instead of title */"], "whitespace/parens"]
["src/nvim/option.c", [" */", "void ", "set_options_bin ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["void ", "set_options_bin (", "    int oldval,"], "whitespace/parens"]
["src/nvim/option.c", ["      p_wm = 0;", "      p_ml = FALSE;", "      p_et = FALSE;"], "readability/bool"]
["src/nvim/option.c", ["      p_ml = FALSE;", "      p_et = FALSE;", "      p_bin = TRUE;             /* needed when called for the \"-b\" argument */"], "readability/bool"]
["src/nvim/option.c", ["      p_et = FALSE;", "      p_bin = TRUE;             /* needed when called for the \"-b\" argument */", "    }"], "readability/bool"]
["src/nvim/option.c", ["  expand_env_esc(val, NameBuff, MAXPATHL,", "      (char_u **)options[opt_idx].var == &p_tags, FALSE,", "      (char_u **)options[opt_idx].var == &p_sps ? (char_u *)\"file:\" :"], "readability/bool"]
["src/nvim/option.c", ["static void redraw_titles(void) {", "  need_maketitle = TRUE;", "  redraw_tabline = TRUE;"], "readability/bool"]
["src/nvim/option.c", ["  need_maketitle = TRUE;", "  redraw_tabline = TRUE;", "}"], "readability/bool"]
["src/nvim/option.c", [" */", "void ", "set_string_option_direct ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["void ", "set_string_option_direct (", "    char_u *name,"], "whitespace/parens"]
["src/nvim/option.c", [" */", "static void ", "set_string_option_global ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["static void ", "set_string_option_global (", "    int opt_idx,                    /* option index */"], "whitespace/parens"]
["src/nvim/option.c", ["static char_u *", "set_string_option (", "    int opt_idx,"], "whitespace/parens"]
["src/nvim/option.c", ["  *varp = s;", "  if ((r = did_set_string_option(opt_idx, varp, TRUE, oldval, NULL,", "          opt_flags)) == NULL)"], "readability/bool"]
["src/nvim/option.c", ["          opt_flags)) == NULL)", "    did_set_option(opt_idx, opt_flags, TRUE);", ""], "readability/bool"]
["src/nvim/option.c", ["static char_u *", "did_set_string_option (", "    int opt_idx,                            /* index in options[] table */"], "whitespace/parens"]
["src/nvim/option.c", ["  char_u      *s, *p;", "  int did_chartab = FALSE;", "  char_u      **gvarp;"], "readability/bool"]
["src/nvim/option.c", ["   * often illegal in a file name. */", "  else if ((options[opt_idx].flags & P_NFNAME)", "           && vim_strpbrk(*varp, (char_u *)\"/\\\\*?[|<>\") != NULL) {"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'backupcopy' */", "  else if (gvarp == &p_bkc) {", "    char_u       *bkc   = p_bkc;"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'backupext' and 'patchmode' */", "  else if (varp == &p_bex || varp == &p_pm) {", "    if (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'breakindentopt' */", "  else if (varp == &curwin->w_p_briopt) {", "    if (briopt_check(curwin) == FAIL)"], "whitespace/newline"]
["src/nvim/option.c", ["   */", "  else if (  varp == &p_isi", "             || varp == &(curbuf->b_p_isk)"], "whitespace/newline"]
["src/nvim/option.c", ["    if (init_chartab() == FAIL) {", "      did_chartab = TRUE;           /* need to restore it below */", "      errmsg = e_invarg;            /* error in value */"], "readability/bool"]
["src/nvim/option.c", ["  /* 'helpfile' */", "  else if (varp == &p_hf) {", "    /* May compute new values for $VIM and $VIMRUNTIME */"], "whitespace/newline"]
["src/nvim/option.c", ["      vim_setenv(\"VIM\", \"\");", "      didset_vim = FALSE;", "    }"], "readability/bool"]
["src/nvim/option.c", ["      vim_setenv(\"VIMRUNTIME\", \"\");", "      didset_vimruntime = FALSE;", "    }"], "readability/bool"]
["src/nvim/option.c", ["  /* 'colorcolumn' */", "  else if (varp == &curwin->w_p_cc)", "    errmsg = check_colorcolumn(curwin);"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'highlight' */", "  else if (varp == &p_hl) {", "    if (highlight_changed() == FAIL)"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'nrformats' */", "  else if (gvarp == &p_nf) {", "    if (check_opt_strings(*varp, p_nf_values, TRUE) != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (gvarp == &p_nf) {", "    if (check_opt_strings(*varp, p_nf_values, TRUE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'scrollopt' */", "  else if (varp == &p_sbo) {", "    if (check_opt_strings(p_sbo, p_scbopt_values, TRUE) != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == &p_sbo) {", "    if (check_opt_strings(p_sbo, p_scbopt_values, TRUE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'ambiwidth' */", "  else if (varp == &p_ambw) {", "    if (check_opt_strings(p_ambw, p_ambw_values, FALSE) != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == &p_ambw) {", "    if (check_opt_strings(p_ambw, p_ambw_values, FALSE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'background' */", "  else if (varp == &p_bg) {", "    if (check_opt_strings(p_bg, p_bg_values, FALSE) == OK) {"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == &p_bg) {", "    if (check_opt_strings(p_bg, p_bg_values, FALSE) == OK) {", "      int dark = (*p_bg == 'd');"], "readability/bool"]
["src/nvim/option.c", ["", "      init_highlight(FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/option.c", ["         * scheme and set the colors again. */", "        do_unlet((char_u *)\"g:colors_name\", TRUE);", "        free_string_option(p_bg);"], "readability/bool"]
["src/nvim/option.c", ["        check_string_option(&p_bg);", "        init_highlight(FALSE, FALSE);", "      }"], "readability/bool"]
["src/nvim/option.c", ["      }", "    } else", "      errmsg = e_invarg;"], "readability/braces"]
["src/nvim/option.c", ["  /* 'wildmode' */", "  else if (varp == &p_wim) {", "    if (check_opt_wim() == FAIL)"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'wildoptions' */", "  else if (varp == &p_wop) {", "    if (check_opt_strings(p_wop, p_wop_values, TRUE) != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == &p_wop) {", "    if (check_opt_strings(p_wop, p_wop_values, TRUE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'winaltkeys' */", "  else if (varp == &p_wak) {", "    if (*p_wak == NUL"], "whitespace/newline"]
["src/nvim/option.c", ["    if (*p_wak == NUL", "        || check_opt_strings(p_wak, p_wak_values, FALSE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'eventignore' */", "  else if (varp == &p_ei) {", "    if (check_ei() == FAIL)"], "whitespace/newline"]
["src/nvim/option.c", ["        errmsg = e_invarg;", "      else {", "        /* May show a \"+\" in the title now. */"], "readability/braces"]
["src/nvim/option.c", ["  /* 'fileformat' */", "  else if (gvarp == &p_ff) {", "    if (!MODIFIABLE(curbuf) && !(opt_flags & OPT_GLOBAL))"], "whitespace/newline"]
["src/nvim/option.c", ["      errmsg = e_modifiable;", "    else if (check_opt_strings(*varp, p_ff_values, FALSE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["      errmsg = e_invarg;", "    else {", "      redraw_titles();"], "readability/braces"]
["src/nvim/option.c", ["  /* 'fileformats' */", "  else if (varp == &p_ffs) {", "    if (check_opt_strings(p_ffs, p_ff_values, TRUE) != OK) {"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == &p_ffs) {", "    if (check_opt_strings(p_ffs, p_ff_values, TRUE) != OK) {", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'matchpairs' */", "  else if (gvarp == &p_mps) {", "    if (has_mbyte) {"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'comments' */", "  else if (gvarp == &p_com) {", "    for (s = *varp; *s; ) {"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'listchars' */", "  else if (varp == &p_lcs) {", "    errmsg = set_chars_option(varp);"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'fillchars' */", "  else if (varp == &p_fcs) {", "    errmsg = set_chars_option(varp);"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'cedit' */", "  else if (varp == &p_cedit) {", "    errmsg = check_cedit();"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'verbosefile' */", "  else if (varp == &p_vfile) {", "    verbose_stop();"], "whitespace/newline"]
["src/nvim/option.c", ["        while (*++s && *s != ',')", "          ;", "      } else if (*s == '%') {"], "whitespace/semicolon"]
["src/nvim/option.c", ["        while (ascii_isdigit(*++s))", "          ;", "      } else if (*s == '!' || *s == 'h' || *s == 'c')"], "whitespace/semicolon"]
["src/nvim/option.c", ["          ;", "      } else if (*s == '!' || *s == 'h' || *s == 'c')", "        ++s;                    /* no extra chars */"], "readability/braces"]
["src/nvim/option.c", ["        ++s;                    /* no extra chars */", "      else {                    /* must have a number */", "        while (ascii_isdigit(*++s))"], "readability/braces"]
["src/nvim/option.c", ["        while (ascii_isdigit(*++s))", "          ;", ""], "whitespace/semicolon"]
["src/nvim/option.c", ["          if (errbuf != NULL) {", "            sprintf((char *)errbuf,", "                _(\"E526: Missing number after <%s>\"),"], "runtime/printf"]
["src/nvim/option.c", ["            errmsg = errbuf;", "          } else", "            errmsg = (char_u *)\"\";"], "readability/braces"]
["src/nvim/option.c", ["  /* 'showbreak' */", "  else if (varp == &p_sbr) {", "    for (s = p_sbr; *s; ) {"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'guicursor' */", "  else if (varp == &p_guicursor)", "    errmsg = parse_shape_opt(SHAPE_CURSOR);"], "whitespace/newline"]
["src/nvim/option.c", ["    did_set_title(varp == &p_iconstring);", "", "  }"], "whitespace/blank_line"]
["src/nvim/option.c", ["  /* 'selection' */", "  else if (varp == &p_sel) {", "    if (*p_sel == NUL"], "whitespace/newline"]
["src/nvim/option.c", ["    if (*p_sel == NUL", "        || check_opt_strings(p_sel, p_sel_values, FALSE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'selectmode' */", "  else if (varp == &p_slm) {", "    if (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == &p_slm) {", "    if (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'keymodel' */", "  else if (varp == &p_km) {", "    if (check_opt_strings(p_km, p_km_values, TRUE) != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == &p_km) {", "    if (check_opt_strings(p_km, p_km_values, TRUE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["      errmsg = e_invarg;", "    else {", "      km_stopsel = (vim_strchr(p_km, 'o') != NULL);"], "readability/braces"]
["src/nvim/option.c", ["  /* 'mousemodel' */", "  else if (varp == &p_mousem) {", "    if (check_opt_strings(p_mousem, p_mousem_values, FALSE) != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == &p_mousem) {", "    if (check_opt_strings(p_mousem, p_mousem_values, FALSE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'debug' */", "  else if (varp == &p_debug) {", "    if (check_opt_strings(p_debug, p_debug_values, TRUE) != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == &p_debug) {", "    if (check_opt_strings(p_debug, p_debug_values, TRUE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["      (void)init_chartab();", "", "  }"], "whitespace/blank_line"]
["src/nvim/option.c", ["  /* 'eadirection' */", "  else if (varp == &p_ead) {", "    if (check_opt_strings(p_ead, p_ead_values, FALSE) != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == &p_ead) {", "    if (check_opt_strings(p_ead, p_ead_values, FALSE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* When 'spellcapcheck' is set compile the regexp program. */", "  else if (varp == &(curwin->w_s->b_p_spc)) {", "    errmsg = compile_cap_prog(curwin->w_s);"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'spellsuggest' */", "  else if (varp == &p_sps) {", "    if (spell_check_sps() != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'mkspellmem' */", "  else if (varp == &p_msm) {", "    if (spell_check_msm() != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  /* When 'bufhidden' is set, check for valid value. */", "  else if (gvarp == &p_bh) {", "    if (check_opt_strings(curbuf->b_p_bh, p_bufhidden_values, FALSE) != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (gvarp == &p_bh) {", "    if (check_opt_strings(curbuf->b_p_bh, p_bufhidden_values, FALSE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* When 'buftype' is set, check for valid value. */", "  else if (gvarp == &p_bt) {", "    if ((curbuf->terminal && curbuf->b_p_bt[0] != 't')"], "whitespace/newline"]
["src/nvim/option.c", ["        || (!curbuf->terminal && curbuf->b_p_bt[0] == 't')", "        || check_opt_strings(curbuf->b_p_bt, p_buftype_values, FALSE) != OK) {", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["      if (curwin->w_status_height) {", "        curwin->w_redr_status = TRUE;", "        redraw_later(VALID);"], "readability/bool"]
["src/nvim/option.c", ["  /* 'statusline' or 'rulerformat' */", "  else if (gvarp == &p_stl || varp == &p_ruf) {", "    int wid;"], "whitespace/newline"]
["src/nvim/option.c", ["    /* check 'statusline' only if it doesn't start with \"%!\" */", "    else if (varp == &p_ruf || s[0] != '%' || s[1] != '!')", "      errmsg = check_stl_option(s);"], "whitespace/newline"]
["src/nvim/option.c", ["  /* check if it is a valid value for 'complete' -- Acevedo */", "  else if (gvarp == &p_cpt) {", "    for (s = *varp; *s; ) {"], "whitespace/newline"]
["src/nvim/option.c", ["          if (errbuf != NULL) {", "            sprintf((char *)errbuf,", "                _(\"E535: Illegal character after <%c>\"),"], "runtime/printf"]
["src/nvim/option.c", ["            errmsg = errbuf;", "          } else", "            errmsg = (char_u *)\"\";"], "readability/braces"]
["src/nvim/option.c", ["  /* 'completeopt' */", "  else if (varp == &p_cot) {", "    if (check_opt_strings(p_cot, p_cot_values, TRUE) != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == &p_cot) {", "    if (check_opt_strings(p_cot, p_cot_values, TRUE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'pastetoggle': translate key codes like in a mapping */", "  else if (varp == &p_pt) {", "    if (*p_pt) {"], "whitespace/newline"]
["src/nvim/option.c", ["    if (*p_pt) {", "      (void)replace_termcodes(p_pt, &p, TRUE, TRUE, FALSE);", "      if (p != NULL) {"], "readability/bool"]
["src/nvim/option.c", ["        p_pt = p;", "        new_value_alloced = TRUE;", "      }"], "readability/bool"]
["src/nvim/option.c", ["  /* 'backspace' */", "  else if (varp == &p_bs) {", "    if (ascii_isdigit(*p_bs)) {"], "whitespace/newline"]
["src/nvim/option.c", ["        errmsg = e_invarg;", "    } else if (check_opt_strings(p_bs, p_bs_values, TRUE) != OK)", "      errmsg = e_invarg;"], "readability/braces"]
["src/nvim/option.c", ["        errmsg = e_invarg;", "    } else if (check_opt_strings(p_bs, p_bs_values, TRUE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'diffopt' */", "  else if (varp == &p_dip) {", "    if (diffopt_changed() == FAIL)"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'foldmethod' */", "  else if (gvarp == &curwin->w_allbuf_opt.wo_fdm) {", "    if (check_opt_strings(*varp, p_fdm_values, FALSE) != OK"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (gvarp == &curwin->w_allbuf_opt.wo_fdm) {", "    if (check_opt_strings(*varp, p_fdm_values, FALSE) != OK", "        || *curwin->w_p_fdm == NUL)"], "readability/bool"]
["src/nvim/option.c", ["      errmsg = e_invarg;", "    else {", "      foldUpdateAll(curwin);"], "readability/braces"]
["src/nvim/option.c", ["  /* 'foldexpr' */", "  else if (varp == &curwin->w_p_fde) {", "    if (foldmethodIsExpr(curwin))"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'foldmarker' */", "  else if (gvarp == &curwin->w_allbuf_opt.wo_fmr) {", "    p = vim_strchr(*varp, ',');"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'commentstring' */", "  else if (gvarp == &p_cms) {", "    if (**varp != NUL && strstr((char *)*varp, \"%s\") == NULL)"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'foldclose' */", "  else if (varp == &p_fcl) {", "    if (check_opt_strings(p_fcl, p_fcl_values, TRUE) != OK)"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == &p_fcl) {", "    if (check_opt_strings(p_fcl, p_fcl_values, TRUE) != OK)", "      errmsg = e_invarg;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'foldignore' */", "  else if (gvarp == &curwin->w_allbuf_opt.wo_fdi) {", "    if (foldmethodIsIndent(curwin))"], "whitespace/newline"]
["src/nvim/option.c", ["          break;", "        } else if (p[2] == NUL)", "          break;"], "readability/braces"]
["src/nvim/option.c", ["  /* 'cinoptions' */", "  else if (gvarp == &p_cino) {", "    /* TODO: recognize errors */"], "whitespace/newline"]
["src/nvim/option.c", ["  /* Options that are a list of flags. */", "  else {", "    p = NULL;"], "whitespace/newline"]
["src/nvim/option.c", ["  /* Options that are a list of flags. */", "  else {", "    p = NULL;"], "readability/braces"]
["src/nvim/option.c", ["    /* May set global value for local option. */", "    else if (!(opt_flags & OPT_LOCAL) && opt_flags != OPT_GLOBAL)", "      set_string_option_global(opt_idx, varp);"], "whitespace/newline"]
["src/nvim/option.c", ["      apply_autocmds(EVENT_SYNTAX, curbuf->b_p_syn,", "          curbuf->b_fname, TRUE, curbuf);", "    } else if (varp == &(curbuf->b_p_ft)) {"], "readability/bool"]
["src/nvim/option.c", ["      /* 'filetype' is set, trigger the FileType autocommand */", "      did_filetype = TRUE;", "      apply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft,"], "readability/bool"]
["src/nvim/option.c", ["      apply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft,", "          curbuf->b_fname, TRUE, curbuf);", "    }"], "readability/bool"]
["src/nvim/option.c", ["          break;", "      vim_snprintf((char *)fname, 200, \"spell/%.*s.vim\", (int)(p - q), q);", "      source_runtime(fname, TRUE);"], "runtime/printf"]
["src/nvim/option.c", ["      vim_snprintf((char *)fname, 200, \"spell/%.*s.vim\", (int)(p - q), q);", "      source_runtime(fname, TRUE);", "    }"], "readability/bool"]
["src/nvim/option.c", ["      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)", "    curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/option.c", ["  return errmsg;", "}", ""], "readability/fn_size"]
["src/nvim/option.c", ["        goto skip;", "    } else if (ascii_isdigit(*s))", "      col = getdigits_int(&s);"], "readability/braces"]
["src/nvim/option.c", ["    wp->w_p_cc_cols = NULL;", "  else {", "    wp->w_p_cc_cols = xmalloc(sizeof(int) * (count + 1));"], "readability/braces"]
["src/nvim/option.c", ["                lcs_tab2 = c2;", "              } else if (tab[i].cp != NULL)", "                *(tab[i].cp) = c1;"], "readability/braces"]
["src/nvim/option.c", ["                *(tab[i].cp) = c1;", "", "            }"], "whitespace/blank_line"]
["src/nvim/option.c", ["    synblock->b_cap_prog = NULL;", "  else {", "    /* Prepend a ^ so that we only match at one column */"], "readability/braces"]
["src/nvim/option.c", ["static char_u *", "set_bool_option (", "    int opt_idx,                            /* index in options[] table */"], "whitespace/parens"]
["src/nvim/option.c", ["  // Ensure that options set to p_force_on cannot be disabled.", "  if ((int *)varp == &p_force_on && p_force_on == FALSE) {", "    p_force_on = TRUE;"], "readability/bool"]
["src/nvim/option.c", ["  if ((int *)varp == &p_force_on && p_force_on == FALSE) {", "    p_force_on = TRUE;", "    return e_unsupportedoption;"], "readability/bool"]
["src/nvim/option.c", ["  // Ensure that options set to p_force_off cannot be enabled.", "  else if ((int *)varp == &p_force_off && p_force_off == TRUE) {", "    p_force_off = FALSE;"], "whitespace/newline"]
["src/nvim/option.c", ["  // Ensure that options set to p_force_off cannot be enabled.", "  else if ((int *)varp == &p_force_off && p_force_off == TRUE) {", "    p_force_off = FALSE;"], "readability/bool"]
["src/nvim/option.c", ["  else if ((int *)varp == &p_force_off && p_force_off == TRUE) {", "    p_force_off = FALSE;", "    return e_unsupportedoption;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'undofile' */", "  else if ((int *)varp == &curbuf->b_p_udf || (int *)varp == &p_udf) {", "    /* Only take action when the option was set. When reset we do not"], "whitespace/newline"]
["src/nvim/option.c", ["    if (!curbuf->b_p_ro && (opt_flags & OPT_LOCAL) == 0)", "      readonlymode = FALSE;", ""], "readability/bool"]
["src/nvim/option.c", ["  /* when 'modifiable' is changed, redraw the window title */", "  else if ((int *)varp == &curbuf->b_p_ma) {", "    redraw_titles();"], "whitespace/newline"]
["src/nvim/option.c", ["  /* when 'endofline' is changed, redraw the window title */", "  else if ((int *)varp == &curbuf->b_p_eol) {", "    redraw_titles();"], "whitespace/newline"]
["src/nvim/option.c", ["  /* when 'bomb' is changed, redraw the window title and tab page text */", "  else if ((int *)varp == &curbuf->b_p_bomb) {", "    redraw_titles();"], "whitespace/newline"]
["src/nvim/option.c", ["  /* when 'bin' is set also set some other options */", "  else if ((int *)varp == &curbuf->b_p_bin) {", "    set_options_bin(old_value, curbuf->b_p_bin, opt_flags);"], "whitespace/newline"]
["src/nvim/option.c", ["  /* when 'buflisted' changes, trigger autocommands */", "  else if ((int *)varp == &curbuf->b_p_bl && old_value != curbuf->b_p_bl) {", "    apply_autocmds(curbuf->b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,"], "whitespace/newline"]
["src/nvim/option.c", ["    apply_autocmds(curbuf->b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,", "        NULL, NULL, TRUE, curbuf);", "  }"], "readability/bool"]
["src/nvim/option.c", ["  /* when 'swf' is set, create swapfile, when reset remove swapfile */", "  else if ((int *)varp == (int *)&curbuf->b_p_swf) {", "    if (curbuf->b_p_swf && p_uc)"], "whitespace/newline"]
["src/nvim/option.c", ["  /* when 'terse' is set change 'shortmess' */", "  else if ((int *)varp == &p_terse) {", "    char_u  *p;"], "whitespace/newline"]
["src/nvim/option.c", ["    /* remove 's' from p_shm */", "    else if (!p_terse && p != NULL)", "      STRMOVE(p, p + 1);"], "whitespace/newline"]
["src/nvim/option.c", ["  /* when 'paste' is set or reset also change other options */", "  else if ((int *)varp == &p_paste) {", "    paste_option_changed();"], "whitespace/newline"]
["src/nvim/option.c", ["  /* when 'insertmode' is set from an autocommand need to do work here */", "  else if ((int *)varp == &p_im) {", "    if (p_im) {"], "whitespace/newline"]
["src/nvim/option.c", ["      if ((State & INSERT) == 0)", "        need_start_insertmode = TRUE;", "      stop_insert_mode = FALSE;"], "readability/bool"]
["src/nvim/option.c", ["        need_start_insertmode = TRUE;", "      stop_insert_mode = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/option.c", ["    } else {", "      need_start_insertmode = FALSE;", "      stop_insert_mode = TRUE;"], "readability/bool"]
["src/nvim/option.c", ["      need_start_insertmode = FALSE;", "      stop_insert_mode = TRUE;", "      if (restart_edit != 0 && mode_displayed)"], "readability/bool"]
["src/nvim/option.c", ["      if (restart_edit != 0 && mode_displayed)", "        clear_cmdline = TRUE;           /* remove \"(insert)\" */", "      restart_edit = 0;"], "readability/bool"]
["src/nvim/option.c", ["  /* when 'ignorecase' is set or reset and 'hlsearch' is set, redraw */", "  else if ((int *)varp == &p_ic && p_hls) {", "    redraw_all_later(SOME_VALID);"], "whitespace/newline"]
["src/nvim/option.c", ["  /* when 'hlsearch' is set or reset: reset no_hlsearch */", "  else if ((int *)varp == &p_hls) {", "    SET_NO_HLSEARCH(FALSE);"], "whitespace/newline"]
["src/nvim/option.c", ["  else if ((int *)varp == &p_hls) {", "    SET_NO_HLSEARCH(FALSE);", "  }"], "readability/bool"]
["src/nvim/option.c", ["   * at the end of normal_cmd() */", "  else if ((int *)varp == &curwin->w_p_scb) {", "    if (curwin->w_p_scb) {"], "whitespace/newline"]
["src/nvim/option.c", ["    if (curwin->w_p_scb) {", "      do_check_scrollbind(FALSE);", "      curwin->w_scbind_pos = curwin->w_topline;"], "readability/bool"]
["src/nvim/option.c", ["  /* There can be only one window with 'previewwindow' set. */", "  else if ((int *)varp == &curwin->w_p_pvw) {", "    if (curwin->w_p_pvw) {"], "whitespace/newline"]
["src/nvim/option.c", ["        if (win->w_p_pvw && win != curwin) {", "          curwin->w_p_pvw = FALSE;", "          return (char_u *)N_(\"E590: A preview window already exists\");"], "readability/bool"]
["src/nvim/option.c", ["   */", "  else if (varp == (char_u *)&(curbuf->b_p_lisp)) {", "    (void)buf_init_chartab(curbuf, FALSE);          /* ignore errors */"], "whitespace/newline"]
["src/nvim/option.c", ["  else if (varp == (char_u *)&(curbuf->b_p_lisp)) {", "    (void)buf_init_chartab(curbuf, FALSE);          /* ignore errors */", "  }"], "readability/bool"]
["src/nvim/option.c", ["  /* when 'title' changed, may need to change the title; same for 'icon' */", "  else if ((int *)varp == &p_title) {", "    did_set_title(FALSE);"], "whitespace/newline"]
["src/nvim/option.c", ["  else if ((int *)varp == &p_title) {", "    did_set_title(FALSE);", "  } else if ((int *)varp == &p_icon) {"], "readability/bool"]
["src/nvim/option.c", ["  } else if ((int *)varp == &p_icon) {", "    did_set_title(TRUE);", "  } else if ((bool *)varp == &curbuf->b_changed) {"], "readability/bool"]
["src/nvim/option.c", ["  /* 'diff' */", "  else if ((int *)varp == &curwin->w_p_diff) {", "    /* May add or remove the buffer from the list of diff buffers. */"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'spell' */", "  else if ((int *)varp == &curwin->w_p_spell) {", "    if (curwin->w_p_spell) {"], "whitespace/newline"]
["src/nvim/option.c", ["    p_altkeymap = p_fkmap;", "    curwin->w_p_arab = FALSE;", "    (void)init_chartab();"], "readability/bool"]
["src/nvim/option.c", ["    p_fkmap = 0;", "    curwin->w_p_arab = FALSE;", "    (void)init_chartab();"], "readability/bool"]
["src/nvim/option.c", ["    p_hkmap = 0;", "    curwin->w_p_arab = FALSE;", "    (void)init_chartab();"], "readability/bool"]
["src/nvim/option.c", ["        if (!curwin->w_p_rl) {", "          curwin->w_p_rl = TRUE;", "          changed_window_setting();"], "readability/bool"]
["src/nvim/option.c", ["        if (!p_arshape) {", "          p_arshape = TRUE;", "          redraw_later_clear();"], "readability/bool"]
["src/nvim/option.c", ["      /* set 'delcombine' */", "      p_deco = TRUE;", ""], "readability/bool"]
["src/nvim/option.c", ["        if (curwin->w_p_rl) {", "          curwin->w_p_rl = FALSE;", "          changed_window_setting();"], "readability/bool"]
["src/nvim/option.c", ["      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)", "    curwin->w_set_curswant = TRUE;", "  check_redraw(options[opt_idx].flags);"], "readability/bool"]
["src/nvim/option.c", ["static char_u *", "set_num_option (", "    int opt_idx,                            /* index in options[] table */"], "whitespace/parens"]
["src/nvim/option.c", ["    size_t errbuflen,                       /* length of \"errbuf\" */", "    int opt_flags                          /* OPT_LOCAL, OPT_GLOBAL and", "                                           OPT_MODELINE */"], "readability/multiline_comment"]
["src/nvim/option.c", ["  /* 'winminheight' */", "  else if (pp == &p_wmh) {", "    if (p_wmh < 0) {"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'winminwidth' */", "  else if (pp == &p_wmw) {", "    if (p_wmw < 0) {"], "whitespace/newline"]
["src/nvim/option.c", ["  /* (re)set tab page line */", "  else if (pp == &p_stal) {", "    shell_new_rows();           /* recompute window positions and heights */"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'foldlevel' */", "  else if (pp == &curwin->w_p_fdl) {", "    if (curwin->w_p_fdl < 0)"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'foldminlines' */", "  else if (pp == &curwin->w_p_fml) {", "    foldUpdateAll(curwin);"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'foldnestmax' */", "  else if (pp == &curwin->w_p_fdn) {", "    if (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin))"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'foldcolumn' */", "  else if (pp == &curwin->w_p_fdc) {", "    if (curwin->w_p_fdc < 0) {"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'shiftwidth' or 'tabstop' */", "  else if (pp == &curbuf->b_p_sw || pp == &curbuf->b_p_ts) {", "    if (foldmethodIsIndent(curwin))"], "whitespace/newline"]
["src/nvim/option.c", ["  /* 'maxcombine' */", "  else if (pp == &p_mco) {", "    if (p_mco > MAX_MCO)"], "whitespace/newline"]
["src/nvim/option.c", ["  /* if 'titlelen' has changed, redraw the title */", "  else if (pp == &p_titlelen) {", "    if (p_titlelen < 0) {"], "whitespace/newline"]
["src/nvim/option.c", ["    if (starting != NO_SCREEN && old_value != p_titlelen)", "      need_maketitle = TRUE;", "  }"], "readability/bool"]
["src/nvim/option.c", ["  /* if p_ch changed value, change the command line height */", "  else if (pp == &p_ch) {", "    if (p_ch < 1) {"], "whitespace/newline"]
["src/nvim/option.c", ["  /* when 'updatecount' changes from zero to non-zero, open swap files */", "  else if (pp == &p_uc) {", "    if (p_uc < 0) {"], "whitespace/newline"]
["src/nvim/option.c", ["  /* sync undo before 'undolevels' changes */", "  else if (pp == &p_ul) {", "    /* use the old value, otherwise u_sync() may not work properly */"], "whitespace/newline"]
["src/nvim/option.c", ["    p_ul = old_value;", "    u_sync(TRUE);", "    p_ul = value;"], "readability/bool"]
["src/nvim/option.c", ["    curbuf->b_p_ul = old_value;", "    u_sync(TRUE);", "    curbuf->b_p_ul = value;"], "readability/bool"]
["src/nvim/option.c", ["  /* 'numberwidth' must be positive */", "  else if (pp == &curwin->w_p_nuw) {", "    if (curwin->w_p_nuw < 1) {"], "whitespace/newline"]
["src/nvim/option.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/option.c", ["     * it. */", "    else if (curwin->w_p_scr <= 0)", "      curwin->w_p_scr = 1;"], "whitespace/newline"]
["src/nvim/option.c", ["      p_sj = Rows / 2;", "    else {", "      errmsg = e_scroll;"], "readability/braces"]
["src/nvim/option.c", ["      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)", "    curwin->w_set_curswant = TRUE;", "  check_redraw(options[opt_idx].flags);"], "readability/bool"]
["src/nvim/option.c", ["  char            *s, *p;", "  static short quick_tab[27] = {0, 0};          /* quick access table */", "  int is_term_opt;"], "runtime/int"]
["src/nvim/option.c", ["    p = options[0].fullname;", "    for (short int i = 1; (s = options[i].fullname) != NULL; i++) {", "      if (s[0] != p[0]) {"], "runtime/int"]
["src/nvim/option.c", ["      // We now have a different color setup, initialize it again.", "      init_highlight(TRUE, FALSE);", "    }"], "readability/bool"]
["src/nvim/option.c", [" */", "int ", "get_option_value ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["int ", "get_option_value (", "    char_u *name,"], "whitespace/parens"]
["src/nvim/option.c", ["    *numval = *(long *)varp;", "  else {", "    /* Special case: 'modified' is b_changed, but we also want to consider"], "readability/braces"]
["src/nvim/option.c", ["// Returned flags:", "//       0 hidden or unknown option, also option that does not have requested ", "//         type (see SREQ_* in option_defs.h)"], "whitespace/end_of_line"]
["src/nvim/option.c", ["    else", "      return 0; // Did not request global-only option", "  } else {"], "whitespace/comments"]
["src/nvim/option.c", ["    } else if (opt_type == SREQ_GLOBAL) {", "      return 0; // Requested global option", "    }"], "whitespace/comments"]
["src/nvim/option.c", ["      if (opt_type == SREQ_BUF) {", "        return 0; // Did not request window-local option", "      } else {"], "whitespace/comments"]
["src/nvim/option.c", ["      if (opt_type == SREQ_WIN) {", "        return 0; // Did not request buffer-local option", "      } else {"], "whitespace/comments"]
["src/nvim/option.c", ["      } else {", "        aco_save_T\taco;", "        aucmd_prepbuf(&aco, (buf_T *) from);"], "whitespace/tab"]
["src/nvim/option.c", ["    } else if (opt_type == SREQ_WIN) {", "      win_T\t*save_curwin;", "      save_curwin = curwin;"], "whitespace/tab"]
["src/nvim/option.c", ["char_u *", "set_option_value (", "    char_u *name,"], "whitespace/parens"]
["src/nvim/option.c", ["    EMSG2(_(\"E355: Unknown option: %s\"), name);", "  else {", "    uint32_t flags = options[opt_idx].flags;"], "readability/braces"]
["src/nvim/option.c", ["      return set_string_option(opt_idx, string, opt_flags);", "    else {", "      varp = get_varp_scope(&(options[opt_idx]), opt_flags);"], "readability/braces"]
["src/nvim/option.c", ["          for (idx = 0; string[idx] == '0'; ++idx)", "            ;", "          if (string[idx] != NUL || idx == 0) {"], "whitespace/semicolon"]
["src/nvim/option.c", ["            return NULL;                 /* do nothing as we hit an error */", "", "          }"], "whitespace/blank_line"]
["src/nvim/option.c", ["    key = TERMCAP2KEY(arg[2], arg[3]);", "  else {", "    --arg;                          /* put arg at the '<' */"], "readability/braces"]
["src/nvim/option.c", ["    modifiers = 0;", "    key = find_special_key(&arg, &modifiers, TRUE, TRUE);", "    if (modifiers)                  /* can't handle modifiers here */"], "readability/bool"]
["src/nvim/option.c", [" */", "static void ", "showoptions ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["static void ", "showoptions (", "    int all,"], "whitespace/parens"]
["src/nvim/option.c", ["          varp = get_varp_scope(p, opt_flags);", "      } else", "        varp = get_varp(p);"], "readability/braces"]
["src/nvim/option.c", ["          len = 1;                      /* a toggle option fits always */", "        else {", "          option_value2string(p, opt_flags);"], "readability/braces"]
["src/nvim/option.c", ["      rows = (item_count + cols - 1) / cols;", "    } else      /* run == 2 */", "      rows = item_count;"], "readability/braces"]
["src/nvim/option.c", ["  if (varp == NULL)", "    return TRUE;            /* hidden option is always at default */", "  dvi = ((p->flags & P_VI_DEF) || p_cp) ? VI_DEFAULT : VIM_DEFAULT;"], "readability/bool"]
["src/nvim/option.c", [" */", "static void ", "showoneopt ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["static void ", "showoneopt (", "    vimoption_T *p,"], "whitespace/parens"]
["src/nvim/option.c", ["", "  silent_mode = FALSE;", "  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */"], "readability/bool"]
["src/nvim/option.c", ["  silent_mode = FALSE;", "  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */", ""], "readability/bool"]
["src/nvim/option.c", ["  silent_mode = save_silent;", "  info_message = FALSE;", "}"], "readability/bool"]
["src/nvim/option.c", ["          } else {    /* P_STRING */", "            int do_endif = FALSE;", ""], "readability/bool"]
["src/nvim/option.c", ["                return FAIL;", "              do_endif = TRUE;", "            }"], "readability/bool"]
["src/nvim/option.c", ["{", "  if (put_setstring(fd, \"setlocal\", \"fdm\", &curwin->w_p_fdm, FALSE) == FAIL", "      || put_setstring(fd, \"setlocal\", \"fde\", &curwin->w_p_fde, FALSE)"], "readability/bool"]
["src/nvim/option.c", ["  if (put_setstring(fd, \"setlocal\", \"fdm\", &curwin->w_p_fdm, FALSE) == FAIL", "      || put_setstring(fd, \"setlocal\", \"fde\", &curwin->w_p_fde, FALSE)", "      == FAIL"], "readability/bool"]
["src/nvim/option.c", ["      == FAIL", "      || put_setstring(fd, \"setlocal\", \"fmr\", &curwin->w_p_fmr, FALSE)", "      == FAIL"], "readability/bool"]
["src/nvim/option.c", ["      == FAIL", "      || put_setstring(fd, \"setlocal\", \"fdi\", &curwin->w_p_fdi, FALSE)", "      == FAIL"], "readability/bool"]
["src/nvim/option.c", ["", "static int put_setstring(FILE *fd, char *cmd, char *name, char_u **valuep, int expand)", "{"], "whitespace/line_length"]
["src/nvim/option.c", ["      while (*s != NUL)", "        if (put_escstr(fd, str2special(&s, FALSE), 2) == FAIL)", "          return FAIL;"], "readability/bool"]
["src/nvim/option.c", ["      buf = xmalloc(MAXPATHL);", "      home_replace(NULL, *valuep, buf, MAXPATHL, FALSE);", "      if (put_escstr(fd, buf, 2) == FAIL) {"], "readability/bool"]
["src/nvim/option.c", ["      xfree(buf);", "    } else if (put_escstr(fd, *valuep, 2) == FAIL)", "      return FAIL;"], "readability/braces"]
["src/nvim/option.c", ["      return FAIL;", "  } else if (fprintf(fd, \"%\" PRId64, (int64_t)*valuep) < 0)", "    return FAIL;"], "readability/braces"]
["src/nvim/option.c", ["{", "  int should_copy = TRUE;", "  char_u      *save_p_isk = NULL;           /* init for GCC */"], "readability/bool"]
["src/nvim/option.c", ["  int dont_do_help;", "  int did_isk = FALSE;", ""], "readability/bool"]
["src/nvim/option.c", ["                && vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))", "      should_copy = FALSE;", ""], "readability/bool"]
["src/nvim/option.c", ["      if (!buf->b_p_initialized) {", "        free_buf_options(buf, TRUE);", "        buf->b_p_ro = FALSE;                    /* don't copy readonly */"], "readability/bool"]
["src/nvim/option.c", ["        free_buf_options(buf, TRUE);", "        buf->b_p_ro = FALSE;                    /* don't copy readonly */", "        buf->b_p_fenc = vim_strsave(p_fenc);"], "readability/bool"]
["src/nvim/option.c", ["        buf->b_p_bt = empty_option;", "      } else", "        free_buf_options(buf, FALSE);"], "readability/braces"]
["src/nvim/option.c", ["      } else", "        free_buf_options(buf, FALSE);", ""], "readability/bool"]
["src/nvim/option.c", ["        buf->b_p_isk = save_p_isk;", "      else {", "        buf->b_p_isk = vim_strsave(p_isk);"], "readability/braces"]
["src/nvim/option.c", ["        buf->b_p_isk = vim_strsave(p_isk);", "        did_isk = TRUE;", "        buf->b_p_ts = p_ts;"], "readability/bool"]
["src/nvim/option.c", ["  if (did_isk)", "    (void)buf_init_chartab(buf, FALSE);", "}"], "readability/bool"]
["src/nvim/option.c", ["", "  curbuf->b_p_ma = FALSE;", "  p_ma = FALSE;"], "readability/bool"]
["src/nvim/option.c", ["  curbuf->b_p_ma = FALSE;", "  p_ma = FALSE;", "  opt_idx = findoption((char_u *)\"ma\");"], "readability/bool"]
["src/nvim/option.c", ["  if (opt_idx >= 0)", "    options[opt_idx].def_val[VI_DEFAULT] = FALSE;", "}"], "readability/bool"]
["src/nvim/option.c", ["", "void ", "set_context_in_set_cmd ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["void ", "set_context_in_set_cmd (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/option.c", ["  char_u      *s;", "  int is_term_option = FALSE;", "  int key;"], "readability/bool"]
["src/nvim/option.c", ["    nextchar = *++p;", "    is_term_option = TRUE;", "    expand_option_name[2] = (char_u)KEY2TERMCAP0(key);"], "readability/bool"]
["src/nvim/option.c", ["      nextchar = *++p;", "      is_term_option = TRUE;", "      expand_option_name[2] = p[-2];"], "readability/bool"]
["src/nvim/option.c", ["", "int ExpandSettings(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file)", "{"], "whitespace/line_length"]
["src/nvim/option.c", ["    }", "    for (size_t opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;", "         opt_idx++) {"], "whitespace/line_length"]
["src/nvim/option.c", ["        continue;", "      match = FALSE;", "      if (vim_regexec(regmatch, str, (colnr_T)0)"], "readability/bool"]
["src/nvim/option.c", ["              && vim_regexec(regmatch,", "                  (char_u *)options[opt_idx].shortname, (colnr_T)0))){", "        match = TRUE;"], "whitespace/braces"]
["src/nvim/option.c", ["                  (char_u *)options[opt_idx].shortname, (colnr_T)0))){", "        match = TRUE;", "      }"], "readability/bool"]
["src/nvim/option.c", ["          num_normal++;", "        } else", "          (*file)[count++] = vim_strsave(str);"], "readability/braces"]
["src/nvim/option.c", ["    var = NameBuff;", "  } else if (var == NULL)", "    var = (char_u *)\"\";"], "readability/braces"]
["src/nvim/option.c", [" */", "static void ", "option_value2string ("], "whitespace/end_of_line"]
["src/nvim/option.c", ["static void ", "option_value2string (", "    vimoption_T *opp,"], "whitespace/parens"]
["src/nvim/option.c", ["    else", "      sprintf((char *)NameBuff, \"%\" PRId64, (int64_t)*(long *)varp);", "  } else { /* P_STRING */"], "runtime/printf"]
["src/nvim/option.c", ["    else if (opp->flags & P_EXPAND)", "      home_replace(NULL, varp, NameBuff, MAXPATHL, FALSE);", "    /* Translate 'pastetoggle' into special key names */"], "readability/bool"]
["src/nvim/option.c", ["    if (IS_SPECIAL(*wcp) || find_special_key_in_table((int)*wcp) >= 0)", "      return TRUE;", "  }"], "readability/bool"]
["src/nvim/option.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/option.c", ["        langmap_set_entry(from, to);", "      else {", "        assert(to <= UCHAR_MAX);"], "readability/braces"]
["src/nvim/option.c", ["  if (p_paste)", "    return FALSE;", "  return vim_strchr(curbuf->b_p_fo, x) != NULL;"], "readability/bool"]
["src/nvim/option.c", ["  return p_shm != NULL &&", "         (   vim_strchr(p_shm, x) != NULL", "             || (vim_strchr(p_shm, 'a') != NULL"], "whitespace/parens"]
["src/nvim/option.c", ["{", "  static int old_p_paste = FALSE;", "  static int save_sm = 0;"], "readability/bool"]
["src/nvim/option.c", ["   */", "  else if (old_p_paste) {", "    /* restore options for each buffer */"], "whitespace/newline"]
["src/nvim/option.c", ["      /* Set $MYVIMRC to the first vimrc file found. */", "      p = (char_u *)FullName_save((char *)fname, FALSE);", "      if (p != NULL) {"], "readability/bool"]
["src/nvim/option.c", ["  if (idx < 0)          /* unknown option */", "    return FALSE;", "  if (options[idx].flags & P_WAS_SET)"], "readability/bool"]
["src/nvim/option.c", ["  if (options[idx].flags & P_WAS_SET)", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/option.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/option.c", ["  for (i = 0; i < 256; i++)", "    breakat_flags[i] = FALSE;", ""], "readability/bool"]
["src/nvim/option.c", ["    for (p = p_breakat; *p; p++)", "      breakat_flags[*p] = TRUE;", "}"], "readability/bool"]
["src/nvim/option.c", ["    for (i = 0; ASCII_ISALPHA(p[i]); ++i)", "      ;", "    if (p[i] != NUL && p[i] != ',' && p[i] != ':')"], "whitespace/semicolon"]
["src/nvim/option.c", ["  switch (*p_bs) {", "  case '2':       return TRUE;", "  case '1':       return what != BS_START;"], "readability/bool"]
["src/nvim/option.c", ["  case '1':       return what != BS_START;", "  case '0':       return FALSE;", "  }"], "readability/bool"]
["src/nvim/option.c", ["  if (buf->b_flags & BF_NEVERLOADED)", "    return FALSE;", "  if (ignore_empty"], "readability/bool"]
["src/nvim/option.c", ["      && buf->b_ml.ml_line_count == 1", "      && *ml_get_buf(buf, (linenr_T)1, FALSE) == NUL)", "    return FALSE;"], "readability/bool"]
["src/nvim/option.c", ["      && *ml_get_buf(buf, (linenr_T)1, FALSE) == NUL)", "    return FALSE;", "  if (buf->b_start_ffc != *buf->b_p_ff)"], "readability/bool"]
["src/nvim/option.c", ["  if (buf->b_start_ffc != *buf->b_p_ff)", "    return TRUE;", "  if (buf->b_p_bin && buf->b_start_eol != buf->b_p_eol)"], "readability/bool"]
["src/nvim/option.c", ["  if (buf->b_p_bin && buf->b_start_eol != buf->b_p_eol)", "    return TRUE;", "  if (!buf->b_p_bin && buf->b_start_bomb != buf->b_p_bomb)"], "readability/bool"]
["src/nvim/option.c", ["  if (!buf->b_p_bin && buf->b_start_bomb != buf->b_p_bomb)", "    return TRUE;", "  if (buf->b_start_fenc == NULL)"], "readability/bool"]
["src/nvim/option.c", ["{", "  return check_opt_strings(p, p_ff_values, FALSE);", "}"], "readability/bool"]
["src/nvim/option.c", ["          *initc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);", "          *backwards = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/option.c", ["          *findc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);", "          *backwards = FALSE;", "        }"], "readability/bool"]
["src/nvim/option.c", ["          *initc = mb_ptr2char(prev);", "          *backwards = FALSE;", "        } else {"], "readability/bool"]
["src/nvim/option.c", ["          *findc = mb_ptr2char(prev);", "          *backwards = TRUE;", "        }"], "readability/bool"]
["src/nvim/option.c", ["        if (switchit) {", "          *backwards = TRUE;", "          *findc = *initc;"], "readability/bool"]
["src/nvim/option.c", ["        } else {", "          *backwards = FALSE;", "          *findc = ptr[2];"], "readability/bool"]
["src/nvim/option.c", ["        if (switchit) {", "          *backwards = FALSE;", "          *findc = *initc;"], "readability/bool"]
["src/nvim/option.c", ["        } else {", "          *backwards = TRUE;", "          *findc =  ptr[-2];"], "readability/bool"]
["src/nvim/option.c", ["    }", "    else if (STRNCMP(p, \"min:\", 4) == 0 && ascii_isdigit(p[4]))", "    {"], "whitespace/newline"]
["src/nvim/option.c", ["    }", "    else if (STRNCMP(p, \"sbr\", 3) == 0)", "    {"], "whitespace/newline"]
["src/nvim/os_unix.c", ["      msg_putchar('\\n');", "      freecon (from_context);", "      return;"], "whitespace/parens"]
["src/nvim/os_unix.c", ["#define STYLE_PRINT     3       /* use \"print -N\", for zsh */", "#define STYLE_BT        4       /* `cmd` expansion, execute the pattern", "                                 * directly */"], "readability/multiline_comment"]
["src/nvim/os_unix.c", ["          ++j;", "        } else if (!intick", "            && ((flags & EW_KEEPDOLLAR) == 0 || pat[i][j] != '$')"], "readability/braces"]
["src/nvim/os_unix.c", ["      extra_shell_arg", "      );", ""], "whitespace/parens"]
["src/nvim/os_unix.c", ["  }", "  long long templen = ftell(fd);        /* get size of temp file */", "  if (templen < 0) {"], "runtime/int"]
["src/nvim/os_unix.c", ["#if SIZEOF_LONG_LONG > SIZEOF_SIZE_T", "  assert(templen <= (long long)SIZE_MAX);", "#endif"], "runtime/int"]
["src/nvim/os_unix.c", ["  /* file names are separated with NL */", "  else if (shell_style == STYLE_BT || shell_style == STYLE_VIMGLOB) {", "    buffer[len] = NUL;                  /* make sure the buffer ends in NUL */"], "whitespace/newline"]
["src/nvim/os_unix.c", ["  /* file names are separated with NUL */", "  else {", "    /*"], "whitespace/newline"]
["src/nvim/os_unix.c", ["  /* file names are separated with NUL */", "  else {", "    /*"], "readability/braces"]
["src/nvim/os_unix.c", ["        *p = NUL;", "      else {", "        *p++ = NUL;"], "readability/braces"]
["src/nvim/os_unix.c", ["  for (j = 0, i = 0; i < *num_file; ++i) {", "    /* Require the files to exist.\tHelps when using /bin/sh */", "    if (!(flags & EW_NOTFOUND) && !os_file_exists((*file)[i]))"], "whitespace/tab"]
["src/nvim/os_unix.c", ["  return FAIL;", "", "}"], "whitespace/blank_line"]
["src/nvim/path.c", ["    if (checkname) {", "      vim_FullName((char *)exp1, (char *)full1, MAXPATHL, FALSE);", "      vim_FullName((char *)s2, (char *)full2, MAXPATHL, FALSE);"], "readability/bool"]
["src/nvim/path.c", ["      vim_FullName((char *)exp1, (char *)full1, MAXPATHL, FALSE);", "      vim_FullName((char *)s2, (char *)full2, MAXPATHL, FALSE);", "      if (fnamecmp(full1, full2) == 0) {"], "readability/bool"]
["src/nvim/path.c", ["///", "/// Takes care of \"c:/\" and \"//\". That means `path_tail_with_sep(\"dir///file.txt\")`", "/// will return a pointer to `\"///file.txt\"`."], "whitespace/line_length"]
["src/nvim/path.c", ["#endif", "  ;", "}"], "whitespace/semicolon"]
["src/nvim/path.c", ["  if (*p != NUL && !after_pathsep(p, p + strlen(p)))", "    strcat(p, PATHSEPSTR);", "}"], "runtime/printf"]
["src/nvim/path.c", ["      s = p + 1;", "    } else if (path_end >= path + wildoff", "               && (vim_strchr((char_u *)\"*?[{~$\", *path_end) != NULL"], "readability/braces"]
["src/nvim/path.c", ["      path_end += len;", "    } else", "      *p++ = *path_end++;"], "readability/braces"]
["src/nvim/path.c", ["  starts_with_dot = (*s == '.');", "  pat = file_pat_to_reg_pat(s, e, NULL, FALSE);", "  if (pat == NULL) {"], "readability/bool"]
["src/nvim/path.c", ["    scandir_next_with_dots(NULL /* initialize */);", "    while((name = (char_u *) scandir_next_with_dots(&dir)) && name != NULL) {", "      if ((name[0] != '.' || starts_with_dot)"], "whitespace/parens"]
["src/nvim/path.c", ["      simplify_filename(buf);", "    } else if (buf[0] == NUL)", "      /* relative to current directory */"], "readability/braces"]
["src/nvim/path.c", ["    while ((fname[j] == path_part[i][j]", "            ) && fname[j] != NUL && path_part[i][j] != NUL)", "      j++;"], "whitespace/parens"]
["src/nvim/path.c", ["  STRCAT(file_pattern, pattern);", "  pat = file_pat_to_reg_pat(file_pattern, NULL, NULL, TRUE);", "  xfree(file_pattern);"], "readability/bool"]
["src/nvim/path.c", ["", "  regmatch.rm_ic = TRUE;                /* always ignore case */", "  regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);"], "readability/bool"]
["src/nvim/path.c", [" */", "static int ", "expand_in_path ("], "whitespace/end_of_line"]
["src/nvim/path.c", ["static int ", "expand_in_path (", "    garray_T *gap,"], "whitespace/parens"]
["src/nvim/path.c", ["      add_pat = expand_backtick(&ga, p, flags);", "    else {", "      /*"], "readability/braces"]
["src/nvim/path.c", [" */", "static int ", "expand_backtick ("], "whitespace/end_of_line"]
["src/nvim/path.c", ["static int ", "expand_backtick (", "    garray_T *gap,"], "whitespace/parens"]
["src/nvim/path.c", ["  if (*cmd == '=')          /* `={expr}`: Expand expression */", "    buffer = eval_to_string(cmd + 1, &p, TRUE);", "  else"], "readability/bool"]
["src/nvim/path.c", [" */", "void ", "addfile ("], "whitespace/end_of_line"]
["src/nvim/path.c", ["void ", "addfile (", "    garray_T *gap,"], "whitespace/parens"]
["src/nvim/path.c", ["      ++p;", "    while (vim_ispathsep(*p));", "  }"], "whitespace/empty_loop_body"]
["src/nvim/path.c", ["        p += 1 + (p[1] != NUL);         /* keep single \".\" or leading \"./\" */", "      else {", "        /* Strip \"./\" or \".///\".  If we are at the end of the file name"], "readability/braces"]
["src/nvim/path.c", ["        }", "      } else if (p == start && !relative)       /* leading \"/..\" or \"/../\" */", "        STRMOVE(p, tail);                       /* strip \"..\" or \"../\" */"], "readability/braces"]
["src/nvim/path.c", ["        STRMOVE(p, tail);                       /* strip \"..\" or \"../\" */", "      else {", "        if (p == start + 2 && p[-2] == '.') {           /* leading \"./../\" */"], "readability/braces"]
["src/nvim/path.c", ["char_u *", "find_file_name_in_path (", "    char_u *ptr,"], "whitespace/parens"]
["src/nvim/path.c", ["    file_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,", "                                  TRUE, rel_fname);", ""], "readability/bool"]
["src/nvim/path.c", ["        file_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,", "                                      TRUE, rel_fname);", "      }"], "readability/bool"]
["src/nvim/path.c", ["      xfree(file_name);", "      file_name = find_file_in_path(ptr, len, options, FALSE, rel_fname);", "    }"], "readability/bool"]
["src/nvim/path.c", ["    }", "  } else", "    file_name = vim_strnsave(ptr, len);"], "readability/braces"]
["src/nvim/path.c", ["", "  (void)vim_FullName((char *)f1, (char *)ffname, MAXPATHL, FALSE);", "  t1 = path_tail_with_sep(ffname);"], "readability/bool"]
["src/nvim/path.c", ["    for (i = 0; i < *num_file; ++i) {", "      ffname = (char_u *)FullName_save((char *)(*file)[i], FALSE);", "      if (ffname == NULL)               /* out of memory */"], "readability/bool"]
["src/nvim/path.c", ["/// @return `FAIL` for failure, `OK` for success.", "static int path_get_absolute_path(const char_u *fname, char_u *buf, int len, int force)", "{"], "whitespace/line_length"]
["src/nvim/popupmnu.c", ["", "static pumitem_T *pum_array = NULL; // items of displayed pum", "static int pum_size;                // nr of items in \"pum_array\""], "whitespace/comments"]
["src/nvim/popupmnu.c", ["", "static int pum_do_redraw = FALSE;   // do redraw anyway", ""], "readability/bool"]
["src/nvim/popupmnu.c", ["                  // Most left character requires 2-cells but only 1 cell", "                  // is available on screen.  Put a '<' on the left of the ", "                  // pum item"], "whitespace/end_of_line"]
["src/nvim/popupmnu.c", ["{", "  int resized = FALSE;", "  int context = pum_height / 2;"], "readability/bool"]
["src/nvim/popupmnu.c", ["          while (!bufempty()) {", "            ml_delete((linenr_T)1, FALSE);", "          }"], "readability/bool"]
["src/nvim/popupmnu.c", ["            if (e == NULL) {", "              ml_append(lnum++, p, 0, FALSE);", "              break;"], "readability/bool"]
["src/nvim/popupmnu.c", ["              *e = NUL;", "              ml_append(lnum++, p, (int)(e - p + 1), FALSE);", "              *e = '\\n';"], "readability/bool"]
["src/nvim/popupmnu.c", ["              win_setheight((int)lnum);", "              resized = TRUE;", "            }"], "readability/bool"]
["src/nvim/popupmnu.c", ["          curbuf->b_changed = false;", "          curbuf->b_p_ma = FALSE;", "          curwin->w_cursor.lnum = 1;"], "readability/bool"]
["src/nvim/popupmnu.c", ["            if (ins_compl_active() && !resized) {", "              curwin->w_redr_status = FALSE;", "            }"], "readability/bool"]
["src/nvim/popupmnu.c", ["            // Enable updating the status lines.", "            pum_do_redraw = TRUE;", "            update_screen(0);"], "readability/bool"]
["src/nvim/popupmnu.c", ["            update_screen(0);", "            pum_do_redraw = FALSE;", ""], "readability/bool"]
["src/nvim/popupmnu.c", ["            // autocommands involved.", "            pum_do_redraw = TRUE;", "            update_screen(0);"], "readability/bool"]
["src/nvim/popupmnu.c", ["            update_screen(0);", "            pum_do_redraw = FALSE;", "          }"], "readability/bool"]
["src/nvim/popupmnu.c", ["  redraw_all_later(SOME_VALID);", "  redraw_tabline = TRUE;", "  status_redraw_all();"], "readability/bool"]
["src/nvim/po/sjiscorr.c", ["{", "\tchar buffer[BUFSIZ];", "\tchar *p;"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\tchar buffer[BUFSIZ];", "\tchar *p;", ""], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["", "\twhile (fgets(buffer, BUFSIZ, stdin) != NULL)", "\t{"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\twhile (fgets(buffer, BUFSIZ, stdin) != NULL)", "\t{", "\t\tfor (p = buffer; *p != 0; p++)"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\twhile (fgets(buffer, BUFSIZ, stdin) != NULL)", "\t{", "\t\tfor (p = buffer; *p != 0; p++)"], "whitespace/braces"]
["src/nvim/po/sjiscorr.c", ["\t{", "\t\tfor (p = buffer; *p != 0; p++)", "\t\t{"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\tfor (p = buffer; *p != 0; p++)", "\t\t{", "\t\t\tif (strncmp(p, \"charset=utf-8\", 13) == 0)"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\tfor (p = buffer; *p != 0; p++)", "\t\t{", "\t\t\tif (strncmp(p, \"charset=utf-8\", 13) == 0)"], "whitespace/braces"]
["src/nvim/po/sjiscorr.c", ["\t\t{", "\t\t\tif (strncmp(p, \"charset=utf-8\", 13) == 0)", "\t\t\t{"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\tif (strncmp(p, \"charset=utf-8\", 13) == 0)", "\t\t\t{", "\t\t\t\tfputs(\"charset=cp932\", stdout);"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\tif (strncmp(p, \"charset=utf-8\", 13) == 0)", "\t\t\t{", "\t\t\t\tfputs(\"charset=cp932\", stdout);"], "whitespace/braces"]
["src/nvim/po/sjiscorr.c", ["\t\t\t{", "\t\t\t\tfputs(\"charset=cp932\", stdout);", "\t\t\t\tp += 12;"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\tfputs(\"charset=cp932\", stdout);", "\t\t\t\tp += 12;", "\t\t\t}"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\tp += 12;", "\t\t\t}", "\t\t\telse if (strncmp(p, \"# Original translations\", 23) == 0)"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t}", "\t\t\telse if (strncmp(p, \"# Original translations\", 23) == 0)", "\t\t\t{"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t}", "\t\t\telse if (strncmp(p, \"# Original translations\", 23) == 0)", "\t\t\t{"], "whitespace/newline"]
["src/nvim/po/sjiscorr.c", ["\t\t\telse if (strncmp(p, \"# Original translations\", 23) == 0)", "\t\t\t{", "\t\t\t\tfputs(\"# generated from ja.po, DO NOT EDIT\", stdout);"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\telse if (strncmp(p, \"# Original translations\", 23) == 0)", "\t\t\t{", "\t\t\t\tfputs(\"# generated from ja.po, DO NOT EDIT\", stdout);"], "whitespace/braces"]
["src/nvim/po/sjiscorr.c", ["\t\t\t{", "\t\t\t\tfputs(\"# generated from ja.po, DO NOT EDIT\", stdout);", "\t\t\t\twhile (p[1] != '\\n')"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\tfputs(\"# generated from ja.po, DO NOT EDIT\", stdout);", "\t\t\t\twhile (p[1] != '\\n')", "\t\t\t\t\t++p;"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\twhile (p[1] != '\\n')", "\t\t\t\t\t++p;", "\t\t\t}"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\t\t++p;", "\t\t\t}", "\t\t\telse if (*(unsigned char *)p == 0x81 && p[1] == '_')"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t}", "\t\t\telse if (*(unsigned char *)p == 0x81 && p[1] == '_')", "\t\t\t{"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t}", "\t\t\telse if (*(unsigned char *)p == 0x81 && p[1] == '_')", "\t\t\t{"], "whitespace/newline"]
["src/nvim/po/sjiscorr.c", ["\t\t\telse if (*(unsigned char *)p == 0x81 && p[1] == '_')", "\t\t\t{", "\t\t\t\tputchar('\\\\');"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\telse if (*(unsigned char *)p == 0x81 && p[1] == '_')", "\t\t\t{", "\t\t\t\tputchar('\\\\');"], "whitespace/braces"]
["src/nvim/po/sjiscorr.c", ["\t\t\t{", "\t\t\t\tputchar('\\\\');", "\t\t\t\t++p;"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\tputchar('\\\\');", "\t\t\t\t++p;", "\t\t\t}"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\t++p;", "\t\t\t}", "\t\t\telse"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t}", "\t\t\telse", "\t\t\t{"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t}", "\t\t\telse", "\t\t\t{"], "whitespace/newline"]
["src/nvim/po/sjiscorr.c", ["\t\t\telse", "\t\t\t{", "\t\t\t\tif (*p & 0x80)"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\telse", "\t\t\t{", "\t\t\t\tif (*p & 0x80)"], "whitespace/braces"]
["src/nvim/po/sjiscorr.c", ["\t\t\t{", "\t\t\t\tif (*p & 0x80)", "\t\t\t\t{"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\tif (*p & 0x80)", "\t\t\t\t{", "\t\t\t\t\tputchar(*p++);"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\tif (*p & 0x80)", "\t\t\t\t{", "\t\t\t\t\tputchar(*p++);"], "whitespace/braces"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\t{", "\t\t\t\t\tputchar(*p++);", "\t\t\t\t\tif (*p == '\\\\')"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\t\tputchar(*p++);", "\t\t\t\t\tif (*p == '\\\\')", "\t\t\t\t\t\tputchar(*p);"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\t\tif (*p == '\\\\')", "\t\t\t\t\t\tputchar(*p);", "\t\t\t\t}"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\t\t\tputchar(*p);", "\t\t\t\t}", "\t\t\t\tputchar(*p);"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\t}", "\t\t\t\tputchar(*p);", "\t\t\t}"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t\tputchar(*p);", "\t\t\t}", "\t\t}"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t\t}", "\t\t}", "\t}"], "whitespace/tab"]
["src/nvim/po/sjiscorr.c", ["\t\t}", "\t}", "}"], "whitespace/tab"]
["src/nvim/quickfix.c", ["  char_u qf_cleared;            /* set to TRUE if line has been deleted */", "  char_u qf_type;               /* type of the error (mostly 'E'); 1 for", "                                   :helpgrep */"], "readability/multiline_comment"]
["src/nvim/quickfix.c", ["  int qf_nonevalid;             /* TRUE if not a single valid entry found */", "  char_u      *qf_title;        /* title derived from the command that created", "                                 * the error list */"], "readability/multiline_comment"]
["src/nvim/quickfix.c", [" */", "int ", "qf_init ("], "whitespace/end_of_line"]
["src/nvim/quickfix.c", ["int ", "qf_init (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/quickfix.c", [" */", "static int ", "qf_init_ext ("], "whitespace/end_of_line"]
["src/nvim/quickfix.c", ["static int ", "qf_init_ext (", "    qf_info_T *qi,"], "whitespace/parens"]
["src/nvim/quickfix.c", ["  int col = 0;", "  char_u use_viscol = FALSE;", "  int type = 0;"], "readability/bool"]
["src/nvim/quickfix.c", ["  int idx = 0;", "  int multiline = FALSE;", "  int multiignore = FALSE;"], "readability/bool"]
["src/nvim/quickfix.c", ["  int multiline = FALSE;", "  int multiignore = FALSE;", "  int multiscan = FALSE;"], "readability/bool"]
["src/nvim/quickfix.c", ["  int multiignore = FALSE;", "  int multiscan = FALSE;", "  int retval = -1;                      /* default: return error flag */"], "readability/bool"]
["src/nvim/quickfix.c", ["    {'r', \".*\"},", "    {'p', \"[- \t.]*\"},", "    {'v', \"\\\\d\\\\+\"},"], "whitespace/tab"]
["src/nvim/quickfix.c", ["         qfprev->qf_next != qfprev; qfprev = qfprev->qf_next)", "      ;", ""], "whitespace/semicolon"]
["src/nvim/quickfix.c", ["          if (fmt_ptr->addr[idx]) {", "            sprintf((char *)errmsg,", "                _(\"E372: Too many %%%c in format string\"), *efmp);"], "runtime/printf"]
["src/nvim/quickfix.c", ["                      fmt_ptr->prefix) == NULL)) {", "            sprintf((char *)errmsg,", "                _(\"E373: Unexpected %%%c in format string\"), *efmp);"], "runtime/printf"]
["src/nvim/quickfix.c", ["                       && (*ptr++ = *++efmp) != ']')", "                  /* skip */;", "                if (efmp == efm + len) {"], "whitespace/semicolon"]
["src/nvim/quickfix.c", ["              }", "            } else if (efmp < efm + len)                /* %*\\D, %*\\s etc. */", "              *ptr++ = *++efmp;"], "readability/braces"]
["src/nvim/quickfix.c", ["            /* TODO: scanf()-like: %*ud, %*3c, %*f, ... ? */", "            sprintf((char *)errmsg,", "                _(\"E375: Unsupported %%%c in format string\"), *efmp);"], "runtime/printf"]
["src/nvim/quickfix.c", ["          }", "        } else if (vim_strchr((char_u *)\"%\\\\.^$~[\", *efmp) != NULL)", "          *ptr++ = *efmp;                       /* regexp magic characters */"], "readability/braces"]
["src/nvim/quickfix.c", ["        else if (*efmp == '>')", "          fmt_ptr->conthere = TRUE;", "        else if (efmp == efm + 1) {                     /* analyse prefix */"], "readability/bool"]
["src/nvim/quickfix.c", ["            fmt_ptr->prefix = *efmp;", "          else {", "            sprintf((char *)errmsg,"], "readability/braces"]
["src/nvim/quickfix.c", ["          else {", "            sprintf((char *)errmsg,", "                _(\"E376: Invalid %%%c in format string prefix\"), *efmp);"], "runtime/printf"]
["src/nvim/quickfix.c", ["        } else {", "          sprintf((char *)errmsg,", "              _(\"E377: Invalid %%%c in format string\"), *efmp);"], "runtime/printf"]
["src/nvim/quickfix.c", ["   */", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["  /* Always ignore case when looking for a matching error. */", "  regmatch.rm_ic = TRUE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["          break;", "        STRLCPY(IObuff, ml_get_buf(buf, buflnum++, FALSE),", "            CMDBUFFSIZE - 1);"], "readability/bool"]
["src/nvim/quickfix.c", ["      }", "    } else if (fgets((char *)IObuff, CMDBUFFSIZE - 2, fd) == NULL)", "      break;"], "readability/braces"]
["src/nvim/quickfix.c", ["      fmt_ptr = fmt_first;", "    else {", "      fmt_ptr = fmt_start;"], "readability/braces"]
["src/nvim/quickfix.c", ["     */", "    valid = TRUE;", "restofline:"], "readability/bool"]
["src/nvim/quickfix.c", ["      col = 0;", "      use_viscol = FALSE;", "      enr = -1;"], "readability/bool"]
["src/nvim/quickfix.c", ["          ++col;", "          use_viscol = TRUE;", "        }"], "readability/bool"]
["src/nvim/quickfix.c", ["          col = (int)atol((char *)regmatch.startp[i]);", "          use_viscol = TRUE;", "        }"], "readability/bool"]
["src/nvim/quickfix.c", ["    }", "    multiscan = FALSE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["            goto error2;", "        } else if (idx == 'X')                          /* leave directory */", "          directory = qf_pop_dir(&dir_stack);"], "readability/braces"]
["src/nvim/quickfix.c", ["      lnum = 0;                         /* don't jump to this line */", "      valid = FALSE;", "      STRCPY(errmsg, IObuff);           /* copy whole line to error message */"], "readability/bool"]
["src/nvim/quickfix.c", ["      if (fmt_ptr == NULL)", "        multiline = multiignore = FALSE;", "    } else if (fmt_ptr != NULL) {"], "readability/bool"]
["src/nvim/quickfix.c", ["      if (vim_strchr((char_u *)\"AEWI\", idx) != NULL) {", "        multiline = TRUE;    /* start of a multi-line message */", "        multiignore = FALSE; /* reset continuation */"], "readability/bool"]
["src/nvim/quickfix.c", ["        multiline = TRUE;    /* start of a multi-line message */", "        multiignore = FALSE; /* reset continuation */", "      } else if (vim_strchr((char_u *)\"CZ\", idx)"], "readability/bool"]
["src/nvim/quickfix.c", ["        if (idx == 'Z')", "          multiline = multiignore = FALSE;", "        line_breakcheck();"], "readability/bool"]
["src/nvim/quickfix.c", ["        /* global file names */", "        valid = FALSE;", "        if (*namebuf == NUL || os_file_exists(namebuf)) {"], "readability/bool"]
["src/nvim/quickfix.c", ["            STRMOVE(IObuff, skipwhite(tail));", "            multiscan = TRUE;", "            goto restofline;"], "readability/bool"]
["src/nvim/quickfix.c", ["        if (multiline)", "          multiignore = TRUE;           /* also exclude continuation lines */", "        continue;"], "readability/bool"]
["src/nvim/quickfix.c", ["      qi->qf_lists[qi->qf_curlist].qf_index = 1;", "      qi->qf_lists[qi->qf_curlist].qf_nonevalid = TRUE;", "    } else {"], "readability/bool"]
["src/nvim/quickfix.c", ["    } else {", "      qi->qf_lists[qi->qf_curlist].qf_nonevalid = FALSE;", "      if (qi->qf_lists[qi->qf_curlist].qf_ptr == NULL)"], "readability/bool"]
["src/nvim/quickfix.c", ["  return retval;", "}", ""], "readability/fn_size"]
["src/nvim/quickfix.c", ["    qi->qf_lists[qi->qf_curlist].qf_title = p;", "    sprintf((char *)p, \":%s\", (char *)title);", "  }"], "runtime/printf"]
["src/nvim/quickfix.c", ["    qi->qf_curlist = LISTCOUNT - 1;", "  } else", "    qi->qf_curlist = qi->qf_listcount++;"], "readability/braces"]
["src/nvim/quickfix.c", ["    ll_free_all(&wp->w_llist_ref);", "  } else", "    /* quickfix list */"], "readability/braces"]
["src/nvim/quickfix.c", [" */", "static int ", "qf_add_entry ("], "whitespace/end_of_line"]
["src/nvim/quickfix.c", ["static int ", "qf_add_entry (", "    qf_info_T *qi,                /* quickfix list */"], "whitespace/parens"]
["src/nvim/quickfix.c", ["    qf_info_T *qi,                /* quickfix list */", "    qfline_T **prevp,            /* nonnull pointer (to previously added entry or NULL) */", "    char_u *dir,               /* optional directory name */"], "whitespace/line_length"]
["src/nvim/quickfix.c", ["  qfp->qf_next = qfp;   /* last element points to itself */", "  qfp->qf_cleared = FALSE;", "  *prevp = qfp;"], "readability/bool"]
["src/nvim/quickfix.c", ["    if (directory != NULL && !vim_isAbsName(fname)) {", "      ptr = (char_u *)concat_fnames((char *)directory, (char *)fname, TRUE);", "      /*"], "readability/bool"]
["src/nvim/quickfix.c", ["        if (directory)", "          ptr = (char_u *)concat_fnames((char *)directory, (char *)fname, TRUE);", "        else"], "readability/bool"]
["src/nvim/quickfix.c", ["    (*stackptr)->dirname = vim_strsave(dirbuf);", "  else {", "    /* Okay we don't have an absolute path."], "readability/braces"]
["src/nvim/quickfix.c", ["      (*stackptr)->dirname = (char_u *)concat_fnames((char *)ds_new->dirname,", "          (char *)dirbuf, TRUE);", "      if (os_isdir((*stackptr)->dirname))"], "readability/bool"]
["src/nvim/quickfix.c", ["    return (*stackptr)->dirname;", "  else {", "    ds_ptr = *stackptr;"], "readability/braces"]
["src/nvim/quickfix.c", ["    xfree(fullname);", "    fullname = (char_u *)concat_fnames((char *)ds_ptr->dirname, (char *)filename, TRUE);", ""], "whitespace/line_length"]
["src/nvim/quickfix.c", ["    xfree(fullname);", "    fullname = (char_u *)concat_fnames((char *)ds_ptr->dirname, (char *)filename, TRUE);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["", "  return ds_ptr==NULL ? NULL : ds_ptr->dirname;", ""], "whitespace/operators"]
["src/nvim/quickfix.c", ["  return ds_ptr==NULL ? NULL : ds_ptr->dirname;", "", "}"], "whitespace/blank_line"]
["src/nvim/quickfix.c", ["  unsigned old_swb_flags = swb_flags;", "  int opened_window = FALSE;", "  win_T               *win;"], "readability/bool"]
["src/nvim/quickfix.c", ["  win_T               *oldwin = curwin;", "  int print_message = TRUE;", "  int len;"], "readability/bool"]
["src/nvim/quickfix.c", ["     * window */", "    print_message = FALSE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["      win_enter(wp, true);", "    else {", "      /*"], "readability/braces"]
["src/nvim/quickfix.c", ["        goto theend;", "      opened_window = TRUE;             /* close it when fail */", ""], "readability/bool"]
["src/nvim/quickfix.c", ["        goto failed;                    /* not enough room for window */", "      opened_window = TRUE;             /* close it when fail */", "      p_swb = empty_option;             /* don't split again */"], "readability/bool"]
["src/nvim/quickfix.c", ["      } else {", "", "        /*"], "whitespace/blank_line"]
["src/nvim/quickfix.c", ["        EMSG(_(e_nowrtmsg));", "        ok = FALSE;", "      } else"], "readability/bool"]
["src/nvim/quickfix.c", ["        ok = FALSE;", "      } else", "        ok = do_ecmd(qf_ptr->qf_fnum, NULL, NULL, NULL, (linenr_T)1,"], "readability/braces"]
["src/nvim/quickfix.c", ["            oldwin == curwin ? curwin : NULL);", "    } else", "      ok = buflist_getfile(qf_ptr->qf_fnum,"], "readability/braces"]
["src/nvim/quickfix.c", ["        curwin->w_cursor.col = qf_ptr->qf_col - 1;", "        if (qf_ptr->qf_viscol == TRUE) {", "          /*"], "readability/bool"]
["src/nvim/quickfix.c", ["              screen_col += 8 - (screen_col % 8);", "            } else", "              ++screen_col;"], "readability/braces"]
["src/nvim/quickfix.c", ["        check_cursor();", "      } else", "        beginline(BL_WHITE | BL_FIX);"], "readability/braces"]
["src/nvim/quickfix.c", ["        update_topline_redraw();", "      sprintf((char *)IObuff, _(\"(%d of %d)%s%s: \"), qf_index,", "          qi->qf_lists[qi->qf_curlist].qf_count,"], "runtime/printf"]
["src/nvim/quickfix.c", ["      if (curbuf == old_curbuf && curwin->w_cursor.lnum == old_lnum)", "        msg_scroll = TRUE;", "      else if (!msg_scrolled && shortmess(SHM_OVERALL))"], "readability/bool"]
["src/nvim/quickfix.c", ["      else if (!msg_scrolled && shortmess(SHM_OVERALL))", "        msg_scroll = FALSE;", "      msg_attr_keep(IObuff, 0, TRUE);"], "readability/bool"]
["src/nvim/quickfix.c", ["        msg_scroll = FALSE;", "      msg_attr_keep(IObuff, 0, TRUE);", "      msg_scroll = i;"], "readability/bool"]
["src/nvim/quickfix.c", ["    if (opened_window)", "      win_close(curwin, TRUE);          /* Close opened window */", "    if (qf_ptr->qf_fnum != 0) {"], "readability/bool"]
["src/nvim/quickfix.c", ["      swb_flags = old_swb_flags;", "    } else", "      free_string_option(old_swb);"], "readability/braces"]
["src/nvim/quickfix.c", ["  char_u      *arg = eap->arg;", "  int all = eap->forceit;               /* if not :cl!, only show", "                                                   recognised errors */"], "readability/multiline_comment"]
["src/nvim/quickfix.c", ["  if (qi->qf_lists[qi->qf_curlist].qf_nonevalid)", "    all = TRUE;", "  qfp = qi->qf_lists[qi->qf_curlist].qf_start;"], "readability/bool"]
["src/nvim/quickfix.c", ["      if (fname == NULL)", "        sprintf((char *)IObuff, \"%2d\", i);", "      else"], "runtime/printf"]
["src/nvim/quickfix.c", ["      else if (qfp->qf_col == 0)", "        sprintf((char *)IObuff, \":%\" PRId64, (int64_t)qfp->qf_lnum);", "      else"], "runtime/printf"]
["src/nvim/quickfix.c", ["      else", "        sprintf((char *)IObuff, \":%\" PRId64 \" col %d\",", "                (int64_t)qfp->qf_lnum, qfp->qf_col);"], "runtime/printf"]
["src/nvim/quickfix.c", ["                (int64_t)qfp->qf_lnum, qfp->qf_col);", "      sprintf((char *)IObuff + STRLEN(IObuff), \"%s:\",", "          (char *)qf_types(qfp->qf_type, qfp->qf_nr));"], "runtime/printf"]
["src/nvim/quickfix.c", ["          IObuff, IOSIZE);", "      msg_prt_line(IObuff, FALSE);", "      ui_flush();                      /* show one line at a time */"], "readability/bool"]
["src/nvim/quickfix.c", ["          break;", "    } else", "      buf[i] = *p++;"], "readability/braces"]
["src/nvim/quickfix.c", ["  qfline_T    *qfp;", "  int stop = FALSE;", ""], "readability/bool"]
["src/nvim/quickfix.c", [" */", "void qf_mark_adjust(win_T *wp, linenr_T line1, linenr_T line2, long amount, long amount_after)", "{"], "whitespace/line_length"]
["src/nvim/quickfix.c", ["            if (amount == MAXLNUM)", "              qfp->qf_cleared = TRUE;", "            else"], "readability/bool"]
["src/nvim/quickfix.c", ["              qfp->qf_lnum += amount;", "          } else if (amount_after && qfp->qf_lnum > line2)", "            qfp->qf_lnum += amount_after;"], "readability/braces"]
["src/nvim/quickfix.c", ["    p = (char_u *)\"\";", "  else {", "    cc[0] = ' ';"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  sprintf((char *)buf, \"%s %3d\", (char *)p, nr);", "  return buf;"], "runtime/printf"]
["src/nvim/quickfix.c", ["      ex_cclose(eap);", "  } else if (win == NULL)", "    ex_copen(eap);"], "readability/braces"]
["src/nvim/quickfix.c", ["  if (win != NULL)", "    win_close(win, FALSE);", "}"], "readability/bool"]
["src/nvim/quickfix.c", ["          ECMD_HIDE + ECMD_OLDBUF, oldwin);", "    else {", "      /* Create a new quickfix buffer */"], "readability/braces"]
["src/nvim/quickfix.c", ["      RESET_BINDING(curwin);", "      curwin->w_p_diff = FALSE;", "      set_option_value((char_u *)\"fdm\", 0L, (char_u *)\"manual\","], "readability/bool"]
["src/nvim/quickfix.c", ["      win_setheight(height);", "    curwin->w_p_wfh = TRUE;         /* set 'winfixheight' */", "    if (win_valid(win))"], "readability/bool"]
["src/nvim/quickfix.c", [" */", "static int ", "qf_win_pos_update ("], "whitespace/end_of_line"]
["src/nvim/quickfix.c", ["static int ", "qf_win_pos_update (", "    qf_info_T *qi,"], "whitespace/parens"]
["src/nvim/quickfix.c", ["    redraw_later(VALID);", "    curwin->w_redr_status = TRUE;       /* update ruler */", "    curwin = old_curwin;"], "readability/bool"]
["src/nvim/quickfix.c", ["        || (qi != &ql_info && win->w_llist_ref == qi))", "      return TRUE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/quickfix.c", ["      curwin = curwin_save;", "", "    }"], "whitespace/blank_line"]
["src/nvim/quickfix.c", ["  while ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)", "    (void)ml_delete((linenr_T)1, FALSE);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["        len = (int)STRLEN(IObuff);", "      } else", "        len = 0;"], "readability/braces"]
["src/nvim/quickfix.c", ["      if (qfp->qf_lnum > 0) {", "        sprintf((char *)IObuff + len, \"%\" PRId64, (int64_t)qfp->qf_lnum);", "        len += (int)STRLEN(IObuff + len);"], "runtime/printf"]
["src/nvim/quickfix.c", ["        if (qfp->qf_col > 0) {", "          sprintf((char *)IObuff + len, \" col %d\", qfp->qf_col);", "          len += (int)STRLEN(IObuff + len);"], "runtime/printf"]
["src/nvim/quickfix.c", ["", "        sprintf((char *)IObuff + len, \"%s\",", "            (char *)qf_types(qfp->qf_type, qfp->qf_nr));"], "runtime/printf"]
["src/nvim/quickfix.c", ["", "      if (ml_append(lnum, IObuff, (colnr_T)STRLEN(IObuff) + 1, FALSE)", "          == FAIL)"], "readability/bool"]
["src/nvim/quickfix.c", ["    /* Delete the empty line which is now at the end */", "    (void)ml_delete(lnum + 1, FALSE);", "  }"], "readability/bool"]
["src/nvim/quickfix.c", ["  /* correct cursor position */", "  check_lnums(TRUE);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["  set_option_value((char_u *)\"ft\", 0L, (char_u *)\"qf\", OPT_LOCAL);", "  curbuf->b_p_ma = FALSE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["", "  keep_filetype = TRUE;                 /* don't detect 'filetype' */", "  apply_autocmds(EVENT_BUFREADPOST, (char_u *)\"quickfix\", NULL,"], "readability/bool"]
["src/nvim/quickfix.c", ["  apply_autocmds(EVENT_BUFREADPOST, (char_u *)\"quickfix\", NULL,", "      FALSE, curbuf);", "  apply_autocmds(EVENT_BUFWINENTER, (char_u *)\"quickfix\", NULL,"], "readability/bool"]
["src/nvim/quickfix.c", ["  apply_autocmds(EVENT_BUFWINENTER, (char_u *)\"quickfix\", NULL,", "      FALSE, curbuf);", "  keep_filetype = FALSE;"], "readability/bool"]
["src/nvim/quickfix.c", ["      FALSE, curbuf);", "  keep_filetype = FALSE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["    EMSG(_(\"E382: Cannot write, 'buftype' option is set\"));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/quickfix.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/quickfix.c", ["  case 'w':                         /* \"wipe\" */", "  case 'd': return FALSE;           /* \"delete\" */", "  case 'h': return TRUE;            /* \"hide\" */"], "readability/bool"]
["src/nvim/quickfix.c", ["  case 'd': return FALSE;           /* \"delete\" */", "  case 'h': return TRUE;            /* \"hide\" */", "  }"], "readability/bool"]
["src/nvim/quickfix.c", ["    apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,", "        curbuf->b_fname, TRUE, curbuf);", "    if (did_throw || force_abort)"], "readability/bool"]
["src/nvim/quickfix.c", ["  cmd = xmalloc(len);", "  sprintf((char *)cmd, \"%s%s%s\", (char *)p_shq, (char *)eap->arg,", "      (char *)p_shq);"], "runtime/printf"]
["src/nvim/quickfix.c", ["  if (msg_col == 0)", "    msg_didout = FALSE;", "  msg_start();"], "readability/bool"]
["src/nvim/quickfix.c", ["    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,", "        curbuf->b_fname, TRUE, curbuf);", "    if (qi->qf_curlist < qi->qf_listcount)"], "readability/bool"]
["src/nvim/quickfix.c", ["  if (res > 0 && !eap->forceit)", "    qf_jump(qi, 0, 0, FALSE);                   /* display first error */", ""], "readability/bool"]
["src/nvim/quickfix.c", ["    STRCPY(name, p_mef);", "    sprintf((char *)name + (p - p_mef), \"%d%d\", start, off);", "    STRCAT(name, p + 2);"], "runtime/printf"]
["src/nvim/quickfix.c", ["  if (au_name != NULL)", "    apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name, NULL, FALSE, curbuf);", "  if (*eap->arg != NUL)"], "readability/bool"]
["src/nvim/quickfix.c", ["    if (au_name != NULL)", "      apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, NULL, FALSE, curbuf);", "    if (wp != NULL)"], "readability/bool"]
["src/nvim/quickfix.c", ["    if (au_name != NULL)", "      apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, NULL, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/quickfix.c", ["  buf_T       *buf;", "  int duplicate_name = FALSE;", "  int using_dummy;"], "readability/bool"]
["src/nvim/quickfix.c", ["  int using_dummy;", "  int redraw_for_dummy = FALSE;", "  int found_match;"], "readability/bool"]
["src/nvim/quickfix.c", ["    apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,", "        curbuf->b_fname, TRUE, curbuf);", "    if (did_throw || force_abort)"], "readability/bool"]
["src/nvim/quickfix.c", ["", "  /* Get the search pattern: either white-separated or enclosed in // */", "  regmatch.regprog = NULL;"], "readability/multiline_comment"]
["src/nvim/quickfix.c", ["", "  /* Get the search pattern: either white-separated or enclosed in // */", "  regmatch.regprog = NULL;"], "whitespace/comments"]
["src/nvim/quickfix.c", ["    regmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);", "  } else", "    regmatch.regprog = vim_regcomp(s, RE_MAGIC);"], "readability/braces"]
["src/nvim/quickfix.c", ["         prevp->qf_next != prevp; prevp = prevp->qf_next)", "      ;", ""], "whitespace/semicolon"]
["src/nvim/quickfix.c", ["      msg_start();", "      p = msg_strtrunc(fname, TRUE);", "      if (p == NULL)"], "readability/bool"]
["src/nvim/quickfix.c", ["        msg_outtrans(fname);", "      else {", "        msg_outtrans(p);"], "readability/braces"]
["src/nvim/quickfix.c", ["      msg_clr_eos();", "      msg_didout = FALSE;           /* overwrite this message */", "      msg_nowait = TRUE;            /* don't wait for this message */"], "readability/bool"]
["src/nvim/quickfix.c", ["      msg_didout = FALSE;           /* overwrite this message */", "      msg_nowait = TRUE;            /* don't wait for this message */", "      msg_col = 0;"], "readability/bool"]
["src/nvim/quickfix.c", ["      duplicate_name = (buf != NULL);", "      using_dummy = TRUE;", "      redraw_for_dummy = TRUE;"], "readability/bool"]
["src/nvim/quickfix.c", ["      using_dummy = TRUE;", "      redraw_for_dummy = TRUE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["      au_event_restore(save_ei);", "    } else", "      /* Use existing, loaded buffer. */"], "readability/braces"]
["src/nvim/quickfix.c", ["      /* Use existing, loaded buffer. */", "      using_dummy = FALSE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["       * For \":1vimgrep\" look for first match only. */", "      found_match = FALSE;", "      for (lnum = 1; lnum <= buf->b_ml.ml_line_count && tomatch > 0;"], "readability/bool"]
["src/nvim/quickfix.c", ["                   col, NULL) > 0) {", "          ;", "          if (qf_add_entry(qi, &prevp,"], "whitespace/semicolon"]
["src/nvim/quickfix.c", ["                  ml_get_buf(buf,", "                      regmatch.startpos[0].lnum + lnum, FALSE),", "                  regmatch.startpos[0].lnum + lnum,"], "readability/bool"]
["src/nvim/quickfix.c", ["                  regmatch.startpos[0].col + 1,", "                  FALSE,                    /* vis_col */", "                  NULL,                     /* search pattern */"], "readability/bool"]
["src/nvim/quickfix.c", ["                  0,                        /* type */", "                  TRUE                      /* valid */", "                  ) == FAIL) {"], "readability/bool"]
["src/nvim/quickfix.c", ["                  TRUE                      /* valid */", "                  ) == FAIL) {", "            got_int = TRUE;"], "whitespace/parens"]
["src/nvim/quickfix.c", ["                  ) == FAIL) {", "            got_int = TRUE;", "            break;"], "readability/bool"]
["src/nvim/quickfix.c", ["          }", "          found_match = TRUE;", "          if (--tomatch == 0)"], "readability/bool"]
["src/nvim/quickfix.c", ["                + (col == regmatch.endpos[0].col);", "          if (col > (colnr_T)STRLEN(ml_get_buf(buf, lnum, FALSE)))", "            break;"], "readability/bool"]
["src/nvim/quickfix.c", ["          apply_autocmds(EVENT_FILETYPE, buf->b_p_ft,", "              buf->b_fname, TRUE, buf);", "          do_modelines(OPT_NOWIN);"], "readability/bool"]
["src/nvim/quickfix.c", ["", "  qi->qf_lists[qi->qf_curlist].qf_nonevalid = FALSE;", "  qi->qf_lists[qi->qf_curlist].qf_ptr = qi->qf_lists[qi->qf_curlist].qf_start;"], "readability/bool"]
["src/nvim/quickfix.c", ["    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,", "        curbuf->b_fname, TRUE, curbuf);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["         * taken care of. */", "        redraw_for_dummy = FALSE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["    }", "  } else", "    EMSG2(_(e_nomatch2), s);"], "readability/braces"]
["src/nvim/quickfix.c", ["    c = *p;", "    p = skip_regexp(p + 1, c, TRUE, NULL);", "    if (*p != c)"], "readability/bool"]
["src/nvim/quickfix.c", ["static buf_T *", "load_dummy_buffer (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/quickfix.c", ["  buf_T       *newbuf_to_wipe = NULL;", "  int failed = TRUE;", "  aco_save_T aco;"], "readability/bool"]
["src/nvim/quickfix.c", ["    /* Need to set the filename for autocommands. */", "    (void)setfname(curbuf, fname, NULL, FALSE);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["    /* Create swap file now to avoid the ATTENTION message. */", "    check_need_swap(TRUE);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["        && !(curbuf->b_flags & BF_NEW)) {", "      failed = FALSE;", "      if (curbuf != newbuf) {"], "readability/bool"]
["src/nvim/quickfix.c", ["    if (newbuf_to_wipe != NULL && buf_valid(newbuf_to_wipe))", "      wipe_buffer(newbuf_to_wipe, FALSE);", "  }"], "readability/bool"]
["src/nvim/quickfix.c", ["", "    wipe_buffer(buf, FALSE);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["  if (curbuf != buf) {          /* safety check */", "    close_buffer(NULL, buf, DOBUF_UNLOAD, FALSE);", ""], "readability/bool"]
["src/nvim/quickfix.c", ["  qf_info_T   *qi = &ql_info;", "  int did_bufnr_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["         prevp->qf_next != prevp; prevp = prevp->qf_next)", "      ;", "  else if (action == 'r') {"], "whitespace/semicolon"]
["src/nvim/quickfix.c", ["", "    filename = get_dict_string(d, (char_u *)\"filename\", TRUE);", "    bufnum = get_dict_number(d, (char_u *)\"bufnr\");"], "readability/bool"]
["src/nvim/quickfix.c", ["    nr = get_dict_number(d, (char_u *)\"nr\");", "    type = get_dict_string(d, (char_u *)\"type\", TRUE);", "    pattern = get_dict_string(d, (char_u *)\"pattern\", TRUE);"], "readability/bool"]
["src/nvim/quickfix.c", ["    type = get_dict_string(d, (char_u *)\"type\", TRUE);", "    pattern = get_dict_string(d, (char_u *)\"pattern\", TRUE);", "    text = get_dict_string(d, (char_u *)\"text\", TRUE);"], "readability/bool"]
["src/nvim/quickfix.c", ["    pattern = get_dict_string(d, (char_u *)\"pattern\", TRUE);", "    text = get_dict_string(d, (char_u *)\"text\", TRUE);", "    if (text == NULL)"], "readability/bool"]
["src/nvim/quickfix.c", ["", "    valid = TRUE;", "    if ((filename == NULL && bufnum == 0) || (lnum == 0 && pattern == NULL))"], "readability/bool"]
["src/nvim/quickfix.c", ["    if ((filename == NULL && bufnum == 0) || (lnum == 0 && pattern == NULL))", "      valid = FALSE;", ""], "readability/bool"]
["src/nvim/quickfix.c", ["      if (!did_bufnr_emsg) {", "        did_bufnr_emsg = TRUE;", "        EMSGN(_(\"E92: Buffer %\" PRId64 \" not found\"), bufnum);"], "readability/bool"]
["src/nvim/quickfix.c", ["      }", "      valid = FALSE;", "      bufnum = 0;"], "readability/bool"]
["src/nvim/quickfix.c", ["    /* no valid entry */", "    qi->qf_lists[qi->qf_curlist].qf_nonevalid = TRUE;", "  else"], "readability/bool"]
["src/nvim/quickfix.c", ["  else", "    qi->qf_lists[qi->qf_curlist].qf_nonevalid = FALSE;", "  qi->qf_lists[qi->qf_curlist].qf_ptr = qi->qf_lists[qi->qf_curlist].qf_start;"], "readability/bool"]
["src/nvim/quickfix.c", ["    EMSG(_(\"E681: Buffer is not loaded\"));", "  else {", "    if (eap->addr_count == 0) {"], "readability/braces"]
["src/nvim/quickfix.c", ["      EMSG(_(e_invrange));", "    else {", "      char_u *qf_title = *eap->cmdlinep;"], "readability/braces"]
["src/nvim/quickfix.c", ["        qf_jump(qi, 0, 0, eap->forceit);          /* display first error */", "    } else", "      EMSG(_(\"E777: String or List expected\"));"], "readability/braces"]
["src/nvim/quickfix.c", ["  qf_info_T   *qi = &ql_info;", "  int new_qi = FALSE;", "  char_u      *au_name =  NULL;"], "readability/bool"]
["src/nvim/quickfix.c", ["    apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,", "        curbuf->b_fname, TRUE, curbuf);", "    if (did_throw || force_abort)"], "readability/bool"]
["src/nvim/quickfix.c", ["      qi = ll_new_list();", "      new_qi = TRUE;", "    }"], "readability/bool"]
["src/nvim/quickfix.c", ["  regmatch.regprog = vim_regcomp(eap->arg, RE_MAGIC + RE_STRING);", "  regmatch.rm_ic = FALSE;", "  if (regmatch.regprog != NULL) {"], "readability/bool"]
["src/nvim/quickfix.c", ["", "      // Note: We cannot just do `&NameBuff` because it is a statically sized array", "      //       so `NameBuff == &NameBuff` according to C semantics."], "whitespace/line_length"]
["src/nvim/quickfix.c", ["                        + 1,                                         /* col */", "                        FALSE,                          /* vis_col */", "                        NULL,                           /* search pattern */"], "readability/bool"]
["src/nvim/quickfix.c", ["                        1,                              /* type */", "                        TRUE                            /* valid */", "                        ) == FAIL) {"], "readability/bool"]
["src/nvim/quickfix.c", ["                        TRUE                            /* valid */", "                        ) == FAIL) {", "                  got_int = TRUE;"], "whitespace/parens"]
["src/nvim/quickfix.c", ["                        ) == FAIL) {", "                  got_int = TRUE;", "                  if (line != IObuff)"], "readability/bool"]
["src/nvim/quickfix.c", ["", "    qi->qf_lists[qi->qf_curlist].qf_nonevalid = FALSE;", "    qi->qf_lists[qi->qf_curlist].qf_ptr ="], "readability/bool"]
["src/nvim/quickfix.c", ["    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,", "        curbuf->b_fname, TRUE, curbuf);", "    if (!new_qi && qi != &ql_info && qf_find_buf(qi) == NULL)"], "readability/bool"]
["src/nvim/quickfix.c", ["  if (qi->qf_lists[qi->qf_curlist].qf_count > 0)", "    qf_jump(qi, 0, 0, FALSE);", "  else"], "readability/bool"]
["src/nvim/quickfix.c", ["        ll_free_all(&qi);", "    } else if (curwin->w_llist == NULL)", "      curwin->w_llist = qi;"], "readability/braces"]
["src/nvim/regexp.c", ["", "/* definition\tnumber\t\t   opnd?    meaning */", "#define END             0       /*\tEnd of program or NOMATCH operand. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["/* definition\tnumber\t\t   opnd?    meaning */", "#define END             0       /*\tEnd of program or NOMATCH operand. */", "#define BOL             1       /*\tMatch \"\" at beginning of line. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define END             0       /*\tEnd of program or NOMATCH operand. */", "#define BOL             1       /*\tMatch \"\" at beginning of line. */", "#define EOL             2       /*\tMatch \"\" at end of line. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define BOL             1       /*\tMatch \"\" at beginning of line. */", "#define EOL             2       /*\tMatch \"\" at end of line. */", "#define BRANCH          3       /* node Match this alternative, or the"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define EOL             2       /*\tMatch \"\" at end of line. */", "#define BRANCH          3       /* node Match this alternative, or the", "                                 *\tnext... */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define BRANCH          3       /* node Match this alternative, or the", "                                 *\tnext... */", "#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\tnext... */", "#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */", "#define EXACTLY         5       /* str\tMatch this string. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */", "#define EXACTLY         5       /* str\tMatch this string. */", "#define NOTHING         6       /*\tMatch empty string. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define EXACTLY         5       /* str\tMatch this string. */", "#define NOTHING         6       /*\tMatch empty string. */", "#define STAR            7       /* node Match this (simple) thing 0 or more"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NOTHING         6       /*\tMatch empty string. */", "#define STAR            7       /* node Match this (simple) thing 0 or more", "                                 *\ttimes. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define STAR            7       /* node Match this (simple) thing 0 or more", "                                 *\ttimes. */", "#define PLUS            8       /* node Match this (simple) thing 1 or more"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\ttimes. */", "#define PLUS            8       /* node Match this (simple) thing 1 or more", "                                 *\ttimes. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define PLUS            8       /* node Match this (simple) thing 1 or more", "                                 *\ttimes. */", "#define MATCH           9       /* node match the operand zero-width */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SUBPAT          13      /* node match the operand here */", "#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/comma"]
["src/nvim/regexp.c", ["#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and", "                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */"], "whitespace/parens"]
["src/nvim/regexp.c", ["                                 *\tn times (\\{m,n\\}). */", "#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */", "#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */", "#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */", "#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */", "#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE", "                                 *\tand BRACE_COMPLEX. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE", "                                 *\tand BRACE_COMPLEX. */", "#define NEWL            18      /*\tMatch line-break */"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\tand BRACE_COMPLEX. */", "#define NEWL            18      /*\tMatch line-break */", "#define BHPOS           19      /*\tEnd position for BEHIND or NOBEHIND */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NEWL            18      /*\tMatch line-break */", "#define BHPOS           19      /*\tEnd position for BEHIND or NOBEHIND */", ""], "whitespace/tab"]
["src/nvim/regexp.c", ["#define FIRST_NL        ANY + ADD_NL", "#define ANY             20      /*\tMatch any one character. */", "#define ANYOF           21      /* str\tMatch any character in this string. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define ANY             20      /*\tMatch any one character. */", "#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this", "                                 *\tstring. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["#define ANYOF           21      /* str\tMatch any character in this string. */", "#define ANYBUT          22      /* str\tMatch any character not in this", "                                 *\tstring. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define ANYBUT          22      /* str\tMatch any character not in this", "                                 *\tstring. */", "#define IDENT           23      /*\tMatch identifier char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["                                 *\tstring. */", "#define IDENT           23      /*\tMatch identifier char */", "#define SIDENT          24      /*\tMatch identifier char but no digit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define IDENT           23      /*\tMatch identifier char */", "#define SIDENT          24      /*\tMatch identifier char but no digit */", "#define KWORD           25      /*\tMatch keyword char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SIDENT          24      /*\tMatch identifier char but no digit */", "#define KWORD           25      /*\tMatch keyword char */", "#define SKWORD          26      /*\tMatch word char but no digit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define KWORD           25      /*\tMatch keyword char */", "#define SKWORD          26      /*\tMatch word char but no digit */", "#define FNAME           27      /*\tMatch file name char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SKWORD          26      /*\tMatch word char but no digit */", "#define FNAME           27      /*\tMatch file name char */", "#define SFNAME          28      /*\tMatch file name char but no digit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define FNAME           27      /*\tMatch file name char */", "#define SFNAME          28      /*\tMatch file name char but no digit */", "#define PRINT           29      /*\tMatch printable char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SFNAME          28      /*\tMatch file name char but no digit */", "#define PRINT           29      /*\tMatch printable char */", "#define SPRINT          30      /*\tMatch printable char but no digit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define PRINT           29      /*\tMatch printable char */", "#define SPRINT          30      /*\tMatch printable char but no digit */", "#define WHITE           31      /*\tMatch whitespace char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define SPRINT          30      /*\tMatch printable char but no digit */", "#define WHITE           31      /*\tMatch whitespace char */", "#define NWHITE          32      /*\tMatch non-whitespace char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define WHITE           31      /*\tMatch whitespace char */", "#define NWHITE          32      /*\tMatch non-whitespace char */", "#define DIGIT           33      /*\tMatch digit char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NWHITE          32      /*\tMatch non-whitespace char */", "#define DIGIT           33      /*\tMatch digit char */", "#define NDIGIT          34      /*\tMatch non-digit char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define DIGIT           33      /*\tMatch digit char */", "#define NDIGIT          34      /*\tMatch non-digit char */", "#define HEX             35      /*\tMatch hex char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NDIGIT          34      /*\tMatch non-digit char */", "#define HEX             35      /*\tMatch hex char */", "#define NHEX            36      /*\tMatch non-hex char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define HEX             35      /*\tMatch hex char */", "#define NHEX            36      /*\tMatch non-hex char */", "#define OCTAL           37      /*\tMatch octal char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NHEX            36      /*\tMatch non-hex char */", "#define OCTAL           37      /*\tMatch octal char */", "#define NOCTAL          38      /*\tMatch non-octal char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define OCTAL           37      /*\tMatch octal char */", "#define NOCTAL          38      /*\tMatch non-octal char */", "#define WORD            39      /*\tMatch word char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NOCTAL          38      /*\tMatch non-octal char */", "#define WORD            39      /*\tMatch word char */", "#define NWORD           40      /*\tMatch non-word char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define WORD            39      /*\tMatch word char */", "#define NWORD           40      /*\tMatch non-word char */", "#define HEAD            41      /*\tMatch head char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NWORD           40      /*\tMatch non-word char */", "#define HEAD            41      /*\tMatch head char */", "#define NHEAD           42      /*\tMatch non-head char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define HEAD            41      /*\tMatch head char */", "#define NHEAD           42      /*\tMatch non-head char */", "#define ALPHA           43      /*\tMatch alpha char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NHEAD           42      /*\tMatch non-head char */", "#define ALPHA           43      /*\tMatch alpha char */", "#define NALPHA          44      /*\tMatch non-alpha char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define ALPHA           43      /*\tMatch alpha char */", "#define NALPHA          44      /*\tMatch non-alpha char */", "#define LOWER           45      /*\tMatch lowercase char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NALPHA          44      /*\tMatch non-alpha char */", "#define LOWER           45      /*\tMatch lowercase char */", "#define NLOWER          46      /*\tMatch non-lowercase char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define LOWER           45      /*\tMatch lowercase char */", "#define NLOWER          46      /*\tMatch non-lowercase char */", "#define UPPER           47      /*\tMatch uppercase char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NLOWER          46      /*\tMatch non-lowercase char */", "#define UPPER           47      /*\tMatch uppercase char */", "#define NUPPER          48      /*\tMatch non-uppercase char */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define UPPER           47      /*\tMatch uppercase char */", "#define NUPPER          48      /*\tMatch non-uppercase char */", "#define LAST_NL         NUPPER + ADD_NL"], "whitespace/tab"]
["src/nvim/regexp.c", ["", "#define MOPEN           80  /* -89\t Mark this point in input as start of", "                             *\t \\( subexpr.  MOPEN + 0 marks start of"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["", "#define MOPEN           80  /* -89\t Mark this point in input as start of", "                             *\t \\( subexpr.  MOPEN + 0 marks start of"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define MOPEN           80  /* -89\t Mark this point in input as start of", "                             *\t \\( subexpr.  MOPEN + 0 marks start of", "                             *\t match. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define MOPEN           80  /* -89\t Mark this point in input as start of", "                             *\t \\( subexpr.  MOPEN + 0 marks start of", "                             *\t match. */"], "whitespace/parens"]
["src/nvim/regexp.c", ["                             *\t \\( subexpr.  MOPEN + 0 marks start of", "                             *\t match. */", "#define MCLOSE          90  /* -99\t Analogous to MOPEN.  MCLOSE + 0 marks"], "whitespace/tab"]
["src/nvim/regexp.c", ["                             *\t match. */", "#define MCLOSE          90  /* -99\t Analogous to MOPEN.  MCLOSE + 0 marks", "                             *\t end of match. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["                             *\t match. */", "#define MCLOSE          90  /* -99\t Analogous to MOPEN.  MCLOSE + 0 marks", "                             *\t end of match. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define MCLOSE          90  /* -99\t Analogous to MOPEN.  MCLOSE + 0 marks", "                             *\t end of match. */", "#define BACKREF         100 /* -109 node Match same string again \\1-\\9 */"], "whitespace/tab"]
["src/nvim/regexp.c", ["", "# define ZOPEN          110 /* -119\t Mark this point in input as start of", "                             *\t \\z( subexpr. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["", "# define ZOPEN          110 /* -119\t Mark this point in input as start of", "                             *\t \\z( subexpr. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["# define ZOPEN          110 /* -119\t Mark this point in input as start of", "                             *\t \\z( subexpr. */", "# define ZCLOSE         120 /* -129\t Analogous to ZOPEN. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["# define ZOPEN          110 /* -119\t Mark this point in input as start of", "                             *\t \\z( subexpr. */", "# define ZCLOSE         120 /* -129\t Analogous to ZOPEN. */"], "whitespace/parens"]
["src/nvim/regexp.c", ["                             *\t \\z( subexpr. */", "# define ZCLOSE         120 /* -129\t Analogous to ZOPEN. */", "# define ZREF           130 /* -139 node Match external submatch \\z1-\\z9 */"], "whitespace/tab"]
["src/nvim/regexp.c", ["", "#define NOPEN           150     /*\tMark this point in input as start of", "                                 \\%( subexpr. */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["", "#define NOPEN           150     /*\tMark this point in input as start of", "                                 \\%( subexpr. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define NOPEN           150     /*\tMark this point in input as start of", "                                 \\%( subexpr. */", "#define NCLOSE          151     /*\tAnalogous to NOPEN. */"], "whitespace/parens"]
["src/nvim/regexp.c", ["                                 \\%( subexpr. */", "#define NCLOSE          151     /*\tAnalogous to NOPEN. */", ""], "whitespace/tab"]
["src/nvim/regexp.c", ["", "#define MULTIBYTECODE   200     /* mbc\tMatch one multi-byte character */", "#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define MULTIBYTECODE   200     /* mbc\tMatch one multi-byte character */", "#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */", "#define RE_EOF          202     /*\tMatch \"\" at end of file. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */", "#define RE_EOF          202     /*\tMatch \"\" at end of file. */", "#define CURSOR          203     /*\tMatch location of cursor. */"], "whitespace/tab"]
["src/nvim/regexp.c", ["#define RE_EOF          202     /*\tMatch \"\" at end of file. */", "#define CURSOR          203     /*\tMatch location of cursor. */", ""], "whitespace/tab"]
["src/nvim/regexp.c", ["#define RE_MARK         207     /* mark cmp  Match mark position */", "#define RE_VISUAL       208     /*\tMatch Visual area */", "#define RE_COMPOSING    209     // any composing characters"], "whitespace/tab"]
["src/nvim/regexp.c", ["  } rs_un;                      /* room for saving reginput */", "  short rs_no;                  /* submatch nr or BEHIND/NOBEHIND */", "} regitem_T;"], "runtime/int"]
["src/nvim/regexp.c", [" * rc_did_emsg and return NULL */", "#define EMSG_RET_NULL(m) return (EMSG(m), rc_did_emsg = TRUE, (void *)NULL)", "#define EMSG_RET_FAIL(m) return (EMSG(m), rc_did_emsg = TRUE, FAIL)"], "readability/bool"]
["src/nvim/regexp.c", ["#define EMSG_RET_NULL(m) return (EMSG(m), rc_did_emsg = TRUE, (void *)NULL)", "#define EMSG_RET_FAIL(m) return (EMSG(m), rc_did_emsg = TRUE, FAIL)", "#define EMSG2_RET_NULL(m, \\"], "readability/bool"]
["src/nvim/regexp.c", ["                       c) return (EMSG2((m), \\", "                                      (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, \\", "                                  (void *)NULL)"], "readability/bool"]
["src/nvim/regexp.c", ["                       c) return (EMSG2((m), \\", "                                      (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, \\", "                                  FAIL)"], "readability/bool"]
["src/nvim/regexp.c", [" */", "static short class_tab[256];", ""], "runtime/int"]
["src/nvim/regexp.c", ["  int i;", "  static int done = FALSE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["  class_tab['\\t'] |= RI_WHITE;", "  done = TRUE;", "}"], "readability/bool"]
["src/nvim/regexp.c", ["static int had_eol;             /* TRUE when EOL found by vim_regcomp() */", "static int one_exactly = FALSE;         /* only do one char for EXACTLY */", ""], "readability/bool"]
["src/nvim/regexp.c", ["", "static int reg_string;          /* matching with a string instead of a buffer", "                                   line */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "  /*\t\t   %  &     (  )  *  +\t      .    */", "  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,", "  /*     1  2  3\t4  5  6  7  8  9\t<  =  >  ? */", "  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,", "  /*  @  A     C\tD     F     H  I     K\tL  M\t O */", "  1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,", "  /*  P\t     S\t   U  V  W  X\t  Z  [\t\t _ */", "  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,", "  /*     a     c\td     f     h  i     k\tl  m  n  o */", "  0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,"], "whitespace/tab"]
["src/nvim/regexp.c", ["  0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,", "  /*  p\t     s\t   u  v  w  x\t  z  {\t|     ~    */", "  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1"], "whitespace/tab"]
["src/nvim/regexp.c", ["    case '\\303': case '\\304': case '\\305':", "      regmbc('A'); regmbc('\\300'); regmbc('\\301');", "      regmbc('\\302'); regmbc('\\303'); regmbc('\\304');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('A'); regmbc('\\300'); regmbc('\\301');", "      regmbc('\\302'); regmbc('\\303'); regmbc('\\304');", "      regmbc('\\305');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a) CASEMBC(0x10c)", "      regmbc('C'); regmbc('\\307');", "      REGMBC(0x106) REGMBC(0x108) REGMBC(0x10a)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x11a) CASEMBC(0x1eba) CASEMBC(0x1ebc)", "      regmbc('E'); regmbc('\\310'); regmbc('\\311');", "      regmbc('\\312'); regmbc('\\313');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('E'); regmbc('\\310'); regmbc('\\311');", "      regmbc('\\312'); regmbc('\\313');", "      REGMBC(0x112) REGMBC(0x114) REGMBC(0x116)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x130) CASEMBC(0x1cf) CASEMBC(0x1ec8)", "      regmbc('I'); regmbc('\\314'); regmbc('\\315');", "      regmbc('\\316'); regmbc('\\317');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('I'); regmbc('\\314'); regmbc('\\315');", "      regmbc('\\316'); regmbc('\\317');", "      REGMBC(0x128) REGMBC(0x12a) REGMBC(0x12c)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1e48)", "      regmbc('N'); regmbc('\\321');", "      REGMBC(0x143) REGMBC(0x145) REGMBC(0x147)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1d1) CASEMBC(0x1ea) CASEMBC(0x1ec) CASEMBC(0x1ece)", "      regmbc('O'); regmbc('\\322'); regmbc('\\323');", "      regmbc('\\324'); regmbc('\\325'); regmbc('\\326');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('O'); regmbc('\\322'); regmbc('\\323');", "      regmbc('\\324'); regmbc('\\325'); regmbc('\\326');", "      regmbc('\\330');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1ee6)", "      regmbc('U'); regmbc('\\331'); regmbc('\\332');", "      regmbc('\\333'); regmbc('\\334');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('U'); regmbc('\\331'); regmbc('\\332');", "      regmbc('\\333'); regmbc('\\334');", "      REGMBC(0x168) REGMBC(0x16a) REGMBC(0x16c)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1ef6) CASEMBC(0x1ef8)", "      regmbc('Y'); regmbc('\\335');", "      REGMBC(0x176) REGMBC(0x178) REGMBC(0x1e8e)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1df) CASEMBC(0x1e1) CASEMBC(0x1ea3)", "      regmbc('a'); regmbc('\\340'); regmbc('\\341');", "      regmbc('\\342'); regmbc('\\343'); regmbc('\\344');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('a'); regmbc('\\340'); regmbc('\\341');", "      regmbc('\\342'); regmbc('\\343'); regmbc('\\344');", "      regmbc('\\345');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x107) CASEMBC(0x109) CASEMBC(0x10b) CASEMBC(0x10d)", "      regmbc('c'); regmbc('\\347');", "      REGMBC(0x107) REGMBC(0x109) REGMBC(0x10b)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x11b) CASEMBC(0x1ebb) CASEMBC(0x1ebd)", "      regmbc('e'); regmbc('\\350'); regmbc('\\351');", "      regmbc('\\352'); regmbc('\\353');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('e'); regmbc('\\350'); regmbc('\\351');", "      regmbc('\\352'); regmbc('\\353');", "      REGMBC(0x113) REGMBC(0x115) REGMBC(0x117)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1d0) CASEMBC(0x1ec9)", "      regmbc('i'); regmbc('\\354'); regmbc('\\355');", "      regmbc('\\356'); regmbc('\\357');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('i'); regmbc('\\354'); regmbc('\\355');", "      regmbc('\\356'); regmbc('\\357');", "      REGMBC(0x129) REGMBC(0x12b) REGMBC(0x12d)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1e45) CASEMBC(0x1e49)", "      regmbc('n'); regmbc('\\361');", "      REGMBC(0x144) REGMBC(0x146) REGMBC(0x148)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1d2) CASEMBC(0x1eb) CASEMBC(0x1ed) CASEMBC(0x1ecf)", "      regmbc('o'); regmbc('\\362'); regmbc('\\363');", "      regmbc('\\364'); regmbc('\\365'); regmbc('\\366');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('o'); regmbc('\\362'); regmbc('\\363');", "      regmbc('\\364'); regmbc('\\365'); regmbc('\\366');", "      regmbc('\\370');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1ee7)", "      regmbc('u'); regmbc('\\371'); regmbc('\\372');", "      regmbc('\\373'); regmbc('\\374');"], "whitespace/newline"]
["src/nvim/regexp.c", ["      regmbc('u'); regmbc('\\371'); regmbc('\\372');", "      regmbc('\\373'); regmbc('\\374');", "      REGMBC(0x169) REGMBC(0x16b) REGMBC(0x16d)"], "whitespace/newline"]
["src/nvim/regexp.c", ["      CASEMBC(0x1ef3) CASEMBC(0x1ef7) CASEMBC(0x1ef9)", "      regmbc('y'); regmbc('\\375'); regmbc('\\377');", "      REGMBC(0x177) REGMBC(0x1e8f) REGMBC(0x1e99)"], "whitespace/newline"]
["src/nvim/regexp.c", ["        mb_ptr_adv(p);", "    } else if (*p == '\\\\'", "               && (vim_strchr(REGEXP_INRANGE, p[1]) != NULL"], "readability/braces"]
["src/nvim/regexp.c", ["        ++p;         /* It is not a class name and not NUL */", "    } else", "      ++p;"], "readability/braces"]
["src/nvim/regexp.c", ["        STRMOVE(p, p + 1);", "      } else", "        ++p;            /* skip next character */"], "readability/braces"]
["src/nvim/regexp.c", [" */", "static void ", "regcomp_start ("], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["static void ", "regcomp_start (", "    char_u *expr,"], "whitespace/parens"]
["src/nvim/regexp.c", ["  regsize = 0L;", "  reg_toolong = FALSE;", "  regflags = 0;"], "readability/bool"]
["src/nvim/regexp.c", ["  regflags = 0;", "  had_eol = FALSE;", "}"], "readability/bool"]
["src/nvim/regexp.c", ["static char_u *", "reg (", "    int paren,              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */"], "whitespace/parens"]
["src/nvim/regexp.c", ["reg (", "    int paren,              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */", "    int *flagp"], "whitespace/line_length"]
["src/nvim/regexp.c", ["    ret = regnode(NOPEN);", "  } else", "    ret = NULL;"], "readability/braces"]
["src/nvim/regexp.c", ["  if (paren == REG_PAREN)", "    had_endbrace[parno] = TRUE;         /* have seen the close paren */", "  return ret;"], "readability/bool"]
["src/nvim/regexp.c", ["  int flags;", "  int cont = TRUE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["    case Magic(')'):", "      cont = FALSE;", "      break;"], "readability/bool"]
["src/nvim/regexp.c", ["      reginsert(STAR, ret);", "    else {", "      /* Emit x* as (x&|), where & means \"self\". */"], "readability/braces"]
["src/nvim/regexp.c", ["      reginsert(PLUS, ret);", "    else {", "      /* Emit x+ as x(&|), where & means \"self\". */"], "readability/braces"]
["src/nvim/regexp.c", ["      reginsert_nr(lop, (uint32_t)nr, ret);", "    } else", "      reginsert(lop, ret);"], "readability/braces"]
["src/nvim/regexp.c", ["    if (peekchr() == Magic('*'))", "      sprintf((char *)IObuff, _(\"E61: Nested %s*\"),", "          reg_magic >= MAGIC_ON ? \"\" : \"\\\\\");"], "runtime/printf"]
["src/nvim/regexp.c", ["    else", "      sprintf((char *)IObuff, _(\"E62: Nested %s%c\"),", "          reg_magic == MAGIC_ALL ? \"\" : \"\\\\\", no_Magic(peekchr()));"], "runtime/printf"]
["src/nvim/regexp.c", ["    ret = regnode(EOL);", "    had_eol = TRUE;", "    break;"], "readability/bool"]
["src/nvim/regexp.c", ["      ret = regnode(EOL);", "      had_eol = TRUE;", "      break;"], "readability/bool"]
["src/nvim/regexp.c", ["    c = no_Magic(c);", "    sprintf((char *)IObuff, _(\"E64: %s%c follows nothing\"),", "        (c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL)"], "runtime/printf"]
["src/nvim/regexp.c", ["      }", "    } else", "      EMSG_RET_NULL(_(e_nopresub));"], "readability/braces"]
["src/nvim/regexp.c", ["          ungetchr();", "          one_exactly = TRUE;", "          lastnode = regatom(flagp);"], "readability/bool"]
["src/nvim/regexp.c", ["          lastnode = regatom(flagp);", "          one_exactly = FALSE;", "          if (lastnode == NULL)"], "readability/bool"]
["src/nvim/regexp.c", ["              br = OPERAND(br);", "            } else", "              br = regnext(br);"], "readability/braces"]
["src/nvim/regexp.c", ["            regsize += 2;", "          else {", "            *regcode++ = c;"], "readability/braces"]
["src/nvim/regexp.c", ["            regsize += 5;", "          else {", "            /* put the number and the optional"], "readability/braces"]
["src/nvim/regexp.c", ["          regparse++;", "        } else", "          ret = regnode(ANYOF + extra);"], "readability/braces"]
["src/nvim/regexp.c", ["           */", "          else if (*regparse == '\\\\'", "                   && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL"], "whitespace/newline"]
["src/nvim/regexp.c", ["        break;", "      } else if (reg_strict)", "        EMSG2_RET_NULL(_(e_missingbracket), reg_magic > MAGIC_OFF);"], "readability/braces"]
["src/nvim/regexp.c", ["        }", "      } else", "        regc(c);"], "readability/braces"]
["src/nvim/regexp.c", ["  return ret;", "}", ""], "readability/fn_size"]
["src/nvim/regexp.c", ["    regsize += 3;", "  else {", "    *regcode++ = op;"], "readability/braces"]
["src/nvim/regexp.c", ["  if (offset > 0xffff)", "    reg_toolong = TRUE;", "  else {"], "readability/bool"]
["src/nvim/regexp.c", ["    reg_toolong = TRUE;", "  else {", "    *(scan + 1) = (char_u) (((unsigned)offset >> 8) & 0377);"], "readability/braces"]
["src/nvim/regexp.c", ["  curchr = prevprevchr = prevchr = nextchr = -1;", "  at_start = TRUE;", "  prev_at_start = FALSE;"], "readability/bool"]
["src/nvim/regexp.c", ["  at_start = TRUE;", "  prev_at_start = FALSE;", "}"], "readability/bool"]
["src/nvim/regexp.c", ["{", "  static int after_slash = FALSE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["      curchr = Magic('^');", "      at_start = TRUE;", "      prev_at_start = FALSE;"], "readability/bool"]
["src/nvim/regexp.c", ["      at_start = TRUE;", "      prev_at_start = FALSE;", "    }"], "readability/bool"]
["src/nvim/regexp.c", ["      prev_at_start = at_start;", "      at_start = FALSE;               /* be able to say \"/\\*ptr\" */", "      ++regparse;"], "readability/bool"]
["src/nvim/regexp.c", ["      curchr = backslash_trans(c);", "    } else if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))", "      curchr = toggle_Magic(c);"], "readability/braces"]
["src/nvim/regexp.c", ["      curchr = toggle_Magic(c);", "    else {", "      /*"], "readability/braces"]
["src/nvim/regexp.c", ["  prev_at_start = at_start;", "  at_start = FALSE;", "  prevprevchr = prevchr;"], "readability/bool"]
["src/nvim/regexp.c", ["  at_start = prev_at_start;", "  prev_at_start = FALSE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["{", "  int reverse = FALSE;", "  char_u      *first_char;"], "readability/bool"]
["src/nvim/regexp.c", ["    regparse++;", "    reverse = TRUE;", "  }"], "readability/bool"]
["src/nvim/regexp.c", ["      *maxval = MAX_LIMIT;", "  } else if (ascii_isdigit(*first_char))", "    *maxval = *minval;              /* It was \\{n} or \\{-n} */"], "readability/braces"]
["src/nvim/regexp.c", ["  if (*regparse != '}') {", "    sprintf((char *)IObuff, _(\"E554: Syntax error in %s{...}\"),", "        reg_magic == MAGIC_ALL ? \"\" : \"\\\\\");"], "runtime/printf"]
["src/nvim/regexp.c", ["", "static int need_clear_subexpr;          /* subexpressions still need to be", "                                         * cleared */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["                                         * cleared */", "static int need_clear_zsubexpr = FALSE;         /* extmatch subexpressions", "                                                 * still need to be cleared */"], "readability/multiline_comment"]
["src/nvim/regexp.c", ["                                         * cleared */", "static int need_clear_zsubexpr = FALSE;         /* extmatch subexpressions", "                                                 * still need to be cleared */"], "readability/bool"]
["src/nvim/regexp.c", ["      *(posp) = (savep)->se_u.pos; \\", "    else \\", "      *(pp) = (savep)->se_u.ptr; }"], "whitespace/newline"]
["src/nvim/regexp.c", ["    return (char_u *)\"\";", "  return ml_get_buf(reg_buf, reg_firstlnum + lnum, FALSE);", "}"], "readability/bool"]
["src/nvim/regexp.c", [" */", "static int ", "bt_regexec_nl ("], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["static int ", "bt_regexec_nl (", "    regmatch_T *rmp,"], "whitespace/parens"]
["src/nvim/regexp.c", ["  ireg_ic = rmp->rm_ic;", "  ireg_icombine = FALSE;", "  ireg_maxcol = 0;"], "readability/bool"]
["src/nvim/regexp.c", ["/// Uses curbuf for line count and 'iskeyword'.", "/// ", "/// @param win Window in which to search or NULL"], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["/// @param buf Buffer in which to search", "/// @param lnum Number of line to start looking for match ", "/// @param col Column to start looking for match"], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["  reg_maxline = reg_buf->b_ml.ml_line_count - lnum;", "  reg_line_lbr = FALSE;", "  ireg_ic = rmp->rmm_ic;"], "readability/bool"]
["src/nvim/regexp.c", ["  ireg_ic = rmp->rmm_ic;", "  ireg_icombine = FALSE;", "  ireg_maxcol = rmp->rmm_maxcol;"], "readability/bool"]
["src/nvim/regexp.c", ["  if (prog->regflags & RF_ICASE)", "    ireg_ic = TRUE;", "  else if (prog->regflags & RF_NOICASE)"], "readability/bool"]
["src/nvim/regexp.c", ["  else if (prog->regflags & RF_NOICASE)", "    ireg_ic = FALSE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["  if (prog->regflags & RF_ICOMBINE)", "    ireg_icombine = TRUE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["      }", "    else if (!ireg_ic || (!enc_utf8 && mb_char2len(c) > 1))", "      while ((s = vim_strchr(s, c)) != NULL) {"], "whitespace/newline"]
["src/nvim/regexp.c", ["      }", "    else", "      while ((s = cstrchr(s, c)) != NULL) {"], "whitespace/newline"]
["src/nvim/regexp.c", ["  reglnum = 0;", "  reg_toolong = FALSE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["  reginput = regline + col;", "  need_clear_subexpr = TRUE;", "  /* Clear the external match subpointers if necessary. */"], "readability/bool"]
["src/nvim/regexp.c", ["  if (prog->reghasz == REX_SET)", "    need_clear_zsubexpr = TRUE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["      reg_endpos[0].col = (int)(reginput - regline);", "    } else", "      /* Use line number of \"\\ze\". */"], "readability/braces"]
["src/nvim/regexp.c", ["  if (reg_buf != curbuf || VIsual.lnum == 0)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["  if (lnum < top.lnum || lnum > bot.lnum)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["        || (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))", "      return FALSE;", "  } else if (mode == Ctrl_V) {"], "readability/bool"]
["src/nvim/regexp.c", ["    if (cols < start || cols > end - (*p_sel == 'e'))", "      return FALSE;", "  }"], "readability/bool"]
["src/nvim/regexp.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/regexp.c", [" */", "static int ", "regmatch ("], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["static int ", "regmatch (", "    char_u *scan              /* Current node. */"], "whitespace/parens"]
["src/nvim/regexp.c", ["", "          pos = getmark_buf(reg_buf, mark, FALSE);", "          if (pos == NULL                    /* mark doesn't exist */"], "readability/bool"]
["src/nvim/regexp.c", ["              }", "            } else", "              for (i = 0; i < len; ++i)"], "readability/braces"]
["src/nvim/regexp.c", ["            reginput += len;", "          } else", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            p->bp_scan = scan;", "          } else if (reg_save_equal(&bp[i].bp_pos))", "            /* Still at same position as last time, fail. */"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["            next = OPERAND(scan);               /* Avoid recursion. */", "          else {", "            rp = regstack_push(RS_BRANCH, scan);"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_FAIL;", "            else {", "              rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                rp->rs_no = no;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                reg_save(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["                rst.nextb_ic = vim_toupper(rst.nextb);", "            } else", "              rst.nextb_ic = rst.nextb;"], "readability/braces"]
["src/nvim/regexp.c", ["                status = RA_FAIL;", "              else {", "                *(((regstar_T *)rp) - 1) = rst;"], "readability/braces"]
["src/nvim/regexp.c", ["            }", "          } else", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["            status = RA_NOMATCH;", "", "        }"], "whitespace/blank_line"]
["src/nvim/regexp.c", ["            status = RA_FAIL;", "          else {", "            rp->rs_no = op;"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_FAIL;", "            else {", "              /* Need to save the subexpr to be able to restore them"], "readability/braces"]
["src/nvim/regexp.c", ["              status = RA_NOMATCH;", "          } else if (behind_pos.rs_u.ptr != reginput)", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["      scan = next;", "", "    } /* end of inner loop */"], "whitespace/blank_line"]
["src/nvim/regexp.c", ["          regstack_pop(&scan);", "        else {", "          if (status != RA_BREAK) {"], "readability/braces"]
["src/nvim/regexp.c", ["          status = RA_NOMATCH;", "        else {", "          status = RA_CONT;"], "readability/braces"]
["src/nvim/regexp.c", ["                &backpos);", "          else {", "            /* But we didn't want a match.  Need to restore the"], "readability/braces"]
["src/nvim/regexp.c", ["                no = FAIL;", "              else {", "                reg_restore(&rp->rs_un.regsave, &backpos);"], "readability/braces"]
["src/nvim/regexp.c", ["              no = FAIL;", "            else {", "              mb_ptr_back(regline, rp->rs_un.regsave.rs_u.ptr);"], "readability/braces"]
["src/nvim/regexp.c", ["                fast_breakcheck();", "              } else", "                mb_ptr_back(regline, reginput);"], "readability/braces"]
["src/nvim/regexp.c", ["              break;", "          } else", "            status = RA_NOMATCH;"], "readability/braces"]
["src/nvim/regexp.c", ["      if (status == RA_FAIL)", "        got_int = TRUE;", "      return status == RA_MATCH;"], "readability/bool"]
["src/nvim/regexp.c", ["    }", "", "  } /* End of loop until the regstack is empty. */"], "whitespace/blank_line"]
["src/nvim/regexp.c", ["  /* NOTREACHED */", "}", ""], "readability/fn_size"]
["src/nvim/regexp.c", [" */", "static int ", "regrepeat ("], "whitespace/end_of_line"]
["src/nvim/regexp.c", ["static int ", "regrepeat (", "    char_u *p,"], "whitespace/parens"]
["src/nvim/regexp.c", ["  case IDENT + ADD_NL:", "    testval = TRUE;", "  /*FALLTHROUGH*/"], "readability/bool"]
["src/nvim/regexp.c", ["          break;", "      } else if (reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))", "        ++scan;"], "readability/braces"]
["src/nvim/regexp.c", ["  case KWORD + ADD_NL:", "    testval = TRUE;", "  /*FALLTHROUGH*/"], "readability/bool"]
["src/nvim/regexp.c", ["          break;", "      } else if (reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))", "        ++scan;"], "readability/braces"]
["src/nvim/regexp.c", ["  case FNAME + ADD_NL:", "    testval = TRUE;", "  /*FALLTHROUGH*/"], "readability/bool"]
["src/nvim/regexp.c", ["          break;", "      } else if (reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))", "        ++scan;"], "readability/braces"]
["src/nvim/regexp.c", ["  case PRINT + ADD_NL:", "    testval = TRUE;", "  /*FALLTHROUGH*/"], "readability/bool"]
["src/nvim/regexp.c", ["        mb_ptr_adv(scan);", "      } else if (reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))", "        ++scan;"], "readability/braces"]
["src/nvim/regexp.c", ["        scan += l;", "      } else if ((class_tab[*scan] & mask) == testval)", "        ++scan;"], "readability/braces"]
["src/nvim/regexp.c", ["  case ANYOF + ADD_NL:", "    testval = TRUE;", "  /*FALLTHROUGH*/"], "readability/bool"]
["src/nvim/regexp.c", ["          break;", "      } else if (reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))", "        ++scan;"], "readability/braces"]
["src/nvim/regexp.c", ["    /* For NFA matcher we don't check the magic */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["    EMSG(_(e_re_corr));", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/regexp.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/regexp.c", ["    }", "    need_clear_subexpr = FALSE;", "  }"], "readability/bool"]
["src/nvim/regexp.c", ["    }", "    need_clear_zsubexpr = FALSE;", "  }"], "readability/bool"]
["src/nvim/regexp.c", ["    save->rs_u.pos.lnum = reglnum;", "  } else", "    save->rs_u.ptr = reginput;"], "readability/braces"]
["src/nvim/regexp.c", ["    reginput = regline + save->rs_u.pos.col;", "  } else", "    reginput = save->rs_u.ptr;"], "readability/braces"]
["src/nvim/regexp.c", [" */", "static int match_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen)", "{"], "whitespace/line_length"]
["src/nvim/regexp.c", ["    op = OP(s);", "    fprintf(f, \"%2d%s\", (int)(s - r->program), regprop(s));     /* Where, what. */", "    next = regnext(s);"], "whitespace/line_length"]
["src/nvim/regexp.c", ["  case MOPEN + 9:", "    sprintf(buf + STRLEN(buf), \"MOPEN%d\", OP(op) - MOPEN);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case MCLOSE + 9:", "    sprintf(buf + STRLEN(buf), \"MCLOSE%d\", OP(op) - MCLOSE);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case BACKREF + 9:", "    sprintf(buf + STRLEN(buf), \"BACKREF%d\", OP(op) - BACKREF);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case ZOPEN + 9:", "    sprintf(buf + STRLEN(buf), \"ZOPEN%d\", OP(op) - ZOPEN);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case ZCLOSE + 9:", "    sprintf(buf + STRLEN(buf), \"ZCLOSE%d\", OP(op) - ZCLOSE);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case ZREF + 9:", "    sprintf(buf + STRLEN(buf), \"ZREF%d\", OP(op) - ZREF);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  case BRACE_COMPLEX + 9:", "    sprintf(buf + STRLEN(buf), \"BRACE_COMPLEX%d\", OP(op) - BRACE_COMPLEX);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["  default:", "    sprintf(buf + STRLEN(buf), \"corrupt %d\", OP(op));", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp.c", ["{", "  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */"], "whitespace/tab"]
["src/nvim/regexp.c", ["{", "  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e2,0,0},                  /* 0xfb20\talt ayin */", "  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d0,0,0},                  /* 0xfb21\talt alef */", "  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d3,0,0},                  /* 0xfb22\talt dalet */", "  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d4,0,0},                  /* 0xfb23\talt he */", "  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5db,0,0},                  /* 0xfb24\talt kaf */", "  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5dc,0,0},                  /* 0xfb25\talt lamed */", "  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */", "  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e8,0,0},                  /* 0xfb27\talt resh */", "  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0x5ea,0,0},                  /* 0xfb28\talt tav */", "  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {'+', 0, 0},                  /* 0xfb29\talt plus */", "  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */", "  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */", "  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */", "  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */", "  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */", "  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */", "  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */", "  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */", "  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */", "  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */", "  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */", "  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */", "  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */", "  {0xfb37, 0, 0},               /* 0xfb37 -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb37, 0, 0},               /* 0xfb37 -- */", "  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */", "  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */", "  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */", "  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */", "  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */", "  {0xfb3d, 0, 0},               /* 0xfb3d -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb3d, 0, 0},               /* 0xfb3d -- */", "  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */", "  {0xfb3f, 0, 0},               /* 0xfb3f -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb3f, 0, 0},               /* 0xfb3f -- */", "  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */", "  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */", "  {0xfb42, 0, 0},               /* 0xfb42 -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0xfb42, 0, 0},               /* 0xfb42 -- */", "  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */", "  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */", "  {0xfb45, 0, 0},               /* 0xfb45 -- */"], "whitespace/comma"]
["src/nvim/regexp.c", ["  {0xfb45, 0, 0},               /* 0xfb45 -- */", "  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */", "  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */", "  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */", "  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */", "  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */", "  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */", "  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */", "  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */", "  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */"], "whitespace/tab"]
["src/nvim/regexp.c", ["  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */", "  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */", "};"], "whitespace/tab"]
["src/nvim/regexp.c", ["    result = STRNCMP(s1, s2, *n);", "  else {", "    assert(*n >= 0);"], "readability/braces"]
["src/nvim/regexp.c", ["          return p;", "      } else if (*p == c || *p == cc)", "        return p;"], "readability/braces"]
["src/nvim/regexp.c", ["    }", "  } else", "    /* Faster version for when there are no multi-byte characters. */"], "readability/braces"]
["src/nvim/regexp.c", ["        p = newsub + len + prevlen;", "      } else if (magic)", "        STRMOVE(p, p + 1);              /* remove '~' */"], "readability/braces"]
["src/nvim/regexp.c", ["", "static int can_f_submatch = FALSE;      /* TRUE when submatch() can be used */", ""], "readability/bool"]
["src/nvim/regexp.c", [" */", "int vim_regsub(regmatch_T *rmp, char_u *source, char_u *dest, int copy, int magic, int backslash)", "{"], "whitespace/line_length"]
["src/nvim/regexp.c", ["  reg_buf = curbuf;", "  reg_line_lbr = TRUE;", "  return vim_regsub_both(source, dest, copy, magic, backslash);"], "readability/bool"]
["src/nvim/regexp.c", ["", "int vim_regsub_multi(regmmatch_T *rmp, linenr_T lnum, char_u *source, char_u *dest, int copy, int magic, int backslash)", "{"], "whitespace/line_length"]
["src/nvim/regexp.c", ["  reg_maxline = curbuf->b_ml.ml_line_count - lnum;", "  reg_line_lbr = FALSE;", "  return vim_regsub_both(source, dest, copy, magic, backslash);"], "readability/bool"]
["src/nvim/regexp.c", ["", "static int vim_regsub_both(char_u *source, char_u *dest, int copy, int magic, int backslash)", "{"], "whitespace/line_length"]
["src/nvim/regexp.c", ["      save_ireg_ic = ireg_ic;", "      can_f_submatch = TRUE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["", "      eval_result = eval_to_string(source + 2, NULL, TRUE);", "      if (eval_result != NULL) {"], "readability/bool"]
["src/nvim/regexp.c", ["      if (eval_result != NULL) {", "        int had_backslash = FALSE;", ""], "readability/bool"]
["src/nvim/regexp.c", ["              *s = CAR;", "            had_backslash = TRUE;", "          }"], "readability/bool"]
["src/nvim/regexp.c", ["      ireg_ic = save_ireg_ic;", "      can_f_submatch = FALSE;", "    }"], "readability/bool"]
["src/nvim/regexp.c", ["    }", "  } else", "    while ((c = *src++) != NUL) {"], "readability/braces"]
["src/nvim/regexp.c", ["          /* Oh no!  \\e already has meaning in subst pat :-( */", "          /* case 'e':   c = ESC;\t++src;\tbreak; */", "          case 'b':   c = Ctrl_H;     ++src;  break;"], "whitespace/tab"]
["src/nvim/regexp.c", ["          }", "        } else if (has_mbyte)", "          c = mb_ptr2char(src - 1);"], "readability/braces"]
["src/nvim/regexp.c", ["          src += totlen - 1;", "        } else if (copy)", "          *dst = cc;"], "readability/braces"]
["src/nvim/regexp.c", ["            s = NULL;", "          else {", "            s = reg_getline(clnum) + reg_mmatch->startpos[no].col;"], "readability/braces"]
["src/nvim/regexp.c", ["                  len = (int)STRLEN(s);", "              } else", "                break;"], "readability/braces"]
["src/nvim/regexp.c", ["                  dst += mb_char2len(cc) - 1;", "                } else if (copy)", "                  *dst = cc;"], "readability/braces"]
["src/nvim/regexp.c", ["      EMSG(_(", "              \"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used \"));", "      regexp_engine = AUTOMATIC_ENGINE;"], "whitespace/line_length"]
["src/nvim/regexp.c", ["        fclose(f);", "      } else", "        EMSG2(\"(NFA) Could not open \\\"%s\\\" to write !!!\","], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */", "  NFA_RANGE,                        /* range of the two previous items", "                                     * (postfix only) */"], "readability/multiline_comment"]
["src/nvim/regexp_nfa.c", ["", "  NFA_CONCAT,                       /* concatenate two previous items (postfix", "                                     * only) */"], "readability/multiline_comment"]
["src/nvim/regexp_nfa.c", ["", "  NFA_CONCAT,                       /* concatenate two previous items (postfix", "                                     * only) */"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["  NFA_END_PATTERN,", "  NFA_COMPOSING,                    /* Next nodes in NFA are part of the", "                                       composing multibyte char */"], "readability/multiline_comment"]
["src/nvim/regexp_nfa.c", ["  /* NFA_FIRST_NL */", "  NFA_ANY,              /*\tMatch any one character. */", "  NFA_IDENT,            /*\tMatch identifier char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_ANY,              /*\tMatch any one character. */", "  NFA_IDENT,            /*\tMatch identifier char */", "  NFA_SIDENT,           /*\tMatch identifier char but no digit */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_IDENT,            /*\tMatch identifier char */", "  NFA_SIDENT,           /*\tMatch identifier char but no digit */", "  NFA_KWORD,            /*\tMatch keyword char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_SIDENT,           /*\tMatch identifier char but no digit */", "  NFA_KWORD,            /*\tMatch keyword char */", "  NFA_SKWORD,           /*\tMatch word char but no digit */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_KWORD,            /*\tMatch keyword char */", "  NFA_SKWORD,           /*\tMatch word char but no digit */", "  NFA_FNAME,            /*\tMatch file name char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_SKWORD,           /*\tMatch word char but no digit */", "  NFA_FNAME,            /*\tMatch file name char */", "  NFA_SFNAME,           /*\tMatch file name char but no digit */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_FNAME,            /*\tMatch file name char */", "  NFA_SFNAME,           /*\tMatch file name char but no digit */", "  NFA_PRINT,            /*\tMatch printable char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_SFNAME,           /*\tMatch file name char but no digit */", "  NFA_PRINT,            /*\tMatch printable char */", "  NFA_SPRINT,           /*\tMatch printable char but no digit */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_PRINT,            /*\tMatch printable char */", "  NFA_SPRINT,           /*\tMatch printable char but no digit */", "  NFA_WHITE,            /*\tMatch whitespace char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_SPRINT,           /*\tMatch printable char but no digit */", "  NFA_WHITE,            /*\tMatch whitespace char */", "  NFA_NWHITE,           /*\tMatch non-whitespace char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_WHITE,            /*\tMatch whitespace char */", "  NFA_NWHITE,           /*\tMatch non-whitespace char */", "  NFA_DIGIT,            /*\tMatch digit char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NWHITE,           /*\tMatch non-whitespace char */", "  NFA_DIGIT,            /*\tMatch digit char */", "  NFA_NDIGIT,           /*\tMatch non-digit char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_DIGIT,            /*\tMatch digit char */", "  NFA_NDIGIT,           /*\tMatch non-digit char */", "  NFA_HEX,              /*\tMatch hex char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NDIGIT,           /*\tMatch non-digit char */", "  NFA_HEX,              /*\tMatch hex char */", "  NFA_NHEX,             /*\tMatch non-hex char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_HEX,              /*\tMatch hex char */", "  NFA_NHEX,             /*\tMatch non-hex char */", "  NFA_OCTAL,            /*\tMatch octal char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NHEX,             /*\tMatch non-hex char */", "  NFA_OCTAL,            /*\tMatch octal char */", "  NFA_NOCTAL,           /*\tMatch non-octal char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_OCTAL,            /*\tMatch octal char */", "  NFA_NOCTAL,           /*\tMatch non-octal char */", "  NFA_WORD,             /*\tMatch word char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NOCTAL,           /*\tMatch non-octal char */", "  NFA_WORD,             /*\tMatch word char */", "  NFA_NWORD,            /*\tMatch non-word char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_WORD,             /*\tMatch word char */", "  NFA_NWORD,            /*\tMatch non-word char */", "  NFA_HEAD,             /*\tMatch head char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NWORD,            /*\tMatch non-word char */", "  NFA_HEAD,             /*\tMatch head char */", "  NFA_NHEAD,            /*\tMatch non-head char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_HEAD,             /*\tMatch head char */", "  NFA_NHEAD,            /*\tMatch non-head char */", "  NFA_ALPHA,            /*\tMatch alpha char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NHEAD,            /*\tMatch non-head char */", "  NFA_ALPHA,            /*\tMatch alpha char */", "  NFA_NALPHA,           /*\tMatch non-alpha char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_ALPHA,            /*\tMatch alpha char */", "  NFA_NALPHA,           /*\tMatch non-alpha char */", "  NFA_LOWER,            /*\tMatch lowercase char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NALPHA,           /*\tMatch non-alpha char */", "  NFA_LOWER,            /*\tMatch lowercase char */", "  NFA_NLOWER,           /*\tMatch non-lowercase char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LOWER,            /*\tMatch lowercase char */", "  NFA_NLOWER,           /*\tMatch non-lowercase char */", "  NFA_UPPER,            /*\tMatch uppercase char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NLOWER,           /*\tMatch non-lowercase char */", "  NFA_UPPER,            /*\tMatch uppercase char */", "  NFA_NUPPER,           /*\tMatch non-uppercase char */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_UPPER,            /*\tMatch uppercase char */", "  NFA_NUPPER,           /*\tMatch non-uppercase char */", "  NFA_LOWER_IC,         /*\tMatch [a-z] */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NUPPER,           /*\tMatch non-uppercase char */", "  NFA_LOWER_IC,         /*\tMatch [a-z] */", "  NFA_NLOWER_IC,        /*\tMatch [^a-z] */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LOWER_IC,         /*\tMatch [a-z] */", "  NFA_NLOWER_IC,        /*\tMatch [^a-z] */", "  NFA_UPPER_IC,         /*\tMatch [A-Z] */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_NLOWER_IC,        /*\tMatch [^a-z] */", "  NFA_UPPER_IC,         /*\tMatch [A-Z] */", "  NFA_NUPPER_IC,        /*\tMatch [^A-Z] */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_UPPER_IC,         /*\tMatch [A-Z] */", "  NFA_NUPPER_IC,        /*\tMatch [^A-Z] */", ""], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "  NFA_CURSOR,           /*\tMatch cursor pos */", "  NFA_LNUM,             /*\tMatch line number */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_CURSOR,           /*\tMatch cursor pos */", "  NFA_LNUM,             /*\tMatch line number */", "  NFA_LNUM_GT,          /*\tMatch > line number */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM,             /*\tMatch line number */", "  NFA_LNUM_GT,          /*\tMatch > line number */", "  NFA_LNUM_LT,          /*\tMatch < line number */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM_GT,          /*\tMatch > line number */", "  NFA_LNUM_LT,          /*\tMatch < line number */", "  NFA_COL,              /*\tMatch cursor column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_LNUM_LT,          /*\tMatch < line number */", "  NFA_COL,              /*\tMatch cursor column */", "  NFA_COL_GT,           /*\tMatch > cursor column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_COL,              /*\tMatch cursor column */", "  NFA_COL_GT,           /*\tMatch > cursor column */", "  NFA_COL_LT,           /*\tMatch < cursor column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_COL_GT,           /*\tMatch > cursor column */", "  NFA_COL_LT,           /*\tMatch < cursor column */", "  NFA_VCOL,             /*\tMatch cursor virtual column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_COL_LT,           /*\tMatch < cursor column */", "  NFA_VCOL,             /*\tMatch cursor virtual column */", "  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL,             /*\tMatch cursor virtual column */", "  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */", "  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */", "  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */", "  NFA_MARK,             /*\tMatch mark */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */", "  NFA_MARK,             /*\tMatch mark */", "  NFA_MARK_GT,          /*\tMatch > mark */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK,             /*\tMatch mark */", "  NFA_MARK_GT,          /*\tMatch > mark */", "  NFA_MARK_LT,          /*\tMatch < mark */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK_GT,          /*\tMatch > mark */", "  NFA_MARK_LT,          /*\tMatch < mark */", "  NFA_VISUAL,           /*\tMatch Visual area */"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["  NFA_MARK_LT,          /*\tMatch < mark */", "  NFA_VISUAL,           /*\tMatch Visual area */", ""], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["static int nfa_classcodes[] = {", "  NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD,NFA_SKWORD,", "  NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,"], "whitespace/comma"]
["src/nvim/regexp_nfa.c", ["  int count;", "  nfa_pim_T pim;                /* if pim.result != NFA_PIM_UNUSED: postponed", "                                 * invisible match */"], "readability/multiline_comment"]
["src/nvim/regexp_nfa.c", ["", "static int nstate;      /* Number of states in the NFA. Also used when", "                         * executing. */"], "readability/multiline_comment"]
["src/nvim/regexp_nfa.c", ["static void", "nfa_regcomp_start (", "    char_u *expr,"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["  post_end = post_start + nstate_max;", "  nfa_has_zend = FALSE;", "  nfa_has_backref = FALSE;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  nfa_has_zend = FALSE;", "  nfa_has_backref = FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["", "  int newl = FALSE;", "  char_u      *p;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["", "  if (extra_newl == TRUE)", "    newl = TRUE;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  if (extra_newl == TRUE)", "    newl = TRUE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    } else if (p + 1 < end && *p == '\\\\' && *(p + 1) == 'n') {", "      newl = TRUE;", "      p += 2;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    } else if (*p == '\\n') {", "      newl = TRUE;", "      p++;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      p++;", "    } else", "      return FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  if (newl == TRUE)", "    extra_newl = NFA_ADD_NL;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["{", "#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);", "#define EMITMBC(c) EMIT(c); EMIT(NFA_CONCAT);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);", "#define EMITMBC(c) EMIT(c); EMIT(NFA_CONCAT);", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x1de) CASEMBC(0x1e0) CASEMBC(0x1ea2)", "      EMIT2('A'); EMIT2(0300); EMIT2(0301); EMIT2(0302);", "      EMIT2(0303); EMIT2(0304); EMIT2(0305);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('A'); EMIT2(0300); EMIT2(0301); EMIT2(0302);", "      EMIT2(0303); EMIT2(0304); EMIT2(0305);", "      EMITMBC(0x100) EMITMBC(0x102) EMITMBC(0x104)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a) CASEMBC(0x10c)", "      EMIT2('C'); EMIT2(0307); EMITMBC(0x106) EMITMBC(0x108)", "      EMITMBC(0x10a) EMITMBC(0x10c)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x11a) CASEMBC(0x1eba) CASEMBC(0x1ebc)", "      EMIT2('E'); EMIT2(0310); EMIT2(0311); EMIT2(0312);", "      EMIT2(0313);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x130) CASEMBC(0x1cf) CASEMBC(0x1ec8)", "      EMIT2('I'); EMIT2(0314); EMIT2(0315); EMIT2(0316);", "      EMIT2(0317); EMITMBC(0x128) EMITMBC(0x12a)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x1e48)", "      EMIT2('N'); EMIT2(0321); EMITMBC(0x143) EMITMBC(0x145)", "      EMITMBC(0x147) EMITMBC(0x1e44) EMITMBC(0x1e48)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x1d1) CASEMBC(0x1ea) CASEMBC(0x1ec) CASEMBC(0x1ece)", "      EMIT2('O'); EMIT2(0322); EMIT2(0323); EMIT2(0324);", "      EMIT2(0325); EMIT2(0326); EMIT2(0330);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('O'); EMIT2(0322); EMIT2(0323); EMIT2(0324);", "      EMIT2(0325); EMIT2(0326); EMIT2(0330);", "      EMITMBC(0x14c) EMITMBC(0x14e) EMITMBC(0x150)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x1ee6)", "      EMIT2('U'); EMIT2(0331); EMIT2(0332); EMIT2(0333);", "      EMIT2(0334); EMITMBC(0x168) EMITMBC(0x16a)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x1ef6) CASEMBC(0x1ef8)", "      EMIT2('Y'); EMIT2(0335); EMITMBC(0x176) EMITMBC(0x178)", "      EMITMBC(0x1e8e) EMITMBC(0x1ef2) EMITMBC(0x1ef6)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x1df) CASEMBC(0x1e1) CASEMBC(0x1ea3)", "      EMIT2('a'); EMIT2(0340); EMIT2(0341); EMIT2(0342);", "      EMIT2(0343); EMIT2(0344); EMIT2(0345);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('a'); EMIT2(0340); EMIT2(0341); EMIT2(0342);", "      EMIT2(0343); EMIT2(0344); EMIT2(0345);", "      EMITMBC(0x101) EMITMBC(0x103) EMITMBC(0x105)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x107) CASEMBC(0x109) CASEMBC(0x10b) CASEMBC(0x10d)", "      EMIT2('c'); EMIT2(0347); EMITMBC(0x107) EMITMBC(0x109)", "      EMITMBC(0x10b) EMITMBC(0x10d)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x11b) CASEMBC(0x1ebb) CASEMBC(0x1ebd)", "      EMIT2('e'); EMIT2(0350); EMIT2(0351); EMIT2(0352);", "      EMIT2(0353); EMITMBC(0x113) EMITMBC(0x115)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x1d0) CASEMBC(0x1ec9)", "      EMIT2('i'); EMIT2(0354); EMIT2(0355); EMIT2(0356);", "      EMIT2(0357); EMITMBC(0x129) EMITMBC(0x12b)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x1e45) CASEMBC(0x1e49)", "      EMIT2('n'); EMIT2(0361); EMITMBC(0x144) EMITMBC(0x146)", "      EMITMBC(0x148) EMITMBC(0x149) EMITMBC(0x1e45)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x1d2) CASEMBC(0x1eb) CASEMBC(0x1ed) CASEMBC(0x1ecf)", "      EMIT2('o'); EMIT2(0362); EMIT2(0363); EMIT2(0364);", "      EMIT2(0365); EMIT2(0366); EMIT2(0370);"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      EMIT2('o'); EMIT2(0362); EMIT2(0363); EMIT2(0364);", "      EMIT2(0365); EMIT2(0366); EMIT2(0370);", "      EMITMBC(0x14d) EMITMBC(0x14f) EMITMBC(0x151)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x1ee7)", "      EMIT2('u'); EMIT2(0371); EMIT2(0372); EMIT2(0373);", "      EMIT2(0374); EMITMBC(0x169) EMITMBC(0x16b)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      CASEMBC(0x1ef3) CASEMBC(0x1ef7) CASEMBC(0x1ef9)", "      EMIT2('y'); EMIT2(0375); EMIT2(0377); EMITMBC(0x177)", "      EMITMBC(0x1e8f) EMITMBC(0x1e99) EMITMBC(0x1ef3)"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["    EMIT(NFA_EOL);", "    had_eol = TRUE;", "    break;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      EMIT(NFA_EOL);", "      had_eol = TRUE;", "      break;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        EMSGN(_(e_ill_char_class), c);", "        rc_did_emsg = TRUE;", "        return FAIL;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      EMIT(NL);", "    else {", "      /* In buffer text \"\\n\" matches the end of a line. */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    EMIT(NFA_BACKREF1 + (no_Magic(c) - '1'));", "    nfa_has_backref = TRUE;", "    break;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["          EMIT(NFA_OR);", "        } else", "          EMIT(result);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      startc = endc = oldstartc = -1;", "      negated = FALSE;", "      if (*regparse == '^') {                           /* negated range */"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      if (*regparse == '^') {                           /* negated range */", "        negated = TRUE;", "        mb_ptr_adv(regparse);"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        EMIT(NFA_START_NEG_COLL);", "      } else", "        EMIT(NFA_START_COLL);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      /* Emit the OR branches for each character in the [] */", "      emit_range = FALSE;", "      while (regparse < endp) {"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        startc = -1;", "        got_coll_char = FALSE;", "        if (*regparse == '[') {"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        if (*regparse == '-' && oldstartc != -1) {", "          emit_range = TRUE;", "          startc = oldstartc;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["            startc = coll_get_char();", "            got_coll_char = TRUE;", "            mb_ptr_back(old_regparse, regparse);"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["          }", "          emit_range = FALSE;", "          startc = -1;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["          } else {", "            if (got_coll_char == TRUE && startc == 0)", "              EMIT(0x0a);"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      /* Mark end of the collection. */", "      if (negated == TRUE)", "        EMIT(NFA_END_NEG_COLL);"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  return OK;", "}", ""], "readability/fn_size"]
["src/nvim/regexp_nfa.c", ["  long minval, maxval;", "  int greedy = TRUE;                /* Braces are prefixed with '-' ? */", "  parse_state_T old_state;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    EMIT(NFA_CONCAT);", "    skipchr();                  /* skip the \\+\t*/", "    break;"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["    i = 0;", "    switch(op) {", "    case '=':"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["", "    greedy = TRUE;", "    c2 = peekchr();"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      skipchr();", "      greedy = FALSE;", "    }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["", "    quest = (greedy == TRUE ? NFA_QUEST : NFA_QUEST_NONGREEDY);", "    for (i = 0; i < maxval; i++) {"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["            EMIT(NFA_STAR_NONGREEDY);", "        } else", "          EMIT(quest);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["{", "  int cont = TRUE;", "  int first = TRUE;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  int cont = TRUE;", "  int first = TRUE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    case Magic(')'):", "      cont = FALSE;", "      break;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        return FAIL;", "      if (first == FALSE)", "        EMIT(NFA_CONCAT);"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      else", "        first = FALSE;", "      break;"], "readability/bool"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "nfa_reg ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "nfa_reg (", "    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["nfa_reg (", "    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */", ")"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["  if (paren == REG_PAREN) {", "    had_endbrace[parno] = TRUE;         /* have seen the close paren */", "    EMIT(NFA_MOPEN + parno);"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    EMIT(NFA_MOPEN + parno);", "  } else if (paren == REG_ZPAREN)", "    EMIT(NFA_ZOPEN + parno);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["{", "  int addnl = FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  if (c >= NFA_FIRST_NL && c <= NFA_LAST_NL) {", "    addnl = TRUE;", "    c -= NFA_ADD_NL;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_NO_WIDTH:", "    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH\"); break;", "  case NFA_PREV_ATOM_NO_WIDTH_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_NO_WIDTH_NEG:", "    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH_NEG\"); break;", "  case NFA_PREV_ATOM_JUST_BEFORE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_JUST_BEFORE:", "    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE\"); break;", "  case NFA_PREV_ATOM_JUST_BEFORE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_JUST_BEFORE_NEG:", "    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE_NEG\"); break;", "  case NFA_PREV_ATOM_LIKE_PATTERN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_LIKE_PATTERN:", "    STRCPY(code, \"NFA_PREV_ATOM_LIKE_PATTERN\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_FIRST\"); break;", "  case NFA_START_INVISIBLE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_NEG:", "    STRCPY(code, \"NFA_START_INVISIBLE_NEG\"); break;", "  case NFA_START_INVISIBLE_NEG_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_NEG_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_NEG_FIRST\"); break;", "  case NFA_START_INVISIBLE_BEFORE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE\"); break;", "  case NFA_START_INVISIBLE_BEFORE_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_FIRST\"); break;", "  case NFA_START_INVISIBLE_BEFORE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_NEG:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG\"); break;", "  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG_FIRST\"); break;", "  case NFA_START_PATTERN:   STRCPY(code, \"NFA_START_PATTERN\"); break;"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["", "  if (addnl == TRUE)", "    STRCAT(code, \" + NEWLINE \");"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    STRCAT(code, \" + NEWLINE \");", "", "}"], "whitespace/blank_line"]
["src/nvim/regexp_nfa.c", ["    STRNCPY(&p[last], save, 2);", "  } else", "    fprintf(debugf, \" %s\", p);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "  if (nfa_calc_size == FALSE) {", "    /* Allocate space for the stack. Max states on the stack : nstate */"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["       * to postfix form in re2post(). */", "      if (nfa_calc_size == TRUE) {", "        /* nstate += 0; */"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      /* Alternation */", "      if (nfa_calc_size == TRUE) {", "        nstate++;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      /* Zero or more, prefer more */", "      if (nfa_calc_size == TRUE) {", "        nstate++;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      /* Zero or more, prefer zero */", "      if (nfa_calc_size == TRUE) {", "        nstate++;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      /* one or zero atoms=> greedy match */", "      if (nfa_calc_size == TRUE) {", "        nstate++;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      /* zero or one atoms => non-greedy match */", "      if (nfa_calc_size == TRUE) {", "        nstate++;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["       * add the output to the start. */", "      if (nfa_calc_size == TRUE) {", "        nstate++;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["       * range.  Turn them into two states with MIN and MAX. */", "      if (nfa_calc_size == TRUE) {", "        /* nstate += 0; */"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      /* 0-length, used in a repetition with max/min count of 0 */", "      if (nfa_calc_size == TRUE) {", "        nstate++;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      n = *++p;       /* get number of characters */", "      if (nfa_calc_size == TRUE) {", "        nstate += n;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["", "      if (nfa_calc_size == TRUE) {", "        nstate += pattern ? 4 : 2;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    case NFA_NOPEN:     /* \\%( \\) \"Invisible Submatch\" */", "      if (nfa_calc_size == TRUE) {", "        nstate += 2;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    case NFA_ZREF9:", "      if (nfa_calc_size == TRUE) {", "        nstate += 2;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["", "      if (nfa_calc_size == TRUE) {", "        nstate += 1;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      /* Operands */", "      if (nfa_calc_size == TRUE) {", "        nstate++;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      break;", "", "    }     /* switch(*p) */"], "whitespace/blank_line"]
["src/nvim/regexp_nfa.c", ["    }     /* switch(*p) */", "", "  }   /* for(p = postfix; *p; ++p) */"], "whitespace/blank_line"]
["src/nvim/regexp_nfa.c", ["", "  if (nfa_calc_size == TRUE) {", "    nstate++;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      if (match_follows(prog->state[i].out1->out, 0))", "        directly = TRUE;", "      else {"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        directly = TRUE;", "      else {", "        int ch_invisible = failure_chance(prog->state[i].out, 0);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          if (prog->state[i].val <= 0 && ch_follows > 0)", "            directly = FALSE;", "          else"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["          (int)sub->list.multi[j].end_lnum);", "    else {", "      char *s = (char *)sub->list.line[j].start;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    buf[0] = NUL;", "  else {", "    sprintf(buf, \" PIM col %d\", REG_MULTI ? (int)pim->end.pos.col"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  else {", "    sprintf(buf, \" PIM col %d\", REG_MULTI ? (int)pim->end.pos.col", "        : (int)(pim->end.ptr - reginput));"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["    if (REG_MULTI) {", "      if (from->list.multi[0].end_lnum >= 0){", "        to->list.multi[0].end_lnum = from->list.multi[0].end_lnum;"], "whitespace/braces"]
["src/nvim/regexp_nfa.c", ["      if (s1 != s2)", "        return FALSE;", "      if (s1 != -1 && sub1->list.multi[i].start_col"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["          != sub2->list.multi[i].start_col)", "        return FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        if (s1 != s2) {", "          return FALSE;", "        }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["            && sub1->list.multi[i].end_col != sub2->list.multi[i].end_col) {", "          return FALSE;", "        }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      if (sp1 != sp2)", "        return FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        if (sp1 != sp2) {", "          return FALSE;", "        }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "has_state_with_pos ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "has_state_with_pos (", "    nfa_list_T *l,         /* runtime state list */"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["        && pim_equal(&thread->pim, pim))", "      return TRUE;", "  }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    /* one is used and two is not: not equal */", "    return FALSE;", "  /* compare the state id */"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  if (one->state->id != two->state->id)", "    return FALSE;", "  /* compare the position */"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  if (depth > 10)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    case NFA_END_PATTERN:", "      return TRUE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      /* state will advance input */", "      return FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        /* state will advance input */", "        return FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "state_in_list ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "state_in_list (", "    nfa_list_T *l,         /* runtime state list */"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["    if (!nfa_has_backref || has_state_with_pos(l, state, subs, NULL))", "      return TRUE;", "  }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["static regsubs_T *", "addstate (", "    nfa_list_T *l,             /* runtime state list */"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["    nfa_pim_T *pim,           /* postponed look-behind match */", "    int off                            /* byte offset, when -1 go to next line */", ")"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["#ifdef REGEXP_DEBUG", "  int did_print = FALSE;", "#endif"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      thread->pim.result = NFA_PIM_UNUSED;", "    else {", "      copy_pim(&thread->pim, pim);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      copy_pim(&thread->pim, pim);", "      l->has_pim = TRUE;", "    }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    report_state(\"Adding\", &thread->subs.norm, state, l->id, pim);", "    did_print = TRUE;", "#endif"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      } else {", "", "        sub->list.multi[subidx].start_lnum = reglnum;"], "whitespace/blank_line"]
["src/nvim/regexp_nfa.c", ["    if (save_in_use == -1) {", "      if (REG_MULTI){", "        sub->list.multi[subidx].start_lnum = save_lpos.lnum;"], "whitespace/braces"]
["src/nvim/regexp_nfa.c", ["      }", "      else", "        sub->list.line[subidx].start = save_ptr;"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["        sub->list.line[subidx].start = save_ptr;", "    } else", "      sub->in_use = save_in_use;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["", "    if (REG_MULTI){", "      sub->list.multi[subidx].end_lnum = save_lpos.lnum;"], "whitespace/braces"]
["src/nvim/regexp_nfa.c", ["    }", "    else", "      sub->list.line[subidx].end = save_ptr;"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", [" */", "static void ", "addstate_here ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static void ", "addstate_here (", "    nfa_list_T *l,         /* runtime state list */"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "match_backref ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "match_backref (", "    regsub_T *sub,           /* pointers to subexpressions */"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["    *bytelen = 0;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        *bytelen = len;", "        return TRUE;", "      }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["              bytelen) == RA_MATCH)", "        return TRUE;", "    }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      *bytelen = len;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "match_zref ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "match_zref (", "    int subidx,"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["    *bytelen = 0;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    *bytelen = len;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/regexp_nfa.c", [" */", "static int recursive_regmatch(nfa_state_T *state, nfa_pim_T *pim, nfa_regprog_T *prog, regsubs_T *submatch, regsubs_T *m, int **listids)", "{"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["  int result;", "  int need_restore = FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        endpos.se_u.pos.lnum = reglnum;", "      } else", "        endpos.se_u.pos = pim->end.pos;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          reginput = regline;", "        } else", "          reginput = regline + STRLEN(regline);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          reginput -= mb_head_off(regline, reginput);", "      } else", "        reginput = regline;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    nfa_save_listids(prog, *listids);", "    need_restore = TRUE;", "    /* any value of nfa_listid will do */"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    nfa_restore_listids(prog, *listids);", "  else {", "    --nfa_ll_index;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    fprintf(log_fd, \"FINISHED RUNNING nfa_regmatch() recursively\\n\");", "    fprintf(log_fd, \"MATCH = %s\\n\", result == TRUE ? \"OK\" : \"FALSE\");", "    fprintf(log_fd, \"****************************\\n\");"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    EMSG(_(", "            \"Could not open temporary log file for writing, displaying on stderr ... \"));", "    log_fd = stderr;"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["  for (;; ) {", "    match = TRUE;", "    len2 = MB_CHAR2LEN(regstart);     /* skip regstart */"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      if (c1 != c2 && (!ireg_ic || vim_tolower(c1) != vim_tolower(c2))) {", "        match = FALSE;", "        break;"], "readability/bool"]
["src/nvim/regexp_nfa.c", [" */", "static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *submatch, regsubs_T *m)", "{"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["  int flag = 0;", "  int go_to_nextline = FALSE;", "  nfa_thread_T *t;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    EMSG2(_(\"(NFA) COULD NOT OPEN %s !\"), NFA_REGEXP_DEBUG_LOG);", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  if (got_int)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["", "  nfa_match = FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    EMSG(_(", "            \"Could not open temporary log file for writing, displaying on stderr ... \"));", "    log_fd = stderr;"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["  thislist->n = 0;", "  thislist->has_pim = FALSE;", "  nextlist = &list[1];"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  nextlist->n = 0;", "  nextlist->has_pim = FALSE;", "#ifdef REGEXP_DEBUG"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      m->norm.list.multi[0].start_col = (colnr_T)(reginput - regline);", "    } else", "      m->norm.list.line[0].start = reginput;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["    addstate(thislist, start->out, m, NULL, 0);", "  } else", "    addstate(thislist, start, m, NULL, 0);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      clen = 0;", "      go_to_nextline = FALSE;", "    }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    nextlist->n = 0;                /* clear nextlist */", "    nextlist->has_pim = FALSE;", "    ++nfa_listid;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        }", "        nfa_match = TRUE;", "        copy_sub(&submatch->norm, &t->subs.norm);"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["                log_fd,", "                \"Current lnum: %d, endp lnum: %d; current col: %d, endp col: %d\\n\",", "                (int)reglnum,"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["#endif", "        nfa_match = TRUE;", "        /* See comment above at \"goto nextchar\". */"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["            pim.end.pos.lnum = reglnum;", "          } else", "            pim.end.ptr = reginput;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["              log_fd,", "              \"> Not trying to match pattern, output state %d is already in list %d. char %d: %s\\n\",", "              abs(skip->id), skip_lid, skip->c, code);"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["      case NFA_BOW:", "        result = TRUE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        if (curc == NUL)", "          result = FALSE;", "        else if (has_mbyte) {"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["          if (this_class <= 1)", "            result = FALSE;", "          else if (reg_prev_class() == this_class)"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["          else if (reg_prev_class() == this_class)", "            result = FALSE;", "        } else if (!vim_iswordc_buf(curc, reg_buf)"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["            result = FALSE;", "        } else if (!vim_iswordc_buf(curc, reg_buf)", "                   || (reginput > regline"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["                       && vim_iswordc_buf(reginput[-1], reg_buf)))", "          result = FALSE;", "        if (result) {"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      case NFA_EOW:", "        result = TRUE;", "        if (reginput == regline)"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        if (reginput == regline)", "          result = FALSE;", "        else if (has_mbyte) {"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["              || prev_class == 0 || prev_class == 1)", "            result = FALSE;", "        } else if (!vim_iswordc_buf(reginput[-1], reg_buf)"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["            result = FALSE;", "        } else if (!vim_iswordc_buf(reginput[-1], reg_buf)", "                   || (reginput[0] != NUL"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["                       && vim_iswordc_buf(curc, reg_buf)))", "          result = FALSE;", "        if (result) {"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        /* Check base character matches first, unless ignored. */", "        else if (len > 0 || mc == sta->c) {", "          if (len == 0) {"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["          }", "        } else", "          result = FAIL;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["            && reglnum <= reg_maxline) {", "          go_to_nextline = TRUE;", "          /* Pass -1 for the offset, which means taking the position"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["              int curc_low = vim_tolower(curc);", "              int done = FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["                  result = result_if_matched;", "                  done = TRUE;", "                  break;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["       */", "      case NFA_IDENT:           /*  \\i\t*/", "        result = vim_isIDc(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_SIDENT:          /*  \\I\t*/", "        result = !ascii_isdigit(curc) && vim_isIDc(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_KWORD:           /*  \\k\t*/", "        result = vim_iswordp_buf(reginput, reg_buf);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_SKWORD:          /*  \\K\t*/", "        result = !ascii_isdigit(curc)"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_FNAME:           /*  \\f\t*/", "        result = vim_isfilec(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_SFNAME:          /*  \\F\t*/", "        result = !ascii_isdigit(curc) && vim_isfilec(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_PRINT:           /*  \\p\t*/", "        result = vim_isprintc(PTR2CHAR(reginput));"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_SPRINT:          /*  \\P\t*/", "        result = !ascii_isdigit(curc) && vim_isprintc(PTR2CHAR(reginput));"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_WHITE:           /*  \\s\t*/", "        result = ascii_iswhite(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_NWHITE:          /*  \\S\t*/", "        result = curc != NUL && !ascii_iswhite(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_DIGIT:           /*  \\d\t*/", "        result = ri_digit(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_NDIGIT:          /*  \\D\t*/", "        result = curc != NUL && !ri_digit(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_HEX:             /*  \\x\t*/", "        result = ri_hex(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_NHEX:            /*  \\X\t*/", "        result = curc != NUL && !ri_hex(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_OCTAL:           /*  \\o\t*/", "        result = ri_octal(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_NOCTAL:          /*  \\O\t*/", "        result = curc != NUL && !ri_octal(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_WORD:            /*  \\w\t*/", "        result = ri_word(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_NWORD:           /*  \\W\t*/", "        result = curc != NUL && !ri_word(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_HEAD:            /*  \\h\t*/", "        result = ri_head(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_NHEAD:           /*  \\H\t*/", "        result = curc != NUL && !ri_head(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_ALPHA:           /*  \\a\t*/", "        result = ri_alpha(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_NALPHA:          /*  \\A\t*/", "        result = curc != NUL && !ri_alpha(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_LOWER:           /*  \\l\t*/", "        result = ri_lower(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_NLOWER:          /*  \\L\t*/", "        result = curc != NUL && !ri_lower(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_UPPER:           /*  \\u\t*/", "        result = ri_upper(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "      case NFA_NUPPER:          /* \\U\t*/", "        result = curc != NUL && !ri_upper(curc);"], "whitespace/tab"]
["src/nvim/regexp_nfa.c", ["", "          result = FALSE;", "          win_T *wp = reg_win == NULL ? curwin : reg_win;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      {", "        pos_T   *pos = getmark_buf(reg_buf, t->state->val, FALSE);", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      }", "", "      }       /* switch (t->state->c) */"], "whitespace/blank_line"]
["src/nvim/regexp_nfa.c", ["                log_fd,", "                \"Using previous recursive nfa_regmatch() result, result == %d\\n\",", "                pim->result);"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["                pim->result);", "            fprintf(log_fd, \"MATCH = %s\\n\", result == TRUE ? \"OK\" : \"FALSE\");", "            fprintf(log_fd, \"\\n\");"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["              copy_sub_off(&t->subs.synt, &pim->subs.synt);", "          } else", "            /* look-behind match failed, don't add the state */"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["          addstate_here(thislist, add_state, &t->subs, pim, &listidx);", "        else {", "          addstate(nextlist, add_state, &t->subs, pim, add_off);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["      }", "", "    }     /* for (thislist = thislist; thislist->state; thislist++) */"], "whitespace/blank_line"]
["src/nvim/regexp_nfa.c", ["     * Also don't start a match past the first line. */", "    if (nfa_match == FALSE", "        && ((toplevel"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      if (toplevel) {", "        int add = TRUE;", "        int c;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["#endif", "              add = FALSE;", "            }"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["        }", "      } else", "        addstate(nextlist, start, m, NULL, clen);"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  return nfa_match;", "}", ""], "readability/fn_size"]
["src/nvim/regexp_nfa.c", ["    fclose(f);", "  } else", "    EMSG(_(\"Could not open temporary log file for writing \"));"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  int result = nfa_regmatch(prog, start, &subs, &m);", "  if (result == FALSE) {", "    return 0;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["      reg_endpos[0].col = (int)(reginput - regline);", "    } else", "      /* Use line number of \"\\ze\". */"], "readability/braces"]
["src/nvim/regexp_nfa.c", [" */", "static long ", "nfa_regexec_both ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static long ", "nfa_regexec_both (", "    char_u *line,"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["  if (prog->regflags & RF_ICASE)", "    ireg_ic = TRUE;", "  else if (prog->regflags & RF_NOICASE)"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  else if (prog->regflags & RF_NOICASE)", "    ireg_ic = FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  if (prog->regflags & RF_ICOMBINE)", "    ireg_icombine = TRUE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["", "  need_clear_subexpr = TRUE;", "  /* Clear the external match subpointers if necessary. */"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  if (prog->reghasz == REX_SET) {", "    nfa_has_zsubexpr = TRUE;", "    need_clear_zsubexpr = TRUE;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    nfa_has_zsubexpr = TRUE;", "    need_clear_zsubexpr = TRUE;", "  } else"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["    need_clear_zsubexpr = TRUE;", "  } else", "    nfa_has_zsubexpr = FALSE;"], "readability/braces"]
["src/nvim/regexp_nfa.c", ["  } else", "    nfa_has_zsubexpr = FALSE;", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["          f,", "          \"\\n*****************************\\n\\n\\n\\n\\tCompiling regexp \\\"%s\\\" ... hold on !\\n\",", "          expr);"], "whitespace/line_length"]
["src/nvim/regexp_nfa.c", ["   */", "  post2nfa(postfix, post_ptr, TRUE);", ""], "readability/bool"]
["src/nvim/regexp_nfa.c", ["   */", "  prog->start = post2nfa(postfix, post_ptr, FALSE);", "  if (prog->start == NULL)"], "readability/bool"]
["src/nvim/regexp_nfa.c", [" */", "static int ", "nfa_regexec_nl ("], "whitespace/end_of_line"]
["src/nvim/regexp_nfa.c", ["static int ", "nfa_regexec_nl (", "    regmatch_T *rmp,"], "whitespace/parens"]
["src/nvim/regexp_nfa.c", ["  ireg_ic = rmp->rm_ic;", "  ireg_icombine = FALSE;", "  ireg_maxcol = 0;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  reg_maxline = reg_buf->b_ml.ml_line_count - lnum;", "  reg_line_lbr = FALSE;", "  ireg_ic = rmp->rmm_ic;"], "readability/bool"]
["src/nvim/regexp_nfa.c", ["  ireg_ic = rmp->rmm_ic;", "  ireg_icombine = FALSE;", "  ireg_maxcol = rmp->rmm_maxcol;"], "readability/bool"]
["src/nvim/screen.c", ["", "#define MB_FILLER_CHAR '<'  /* character used when a double-width character", "                             * doesn't fit. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["void", "redrawWinline (", "    linenr_T lnum,"], "whitespace/parens"]
["src/nvim/screen.c", ["    if (i >= 0)", "      curwin->w_lines[i].wl_valid = FALSE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["{", "  static int did_intro = FALSE;", "  int did_one;"], "readability/bool"]
["src/nvim/screen.c", ["  /* Don't do anything if the screen structures are (not yet) valid. */", "  if (!screen_valid(TRUE))", "    return;"], "readability/bool"]
["src/nvim/screen.c", ["", "  updating_screen = TRUE;", "  ++display_tick;           /* let syntax code know we're in a next round of"], "readability/bool"]
["src/nvim/screen.c", ["  updating_screen = TRUE;", "  ++display_tick;           /* let syntax code know we're in a next round of", "                             * display updating */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  if (msg_scrolled) {", "    clear_cmdline = TRUE;", "    if (msg_scrolled > Rows - 5)            /* clearing is faster */"], "readability/bool"]
["src/nvim/screen.c", ["    else if (type != CLEAR) {", "      check_for_delay(FALSE);", "      if (screen_ins_lines(0, 0, msg_scrolled, (int)Rows, NULL) == FAIL)"], "readability/bool"]
["src/nvim/screen.c", ["                <= msg_scrolled) {", "              wp->w_redr_status = TRUE;", "            }"], "readability/bool"]
["src/nvim/screen.c", ["      }", "      redraw_cmdline = TRUE;", "      redraw_tabline = TRUE;"], "readability/bool"]
["src/nvim/screen.c", ["      redraw_cmdline = TRUE;", "      redraw_tabline = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["    msg_scrolled = 0;", "    need_wait_return = FALSE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["  if (clear_cmdline)            /* going to clear cmdline (done below) */", "    check_for_delay(FALSE);", ""], "readability/bool"]
["src/nvim/screen.c", ["               && curwin->w_old_curswant == curwin->w_curswant)", "           ))", "    curwin->w_redr_type = type;"], "whitespace/parens"]
["src/nvim/screen.c", ["   */", "  did_one = FALSE;", "  search_hl.rm.regprog = NULL;"], "readability/bool"]
["src/nvim/screen.c", ["      if (!did_one) {", "        did_one = TRUE;", "        start_search_hl();"], "readability/bool"]
["src/nvim/screen.c", ["", "  updating_screen = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["    maybe_intro_message();", "  did_intro = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["  did_intro = TRUE;", "", "}"], "whitespace/blank_line"]
["src/nvim/screen.c", ["  if (*wp->w_p_cocu == NUL)", "    return FALSE;", "  if (get_real_state() & VISUAL)"], "readability/bool"]
["src/nvim/screen.c", ["  else", "    return FALSE;", "  return vim_strchr(wp->w_p_cocu, c) != NULL;"], "readability/bool"]
["src/nvim/screen.c", ["  if (curwin->w_p_cole > 0 && conceal_cursor_line(curwin)) {", "    need_cursor_line_redraw = TRUE;", "    /* Need to recompute cursor column, e.g., when starting Visual mode"], "readability/bool"]
["src/nvim/screen.c", ["     * without concealing. */", "    curs_columns(TRUE);", "  }"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  need_cursor_line_redraw = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["{", "    updating_screen = TRUE;", "    start_search_hl();"], "readability/bool"]
["src/nvim/screen.c", ["    end_search_hl();", "    updating_screen = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["{", "    int  doit = FALSE;", "    win_foldinfo.fi_level = 0;"], "readability/bool"]
["src/nvim/screen.c", ["      if (wp->w_redr_type != 0) {", "        doit = TRUE;", "      }"], "readability/bool"]
["src/nvim/screen.c", ["  int type;", "  int top_end = 0;              /* Below last row of the top area that needs", "                                   updating.  0 when no top area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no top area updating. */", "  int mid_start = 999;          /* first row of the mid area that needs", "                                   updating.  999 when no mid area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no mid area updating. */", "  int mid_end = 0;              /* Below last row of the mid area that needs", "                                   updating.  0 when no mid area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no mid area updating. */", "  int bot_start = 999;          /* first row of the bot area that needs", "                                   updating.  999 when no bot area updating */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no bot area updating */", "  int scrolled_down = FALSE;            /* TRUE when scrolled down when", "                                           w_topline got smaller a bit */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no bot area updating */", "  int scrolled_down = FALSE;            /* TRUE when scrolled down when", "                                           w_topline got smaller a bit */"], "readability/bool"]
["src/nvim/screen.c", ["  matchitem_T *cur;             /* points to the match list */", "  int top_to_mod = FALSE;              /* redraw above mod_top */", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  int eof = FALSE;              /* if TRUE, we hit the end of the file */", "  int didline = FALSE;           /* if TRUE, we finished the last line */"], "readability/bool"]
["src/nvim/screen.c", ["  int eof = FALSE;              /* if TRUE, we hit the end of the file */", "  int didline = FALSE;           /* if TRUE, we finished the last line */", "  int i;"], "readability/bool"]
["src/nvim/screen.c", ["  long j;", "  static int recursive = FALSE;         /* being called recursively */", "  int old_botline = wp->w_botline;"], "readability/bool"]
["src/nvim/screen.c", ["  if (type == NOT_VALID) {", "    wp->w_redr_status = TRUE;", "    wp->w_lines_valid = 0;"], "readability/bool"]
["src/nvim/screen.c", ["    wp->w_nrwidth = i;", "  } else if (buf->b_mod_set && buf->b_mod_xlines != 0 && wp->w_redraw_top != 0) {", "    /*"], "whitespace/line_length"]
["src/nvim/screen.c", ["          && re_multiline(search_hl.rm.regprog))", "        top_to_mod = TRUE;", "      else {"], "readability/bool"]
["src/nvim/screen.c", ["        top_to_mod = TRUE;", "      else {", "        cur = wp->w_match_head;"], "readability/braces"]
["src/nvim/screen.c", ["              && re_multiline(cur->match.regprog)) {", "            top_to_mod = TRUE;", "            break;"], "readability/bool"]
["src/nvim/screen.c", ["", "      (void)hasFoldingWin(wp, mod_top, &mod_top, NULL, TRUE, NULL);", "      if (mod_top > lnumt)"], "readability/bool"]
["src/nvim/screen.c", ["      --mod_bot;", "      (void)hasFoldingWin(wp, mod_bot, NULL, &mod_bot, TRUE, NULL);", "      ++mod_bot;"], "readability/bool"]
["src/nvim/screen.c", ["                       && wp->w_topfill > wp->w_old_topfill)", "                   )) {", "      /*"], "whitespace/parens"]
["src/nvim/screen.c", ["            break;", "          (void)hasFoldingWin(wp, ln, NULL, &ln, TRUE, NULL);", "        }"], "readability/bool"]
["src/nvim/screen.c", ["        }", "      } else", "        j = wp->w_lines[0].wl_lnum - wp->w_topline;"], "readability/braces"]
["src/nvim/screen.c", ["          if (i > 0)", "            check_for_delay(FALSE);", "          if (win_ins_lines(wp, 0, i, FALSE, wp == firstwin) == OK) {"], "readability/bool"]
["src/nvim/screen.c", ["            check_for_delay(FALSE);", "          if (win_ins_lines(wp, 0, i, FALSE, wp == firstwin) == OK) {", "            if (wp->w_lines_valid != 0) {"], "readability/bool"]
["src/nvim/screen.c", ["              top_end = i;", "              scrolled_down = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["              while (idx >= 0)", "                wp->w_lines[idx--].wl_valid = FALSE;", "            }"], "readability/bool"]
["src/nvim/screen.c", ["            }", "          } else", "            mid_start = 0;                      /* redraw all lines */"], "readability/braces"]
["src/nvim/screen.c", ["            mid_start = 0;                      /* redraw all lines */", "        } else", "          mid_start = 0;                        /* redraw all lines */"], "readability/braces"]
["src/nvim/screen.c", ["          mid_start = 0;                        /* redraw all lines */", "      } else", "        mid_start = 0;                  /* redraw all lines */"], "readability/braces"]
["src/nvim/screen.c", ["        if (row > 0) {", "          check_for_delay(FALSE);", "          if (win_del_lines(wp, 0, row, FALSE, wp == firstwin) == OK)"], "readability/bool"]
["src/nvim/screen.c", ["          check_for_delay(FALSE);", "          if (win_del_lines(wp, 0, row, FALSE, wp == firstwin) == OK)", "            bot_start = wp->w_height - row;"], "readability/bool"]
["src/nvim/screen.c", ["            wp->w_lines[0].wl_size =", "              plines_win_nofill(wp, wp->w_topline, TRUE)", "              + wp->w_topfill;"], "readability/bool"]
["src/nvim/screen.c", ["         * then. */", "        if (screen_cleared != TRUE)", "          screenclear();"], "readability/bool"]
["src/nvim/screen.c", ["     * NOT_VALID, need to reset it here to avoid redrawing twice. */", "    if (screen_cleared == TRUE)", "      must_redraw = 0;"], "readability/bool"]
["src/nvim/screen.c", ["    if (row == wp->w_height) {", "      didline = TRUE;", "      break;"], "readability/bool"]
["src/nvim/screen.c", ["    if (lnum > buf->b_ml.ml_line_count) {", "      eof = TRUE;", "      break;"], "readability/bool"]
["src/nvim/screen.c", ["                        || (wp->w_match_head != NULL && buf->b_mod_xlines != 0)", "                        ))))) {", "      if (lnum == mod_top)"], "whitespace/parens"]
["src/nvim/screen.c", ["      if (lnum == mod_top)", "        top_to_mod = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["          for (l = lnum; l < mod_bot; ++l) {", "            if (hasFoldingWin(wp, l, NULL, &l, TRUE, NULL))", "              ++new_rows;"], "readability/bool"]
["src/nvim/screen.c", ["            else if (l == wp->w_topline)", "              new_rows += plines_win_nofill(wp, l, TRUE)", "                          + wp->w_topfill;"], "readability/bool"]
["src/nvim/screen.c", ["            else", "              new_rows += plines_win(wp, l, TRUE);", "            ++j;"], "readability/bool"]
["src/nvim/screen.c", ["              mod_bot = MAXLNUM;", "            else {", "              check_for_delay(FALSE);"], "readability/braces"]
["src/nvim/screen.c", ["            else {", "              check_for_delay(FALSE);", "              if (win_del_lines(wp, row,"], "readability/bool"]
["src/nvim/screen.c", ["              if (win_del_lines(wp, row,", "                      -xtra_rows, FALSE, FALSE) == FAIL)", "                mod_bot = MAXLNUM;"], "readability/bool"]
["src/nvim/screen.c", ["              mod_bot = MAXLNUM;", "            else {", "              check_for_delay(FALSE);"], "readability/braces"]
["src/nvim/screen.c", ["            else {", "              check_for_delay(FALSE);", "              if (win_ins_lines(wp, row + old_rows,"], "readability/bool"]
["src/nvim/screen.c", ["              if (win_ins_lines(wp, row + old_rows,", "                      xtra_rows, FALSE, FALSE) == FAIL)", "                mod_bot = MAXLNUM;"], "readability/bool"]
["src/nvim/screen.c", ["                wp->w_lines[i].wl_size = 0;", "                wp->w_lines[i--].wl_valid = FALSE;", "              }"], "readability/bool"]
["src/nvim/screen.c", ["        --fold_count;", "        wp->w_lines[idx].wl_folded = TRUE;", "        wp->w_lines[idx].wl_lastlnum = lnum + fold_count;"], "readability/bool"]
["src/nvim/screen.c", ["", "        wp->w_lines[idx].wl_folded = FALSE;", "        wp->w_lines[idx].wl_lastlnum = lnum;"], "readability/bool"]
["src/nvim/screen.c", ["      wp->w_lines[idx].wl_lnum = lnum;", "      wp->w_lines[idx].wl_valid = TRUE;", "      if (row > wp->w_height) {         /* past end of screen */"], "readability/bool"]
["src/nvim/screen.c", ["        if (dollar_vcol == -1)", "          wp->w_lines[idx].wl_size = plines_win(wp, lnum, TRUE);", "        ++idx;"], "readability/bool"]
["src/nvim/screen.c", ["    if (lnum > buf->b_ml.ml_line_count) {", "      eof = TRUE;", "      break;"], "readability/bool"]
["src/nvim/screen.c", ["      }", "    } else if (dollar_vcol == -1)", "      wp->w_botline = lnum;"], "readability/braces"]
["src/nvim/screen.c", ["    if (wp == curwin && wp->w_botline != old_botline && !recursive) {", "      recursive = TRUE;", "      curwin->w_valid &= ~VALID_TOPLINE;"], "readability/bool"]
["src/nvim/screen.c", ["      }", "      recursive = FALSE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["    got_int = save_got_int;", "}", ""], "readability/fn_size"]
["src/nvim/screen.c", [" */", "static void win_draw_end(win_T *wp, int c1, int c2, int row, int endrow, hlf_T hl)", "{"], "whitespace/line_length"]
["src/nvim/screen.c", [" */", "static void fold_line(win_T *wp, long fold_count, foldinfo_T *foldinfo, linenr_T lnum, int row)", "{"], "whitespace/line_length"]
["src/nvim/screen.c", ["  if (fdc > 0) {", "    fill_foldcolumn(buf, wp, TRUE, lnum);", "    if (wp->w_p_rl) {"], "readability/bool"]
["src/nvim/screen.c", ["        ScreenLines[off + wp->w_width - i - 1 - col] = buf[i];", "    } else", "      copy_text_attr(off + col, buf, fdc, hl_attr(HLF_FC));"], "readability/braces"]
["src/nvim/screen.c", ["      ScreenAttrs[off + (wp->w_width - (p) - (l)) + ri] = v; \\", "  else \\", "    for (ri = 0; ri < l; ++ri) \\"], "whitespace/newline"]
["src/nvim/screen.c", ["        num = (long)lnum;", "      else {", "        /* 'relativenumber', don't use negative numbers */"], "readability/braces"]
["src/nvim/screen.c", ["", "      sprintf((char *)buf, fmt, w, num);", "      if (wp->w_p_rl)"], "runtime/printf"]
["src/nvim/screen.c", ["            ScreenLines[idx] = firstbyte;", "          } else", "            prev_c = u8c;"], "readability/braces"]
["src/nvim/screen.c", ["          ScreenLines[idx + 1] = 0;", "      } else if (enc_dbcs == DBCS_JPNU && *p == 0x8e)", "        /* double-byte single width character */"], "readability/braces"]
["src/nvim/screen.c", ["        ScreenLinesC[0][off + col] = 0;", "      } else", "        ScreenLinesUC[off + col] = 0;"], "readability/braces"]
["src/nvim/screen.c", ["                        >= (colnr_T)STRLEN(ml_get_buf(wp->w_buffer, lnume,", "                                FALSE))))))) {", "      if (VIsual_mode == Ctrl_V) {"], "readability/bool"]
["src/nvim/screen.c", ["  SCREEN_LINE(row + wp->w_winrow, wp->w_wincol, wp->w_width,", "              wp->w_width, FALSE);", ""], "readability/bool"]
["src/nvim/screen.c", ["static void", "fill_foldcolumn (", "    char_u *p,"], "whitespace/parens"]
["src/nvim/screen.c", ["static int", "win_line (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/screen.c", ["", "  char_u extra[18];                     /* line number and 'fdc' must fit in here */", "  int n_extra = 0;                      /* number of extra chars */"], "whitespace/line_length"]
["src/nvim/screen.c", ["  int extra_attr = 0;                   /* attributes when n_extra != 0 */", "  static char_u *at_end_str = (char_u *)\"\";   /* used for p_extra when", "                                                 displaying lcs_eol at end-of-line */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  static char_u *at_end_str = (char_u *)\"\";   /* used for p_extra when", "                                                 displaying lcs_eol at end-of-line */", "  int lcs_eol_one = lcs_eol;            /* lcs_eol until it's been used */"], "whitespace/line_length"]
["src/nvim/screen.c", ["  int fromcol_prev = -2;                /* start of inverting after cursor */", "  int noinvcur = FALSE;                 /* don't invert the cursor */", "  pos_T       *top, *bot;"], "readability/bool"]
["src/nvim/screen.c", ["  pos_T       *top, *bot;", "  int lnum_in_visual_area = FALSE;", "  pos_T pos;"], "readability/bool"]
["src/nvim/screen.c", ["  int char_attr = 0;                    /* attributes for next character */", "  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting"], "readability/bool"]
["src/nvim/screen.c", ["  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting", "                                              in this line */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int attr_pri = FALSE;                 /* char_attr has priority */", "  int area_highlighting = FALSE;           /* Visual or incsearch highlighting", "                                              in this line */"], "readability/bool"]
["src/nvim/screen.c", ["  int syntax_attr = 0;                  /* attributes desired by syntax */", "  int has_syntax = FALSE;               /* this buffer has syntax highl. */", "  int save_did_emsg;"], "readability/bool"]
["src/nvim/screen.c", ["  int eol_hl_off = 0;                   /* 1 if highlighted char after EOL */", "  int draw_color_col = FALSE;           /* highlight colorcolumn */", "  int         *color_cols = NULL;       /* pointer to according columns array */"], "readability/bool"]
["src/nvim/screen.c", ["  int nextlinecol = 0;                  /* column where nextline[] starts */", "  int nextline_idx = 0;                 /* index in nextline[] where next line", "                                           starts */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  static linenr_T checked_lnum = 0;     /* line number for \"checked_col\" */", "  static int checked_col = 0;           /* column in \"checked_lnum\" up to which", "                                         * there are no spell errors */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int mb_c = 0;                         /* decoded multi-byte character */", "  int mb_utf8 = FALSE;                  /* screen char is UTF-8 char */", "  int u8cc[MAX_MCO];                    /* composing UTF-8 chars */"], "readability/bool"]
["src/nvim/screen.c", ["  colnr_T trailcol = MAXCOL;            /* start of trailing spaces */", "  int need_showbreak = FALSE;", "  int line_attr = 0;                    /* attribute for the whole line */"], "readability/bool"]
["src/nvim/screen.c", ["  match_T     *shl;                     /* points to search_hl or a match */", "  int shl_flag;                         /* flag to indicate whether search_hl", "                                           has been processed or not */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                           has been processed or not */", "  int prevcol_hl_flag;                  /* flag to indicate whether prevcol", "                                           equals startcol of search_hl or one"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int prevcol_hl_flag;                  /* flag to indicate whether prevcol", "                                           equals startcol of search_hl or one", "                                           of the matches */"], "readability/alt_tokens"]
["src/nvim/screen.c", ["  int conceal_attr    = hl_attr(HLF_CONCEAL);", "  int is_concealing   = FALSE;", "  int boguscols       = 0;              /* nonexistent columns added to force"], "readability/bool"]
["src/nvim/screen.c", ["  int is_concealing   = FALSE;", "  int boguscols       = 0;              /* nonexistent columns added to force", "                                           wrapping */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int vcol_off        = 0;              /* offset for concealed characters */", "  int did_wcol        = FALSE;", "  int old_boguscols = 0;"], "readability/bool"]
["src/nvim/screen.c", ["    save_did_emsg = did_emsg;", "    did_emsg = FALSE;", "    syntax_start(wp, lnum);"], "readability/bool"]
["src/nvim/screen.c", ["    if (did_emsg)", "      wp->w_s->b_syn_error = TRUE;", "    else {"], "readability/bool"]
["src/nvim/screen.c", ["      wp->w_s->b_syn_error = TRUE;", "    else {", "      did_emsg = save_did_emsg;"], "readability/braces"]
["src/nvim/screen.c", ["      did_emsg = save_did_emsg;", "      has_syntax = TRUE;", "      extra_check = TRUE;"], "readability/bool"]
["src/nvim/screen.c", ["      has_syntax = TRUE;", "      extra_check = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["    has_spell = true;", "    extra_check = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["    if (lnum < wp->w_buffer->b_ml.ml_line_count) {", "      line = ml_get_buf(wp->w_buffer, lnum + 1, FALSE);", "      spell_cat_line(nextline + SPWORDLEN, line, SPWORDLEN);"], "readability/bool"]
["src/nvim/screen.c", ["          fromcol = 0;", "        else {", "          getvvcol(wp, top, (colnr_T *)&fromcol, NULL, NULL);"], "readability/braces"]
["src/nvim/screen.c", ["          tocol = MAXCOL;", "        } else if (bot->col == MAXCOL)", "          tocol = MAXCOL;"], "readability/braces"]
["src/nvim/screen.c", ["          tocol = MAXCOL;", "        else {", "          pos = *bot;"], "readability/braces"]
["src/nvim/screen.c", ["            getvvcol(wp, &pos, (colnr_T *)&tocol, NULL, NULL);", "          else {", "            getvvcol(wp, &pos, NULL, NULL, (colnr_T *)&tocol);"], "readability/braces"]
["src/nvim/screen.c", ["        )", "      noinvcur = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["    if (fromcol >= 0) {", "      area_highlighting = TRUE;", "      attr = hl_attr(HLF_V);"], "readability/bool"]
["src/nvim/screen.c", ["   */", "  else if (highlight_match", "           && wp == curwin"], "whitespace/newline"]
["src/nvim/screen.c", ["      getvcol(curwin, &pos, (colnr_T *)&tocol, NULL, NULL);", "    } else", "      tocol = MAXCOL;"], "readability/braces"]
["src/nvim/screen.c", ["      tocol = fromcol + 1;", "    area_highlighting = TRUE;", "    attr = hl_attr(HLF_I);"], "readability/bool"]
["src/nvim/screen.c", ["        diff_hlf = HLF_CHD;             /* changed line */", "    } else", "      diff_hlf = HLF_ADD;               /* added line */"], "readability/braces"]
["src/nvim/screen.c", ["    filler_lines = 0;", "    area_highlighting = TRUE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["  if (v != 0)", "      line_attr = sign_get_attr((int)v, TRUE);", ""], "readability/bool"]
["src/nvim/screen.c", ["  if (line_attr != 0)", "    area_highlighting = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "  ptr = line;"], "readability/bool"]
["src/nvim/screen.c", ["    trailcol += (colnr_T) (ptr - line);", "    extra_check = TRUE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["          (VIsual_active && wp->w_buffer == curwin->w_buffer)", "          )) {", "      vcol = v;"], "whitespace/parens"]
["src/nvim/screen.c", ["    if (wp->w_p_wrap)", "      need_showbreak = TRUE;", "    /* When spell checking a word we need to figure out the start of the"], "readability/bool"]
["src/nvim/screen.c", ["      wp->w_cursor.col = linecol;", "      len = spell_move_to(wp, FORWARD, TRUE, TRUE, &spell_hlf);", ""], "readability/bool"]
["src/nvim/screen.c", ["      /* spell_move_to() may call ml_get() and make \"line\" invalid */", "      line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "      ptr = line + linecol;"], "readability/bool"]
["src/nvim/screen.c", ["        fromcol = -1;", "      } else if ((colnr_T)fromcol < wp->w_virtcol)", "        /* restart highlighting after the cursor */"], "readability/braces"]
["src/nvim/screen.c", ["  cur = wp->w_match_head;", "  shl_flag = FALSE;", "  while (cur != NULL || shl_flag == FALSE) {"], "readability/bool"]
["src/nvim/screen.c", ["  shl_flag = FALSE;", "  while (cur != NULL || shl_flag == FALSE) {", "    if (shl_flag == FALSE) {"], "readability/bool"]
["src/nvim/screen.c", ["  while (cur != NULL || shl_flag == FALSE) {", "    if (shl_flag == FALSE) {", "      shl = &search_hl;"], "readability/bool"]
["src/nvim/screen.c", ["      shl = &search_hl;", "      shl_flag = TRUE;", "    } else"], "readability/bool"]
["src/nvim/screen.c", ["      shl_flag = TRUE;", "    } else", "      shl = &cur->hl;"], "readability/braces"]
["src/nvim/screen.c", ["          /* Draw the 'foldcolumn'. */", "          fill_foldcolumn(extra, wp, FALSE, lnum);", "          n_extra = wp->w_p_fdc;"], "readability/bool"]
["src/nvim/screen.c", ["", "      //sign column", "      if (draw_state == WL_SIGN - 1 && n_extra == 0) {"], "whitespace/comments"]
["src/nvim/screen.c", ["                      }", "                      char_attr = sign_get_attr(text_sign, FALSE);", "                  }"], "readability/bool"]
["src/nvim/screen.c", ["              num = (long)lnum;", "            else {", "              /* 'relativenumber', don't use negative numbers */"], "readability/braces"]
["src/nvim/screen.c", ["", "            sprintf((char *)extra, fmt,", "                number_width(wp), num);"], "runtime/printf"]
["src/nvim/screen.c", ["            c_extra = NUL;", "          } else", "            c_extra = ' ';"], "readability/braces"]
["src/nvim/screen.c", ["        draw_state = WL_BRI;", "        if (wp->w_p_bri && n_extra == 0 && row != startrow && filler_lines == 0) {", "          char_attr = 0; // was: hl_attr(HLF_AT);"], "whitespace/line_length"]
["src/nvim/screen.c", ["        if (wp->w_p_bri && n_extra == 0 && row != startrow && filler_lines == 0) {", "          char_attr = 0; // was: hl_attr(HLF_AT);", ""], "whitespace/comments"]
["src/nvim/screen.c", ["          c_extra = ' ';", "          n_extra = get_breakindent_win(wp, ml_get_buf(wp->w_buffer, lnum, FALSE));", "          /* Correct end of highlighted area for 'breakindent',"], "whitespace/line_length"]
["src/nvim/screen.c", ["          c_extra = ' ';", "          n_extra = get_breakindent_win(wp, ml_get_buf(wp->w_buffer, lnum, FALSE));", "          /* Correct end of highlighted area for 'breakindent',"], "readability/bool"]
["src/nvim/screen.c", ["          char_attr = hl_attr(HLF_AT);", "          need_showbreak = FALSE;", "          vcol_sbr = vcol + MB_CHARLEN(p_sbr);"], "readability/bool"]
["src/nvim/screen.c", ["          char_attr = saved_char_attr;", "        } else", "          char_attr = 0;"], "readability/braces"]
["src/nvim/screen.c", ["        cur = wp->w_match_head;", "        shl_flag = FALSE;", "        while (cur != NULL || shl_flag == FALSE) {"], "readability/bool"]
["src/nvim/screen.c", ["        shl_flag = FALSE;", "        while (cur != NULL || shl_flag == FALSE) {", "          if (shl_flag == FALSE"], "readability/bool"]
["src/nvim/screen.c", ["        while (cur != NULL || shl_flag == FALSE) {", "          if (shl_flag == FALSE", "              && ((cur != NULL"], "readability/bool"]
["src/nvim/screen.c", ["            shl = &search_hl;", "            shl_flag = TRUE;", "          } else"], "readability/bool"]
["src/nvim/screen.c", ["            shl_flag = TRUE;", "          } else", "            shl = &cur->hl;"], "readability/braces"]
["src/nvim/screen.c", ["          }", "          bool pos_inprogress = true; // mark that a position match search is", "                                      // in progress"], "whitespace/comments"]
["src/nvim/screen.c", ["               * may have made it invalid. */", "              line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "              ptr = line + v;"], "readability/bool"]
["src/nvim/screen.c", ["        cur = wp->w_match_head;", "        shl_flag = FALSE;", "        while (cur != NULL || shl_flag == FALSE) {"], "readability/bool"]
["src/nvim/screen.c", ["        shl_flag = FALSE;", "        while (cur != NULL || shl_flag == FALSE) {", "          if (shl_flag == FALSE"], "readability/bool"]
["src/nvim/screen.c", ["        while (cur != NULL || shl_flag == FALSE) {", "          if (shl_flag == FALSE", "              && ((cur != NULL"], "readability/bool"]
["src/nvim/screen.c", ["            shl = &search_hl;", "            shl_flag = TRUE;", "          } else"], "readability/bool"]
["src/nvim/screen.c", ["            shl_flag = TRUE;", "          } else", "            shl = &cur->hl;"], "readability/braces"]
["src/nvim/screen.c", ["      /* Decide which of the highlight attributes to use. */", "      attr_pri = TRUE;", "      if (area_attr != 0)"], "readability/bool"]
["src/nvim/screen.c", ["        char_attr = line_attr;", "      else {", "        attr_pri = FALSE;"], "readability/braces"]
["src/nvim/screen.c", ["      else {", "        attr_pri = FALSE;", "        if (has_syntax)"], "readability/bool"]
["src/nvim/screen.c", ["        if (enc_utf8 && (*mb_char2len)(c) > 1) {", "          mb_utf8 = TRUE;", "          u8cc[0] = 0;"], "readability/bool"]
["src/nvim/screen.c", ["          c = 0xc0;", "        } else", "          mb_utf8 = FALSE;"], "readability/braces"]
["src/nvim/screen.c", ["        } else", "          mb_utf8 = FALSE;", "      } else {"], "readability/bool"]
["src/nvim/screen.c", ["            mb_l = (*mb_ptr2len)(p_extra);", "            mb_utf8 = FALSE;", "            if (mb_l > n_extra)"], "readability/bool"]
["src/nvim/screen.c", ["              mb_c = utfc_ptr2char(p_extra, u8cc);", "              mb_utf8 = TRUE;", "              c = 0xc0;"], "readability/bool"]
["src/nvim/screen.c", ["            mb_l = 1;", "            mb_utf8 = FALSE;", "            multi_attr = hl_attr(HLF_AT);"], "readability/bool"]
["src/nvim/screen.c", ["          mb_l = (*mb_ptr2len)(ptr);", "          mb_utf8 = FALSE;", "          if (mb_l > 1) {"], "readability/bool"]
["src/nvim/screen.c", ["              c = mb_c;", "            mb_utf8 = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["            }", "          } else if (mb_l == 0)          /* at the NUL at end-of-line */", "            mb_l = 1;"], "readability/braces"]
["src/nvim/screen.c", ["            mb_c = arabic_shape(mb_c, &c, &u8cc[0], pc, pc1, nc);", "          } else", "            prev_c = mb_c;"], "readability/braces"]
["src/nvim/screen.c", ["              mb_c = (c << 8) + ptr[1];", "            else {", "              if (ptr[1] == NUL) {"], "readability/braces"]
["src/nvim/screen.c", ["          mb_c = c;", "          mb_utf8 = FALSE;", "          mb_l = 1;"], "readability/bool"]
["src/nvim/screen.c", ["          --ptr;", "        } else if (*ptr != NUL)", "          ptr += mb_l - 1;"], "readability/braces"]
["src/nvim/screen.c", ["          mb_c = c;", "          mb_utf8 = FALSE;", "          mb_l = 1;"], "readability/bool"]
["src/nvim/screen.c", ["        }", "", "      }"], "whitespace/blank_line"]
["src/nvim/screen.c", ["        if (enc_utf8 && (*mb_char2len)(c) > 1) {", "          mb_utf8 = TRUE;", "          u8cc[0] = 0;"], "readability/bool"]
["src/nvim/screen.c", ["          c = 0xc0;", "        } else", "          mb_utf8 = FALSE;"], "readability/braces"]
["src/nvim/screen.c", ["        } else", "          mb_utf8 = FALSE;", "      }"], "readability/bool"]
["src/nvim/screen.c", ["          save_did_emsg = did_emsg;", "          did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["              has_spell ? &can_spell :", "              NULL, FALSE);", ""], "readability/bool"]
["src/nvim/screen.c", ["          if (did_emsg) {", "            wp->w_s->b_syn_error = TRUE;", "            has_syntax = FALSE;"], "readability/bool"]
["src/nvim/screen.c", ["            wp->w_s->b_syn_error = TRUE;", "            has_syntax = FALSE;", "          } else"], "readability/bool"]
["src/nvim/screen.c", ["            has_syntax = FALSE;", "          } else", "            did_emsg = save_did_emsg;"], "readability/braces"]
["src/nvim/screen.c", ["           * have made it invalid. */", "          line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "          ptr = line + v;"], "readability/bool"]
["src/nvim/screen.c", ["              v -= mb_l - 1;", "            } else", "              prev_ptr = ptr - 1;"], "readability/braces"]
["src/nvim/screen.c", ["                                - nextline_idx);", "              } else", "                /* Compute the actual column. */"], "readability/braces"]
["src/nvim/screen.c", ["              1);", "          // TODO: is passing p for start of the line OK?", "          n_extra = win_lbr_chartabsize(wp, line, p, (colnr_T)vcol, NULL) - 1;"], "readability/todo"]
["src/nvim/screen.c", ["          if (enc_utf8 && (*mb_char2len)(c) > 1) {", "            mb_utf8 = TRUE;", "            u8cc[0] = 0;"], "readability/bool"]
["src/nvim/screen.c", ["            c = 0xc0;", "          } else", "            mb_utf8 = FALSE;"], "readability/braces"]
["src/nvim/screen.c", ["          } else", "            mb_utf8 = FALSE;", "        }"], "readability/bool"]
["src/nvim/screen.c", ["          }", "          mb_utf8 = FALSE;              /* don't draw as UTF-8 */", "          if (wp->w_p_list) {"], "readability/bool"]
["src/nvim/screen.c", ["            if (enc_utf8 && (*mb_char2len)(c) > 1) {", "              mb_utf8 = TRUE;", "              u8cc[0] = 0;"], "readability/bool"]
["src/nvim/screen.c", ["              n_extra = 0;", "            else {", "              p_extra = at_end_str;"], "readability/braces"]
["src/nvim/screen.c", ["          if (enc_utf8 && (*mb_char2len)(c) > 1) {", "            mb_utf8 = TRUE;", "            u8cc[0] = 0;"], "readability/bool"]
["src/nvim/screen.c", ["            c = 0xc0;", "          } else", "            mb_utf8 = FALSE;                    /* don't draw as UTF-8 */"], "readability/braces"]
["src/nvim/screen.c", ["          } else", "            mb_utf8 = FALSE;                    /* don't draw as UTF-8 */", "        } else if (c != NUL) {"], "readability/bool"]
["src/nvim/screen.c", ["          }", "          mb_utf8 = FALSE;              /* don't draw as UTF-8 */", "        } else if (VIsual_active"], "readability/bool"]
["src/nvim/screen.c", ["                   line_attr != 0", "                   ) && (", "                   wp->w_p_rl ? (col >= 0) :"], "whitespace/parens"]
["src/nvim/screen.c", ["        } else if (n_skip == 0) {", "          is_concealing = TRUE;", "          n_skip = 1;"], "readability/bool"]
["src/nvim/screen.c", ["        if (enc_utf8 && (*mb_char2len)(c) > 1) {", "          mb_utf8 = TRUE;", "          u8cc[0] = 0;"], "readability/bool"]
["src/nvim/screen.c", ["          c = 0xc0;", "        } else", "          mb_utf8 = FALSE;              /* don't draw as UTF-8 */"], "readability/braces"]
["src/nvim/screen.c", ["        } else", "          mb_utf8 = FALSE;              /* don't draw as UTF-8 */", "      } else {"], "readability/bool"]
["src/nvim/screen.c", ["        prev_syntax_id = 0;", "        is_concealing = FALSE;", "      }"], "readability/bool"]
["src/nvim/screen.c", ["      wp->w_wrow = row;", "      did_wcol = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["      if (enc_utf8 && (*mb_char2len)(c) > 1) {", "        mb_utf8 = TRUE;", "        u8cc[0] = 0;"], "readability/bool"]
["src/nvim/screen.c", ["        c = 0xc0;", "      } else", "        mb_utf8 = FALSE;                /* don't draw as UTF-8 */"], "readability/braces"]
["src/nvim/screen.c", ["      } else", "        mb_utf8 = FALSE;                /* don't draw as UTF-8 */", "      if (!attr_pri) {"], "readability/bool"]
["src/nvim/screen.c", ["       * needed when a '$' was displayed for 'list'. */", "      prevcol_hl_flag = FALSE;", "      if (prevcol == (long)search_hl.startcol)"], "readability/bool"]
["src/nvim/screen.c", ["      if (prevcol == (long)search_hl.startcol)", "        prevcol_hl_flag = TRUE;", "      else {"], "readability/bool"]
["src/nvim/screen.c", ["        prevcol_hl_flag = TRUE;", "      else {", "        cur = wp->w_match_head;"], "readability/braces"]
["src/nvim/screen.c", ["          if (prevcol == (long)cur->hl.startcol) {", "            prevcol_hl_flag = TRUE;", "            break;"], "readability/bool"]
["src/nvim/screen.c", ["              /* highlight 'hlsearch' match at end of line */", "              || (prevcol_hl_flag == TRUE && did_line_attr <= 1)", "              )) {"], "readability/bool"]
["src/nvim/screen.c", ["              || (prevcol_hl_flag == TRUE && did_line_attr <= 1)", "              )) {", "        int n = 0;"], "whitespace/parens"]
["src/nvim/screen.c", ["          cur = wp->w_match_head;", "          shl_flag = FALSE;", "          while (cur != NULL || shl_flag == FALSE) {"], "readability/bool"]
["src/nvim/screen.c", ["          shl_flag = FALSE;", "          while (cur != NULL || shl_flag == FALSE) {", "            if (shl_flag == FALSE"], "readability/bool"]
["src/nvim/screen.c", ["          while (cur != NULL || shl_flag == FALSE) {", "            if (shl_flag == FALSE", "                && ((cur != NULL"], "readability/bool"]
["src/nvim/screen.c", ["              shl = &search_hl;", "              shl_flag = TRUE;", "            } else"], "readability/bool"]
["src/nvim/screen.c", ["              shl_flag = TRUE;", "            } else", "              shl = &cur->hl;"], "readability/braces"]
["src/nvim/screen.c", ["      if (enc_utf8 && (*mb_char2len)(c) > 1) {", "        mb_utf8 = TRUE;", "        u8cc[0] = 0;"], "readability/bool"]
["src/nvim/screen.c", ["        c = 0xc0;", "      } else", "        mb_utf8 = FALSE;"], "readability/braces"]
["src/nvim/screen.c", ["      } else", "        mb_utf8 = FALSE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["          }", "        } else", "          ScreenLinesUC[off] = 0;"], "readability/braces"]
["src/nvim/screen.c", ["        multi_attr = 0;", "      } else", "        ScreenAttrs[off] = char_attr;"], "readability/braces"]
["src/nvim/screen.c", ["      }", "", "    } else"], "whitespace/blank_line"]
["src/nvim/screen.c", ["", "    } else", "      --n_skip;"], "readability/braces"]
["src/nvim/screen.c", ["           && filler_todo <= 0", "           ) || lcs_eol_one == -1)", "        break;"], "whitespace/parens"]
["src/nvim/screen.c", ["        /* Remember that the line wraps, used for modeless copy. */", "        LineWraps[screen_row - 1] = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["      if (filler_todo <= 0)", "        need_showbreak = TRUE;", "      --filler_todo;"], "readability/bool"]
["src/nvim/screen.c", ["    }", "", "  }     /* for every character in the line */"], "whitespace/blank_line"]
["src/nvim/screen.c", ["  return row;", "}", ""], "readability/fn_size"]
["src/nvim/screen.c", ["    if (ScreenLinesC[i][off_from] != ScreenLinesC[i][off_to])", "      return TRUE;", "    if (ScreenLinesC[i][off_from] == 0)"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", [" */", "static void screen_line(int row, int coloff, int endcol, int clear_width, int rlflag)", "{"], "whitespace/line_length"]
["src/nvim/screen.c", ["  int hl;", "  int force = FALSE;                    /* force update rest of the line */", "  int redraw_this                       /* bool: does character need redraw? */"], "readability/bool"]
["src/nvim/screen.c", ["  int redraw_this                       /* bool: does character need redraw? */", "  ;", "  int redraw_next;                      /* redraw_this for next character */"], "whitespace/semicolon"]
["src/nvim/screen.c", ["  int redraw_next;                      /* redraw_this for next character */", "  int clear_next = FALSE;", "  int char_cells;                       /* 1: normal char */"], "readability/bool"]
["src/nvim/screen.c", ["          ScreenLines[off_to + 1] = 0;", "          redraw_next = TRUE;", "        } else if (char_cells == 2"], "readability/bool"]
["src/nvim/screen.c", ["          ScreenLines[off_to + 2] = 0;", "          redraw_next = TRUE;", "        }"], "readability/bool"]
["src/nvim/screen.c", ["                  && (*mb_off2cells)(off_to + 1, max_off_to) > 1)))", "        clear_next = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["      ) {", "", "    /* blank out the rest of the line */"], "whitespace/blank_line"]
["src/nvim/screen.c", ["            ScreenLinesC[0][off_to] = 0;", "          } else", "            ScreenLinesUC[off_to] = 0;"], "readability/braces"]
["src/nvim/screen.c", ["      }", "    } else", "      LineWraps[row] = FALSE;"], "readability/braces"]
["src/nvim/screen.c", ["    } else", "      LineWraps[row] = FALSE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["{", "", "  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {"], "whitespace/blank_line"]
["src/nvim/screen.c", ["    if (wp->w_status_height) {", "      wp->w_redr_status = TRUE;", "      redraw_later(VALID);"], "readability/bool"]
["src/nvim/screen.c", ["    if (wp->w_status_height != 0 && wp->w_buffer == curbuf) {", "      wp->w_redr_status = TRUE;", "      redraw_later(VALID);"], "readability/bool"]
["src/nvim/screen.c", ["  if (frp->fr_layout == FR_LEAF)", "    frp->fr_win->w_redr_status = TRUE;", "  else if (frp->fr_layout == FR_ROW) {"], "readability/bool"]
["src/nvim/screen.c", ["void", "win_redr_status_matches (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/screen.c", ["  int i;", "  int highlight = TRUE;", "  char_u      *selstart = NULL;"], "readability/bool"]
["src/nvim/screen.c", ["  static int first_match = 0;", "  int add_left = FALSE;", "  char_u      *s;"], "readability/bool"]
["src/nvim/screen.c", ["    match = 0;", "    highlight = FALSE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["    first_match = match;", "    add_left = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/screen.c", ["      if (i == num_matches)", "        add_left = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["", "  fillchar = fillchar_status(&attr, TRUE);", ""], "readability/bool"]
["src/nvim/screen.c", ["      clen += l;", "    } else", "      for (; *s != NUL; ++s) {"], "readability/braces"]
["src/nvim/screen.c", ["          p_wmh = 0;", "          last_status(FALSE);", "        }"], "readability/bool"]
["src/nvim/screen.c", ["  int this_ru_col;", "  static int busy = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["    return;", "  busy = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  wp->w_redr_status = FALSE;", "  if (wp->w_status_height == 0) {"], "readability/bool"]
["src/nvim/screen.c", ["    /* no status line, can only be last window */", "    redraw_cmdline = TRUE;", "  } else if (!redrawing()"], "readability/bool"]
["src/nvim/screen.c", ["    /* Don't redraw right now, do it later. */", "    wp->w_redr_status = TRUE;", "  } else if (*p_stl != NUL || *wp->w_p_stl != NUL) {"], "readability/bool"]
["src/nvim/screen.c", ["", "    win_redr_ruler(wp, TRUE);", "  }"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  busy = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["{", "  static int entered = FALSE;", "  int save_called_emsg = called_emsg;"], "readability/bool"]
["src/nvim/screen.c", ["    return;", "  entered = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  called_emsg = FALSE;", "  win_redr_custom(wp, FALSE);"], "readability/bool"]
["src/nvim/screen.c", ["  called_emsg = FALSE;", "  win_redr_custom(wp, FALSE);", "  if (called_emsg) {"], "readability/bool"]
["src/nvim/screen.c", ["  called_emsg |= save_called_emsg;", "  entered = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["      if (fr->fr_next != NULL)", "        return TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["int", "get_keymap_str (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/screen.c", ["  if (wp->w_buffer->b_p_iminsert != B_IMODE_LMAP)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["    ++emsg_skip;", "    s = p = eval_to_string(buf, NULL, FALSE);", "    --emsg_skip;"], "readability/bool"]
["src/nvim/screen.c", ["    if ((int)(STRLEN(p) + 3) < len)", "      sprintf((char *)buf, \"<%s>\", p);", "    else"], "runtime/printf"]
["src/nvim/screen.c", ["static void", "win_redr_custom (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/screen.c", ["{", "  static int entered = FALSE;", "  int attr;"], "readability/bool"]
["src/nvim/screen.c", ["  struct      stl_hlrec tabtab[STL_MAX_ITEM];", "  int use_sandbox = FALSE;", "  win_T       *ewp;"], "readability/bool"]
["src/nvim/screen.c", ["    return;", "  entered = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["  p_crb_save = ewp->w_p_crb;", "  ewp->w_p_crb = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["theend:", "  entered = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["    buf[(*mb_char2bytes)(c, buf)] = NUL;", "  else {", "    buf[0] = c;"], "readability/braces"]
["src/nvim/screen.c", ["    if (ScreenLinesC[i][off] != (u8char_T)u8cc[i])", "      return TRUE;", "    if (u8cc[i] == 0)"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["  int u8cc[MAX_MCO];", "  int clear_next_cell = FALSE;", "  int prev_c = 0;                       /* previous Arabic character */"], "readability/bool"]
["src/nvim/screen.c", ["  int force_redraw_this;", "  int force_redraw_next = FALSE;", "  int need_redraw;"], "readability/bool"]
["src/nvim/screen.c", ["    /* force the cell at \"col\" to be redrawn */", "    force_redraw_next = TRUE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["        mbyte_cells = mbyte_blen;", "      else {            /* enc_utf8 */", "        if (len >= 0)"], "readability/braces"]
["src/nvim/screen.c", ["          u8c = arabic_shape(u8c, &c, &u8cc[0], nc, nc1, pc);", "        } else", "          prev_c = u8c;"], "readability/braces"]
["src/nvim/screen.c", ["    force_redraw_this = force_redraw_next;", "    force_redraw_next = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["      if (clear_next_cell)", "        clear_next_cell = FALSE;", "      else if (l_has_mbyte"], "readability/bool"]
["src/nvim/screen.c", ["                       && (*mb_off2cells)(off + 1, max_off) > 1)))", "        clear_next_cell = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["          ScreenLinesUC[off] = 0;", "        else {", "          int i;"], "readability/braces"]
["src/nvim/screen.c", ["        screen_char(off, row, col);", "      } else", "        screen_char(off, row, col);"], "readability/braces"]
["src/nvim/screen.c", ["  match_T     *shl;             /* points to search_hl or a match */", "  int shl_flag;                 /* flag to indicate whether search_hl", "                                   has been processed or not */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  cur = wp->w_match_head;", "  shl_flag = FALSE;", "  while (cur != NULL || shl_flag == FALSE) {"], "readability/bool"]
["src/nvim/screen.c", ["  shl_flag = FALSE;", "  while (cur != NULL || shl_flag == FALSE) {", "    if (shl_flag == FALSE) {"], "readability/bool"]
["src/nvim/screen.c", ["  while (cur != NULL || shl_flag == FALSE) {", "    if (shl_flag == FALSE) {", "      shl = &search_hl;"], "readability/bool"]
["src/nvim/screen.c", ["      shl = &search_hl;", "      shl_flag = TRUE;", "    } else"], "readability/bool"]
["src/nvim/screen.c", ["      shl_flag = TRUE;", "    } else", "      shl = &cur->hl;"], "readability/braces"]
["src/nvim/screen.c", ["          if (hasFoldingWin(wp, shl->first_lnum - 1,", "                  NULL, NULL, TRUE, NULL))", "            break;"], "readability/bool"]
["src/nvim/screen.c", ["      }", "      bool pos_inprogress = true; // mark that a position match search is", "                                  // in progress"], "whitespace/comments"]
["src/nvim/screen.c", ["static void", "next_search_hl (", "    win_T *win,"], "whitespace/parens"]
["src/nvim/screen.c", ["   */", "  called_emsg = FALSE;", "  for (;; ) {"], "readability/bool"]
["src/nvim/screen.c", ["      matchcol = shl->rm.startpos[0].col;", "      ml = ml_get_buf(shl->buf, lnum, FALSE) + matchcol;", "      if (*ml == NUL) {"], "readability/bool"]
["src/nvim/screen.c", ["        ++matchcol;", "    } else", "      matchcol = shl->rm.endpos[0].col;"], "readability/braces"]
["src/nvim/screen.c", ["", "      nmatched = vim_regexec_multi(&shl->rm, win, shl->buf, lnum, matchcol, &(shl->tm));", "      /* Copy the regprog, in case it got freed and recompiled. */"], "whitespace/line_length"]
["src/nvim/screen.c", ["          vim_regfree(shl->rm.regprog);", "          SET_NO_HLSEARCH(TRUE);", "        }"], "readability/bool"]
["src/nvim/screen.c", ["        shl->lnum = 0;", "        got_int = FALSE; // avoid the \"Type :quit to exit Vim\" message", "        break;"], "whitespace/comments"]
["src/nvim/screen.c", ["        shl->lnum = 0;", "        got_int = FALSE; // avoid the \"Type :quit to exit Vim\" message", "        break;"], "readability/bool"]
["src/nvim/screen.c", ["    linenr_T lnum,", "    posmatch_T *posmatch, // match positions", "    colnr_T mincol        // minimal column for a match"], "whitespace/comments"]
["src/nvim/screen.c", [" */", "void screen_fill(int start_row, int end_row, int start_col, int end_col, int c1, int c2, int attr)", "{"], "whitespace/line_length"]
["src/nvim/screen.c", ["     */", "    did_delete = FALSE;", "    if (c2 == ' '"], "readability/bool"]
["src/nvim/screen.c", ["      }", "      did_delete = TRUE;                /* the chars are cleared now */", "    }"], "readability/bool"]
["src/nvim/screen.c", ["            ScreenLinesC[0][off] = 0;", "          } else", "            ScreenLinesUC[off] = 0;"], "readability/braces"]
["src/nvim/screen.c", ["    if (end_col == Columns)", "      LineWraps[row] = FALSE;", "    if (row == Rows - 1) {              /* overwritten the command line */"], "readability/bool"]
["src/nvim/screen.c", ["    if (row == Rows - 1) {              /* overwritten the command line */", "      redraw_cmdline = TRUE;", "      if (c1 == ' ' && c2 == ' ')"], "readability/bool"]
["src/nvim/screen.c", ["      if (c1 == ' ' && c2 == ' ')", "        clear_cmdline = FALSE;          /* command line has been cleared */", "      if (start_col == 0)"], "readability/bool"]
["src/nvim/screen.c", ["      if (start_col == 0)", "        mode_displayed = FALSE;         /* mode cleared or overwritten */", "    }"], "readability/bool"]
["src/nvim/screen.c", ["    os_delay(1000L, true);", "    emsg_on_display = FALSE;", "    if (check_msg_scroll)"], "readability/bool"]
["src/nvim/screen.c", ["    if (check_msg_scroll)", "      msg_scroll = FALSE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["  int new_row, old_row;", "  int outofmem = FALSE;", "  int len;"], "readability/bool"]
["src/nvim/screen.c", ["  char_u          *new_LineWraps;", "  short           *new_TabPageIdxs;", "  static int entered = FALSE;                   /* avoid recursiveness */"], "runtime/int"]
["src/nvim/screen.c", ["  short           *new_TabPageIdxs;", "  static int entered = FALSE;                   /* avoid recursiveness */", "  static int done_outofmem_msg = FALSE;         /* did outofmem message */"], "readability/bool"]
["src/nvim/screen.c", ["  static int entered = FALSE;                   /* avoid recursiveness */", "  static int done_outofmem_msg = FALSE;         /* did outofmem message */", "  int retry_count = 0;"], "readability/bool"]
["src/nvim/screen.c", ["    return;", "  entered = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["  new_LineWraps = xmalloc((size_t)(Rows * sizeof(char_u)));", "  new_TabPageIdxs = xmalloc((size_t)(Columns * sizeof(short)));", ""], "runtime/int"]
["src/nvim/screen.c", ["       * and over again. */", "      done_outofmem_msg = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["  } else {", "    done_outofmem_msg = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["      new_LineOffset[new_row] = new_row * Columns;", "      new_LineWraps[new_row] = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  entered = FALSE;", "  --RedrawingDisabled;"], "readability/bool"]
["src/nvim/screen.c", ["  if (starting == 0 && ++retry_count <= 3) {", "    apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);", "    /* In rare cases, autocommands may have altered Rows or Columns,"], "readability/bool"]
["src/nvim/screen.c", ["{", "  check_for_delay(FALSE);", "  screenalloc(false);       /* allocate screen buffers if size changed */"], "readability/bool"]
["src/nvim/screen.c", ["    lineclear(LineOffset[i], (int)Columns);", "    LineWraps[i] = FALSE;", "  }"], "readability/bool"]
["src/nvim/screen.c", ["  ui_clear();  // clear the display", "  clear_cmdline = FALSE;", "  mode_displayed = FALSE;"], "readability/bool"]
["src/nvim/screen.c", ["  clear_cmdline = FALSE;", "  mode_displayed = FALSE;", "  screen_cleared = TRUE;        /* can use contents of ScreenLines now */"], "readability/bool"]
["src/nvim/screen.c", ["  mode_displayed = FALSE;", "  screen_cleared = TRUE;        /* can use contents of ScreenLines now */", ""], "readability/bool"]
["src/nvim/screen.c", ["  win_rest_invalid(firstwin);", "  redraw_cmdline = TRUE;", "  redraw_tabline = TRUE;"], "readability/bool"]
["src/nvim/screen.c", ["  redraw_cmdline = TRUE;", "  redraw_tabline = TRUE;", "  if (must_redraw == CLEAR)     /* no need to clear again */"], "readability/bool"]
["src/nvim/screen.c", ["  msg_scrolled = 0;             /* can't scroll back */", "  msg_didany = FALSE;", "  msg_didout = FALSE;"], "readability/bool"]
["src/nvim/screen.c", ["  msg_didany = FALSE;", "  msg_didout = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["", "  retval = win_do_lines(wp, row, line_count, mayclear, FALSE);", "  if (retval != MAYBE)"], "readability/bool"]
["src/nvim/screen.c", ["   */", "  did_delete = FALSE;", "  if (wp->w_next != NULL || wp->w_status_height) {"], "readability/bool"]
["src/nvim/screen.c", ["            line_count, (int)Rows, NULL) == OK)", "      did_delete = TRUE;", "    else if (wp->w_next)"], "readability/bool"]
["src/nvim/screen.c", ["  if (!did_delete) {", "    wp->w_redr_status = TRUE;", "    redraw_cmdline = TRUE;"], "readability/bool"]
["src/nvim/screen.c", ["    wp->w_redr_status = TRUE;", "    redraw_cmdline = TRUE;", "    nextrow = wp->w_winrow + wp->w_height + wp->w_status_height;"], "readability/bool"]
["src/nvim/screen.c", ["    if (did_delete) {", "      wp->w_redr_status = TRUE;", "      win_rest_invalid(wp->w_next);"], "readability/bool"]
["src/nvim/screen.c", ["", "  retval = win_do_lines(wp, row, line_count, mayclear, TRUE);", "  if (retval != MAYBE)"], "readability/bool"]
["src/nvim/screen.c", ["            line_count, (int)Rows, NULL) == FAIL) {", "      wp->w_redr_status = TRUE;", "      win_rest_invalid(wp->w_next);"], "readability/bool"]
["src/nvim/screen.c", ["   */", "  else", "    redraw_cmdline = TRUE;"], "whitespace/newline"]
["src/nvim/screen.c", ["  else", "    redraw_cmdline = TRUE;", "  return OK;"], "readability/bool"]
["src/nvim/screen.c", ["// Returns OK or FAIL when the work has been done.", "static int win_do_lines(win_T *wp, int row, int line_count, int mayclear, int del)", "{"], "whitespace/line_length"]
["src/nvim/screen.c", ["  // otherwise it will stay there forever.", "  clear_cmdline = TRUE;", "  int retval;"], "readability/bool"]
["src/nvim/screen.c", ["    redraw_win_later(wp, NOT_VALID);", "    wp->w_redr_status = TRUE;", "    wp = wp->w_next;"], "readability/bool"]
["src/nvim/screen.c", ["  }", "  redraw_cmdline = TRUE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["// return FAIL for failure, OK for success.", "int screen_ins_lines (", "    int off,"], "whitespace/parens"]
["src/nvim/screen.c", ["", "  if (!screen_valid(TRUE) || line_count <= 0) {", "    return FAIL;"], "readability/bool"]
["src/nvim/screen.c", ["      lineclear(LineOffset[j] + wp->w_wincol, wp->w_width);", "      LineWraps[j] = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/screen.c", ["      LineOffset[j + line_count] = temp;", "      LineWraps[j + line_count] = FALSE;", "      lineclear(temp, (int)Columns);"], "readability/bool"]
["src/nvim/screen.c", ["// Return OK for success, FAIL if the lines are not deleted.", "int screen_del_lines (", "    int off,"], "whitespace/parens"]
["src/nvim/screen.c", ["", "  if (!screen_valid(TRUE) || line_count <= 0) {", "    return FAIL;"], "readability/bool"]
["src/nvim/screen.c", ["      lineclear(LineOffset[j] + wp->w_wincol, wp->w_width);", "      LineWraps[j] = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/screen.c", ["      LineOffset[j - line_count] = temp;", "      LineWraps[j - line_count] = FALSE;", "      lineclear(temp, (int)Columns);"], "readability/bool"]
["src/nvim/screen.c", ["                 || VIsual_active", "                 ));", "  if (do_mode || Recording) {"], "whitespace/parens"]
["src/nvim/screen.c", ["    if (!redrawing() || (char_avail() && !KeyTyped) || msg_silent != 0) {", "      redraw_cmdline = TRUE;                    /* show mode later */", "      return 0;"], "readability/bool"]
["src/nvim/screen.c", ["    /* wait a bit before overwriting an important message */", "    check_for_delay(FALSE);", ""], "readability/bool"]
["src/nvim/screen.c", ["          MSG_PUTS_ATTR(_(\" TERMINAL\"), attr);", "        } else if (State & VREPLACE_FLAG)", "          MSG_PUTS_ATTR(_(\" VREPLACE\"), attr);"], "readability/braces"]
["src/nvim/screen.c", ["          MSG_PUTS_ATTR(_(\" INSERT\"), attr);", "        } else if (restart_edit == 'I')", "          MSG_PUTS_ATTR(_(\" (insert)\"), attr);"], "readability/braces"]
["src/nvim/screen.c", ["", "      need_clear = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["      MSG_PUTS_ATTR(_(\"recording\"), attr);", "      need_clear = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["", "    mode_displayed = TRUE;", "    if (need_clear || clear_cmdline)"], "readability/bool"]
["src/nvim/screen.c", ["      msg_clr_eos();", "    msg_didout = FALSE;                 /* overwrite this message */", "    length = msg_col;"], "readability/bool"]
["src/nvim/screen.c", ["    need_wait_return = nwr_save;        /* never ask for hit-return for this */", "  } else if (clear_cmdline && msg_silent == 0)", "    /* Clear the whole command line.  Will reset \"clear_cmdline\". */"], "readability/braces"]
["src/nvim/screen.c", ["      )", "    win_redr_ruler(lastwin, TRUE);", "  redraw_cmdline = FALSE;"], "readability/bool"]
["src/nvim/screen.c", ["    win_redr_ruler(lastwin, TRUE);", "  redraw_cmdline = FALSE;", "  clear_cmdline = FALSE;"], "readability/bool"]
["src/nvim/screen.c", ["  redraw_cmdline = FALSE;", "  clear_cmdline = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["  if (!redrawing() || (!force && char_avail() && !KeyTyped))", "    redraw_cmdline = TRUE;              /* delete mode later */", "  else {"], "readability/bool"]
["src/nvim/screen.c", ["    redraw_cmdline = TRUE;              /* delete mode later */", "  else {", "    msg_pos_mode();"], "readability/braces"]
["src/nvim/screen.c", ["  int use_sep_chars = (t_colors < 8", "                       );", ""], "whitespace/parens"]
["src/nvim/screen.c", ["", "  redraw_tabline = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["     * screen.  Avoid that by making 'tabline' empty. */", "    called_emsg = FALSE;", "    win_redr_custom(NULL, FALSE);"], "readability/bool"]
["src/nvim/screen.c", ["    called_emsg = FALSE;", "    win_redr_custom(NULL, FALSE);", "    if (called_emsg)"], "readability/bool"]
["src/nvim/screen.c", ["", "      modified = FALSE;", "      for (wincount = 0; wp != NULL; wp = wp->w_next, ++wincount)"], "readability/bool"]
["src/nvim/screen.c", ["        if (bufIsChanged(wp->w_buffer))", "          modified = TRUE;", "      if (modified || wincount > 1) {"], "readability/bool"]
["src/nvim/screen.c", ["          }", "        else if (len > room) {", "          p += len - room;"], "whitespace/newline"]
["src/nvim/screen.c", ["   * set. */", "  redraw_tabline = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["  else", "    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);", "  trans_characters(NameBuff, MAXPATHL);"], "readability/bool"]
["src/nvim/screen.c", ["    /* Don't redraw right now, do it later. */", "    curwin->w_redr_status = TRUE;", "    return;"], "readability/bool"]
["src/nvim/screen.c", ["    redraw_custom_statusline(curwin);", "  } else", "    win_redr_ruler(curwin, always);"], "readability/braces"]
["src/nvim/screen.c", ["", "    called_emsg = FALSE;", "    win_redr_custom(wp, TRUE);"], "readability/bool"]
["src/nvim/screen.c", ["    called_emsg = FALSE;", "    win_redr_custom(wp, TRUE);", "    if (called_emsg)"], "readability/bool"]
["src/nvim/screen.c", ["   */", "  int empty_line = FALSE;", "  if (!(State & INSERT)"], "readability/bool"]
["src/nvim/screen.c", ["  if (!(State & INSERT)", "      && *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)", "    empty_line = TRUE;"], "readability/bool"]
["src/nvim/screen.c", ["      && *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)", "    empty_line = TRUE;", ""], "readability/bool"]
["src/nvim/screen.c", ["             || empty_line != wp->w_ru_empty) {", "", "    int width;"], "whitespace/blank_line"]
["src/nvim/screen.c", ["    if (wp->w_p_list && lcs_tab1 == NUL) {", "      wp->w_p_list = FALSE;", "      getvvcol(wp, &wp->w_cursor, NULL, &virtcol, NULL);"], "readability/bool"]
["src/nvim/screen.c", ["      getvvcol(wp, &wp->w_cursor, NULL, &virtcol, NULL);", "      wp->w_p_list = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["      }", "    } else if (this_ru_col + (int)STRLEN(buffer) > width)", "      buffer[width - this_ru_col] = NUL;"], "readability/braces"]
["src/nvim/screen.c", ["{", "  static int busy = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["      if (curwin->w_p_scb)", "        do_check_scrollbind(TRUE);", "      if (State & CMDLINE) {"], "readability/bool"]
["src/nvim/screen.c", ["          ins_compl_show_pum();           /* This includes the redraw. */", "        } else", "          update_screen(NOT_VALID);"], "readability/braces"]
["src/nvim/search.c", ["static char_u lastc[2] = {NUL, NUL};        /* last character searched for */", "static int lastcdir = FORWARD;              /* last direction of character search */", "static int last_t_cmd = TRUE;               /* last search t_cmd */"], "whitespace/line_length"]
["src/nvim/search.c", ["static int lastcdir = FORWARD;              /* last direction of character search */", "static int last_t_cmd = TRUE;               /* last search t_cmd */", "static char_u lastc_bytes[MB_MAXBYTES + 1];"], "readability/bool"]
["src/nvim/search.c", ["static char_u       *mr_pattern = NULL; /* pattern used by search_regcomp() */", "static int mr_pattern_alloced = FALSE;          /* mr_pattern was allocated */", ""], "readability/bool"]
["src/nvim/search.c", [" */", "int ", "search_regcomp ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["int ", "search_regcomp (", "    char_u *pat,"], "whitespace/parens"]
["src/nvim/search.c", ["", "  rc_did_emsg = FALSE;", "  magic = p_magic;"], "readability/bool"]
["src/nvim/search.c", ["        EMSG(_(e_noprevre));", "      rc_did_emsg = TRUE;", "      return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    no_smartcase = spats[i].no_scs;", "  } else if (options & SEARCH_HIS)      /* put new pattern in history */", "    add_to_history(HIST_SEARCH, pat, TRUE, NUL);"], "readability/braces"]
["src/nvim/search.c", ["  } else if (options & SEARCH_HIS)      /* put new pattern in history */", "    add_to_history(HIST_SEARCH, pat, TRUE, NUL);", ""], "readability/bool"]
["src/nvim/search.c", ["    xfree(mr_pattern);", "    mr_pattern_alloced = FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["    mr_pattern = reverse_text(pat);", "    mr_pattern_alloced = TRUE;", "  } else"], "readability/bool"]
["src/nvim/search.c", ["    mr_pattern_alloced = TRUE;", "  } else", "    mr_pattern = pat;"], "readability/braces"]
["src/nvim/search.c", ["      s_i += mb_len - 1;", "    } else", "      rev[--rev_i] = s[s_i];"], "readability/braces"]
["src/nvim/search.c", ["      redraw_all_later(SOME_VALID);", "    SET_NO_HLSEARCH(FALSE);", "  }"], "readability/bool"]
["src/nvim/search.c", ["    xfree(mr_pattern);", "    mr_pattern_alloced = FALSE;", "    mr_pattern = NULL;"], "readability/bool"]
["src/nvim/search.c", ["    ic = !pat_has_uppercase(pat);", "  no_smartcase = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["      if (enc_utf8 && utf_isupper(utf_ptr2char(p)))", "        return TRUE;", "      p += l;"], "readability/bool"]
["src/nvim/search.c", ["        p += 1;", "    } else if (vim_isupper(*p))", "      return TRUE;"], "readability/braces"]
["src/nvim/search.c", ["    } else if (vim_isupper(*p))", "      return TRUE;", "    else"], "readability/bool"]
["src/nvim/search.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/search.c", ["{", "  return last_t_cmd == TRUE;", "}"], "readability/bool"]
["src/nvim/search.c", ["  spats[idx].magic = magic;", "  spats[idx].no_scs = FALSE;", "  spats[idx].off.dir = '/';"], "readability/bool"]
["src/nvim/search.c", ["  set_vv_searchforward();", "  spats[idx].off.line = FALSE;", "  spats[idx].off.end = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["  spats[idx].off.line = FALSE;", "  spats[idx].off.end = FALSE;", "  spats[idx].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["int searchit(", "    win_T       *win,               /* window to search in, can be NULL for a", "                                       buffer without a window! */"], "readability/multiline_comment"]
["src/nvim/search.c", ["    win_T       *win,               /* window to search in, can be NULL for a", "                                       buffer without a window! */", "    buf_T       *buf,"], "whitespace/operators"]
["src/nvim/search.c", ["    int options,", "    int pat_use,                    /* which pattern to use when \"pat\" is empty */", "    linenr_T stop_lnum,             /* stop after this line number when != 0 */"], "whitespace/line_length"]
["src/nvim/search.c", ["  int save_called_emsg = called_emsg;", "  int break_loop = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["   */", "  called_emsg = FALSE;", "  do {  /* loop for count */"], "readability/bool"]
["src/nvim/search.c", ["      // Watch out for the \"col\" being MAXCOL - 2, used in a closed fold.", "      ptr = ml_get_buf(buf, pos->lnum, FALSE) + pos->col;", "      extra_col = *ptr == NUL ? 1 : (*mb_ptr2len)(ptr);"], "readability/bool"]
["src/nvim/search.c", ["    found = 0;                  /* default: not found */", "    at_first_line = TRUE;       /* default: start in first line */", "    if (pos->lnum == 0) {       /* correct lnum for when starting in line 0 */"], "readability/bool"]
["src/nvim/search.c", ["      pos->col = 0;", "      at_first_line = FALSE;        /* not in first line now */", "    }"], "readability/bool"]
["src/nvim/search.c", ["      lnum = pos->lnum - 1;", "      at_first_line = FALSE;", "    } else"], "readability/bool"]
["src/nvim/search.c", ["      at_first_line = FALSE;", "    } else", "      lnum = pos->lnum;"], "readability/braces"]
["src/nvim/search.c", ["      for (; lnum > 0 && lnum <= buf->b_ml.ml_line_count;", "           lnum += dir, at_first_line = FALSE) {", "        /* Stop after checking \"stop_lnum\", if it's set. */"], "readability/bool"]
["src/nvim/search.c", ["            tm", "            );", "        /* Abort searching on an error (e.g., out of stack). */"], "whitespace/parens"]
["src/nvim/search.c", ["          else", "            ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);", ""], "readability/bool"]
["src/nvim/search.c", ["          if (dir == FORWARD && at_first_line) {", "            match_ok = TRUE;", "            /*"], "readability/bool"]
["src/nvim/search.c", ["                   * this line */", "                  match_ok = FALSE;", "                  break;"], "readability/bool"]
["src/nvim/search.c", ["                          tm", "                          )) == 0) {", "                match_ok = FALSE;"], "whitespace/parens"]
["src/nvim/search.c", ["                          )) == 0) {", "                match_ok = FALSE;", "                break;"], "readability/bool"]
["src/nvim/search.c", ["               * multi-line search may have made it invalid. */", "              ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);", "            }"], "readability/bool"]
["src/nvim/search.c", ["             */", "            match_ok = FALSE;", "            for (;; ) {"], "readability/bool"]
["src/nvim/search.c", ["                             <= (int)start_pos.col)))) {", "                match_ok = TRUE;", "                matchpos = regmatch.startpos[0];"], "readability/bool"]
["src/nvim/search.c", ["                submatch = first_submatch(&regmatch);", "              } else", "                break;"], "readability/braces"]
["src/nvim/search.c", ["                          tm", "                          )) == 0)", "                break;"], "whitespace/parens"]
["src/nvim/search.c", ["               * multi-line search may have made it invalid. */", "              ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);", "            }"], "readability/bool"]
["src/nvim/search.c", ["                pos->col = (colnr_T)STRLEN(ml_get_buf(buf,", "                        pos->lnum, FALSE));", "              }"], "readability/bool"]
["src/nvim/search.c", ["                  && pos->lnum <= buf->b_ml.ml_line_count) {", "                ptr = ml_get_buf(buf, pos->lnum, FALSE);", "                pos->col -= (*mb_head_off)(ptr, ptr + pos->col);"], "readability/bool"]
["src/nvim/search.c", ["            && char_avail()) {", "          break_loop = TRUE;", "          break;"], "readability/bool"]
["src/nvim/search.c", ["      }", "      at_first_line = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["    pos->lnum = buf->b_ml.ml_line_count;", "    pos->col = (int)STRLEN(ml_get_buf(buf, pos->lnum, FALSE));", "    if (pos->col > 0)"], "readability/bool"]
["src/nvim/search.c", ["  if (spats[0].off.line && vim_strchr(p_cpo, CPO_LINEOFF) != NULL) {", "    spats[0].off.line = FALSE;", "    spats[0].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["    dirc = spats[0].off.dir;", "  else {", "    spats[0].off.dir = dirc;"], "readability/braces"]
["src/nvim/search.c", ["    redraw_all_later(SOME_VALID);", "    SET_NO_HLSEARCH(FALSE);", "  }"], "readability/bool"]
["src/nvim/search.c", ["      }", "      spats[0].off.line = FALSE;", "      spats[0].off.end = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["      spats[0].off.line = FALSE;", "      spats[0].off.end = FALSE;", "      spats[0].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["      if (*p == '+' || *p == '-' || ascii_isdigit(*p))", "        spats[0].off.line = TRUE;", "      else if ((options & SEARCH_OPT) &&"], "readability/bool"]
["src/nvim/search.c", ["      }", "      if (ascii_isdigit(*p) || *p == '+' || *p == '-') {      /* got an offset */", "        /* 'nr' or '+nr' or '-nr' */"], "whitespace/line_length"]
["src/nvim/search.c", ["          STRCPY(msgbuf + 2, p);", "        } else", "          STRCPY(msgbuf + 1, p);"], "readability/braces"]
["src/nvim/search.c", ["          if (spats[0].off.off != 0 || spats[0].off.line)", "            sprintf((char *)p, \"%\" PRId64, (int64_t)spats[0].off.off);", "          else"], "runtime/printf"]
["src/nvim/search.c", ["        msg_start();", "        trunc = msg_strtrunc(msgbuf, FALSE);", ""], "readability/bool"]
["src/nvim/search.c", ["          xfree(trunc);", "        } else", "          msg_outtrans(msgbuf);"], "readability/braces"]
["src/nvim/search.c", ["", "        gotocmdline(FALSE);", "        ui_flush();"], "readability/bool"]
["src/nvim/search.c", ["        ui_flush();", "        msg_nowait = TRUE;                  /* don't wait for this message */", "      }"], "readability/bool"]
["src/nvim/search.c", ["    if (p_altkeymap && curwin->w_p_rl)", "      lrFswap(searchstr,0);", ""], "whitespace/comma"]
["src/nvim/search.c", ["        /* to the left, check for start of file */", "        else {", "          while (c++ < 0)"], "whitespace/newline"]
["src/nvim/search.c", ["        /* to the left, check for start of file */", "        else {", "          while (c++ < 0)"], "readability/braces"]
["src/nvim/search.c", ["  curwin->w_cursor = pos;", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/search.c", ["      start = pos->lnum;", "    ptr = ml_get_buf(buf, pos->lnum, FALSE);", "    p = skipwhite(ptr);"], "readability/bool"]
["src/nvim/search.c", ["  int len;", "  int stop = TRUE;", ""], "readability/bool"]
["src/nvim/search.c", ["      if (cap->ncharC1 != 0) {", "        lastc_bytelen += (*mb_char2bytes)(cap->ncharC1, lastc_bytes + lastc_bytelen);", "        if (cap->ncharC2 != 0)"], "whitespace/line_length"]
["src/nvim/search.c", ["        if (cap->ncharC2 != 0)", "          lastc_bytelen += (*mb_char2bytes)(cap->ncharC2, lastc_bytes + lastc_bytelen);", "      }"], "whitespace/line_length"]
["src/nvim/search.c", ["    if (vim_strchr(p_cpo, CPO_SCOLON) == NULL && count == 1 && t_cmd)", "      stop = FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["        }", "        stop = TRUE;", "      }"], "readability/bool"]
["src/nvim/search.c", ["          break;", "        stop = TRUE;", "      }"], "readability/bool"]
["src/nvim/search.c", ["    *prevcol = col;", "  return (col >= 0 && linep[col] == ch) ? TRUE : FALSE;", "}"], "readability/bool"]
["src/nvim/search.c", ["  int count = 0;                        /* cumulative number of braces */", "  int backwards = FALSE;                /* init for gcc */", "  int inquote = FALSE;                  /* TRUE when inside quotes */"], "readability/bool"]
["src/nvim/search.c", ["  int backwards = FALSE;                /* init for gcc */", "  int inquote = FALSE;                  /* TRUE when inside quotes */", "  char_u      *linep;                   /* pointer to current line */"], "readability/bool"]
["src/nvim/search.c", ["  int traveled = 0;                     /* how far we've searched so far */", "  int ignore_cend = FALSE;              /* ignore comment end */", "  int cpo_match;                        /* vi compatible matching */"], "readability/bool"]
["src/nvim/search.c", ["  int comment_col = MAXCOL;             /* start of / / comment */", "  int lispcomm = FALSE;                 /* inside of Lisp-style comment */", "  int lisp = curbuf->b_p_lisp;           /* engage Lisp-specific hacks ;) */"], "readability/bool"]
["src/nvim/search.c", ["    if (initc == '/')", "      ignore_cend = TRUE;", "    backwards = (dir == FORWARD) ? FALSE : TRUE;"], "readability/bool"]
["src/nvim/search.c", ["      ignore_cend = TRUE;", "    backwards = (dir == FORWARD) ? FALSE : TRUE;", "    initc = NUL;"], "readability/bool"]
["src/nvim/search.c", ["  } else if (initc != '#' && initc != NUL) {", "    find_mps_values(&initc, &findc, &backwards, TRUE);", "    if (findc == NUL)"], "readability/bool"]
["src/nvim/search.c", ["   */", "  else {", "    if (initc == '#') {"], "whitespace/newline"]
["src/nvim/search.c", ["   */", "  else {", "    if (initc == '#') {"], "readability/braces"]
["src/nvim/search.c", ["        /* Are we on a comment? */", "        else if (linep[pos.col] == '/') {", "          if (linep[pos.col + 1] == '*') {"], "whitespace/newline"]
["src/nvim/search.c", ["            comment_dir = FORWARD;", "            backwards = FALSE;", "            pos.col++;"], "readability/bool"]
["src/nvim/search.c", ["            comment_dir = BACKWARD;", "            backwards = TRUE;", "            pos.col--;"], "readability/bool"]
["src/nvim/search.c", ["            comment_dir = BACKWARD;", "            backwards = TRUE;", "          } else if (pos.col > 0 && linep[pos.col - 1] == '/') {"], "readability/bool"]
["src/nvim/search.c", ["            comment_dir = FORWARD;", "            backwards = FALSE;", "          }"], "readability/bool"]
["src/nvim/search.c", ["", "          find_mps_values(&initc, &findc, &backwards, FALSE);", "          if (findc)"], "readability/bool"]
["src/nvim/search.c", ["            break;", "        } else if (pos.lnum == 1)", "          break;"], "readability/braces"]
["src/nvim/search.c", ["              return &pos;", "          } else if (STRNCMP(ptr, \"endif\", 5) == 0)", "            count++;"], "readability/braces"]
["src/nvim/search.c", ["  if (lisp && comment_col != MAXCOL && pos.col > (colnr_T)comment_col)", "    lispcomm = TRUE;        /* find match inside this comment */", "  while (!got_int) {"], "readability/bool"]
["src/nvim/search.c", ["      if (!do_quotes) {", "        inquote = FALSE;", "        if (ptr[-1] == '\\\\') {"], "readability/bool"]
["src/nvim/search.c", ["            /* Do we need to use at_start here? */", "            inquote = TRUE;", "            start_in_quotes = TRUE;"], "readability/bool"]
["src/nvim/search.c", ["            inquote = TRUE;", "            start_in_quotes = TRUE;", "          } else if (backwards)"], "readability/bool"]
["src/nvim/search.c", ["            start_in_quotes = TRUE;", "          } else if (backwards)", "            inquote = TRUE;"], "readability/braces"]
["src/nvim/search.c", ["          } else if (backwards)", "            inquote = TRUE;", "        }"], "readability/bool"]
["src/nvim/search.c", ["              if (inquote)", "                start_in_quotes = TRUE;", "            } else if (!backwards)"], "readability/bool"]
["src/nvim/search.c", ["                start_in_quotes = TRUE;", "            } else if (!backwards)", "              inquote = TRUE;"], "readability/braces"]
["src/nvim/search.c", ["            } else if (!backwards)", "              inquote = TRUE;", "          }"], "readability/bool"]
["src/nvim/search.c", ["    if (start_in_quotes == MAYBE)", "      start_in_quotes = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["      if (pos.col == 0 || linep[pos.col - 1] != '\\\\') {", "        inquote = FALSE;", "        start_in_quotes = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["        inquote = FALSE;", "        start_in_quotes = FALSE;", "      }"], "readability/bool"]
["src/nvim/search.c", ["          inquote = !inquote;", "          start_in_quotes = FALSE;", "        }"], "readability/bool"]
["src/nvim/search.c", ["       * quotes when the start is also inside of quotes. */", "      if ((!inquote || start_in_quotes == TRUE)", "          && (c == initc || c == findc)) {"], "readability/bool"]
["src/nvim/search.c", ["            count++;", "          else {", "            if (count == 0)"], "readability/braces"]
["src/nvim/search.c", ["    if (vim_strchr(p, ';') != NULL) {   /* there may be comments */", "      int in_str = FALSE;       /* inside of string */", ""], "readability/bool"]
["src/nvim/search.c", ["            if (*(p - 1) != '\\\\')             /* skip escaped quote */", "              in_str = FALSE;", "          } else if (p == line || ((p - line) >= 2"], "readability/bool"]
["src/nvim/search.c", ["              in_str = FALSE;", "          } else if (p == line || ((p - line) >= 2", "                                   /* skip #\\\" form */"], "readability/braces"]
["src/nvim/search.c", ["                                   && *(p - 1) != '\\\\' && *(p - 2) != '#'))", "            in_str = TRUE;", "        } else if (!in_str && ((p - line) < 2"], "readability/bool"]
["src/nvim/search.c", ["            in_str = TRUE;", "        } else if (!in_str && ((p - line) < 2", "                               || (*(p - 1) != '\\\\' && *(p - 2) != '#')))"], "readability/braces"]
["src/nvim/search.c", ["      }", "    } else", "      p = NULL;"], "readability/braces"]
["src/nvim/search.c", ["      p = NULL;", "  } else", "    while ((p = vim_strchr(p, '/')) != NULL) {"], "readability/braces"]
["src/nvim/search.c", [" */", "void ", "showmatch ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["void ", "showmatch (", "    int c                      /* char to show match for */"], "whitespace/parens"]
["src/nvim/search.c", ["      p_siso = 0;                       /* don't use 'sidescrolloff' here */", "      showruler(FALSE);", "      setcursor();"], "readability/bool"]
["src/nvim/search.c", ["  int startlnum;", "  int noskip = FALSE;               /* do not skip blanks */", "  int cpo_J;"], "readability/bool"]
["src/nvim/search.c", ["          break;", "      while (gchar_pos(&pos) == NUL);", "      if (dir == FORWARD)"], "whitespace/empty_loop_body"]
["src/nvim/search.c", ["     */", "    else if (dir == FORWARD && pos.col == 0 &&", "             startPS(pos.lnum, NUL, FALSE)) {"], "whitespace/newline"]
["src/nvim/search.c", ["    else if (dir == FORWARD && pos.col == 0 &&", "             startPS(pos.lnum, NUL, FALSE)) {", "      if (pos.lnum == curbuf->b_ml.ml_line_count)"], "readability/bool"]
["src/nvim/search.c", ["      goto found;", "    } else if (dir == BACKWARD)", "      decl(&pos);"], "readability/braces"]
["src/nvim/search.c", ["    /* go back to the previous non-blank char */", "    found_dot = FALSE;", "    while ((c = gchar_pos(&pos)) == ' ' || c == '\\t' ||"], "readability/bool"]
["src/nvim/search.c", ["          break;", "        found_dot = TRUE;", "      }"], "readability/bool"]
["src/nvim/search.c", ["      c = gchar_pos(&pos);", "      if (c == NUL || (pos.col == 0 && startPS(pos.lnum, NUL, FALSE))) {", "        if (dir == BACKWARD && pos.lnum != startlnum)"], "readability/bool"]
["src/nvim/search.c", ["        while (vim_strchr((char_u *)\")]\\\"'\", c = gchar_pos(&tpos))", "               != NULL);", "        if (c == -1  || (!cpo_J && (c == ' ' || c == '\\t')) || c == NUL"], "whitespace/empty_loop_body"]
["src/nvim/search.c", ["          return FAIL;", "        noskip = TRUE;", "        break;"], "readability/bool"]
["src/nvim/search.c", ["bool", "findpar (", "    bool *pincl,        /* Return: true if last char is to be included */"], "whitespace/parens"]
["src/nvim/search.c", ["  linenr_T fold_last;       /* last line of a closed fold */", "  bool fold_skipped;        /* true if a closed fold was skipped this", "                               iteration */"], "readability/multiline_comment"]
["src/nvim/search.c", ["    }", "  } else", "    curwin->w_cursor.col = 0;"], "readability/braces"]
["src/nvim/search.c", ["  if (*s == para || *s == '\\f' || (both && *s == '}'))", "    return TRUE;", "  if (*s == '.' && (inmacro(p_sections, s + 1) ||"], "readability/bool"]
["src/nvim/search.c", ["                    (!para && inmacro(p_para, s + 1))))", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/search.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/search.c", [" */", "int ", "fwd_word ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["int ", "fwd_word (", "    long count,"], "whitespace/parens"]
["src/nvim/search.c", ["finished:", "    stop = FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["finished:", "    stop = FALSE;                       /* we move only one word less */", "  }"], "readability/bool"]
["src/nvim/search.c", [" */", "int ", "bckend_word ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["int ", "bckend_word (", "    long count,"], "whitespace/parens"]
["src/nvim/search.c", ["    if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)", "      return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/search.c", ["      return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/search.c", [" */", "static void ", "findsent_forward ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["static void ", "findsent_forward (", "    long count,"], "whitespace/parens"]
["src/nvim/search.c", [" */", "int ", "current_word ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["int ", "current_word (", "    oparg_T *oap,"], "whitespace/parens"]
["src/nvim/search.c", ["  bool inclusive = true;", "  int include_white = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["    if ((cls() == 0) == include) {", "      if (end_word(1L, bigword, TRUE, TRUE) == FAIL)", "        return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["       */", "      fwd_word(1L, bigword, TRUE);", "      if (curwin->w_cursor.col == 0)"], "readability/bool"]
["src/nvim/search.c", ["      if (include)", "        include_white = TRUE;", "    }"], "readability/bool"]
["src/nvim/search.c", ["      if (include != (cls() != 0)) {", "        if (bck_word(1L, bigword, TRUE) == FAIL)", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["      } else {", "        if (bckend_word(1L, bigword, TRUE) == FAIL)", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["      if (include != (cls() == 0)) {", "        if (fwd_word(1L, bigword, TRUE) == FAIL && count > 1)", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["      } else {", "        if (end_word(1L, bigword, TRUE, TRUE) == FAIL)", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["      VIsual_mode = 'v';", "      redraw_cmdline = TRUE;                    /* show mode later */", "    }"], "readability/bool"]
["src/nvim/search.c", ["    }", "  } else", "    oap->inclusive = inclusive;"], "readability/braces"]
["src/nvim/search.c", ["       */", "      at_start_sent = TRUE;", "      decl(&pos);"], "readability/bool"]
["src/nvim/search.c", ["        if (!ascii_iswhite(c)) {", "          at_start_sent = FALSE;", "          break;"], "readability/bool"]
["src/nvim/search.c", ["        if (equalpos(curwin->w_cursor, start_pos))", "          at_start_sent = TRUE;            /* exactly at start of sentence */", "        else"], "readability/bool"]
["src/nvim/search.c", ["      incl(&pos);", "      at_start_sent = TRUE;", "      if (!equalpos(pos, curwin->w_cursor)) {     /* not just before a sentence */"], "readability/bool"]
["src/nvim/search.c", ["      at_start_sent = TRUE;", "      if (!equalpos(pos, curwin->w_cursor)) {     /* not just before a sentence */", "        at_start_sent = FALSE;"], "whitespace/line_length"]
["src/nvim/search.c", ["      if (!equalpos(pos, curwin->w_cursor)) {     /* not just before a sentence */", "        at_start_sent = FALSE;", "        while (lt(pos, curwin->w_cursor)) {"], "readability/bool"]
["src/nvim/search.c", ["          if (!ascii_iswhite(c)) {", "            at_start_sent = TRUE;", "            break;"], "readability/bool"]
["src/nvim/search.c", ["  if (equalpos(pos, curwin->w_cursor)) {", "    start_blank = TRUE;", "    find_first_blank(&start_pos);       /* go back to first blank */"], "readability/bool"]
["src/nvim/search.c", ["  } else {", "    start_blank = FALSE;", "    findsent(BACKWARD, 1L);"], "readability/bool"]
["src/nvim/search.c", ["    ncount = count * 2;", "  else {", "    ncount = count;"], "readability/braces"]
["src/nvim/search.c", ["  if (ncount > 0)", "    findsent_forward(ncount, TRUE);", "  else"], "readability/bool"]
["src/nvim/search.c", ["        decl(&curwin->w_cursor);", "    } else if (c = gchar_cursor(), !ascii_iswhite(c))", "      find_first_blank(&start_pos);"], "readability/braces"]
["src/nvim/search.c", [" */", "int ", "current_block ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["int ", "current_block (", "    oparg_T *oap,"], "whitespace/parens"]
["src/nvim/search.c", ["  char_u      *save_cpo;", "  int sol = FALSE;                      /* '{' at start of line */", ""], "readability/bool"]
["src/nvim/search.c", ["    curwin->w_cursor = VIsual;              /* cursor at low end of Visual */", "  } else", "    old_end = VIsual;"], "readability/braces"]
["src/nvim/search.c", ["    while (inindent(1)) {", "      sol = TRUE;", "      if (decl(&curwin->w_cursor) != 0) {"], "readability/bool"]
["src/nvim/search.c", ["      curwin->w_cursor = *end_pos;", "    } else", "      break;"], "readability/braces"]
["src/nvim/search.c", ["      if (lc != '<')", "        return FALSE;", "      p = lp;"], "readability/bool"]
["src/nvim/search.c", ["    if (*p != '<')", "      return FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["  if (*p == '/')", "    return FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["    if (inc(&pos) < 0)", "      return FALSE;", "    c = *ml_get_pos(&pos);"], "readability/bool"]
["src/nvim/search.c", [" */", "int ", "current_tagblock ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["int ", "current_tagblock (", "    oparg_T *oap,"], "whitespace/parens"]
["src/nvim/search.c", ["", "    if (in_html_tag(FALSE)) {", "      /* cursor on start tag, move to its '>' */"], "readability/bool"]
["src/nvim/search.c", ["          break;", "    } else if (in_html_tag(TRUE)) {", "      /* cursor on end tag, move to just before it */"], "readability/bool"]
["src/nvim/search.c", ["    curwin->w_cursor = VIsual;              /* cursor at low end of Visual */", "  } else", "    old_end = VIsual;"], "readability/braces"]
["src/nvim/search.c", ["  for (cp = p; *cp != NUL && *cp != '>' && !ascii_iswhite(*cp); mb_ptr_adv(cp))", "    ;", "  len = (int)(cp - p);"], "whitespace/semicolon"]
["src/nvim/search.c", ["  epat = xmalloc(len + 9);", "  sprintf((char *)spat, \"<%.*s\\\\>\\\\%%(\\\\s\\\\_[^>]\\\\{-}[^/]>\\\\|>\\\\)\\\\c\", len, p);", "  sprintf((char *)epat, \"</%.*s>\\\\c\", len, p);"], "runtime/printf"]
["src/nvim/search.c", ["  sprintf((char *)spat, \"<%.*s\\\\>\\\\%%(\\\\s\\\\_[^>]\\\\{-}[^/]>\\\\|>\\\\)\\\\c\", len, p);", "  sprintf((char *)epat, \"</%.*s>\\\\c\", len, p);", ""], "runtime/printf"]
["src/nvim/search.c", ["    if (equalpos(start_pos, old_start) && equalpos(end_pos, old_end)) {", "      do_include = TRUE;", "      curwin->w_cursor = old_start;"], "readability/bool"]
["src/nvim/search.c", ["      oap->inclusive = false;", "    } else", "      oap->inclusive = true;"], "readability/braces"]
["src/nvim/search.c", ["", "int ", "current_par ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["int ", "current_par (", "    oparg_T *oap,"], "whitespace/parens"]
["src/nvim/search.c", ["  int retval = OK;", "  int do_white = FALSE;", "  int t;"], "readability/bool"]
["src/nvim/search.c", [" */", "static int ", "find_next_quote ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["static int ", "find_next_quote (", "    char_u *line,"], "whitespace/parens"]
["src/nvim/search.c", [" */", "static int ", "find_prev_quote ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["static int ", "find_prev_quote (", "    char_u *line,"], "whitespace/parens"]
["src/nvim/search.c", [" */", "int ", "current_quote ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["int ", "current_quote (", "    oparg_T *oap,"], "whitespace/parens"]
["src/nvim/search.c", ["  bool inclusive = false;", "  int vis_empty = TRUE;                 /* Visual selection <= 1 char */", "  int vis_bef_curs = FALSE;             /* Visual starts before cursor */"], "readability/bool"]
["src/nvim/search.c", ["  int vis_empty = TRUE;                 /* Visual selection <= 1 char */", "  int vis_bef_curs = FALSE;             /* Visual starts before cursor */", "  int inside_quotes = FALSE;            /* Looks like \"i'\" done before */"], "readability/bool"]
["src/nvim/search.c", ["  int vis_bef_curs = FALSE;             /* Visual starts before cursor */", "  int inside_quotes = FALSE;            /* Looks like \"i'\" done before */", "  int selected_quote = FALSE;           /* Has quote inside selection */"], "readability/bool"]
["src/nvim/search.c", ["  int inside_quotes = FALSE;            /* Looks like \"i'\" done before */", "  int selected_quote = FALSE;           /* Has quote inside selection */", "  int i;"], "readability/bool"]
["src/nvim/search.c", ["      if (line[i++] == quotechar) {", "        selected_quote = TRUE;", "        break;"], "readability/bool"]
["src/nvim/search.c", ["      if (col_start < 0)", "        return FALSE;", "      col_end = find_next_quote(line, col_start + 1, quotechar,"], "readability/bool"]
["src/nvim/search.c", ["      if (line[col_end] != quotechar)", "        return FALSE;", "      col_start = find_prev_quote(line, col_end, quotechar,"], "readability/bool"]
["src/nvim/search.c", ["      if (col_start < 0 || col_start > first_col)", "        return FALSE;", "      /* Find close quote character. */"], "readability/bool"]
["src/nvim/search.c", ["      if (col_end < 0)", "        return FALSE;", "      /* If is cursor between start and end quote character, it is"], "readability/bool"]
["src/nvim/search.c", ["      if (col_start < 0)", "        return FALSE;", "    }"], "readability/bool"]
["src/nvim/search.c", ["    if (col_end < 0)", "      return FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["       || (!vis_empty && inside_quotes)", "       ) && inc_cursor() == 2)", "    inclusive = true;"], "whitespace/parens"]
["src/nvim/search.c", ["      VIsual_mode = 'v';", "      redraw_cmdline = TRUE;                    /* show mode later */", "    }"], "readability/bool"]
["src/nvim/search.c", [" */", "int ", "current_search ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["int ", "current_search (", "    long count,"], "whitespace/parens"]
["src/nvim/search.c", ["    }", "  } else", "    orig_pos = pos = curwin->w_cursor;"], "readability/braces"]
["src/nvim/search.c", ["  curwin->w_cursor = pos;", "  VIsual_active = TRUE;", "  VIsual_mode = 'v';"], "readability/bool"]
["src/nvim/search.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/search.c", ["     * start and end are in the same position. */", "    called_emsg = FALSE;", "    nmatched = vim_regexec_multi(&regmatch, curwin, curbuf,"], "readability/bool"]
["src/nvim/search.c", ["    if (!result && inc(&pos) >= 0 && pos.col == regmatch.endpos[0].col)", "      result = TRUE;", "  }"], "readability/bool"]
["src/nvim/search.c", [" */", "void ", "find_pattern_in_path ("], "whitespace/end_of_line"]
["src/nvim/search.c", ["void ", "find_pattern_in_path (", "    char_u *ptr,               /* pointer to search pattern */"], "whitespace/parens"]
["src/nvim/search.c", ["    int skip_comments,              /* don't match inside comments */", "    int type,                       /* Type of search; are we looking for a type?", "                                   a macro? */"], "readability/multiline_comment"]
["src/nvim/search.c", ["    int skip_comments,              /* don't match inside comments */", "    int type,                       /* Type of search; are we looking for a type?", "                                   a macro? */"], "whitespace/line_length"]
["src/nvim/search.c", ["  regmatch_T def_regmatch;", "  int matched = FALSE;", "  int did_show = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["  int matched = FALSE;", "  int did_show = FALSE;", "  int found = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["  int did_show = FALSE;", "  int found = FALSE;", "  int i;"], "readability/bool"]
["src/nvim/search.c", ["    assert(len <= INT_MAX);", "    sprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", (int)len, ptr);", "    /* ignore case according to p_ic, p_scs and pat */"], "runtime/printf"]
["src/nvim/search.c", ["      goto fpip_end;", "    incl_regmatch.rm_ic = FALSE;        /* don't ignore case in incl. pat. */", "  }"], "readability/bool"]
["src/nvim/search.c", ["      goto fpip_end;", "    def_regmatch.rm_ic = FALSE;         /* don't ignore case in define pat. */", "  }"], "readability/bool"]
["src/nvim/search.c", ["            FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);", "      already_searched = FALSE;", "      if (new_fname != NULL) {"], "readability/bool"]
["src/nvim/search.c", ["            break;", "          if (path_full_compare(new_fname, files[i].name, TRUE) & kEqualFiles) {", "            if (type != CHECK_PATH &&"], "readability/bool"]
["src/nvim/search.c", ["              msg_putchar('\\n');                    /* cursor below last one */", "              if (!got_int) {                       /* don't display if 'q'", "                                                       typed at \"--more--\""], "readability/multiline_comment"]
["src/nvim/search.c", ["            new_fname = NULL;", "            already_searched = TRUE;", "            break;"], "readability/bool"]
["src/nvim/search.c", ["          msg_putchar('\\n');                /* cursor below last one */", "        else {", "          gotocmdline(TRUE);                /* cursor at status line */"], "readability/braces"]
["src/nvim/search.c", ["        else {", "          gotocmdline(TRUE);                /* cursor at status line */", "          MSG_PUTS_TITLE(_(\"--- Included files \"));"], "readability/bool"]
["src/nvim/search.c", ["        }", "        did_show = TRUE;", "        while (depth_displayed < depth && !got_int) {"], "readability/bool"]
["src/nvim/search.c", ["        }", "        if (!got_int) {                     /* don't display if 'q' typed", "                                               for \"--more--\" message */"], "readability/multiline_comment"]
["src/nvim/search.c", ["                   *p && !vim_isfilec(*p); p++)", "                ;", "              for (i = 0; vim_isfilec(p[i]); i++)"], "whitespace/semicolon"]
["src/nvim/search.c", ["              for (i = 0; vim_isfilec(p[i]); i++)", "                ;", "            }"], "whitespace/semicolon"]
["src/nvim/search.c", ["             * happen if \\zs appears in the regexp. */", "            else if (p > line) {", "              if (p[-1] == '\"' || p[-1] == '<') {"], "whitespace/newline"]
["src/nvim/search.c", ["            bigger[i].lnum = 0;", "            bigger[i].matched = FALSE;", "          }"], "readability/bool"]
["src/nvim/search.c", ["          xfree(new_fname);", "        else {", "          if (++depth == old_files) {"], "readability/braces"]
["src/nvim/search.c", ["          files[depth].lnum = 0;", "          files[depth].matched = FALSE;", "          if (action == ACTION_EXPAND) {"], "readability/bool"]
["src/nvim/search.c", ["          if (action == ACTION_EXPAND) {", "            msg_hist_off = TRUE;                /* reset in msg_trunc_attr() */", "            vim_snprintf((char*)IObuff, IOSIZE,"], "readability/bool"]
["src/nvim/search.c", ["                (char *)new_fname);", "            msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));", "          } else if (p_verbose >= 5) {"], "readability/bool"]
["src/nvim/search.c", ["          }", "", "        }"], "whitespace/blank_line"]
["src/nvim/search.c", ["search_line:", "      define_matched = FALSE;", "      if (def_regmatch.regprog != NULL"], "readability/bool"]
["src/nvim/search.c", ["          p++;", "        define_matched = TRUE;", "      }"], "readability/bool"]
["src/nvim/search.c", ["          }", "          else", "            matched = !STRNCMP(startp, ptr, len);"], "whitespace/newline"]
["src/nvim/search.c", ["              && vim_iswordc(startp[len]))", "            matched = FALSE;", "        } else if (regmatch.regprog != NULL"], "readability/bool"]
["src/nvim/search.c", ["                   && vim_regexec(&regmatch, line, (colnr_T)(p - line))) {", "          matched = TRUE;", "          startp = regmatch.startp[0];"], "readability/bool"]
["src/nvim/search.c", ["                 STRNCMP(skipwhite(line + 1), \"define\", 6) != 0)", "                && get_leader_len(line, NULL, FALSE, TRUE))", "              matched = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["                && get_leader_len(line, NULL, FALSE, TRUE))", "              matched = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["                    && (p[1] == '*' || p[1] == '/')) {", "                  matched = FALSE;", "                  /* After \"//\" all text is comment */"], "readability/bool"]
["src/nvim/search.c", ["                  /* Can find match after \"* /\". */", "                  matched = TRUE;", "                  ++p;"], "readability/bool"]
["src/nvim/search.c", ["          break;", "        found = TRUE;", "        aux = p = startp;"], "readability/bool"]
["src/nvim/search.c", ["            line = ml_get(++lnum);", "          } else if (vim_fgets(line = file_line,", "                         LSIZE, files[depth].fp))"], "readability/braces"]
["src/nvim/search.c", ["      } else if (action == ACTION_SHOW_ALL) {", "        found = TRUE;", "        if (!did_show)"], "readability/bool"]
["src/nvim/search.c", ["        if (!did_show)", "          gotocmdline(TRUE);                    /* cursor at status line */", "        if (curr_fname != prev_fname) {"], "readability/bool"]
["src/nvim/search.c", ["            msg_putchar('\\n');                  /* cursor below last one */", "          if (!got_int)                         /* don't display if 'q' typed", "                                                    at \"--more--\" message */"], "readability/multiline_comment"]
["src/nvim/search.c", ["        }", "        did_show = TRUE;", "        if (!got_int)"], "readability/bool"]
["src/nvim/search.c", ["        if (!got_int)", "          show_pat_in_path(line, type, TRUE, action,", "              (depth == -1) ? NULL : files[depth].fp,"], "readability/bool"]
["src/nvim/search.c", ["        for (i = 0; i <= depth; ++i)", "          files[i].matched = TRUE;", "      } else if (--count <= 0) {"], "readability/bool"]
["src/nvim/search.c", ["      } else if (--count <= 0) {", "        found = TRUE;", "        if (depth == -1 && lnum == curwin->w_cursor.lnum"], "readability/bool"]
["src/nvim/search.c", ["              (depth == -1) ? &lnum : &files[depth].lnum, 1L);", "          did_show = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/search.c", ["              if (getfile(0, curwin_save->w_buffer->b_fname,", "                      NULL, TRUE, lnum, FALSE) > 0)", "                break;                  /* failed to jump to file */"], "readability/bool"]
["src/nvim/search.c", ["                break;                  /* failed to jump to file */", "            } else", "              setpcmark();"], "readability/braces"]
["src/nvim/search.c", ["          } else {", "            if (getfile(0, files[depth].name, NULL, TRUE,", "                    files[depth].lnum, FALSE) > 0)"], "readability/bool"]
["src/nvim/search.c", ["            if (getfile(0, files[depth].name, NULL, TRUE,", "                    files[depth].lnum, FALSE) > 0)", "              break;                    /* failed to jump to file */"], "readability/bool"]
["src/nvim/search.c", ["          curwin->w_cursor.col = (colnr_T)(startp - line);", "          curwin->w_set_curswant = TRUE;", "        }"], "readability/bool"]
["src/nvim/search.c", ["exit_matched:", "      matched = FALSE;", "      /* look for other matches in the rest of the line if we"], "readability/bool"]
["src/nvim/search.c", ["", "static void show_pat_in_path(char_u *line, int type, int did_show, int action, FILE *fp, linenr_T *lnum, long count)", "{"], "whitespace/line_length"]
["src/nvim/search.c", ["  else if (!msg_silent)", "    gotocmdline(TRUE);          /* cursor at status line */", "  if (got_int)                  /* 'q' typed at \"--more--\" message */"], "readability/bool"]
["src/nvim/search.c", ["    if (action == ACTION_SHOW_ALL) {", "      sprintf((char *)IObuff, \"%3ld: \", count);         /* show match nr */", "      msg_puts(IObuff);"], "runtime/printf"]
["src/nvim/search.c", ["      msg_puts(IObuff);", "      sprintf((char *)IObuff, \"%4ld\", *lnum);           /* show line nr */", "      /* Highlight line numbers */"], "runtime/printf"]
["src/nvim/search.c", ["    }", "    msg_prt_line(line, FALSE);", "    ui_flush();                        /* show one line at a time */"], "readability/bool"]
["src/nvim/sha256.c", ["  temp2 = S2(a) + F0(a, b, c); \\", "  d += temp1; h = temp1 + temp2; \\", "}"], "whitespace/newline"]
["src/nvim/spell.c", ["#ifndef UNIX            // it's in os/unix_defs.h for Unix", "# include <time.h>      // for time_t", "#endif"], "build/include_order"]
["src/nvim/spell.c", ["#define WF_PFX_UP   (WFP_UP << 24)      // to-upper postponed prefix", "#define WF_PFX_COMPPERMIT (WFP_COMPPERMIT << 24) // postponed prefix with", "                                                 // COMPOUNDPERMITFLAG"], "whitespace/comments"]
["src/nvim/spell.c", ["                                                 // COMPOUNDPERMITFLAG", "#define WF_PFX_COMPFORBID (WFP_COMPFORBID << 24) // postponed prefix with", "                                                 // COMPOUNDFORBIDFLAG"], "whitespace/comments"]
["src/nvim/spell.c", ["  garray_T sl_rep;              // list of fromto_T entries from REP lines", "  short sl_rep_first[256];          // indexes where byte first appears, -1 if", "                                    // there is none"], "runtime/int"]
["src/nvim/spell.c", ["  garray_T sl_repsal;           // list of fromto_T entries from REPSAL lines", "  short sl_repsal_first[256];   // sl_rep_first for REPSAL lines", "  bool sl_nosplitsugs;           // don't suggest splitting a word"], "runtime/int"]
["src/nvim/spell.c", ["  idx_T ts_arridx;              // index in tree array, start of node", "  short ts_curi;                // index in list of child nodes", "  char_u ts_fidx;               // index in fword[], case-folded bad word"], "runtime/int"]
["src/nvim/spell.c", ["  uint16_t wn_flags;            // WF_ flags", "  short wn_region;              // region mask", ""], "runtime/int"]
["src/nvim/spell.c", ["typedef struct {", "  short sft_score;              // lowest score used", "  char_u sft_word[1];           // soundfolded word, actually longer"], "runtime/int"]
["src/nvim/spell.c", ["size_t", "spell_check (", "    win_T *wp,                // current window"], "whitespace/parens"]
["src/nvim/spell.c", ["    // skip over the character (try looking for a word after it).", "    else if (!spell_iswordp_nmw(ptr, wp)) {", "      if (capcol != NULL && wp->w_s->b_cap_prog != NULL) {"], "whitespace/newline"]
["src/nvim/spell.c", ["        regmatch.regprog = wp->w_s->b_cap_prog;", "        regmatch.rm_ic = FALSE;", "        int r = vim_regexec(&regmatch, ptr, 0);"], "readability/bool"]
["src/nvim/spell.c", ["      return 1;", "    } else if (mi.mi_end == ptr)", "      // Always include at least one character.  Required for when there"], "readability/braces"]
["src/nvim/spell.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/spell.c", ["        lo = m + 1;", "      else {", "        lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["      word_ends = false;", "    } else", "      word_ends = true;"], "readability/braces"]
["src/nvim/spell.c", ["      // mip->mi_prefarridx that find_prefix() filled.", "      else if (mode == FIND_PREFIX && !prefix_found) {", "        c = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,"], "whitespace/newline"]
["src/nvim/spell.c", ["              mb_ptr_adv(p);", "          } else", "            p = mip->mi_word + mip->mi_compoff;"], "readability/braces"]
["src/nvim/spell.c", ["            continue;", "        } else if (slang->sl_comprules != NULL", "                   && !match_compoundrule(slang, mip->mi_compflags))"], "readability/braces"]
["src/nvim/spell.c", ["      // Check NEEDCOMPOUND: can't use word without compounding.", "      else if (flags & WF_NEEDCOMP)", "        continue;"], "whitespace/newline"]
["src/nvim/spell.c", ["          res = SP_LOCAL;", "      } else if (flags & WF_RARE)", "        res = SP_RARE;"], "readability/braces"]
["src/nvim/spell.c", ["          mip->mi_end2 = mip->mi_word + wlen;", "        } else if (mip->mi_result2 == res", "                   && mip->mi_end2 < mip->mi_word + wlen)"], "readability/braces"]
["src/nvim/spell.c", ["        mip->mi_end = mip->mi_word + wlen;", "      } else if (mip->mi_result == res && mip->mi_end < mip->mi_word + wlen)", "        mip->mi_end = mip->mi_word + wlen;"], "readability/braces"]
["src/nvim/spell.c", ["static bool", "match_checkcompoundpattern (", "    char_u *ptr,"], "whitespace/parens"]
["src/nvim/spell.c", ["    p = uflags;", "  } else", "    p = flags;"], "readability/braces"]
["src/nvim/spell.c", ["// lines if they don't contain wildcards.", "static bool can_be_compound(trystate_T *sp, slang_T *slang, char_u *compflags, int flag)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["          break;            // none matches", "      } else if (*p != c)", "        break;          // flag of word doesn't match flag in pattern"], "readability/braces"]
["src/nvim/spell.c", ["static int", "valid_word_prefix (", "    int totprefcnt,                 // nr of prefix IDs"], "whitespace/parens"]
["src/nvim/spell.c", ["      }", "    } else if (cond_req)", "      continue;"], "readability/braces"]
["src/nvim/spell.c", ["            mip->mi_prefixlen, mip->mi_word);", "      } else", "        mip->mi_cprefixlen = mip->mi_prefixlen;"], "readability/braces"]
["src/nvim/spell.c", ["        lo = m + 1;", "      else {", "        lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["size_t", "spell_move_to (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/spell.c", ["  while (!got_int) {", "    line = ml_get_buf(wp->w_buffer, lnum, FALSE);", ""], "readability/bool"]
["src/nvim/spell.c", ["      // one.", "      line = ml_get_buf(wp->w_buffer, lnum, FALSE);", "    }"], "readability/bool"]
["src/nvim/spell.c", ["      spell_cat_line(buf + STRLEN(buf),", "                     ml_get_buf(wp->w_buffer, lnum + 1, FALSE),", "                     MAXWLEN);"], "readability/bool"]
["src/nvim/spell.c", ["              (void)syn_get_id(wp, lnum, (colnr_T)col,", "                  FALSE, &can_spell, FALSE);", "              if (!can_spell)"], "readability/bool"]
["src/nvim/spell.c", ["                attr = HLF_COUNT;", "            } else", "              can_spell = true;"], "readability/braces"]
["src/nvim/spell.c", ["            }", "          } else", "            found_one = true;"], "readability/braces"]
["src/nvim/spell.c", ["        break;              // at first line and 'nowrapscan'", "      else {", "        // Wrap around to the end of the buffer.  May search the"], "readability/braces"]
["src/nvim/spell.c", ["        break;              // at first line and 'nowrapscan'", "      else {", "        // Wrap around to the start of the buffer.  May search the"], "readability/braces"]
["src/nvim/spell.c", ["        lang, spell_enc());", "    r = do_in_runtimepath(fname_enc, FALSE, spell_load_cb, &sl);", ""], "readability/bool"]
["src/nvim/spell.c", ["          lang);", "      r = do_in_runtimepath(fname_enc, FALSE, spell_load_cb, &sl);", ""], "readability/bool"]
["src/nvim/spell.c", ["          && apply_autocmds(EVENT_SPELLFILEMISSING, lang,", "              curbuf->b_fname, FALSE, curbuf))", "        continue;"], "readability/bool"]
["src/nvim/spell.c", ["        _(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),", "\t    lang, spell_enc(), lang);", "    }"], "whitespace/tab"]
["src/nvim/spell.c", ["    STRCPY(fname_enc + STRLEN(fname_enc) - 3, \"add.spl\");", "    do_in_runtimepath(fname_enc, TRUE, spell_load_cb, &sl);", "  }"], "readability/bool"]
["src/nvim/spell.c", ["{", "", "  if (STRLEN(p_enc) < 60 && STRCMP(p_enc, \"iso-8859-15\") != 0)"], "whitespace/blank_line"]
["src/nvim/spell.c", ["static slang_T *", "spell_load_file (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/spell.c", ["    lp->sl_add = strstr((char *)path_tail(fname), SPL_FNAME_ADD) != NULL;", "  } else", "    lp = old_lp;"], "readability/braces"]
["src/nvim/spell.c", ["// Return SP_*ERROR flags.", "static int read_rep_section(FILE *fd, garray_T *gap, short *first)", "{"], "runtime/int"]
["src/nvim/spell.c", ["        c = getc(fd);", "    } else", "      smp->sm_oneof = NULL;"], "readability/braces"]
["src/nvim/spell.c", ["static void", "count_common_word (", "    slang_T *lp,"], "whitespace/parens"]
["src/nvim/spell.c", ["    p = word;", "  else {", "    STRLCPY(buf, word, len + 1);"], "readability/braces"]
["src/nvim/spell.c", ["static int", "score_wordcount_adj (", "    slang_T *slang,"], "whitespace/parens"]
["src/nvim/spell.c", ["    ungetc(c, fd);          // be backwards compatible with Vim 7.0b", "  else {", "    --todo;"], "readability/braces"]
["src/nvim/spell.c", ["        atstart = 0;", "      else {", "        if (!byte_in_str(slang->sl_compstartflags, c)) {"], "readability/braces"]
["src/nvim/spell.c", ["        crp = NULL;", "      } else", "        *crp++ = c;"], "readability/braces"]
["src/nvim/spell.c", ["        *inp++ = NUL;                   // NUL at the end", "      } else", "        // mapping byte to char is done in sl_sal_first[]"], "readability/braces"]
["src/nvim/spell.c", ["static int", "spell_read_tree (", "    FILE *fd,"], "whitespace/parens"]
["src/nvim/spell.c", ["static idx_T", "read_tree_node (", "    FILE *fd,"], "whitespace/parens"]
["src/nvim/spell.c", ["        c = 0;", "      } else { // c == BY_INDEX", "        // <nodeidx>"], "whitespace/comments"]
["src/nvim/spell.c", ["        idxs[startidx + i] &= ~SHARED_MASK;", "      else {", "        idxs[startidx + i] = idx;"], "readability/braces"]
["src/nvim/spell.c", ["        region = region_cp;", "      } else", "        dont_use_region = true;"], "readability/braces"]
["src/nvim/spell.c", ["      for (slang = first_lang; slang != NULL; slang = slang->sl_next)", "        if (path_full_compare(lang, slang->sl_fname, FALSE) == kEqualFiles)", "          break;"], "readability/bool"]
["src/nvim/spell.c", ["        lang[len - 3] = NUL;", "      } else", "        dont_use_region = true;"], "readability/braces"]
["src/nvim/spell.c", ["        (void)spell_load_file(lang, lang, NULL, false);", "      else {", "        spell_load_lang(lang);"], "readability/braces"]
["src/nvim/spell.c", ["    for (slang = first_lang; slang != NULL; slang = slang->sl_next)", "      if (filename ? path_full_compare(lang, slang->sl_fname, FALSE) == kEqualFiles", "          : STRICMP(lang, slang->sl_name) == 0) {"], "whitespace/line_length"]
["src/nvim/spell.c", ["    for (slang = first_lang; slang != NULL; slang = slang->sl_next)", "      if (filename ? path_full_compare(lang, slang->sl_fname, FALSE) == kEqualFiles", "          : STRICMP(lang, slang->sl_name) == 0) {"], "readability/bool"]
["src/nvim/spell.c", ["                region_mask = 0;", "            } else", "              // This is probably an error.  Give a warning and"], "readability/braces"]
["src/nvim/spell.c", ["                   region);", "          } else", "            region_mask = 1 << c;"], "readability/braces"]
["src/nvim/spell.c", ["        p = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;", "        if (p != NULL && path_full_compare(spf_name, p, FALSE) == kEqualFiles)", "          break;"], "readability/bool"]
["src/nvim/spell.c", ["    for (slang = first_lang; slang != NULL; slang = slang->sl_next)", "      if (path_full_compare(spf_name, slang->sl_fname, FALSE) == kEqualFiles)", "        break;"], "readability/bool"]
["src/nvim/spell.c", ["        STRCPY(lang, \"internal wordlist\");", "      else {", "        STRLCPY(lang, path_tail(spf_name), MAXWLEN + 1);"], "readability/braces"]
["src/nvim/spell.c", ["        wp->w_s->b_spell_ismw_mb = vim_strnsave(p, l);", "      else {", "        // Append multi-byte chars to \"b_spell_ismw_mb\"."], "readability/braces"]
["src/nvim/spell.c", ["      p += l;", "    } else", "      wp->w_s->b_spell_ismw[*p++] = true;"], "readability/braces"]
["src/nvim/spell.c", ["static int", "captype (", "    char_u *word,"], "whitespace/parens"]
["src/nvim/spell.c", ["        allcap = false;", "      } else if (!allcap)", "        // UlU -> KEEPCAP"], "readability/braces"]
["src/nvim/spell.c", ["          first = true;", "      } else", "        ++l;"], "readability/braces"]
["src/nvim/spell.c", ["static void", "spell_reload_one (", "    char_u *fname,"], "whitespace/parens"]
["src/nvim/spell.c", ["  for (slang = first_lang; slang != NULL; slang = slang->sl_next) {", "    if (path_full_compare(fname, slang->sl_fname, FALSE) == kEqualFiles) {", "      slang_clear(slang);"], "readability/bool"]
["src/nvim/spell.c", ["  for (np = node; np != NULL; np = np->wn_sibling) {", "    np->wn_u1.index = FALSE;", "    spell_clear_flags(np->wn_child);"], "readability/bool"]
["src/nvim/spell.c", ["  } else {", "    node->wn_u1.index = TRUE;", ""], "readability/bool"]
["src/nvim/spell.c", ["        PRINTSOME(line1, depth, \" %c ???\", node->wn_byte, 0);", "    } else", "      PRINTSOME(line1, depth, \" $    \", 0, 0);"], "readability/braces"]
["src/nvim/spell.c", ["", "#endif // SPELL_PRINTTREE", ""], "whitespace/comments"]
["src/nvim/spell.c", ["      }", "      // TODO: remove \"RAR\" later", "      else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)"], "readability/todo"]
["src/nvim/spell.c", ["      // TODO: remove \"RAR\" later", "      else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)", "                || is_aff_rule(items, itemcnt, \"RARE\", 2))"], "whitespace/newline"]
["src/nvim/spell.c", ["      }", "      // TODO: remove \"KEP\" later", "      else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)"], "readability/todo"]
["src/nvim/spell.c", ["      // TODO: remove \"KEP\" later", "      else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)", "                || is_aff_rule(items, itemcnt, \"KEEPCASE\", 2))"], "whitespace/newline"]
["src/nvim/spell.c", ["        if (aff->af_pref.ht_used > 0)", "          smsg(_(\"Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d\"),", "               fname, lnum);"], "whitespace/line_length"]
["src/nvim/spell.c", ["        if (aff->af_pref.ht_used > 0)", "          smsg(_(\"Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d\"),", "               fname, lnum);"], "whitespace/line_length"]
["src/nvim/spell.c", ["          if (cur_aff->ah_combine != (*items[2] == 'Y'))", "            smsg(_(\"Different combining flag in continued affix block in %s line %d: %s\"),", "                 fname, lnum, items[1]);"], "whitespace/line_length"]
["src/nvim/spell.c", ["          cur_aff->ah_follows = true;", "        } else", "          cur_aff->ah_follows = false;"], "readability/braces"]
["src/nvim/spell.c", ["            did_postpone_prefix = false;", "          } else", "            // Did use the ID in a previous block."], "readability/braces"]
["src/nvim/spell.c", ["            if (*items[0] == 'P')", "              sprintf((char *)buf, \"^%s\", items[4]);", "            else"], "runtime/printf"]
["src/nvim/spell.c", ["            else", "              sprintf((char *)buf, \"%s$\", items[4]);", "            aff_entry->ae_prog = vim_regcomp(buf,"], "runtime/printf"]
["src/nvim/spell.c", ["                          spin, buf);", "                    } else", "                      *aff_entry->ae_cond = c_up;"], "readability/braces"]
["src/nvim/spell.c", ["                    if (aff_entry->ae_cond != NULL) {", "                      sprintf((char *)buf, \"^%s\",", "                          aff_entry->ae_cond);"], "runtime/printf"]
["src/nvim/spell.c", ["                 || is_aff_rule(items, itemcnt, \"REPSAL\", 2)) {", "        /* Ignore REP/REPSAL count */;", "        if (!isdigit(*items[1]))"], "whitespace/semicolon"]
["src/nvim/spell.c", ["      // Accept \"SAL from to\" and \"SAL from to  #comment\".", "      else if (is_aff_rule(items, itemcnt, \"SAL\", 3)) {", "        if (do_sal) {"], "whitespace/newline"]
["src/nvim/spell.c", ["        }", "      } else", "        smsg(_(\"Unrecognized or duplicate item in %s line %d: %s\"),"], "readability/braces"]
["src/nvim/spell.c", ["      smsg(_(\"Both SAL and SOFO lines in %s\"), fname);", "    else {", "      aff_check_string(spin->si_sofofr, sofofrom, \"SOFOFROM\");"], "readability/braces"]
["src/nvim/spell.c", ["  return aff;", "}", ""], "readability/fn_size"]
["src/nvim/spell.c", ["// a comment is following after item \"mincount\".", "static bool is_aff_rule(char_u **items, int itemcnt, char *rulename, int mincount)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["// returns zero for failure.", "static unsigned affitem2flag(int flagtype, char_u *item, char_u *fname, int lnum)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["// they fit in one byte.", "static void process_compflags(spellinfo_T *spin, afffile_T *aff, char_u *compflags)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["      *tp++ = *p++;", "    else {", "      // First get the flag number, also checks validity."], "readability/braces"]
["src/nvim/spell.c", ["          id = HI2CI(hi)->ci_newID;", "        else {", "          ci = (compitem_T *)getroom(spin, sizeof(compitem_T), true);"], "readability/braces"]
["src/nvim/spell.c", ["// They are stored case-folded.", "static void add_fromto(spellinfo_T *spin, garray_T *gap, char_u *from, char_u *to)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["      msg_clr_eos();", "      msg_didout = FALSE;", "      msg_col = 0;"], "readability/bool"]
["src/nvim/spell.c", ["      ++duplicate;", "    } else", "      hash_add_item(&ht, hi, dw, hash);"], "readability/braces"]
["src/nvim/spell.c", ["// and return the number of affixes.", "static int get_pfxlist(afffile_T *affile, char_u *afflist, char_u *store_afflist)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["// Puts the flags in \"store_afflist[]\".", "static void get_compflags(afffile_T *affile, char_u *afflist, char_u *store_afflist)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["static int", "store_aff_word (", "    spellinfo_T *spin,         // spell info"], "whitespace/parens"]
["src/nvim/spell.c", ["                    mb_ptr_adv(p);", "                } else", "                  p += STRLEN(ae->ae_chop);"], "readability/braces"]
["src/nvim/spell.c", ["               fname, lnum, line - 1);", "        else {", "          char_u      *enc;"], "readability/braces"]
["src/nvim/spell.c", ["               fname, lnum, line);", "        else {", "          line += 8;"], "readability/braces"]
["src/nvim/spell.c", ["                 fname, lnum, line);", "          else {", "            spin->si_region_count = (int)STRLEN(line) / 2;"], "readability/braces"]
["src/nvim/spell.c", ["  assert(len <= SBLOCKSIZE);", "  ", "  if (align && bl != NULL)"], "whitespace/end_of_line"]
["src/nvim/spell.c", ["static int", "store_word (", "    spellinfo_T *spin,"], "whitespace/parens"]
["src/nvim/spell.c", ["// Returns FAIL when out of memory.", "static int tree_add_word(spellinfo_T *spin, char_u *word, wordnode_T *root, int flags, int region, int affixID)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["        np->wn_refs = 1;", "      else {", "        np->wn_refs = node->wn_refs;"], "readability/braces"]
["src/nvim/spell.c", ["      msg_clr_eos();", "      msg_didout = FALSE;", "      msg_col = 0;"], "readability/bool"]
["src/nvim/spell.c", ["    n = (wordnode_T *)getroom(spin, sizeof(wordnode_T), true);", "  else {", "    n = spin->si_first_free;"], "readability/braces"]
["src/nvim/spell.c", ["static int", "node_compress (", "    spellinfo_T *spin,"], "whitespace/parens"]
["src/nvim/spell.c", ["        }", "      } else", "        // No other child has this hash value, add it to the"], "readability/braces"]
["src/nvim/spell.c", ["    regionmask = (1 << spin->si_region_count) - 1;", "  } else", "    regionmask = 0;"], "readability/braces"]
["src/nvim/spell.c", ["      gap = &spin->si_sal;", "    } else", "      gap = &spin->si_repsal;"], "readability/braces"]
["src/nvim/spell.c", ["    }", "", "  }"], "whitespace/blank_line"]
["src/nvim/spell.c", ["static int", "put_node (", "    FILE *fd,                // NULL when only counting"], "whitespace/parens"]
["src/nvim/spell.c", ["            putc(BY_NOFLAGS, fd);                       // <byte>", "          else {", "            putc(BY_FLAGS, fd);                         // <byte>"], "readability/braces"]
["src/nvim/spell.c", ["        }", "      } else if (np->wn_child->wn_u2.wnode == NULL)", "        // We will write the child below and give it an index."], "readability/braces"]
["src/nvim/spell.c", ["  for (slang = first_lang; slang != NULL; slang = slang->sl_next)", "    if (path_full_compare(wfname, slang->sl_fname, FALSE) == kEqualFiles)", "      break;"], "readability/bool"]
["src/nvim/spell.c", ["    } else {", "", "      // Do one more byte at this node."], "whitespace/blank_line"]
["src/nvim/spell.c", ["static int", "sug_filltable (", "    spellinfo_T *spin,"], "whitespace/parens"]
["src/nvim/spell.c", ["      if (ml_append_buf(spin->si_spellbuf, (linenr_T)wordnr,", "              gap->ga_data, gap->ga_len, TRUE) == FAIL)", "        return -1;"], "readability/bool"]
["src/nvim/spell.c", ["  }", "  if (b3 > 1 || b2 > 0x3f ) {   // 3 bytes", "    buf[0] = 0xc0 + b3;"], "whitespace/parens"]
["src/nvim/spell.c", ["  }", "  if (b2 > 1 || b1 > 0x7f ) {   // 2 bytes", "    buf[0] = 0x80 + b2;"], "whitespace/parens"]
["src/nvim/spell.c", ["  // <SUGHEADER>: <fileID> <versionnr> <timestamp>", "  if (fwrite(VIMSUGMAGIC, VIMSUGMAGICL, (size_t)1, fd) != 1) { // <fileID>", "    EMSG(_(e_write));"], "whitespace/comments"]
["src/nvim/spell.c", ["    // <sugline>: <sugnr> ... NUL", "    char_u *line = ml_get_buf(spin->si_spellbuf, lnum, FALSE);", "    size_t len = STRLEN(line) + 1;"], "readability/bool"]
["src/nvim/spell.c", ["  if (buf != NULL) {", "    ml_close(buf, TRUE);", "    xfree(buf);"], "readability/bool"]
["src/nvim/spell.c", ["static void", "mkspell (", "    int fcount,"], "whitespace/parens"]
["src/nvim/spell.c", ["      STRLCPY(wfname, fnames[0], MAXPATHL);", "    } else", "      // Name should be language, make the file name from it."], "readability/braces"]
["src/nvim/spell.c", ["    EMSG(_(\"E754: Only up to 8 regions supported\"));", "  else {", "    // Check for overwriting before doing things that may take a lot of"], "readability/braces"]
["src/nvim/spell.c", ["          error = true;", "        else {", "          // Read the .dic file and store the words in the trees."], "readability/braces"]
["src/nvim/spell.c", ["      spell_make_sugfile(&spin, wfname);", "", "  }"], "whitespace/blank_line"]
["src/nvim/spell.c", ["void", "spell_add_word (", "    char_u *word,"], "whitespace/parens"]
["src/nvim/spell.c", ["            if (undo) {", "              home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);", "              smsg(_(\"Word '%.*s' removed from %s\"),"], "readability/bool"]
["src/nvim/spell.c", ["      // init_spellfile().", "      if (!dir_of_file_exists(fname) && (p = path_tail_with_sep(fname)) != fname) {", "        int c = *p;"], "whitespace/line_length"]
["src/nvim/spell.c", ["      EMSG2(_(e_notopen), fname);", "    else {", "      if (bad)"], "readability/braces"]
["src/nvim/spell.c", ["", "      home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);", "      smsg(_(\"Word '%.*s' added to %s\"), len, word, NameBuff);"], "readability/bool"]
["src/nvim/spell.c", ["              lend - curbuf->b_s.b_p_spl + 1);", "        else {", "          // Create the \"spell\" directory if it doesn't exist yet."], "readability/braces"]
["src/nvim/spell.c", ["static void", "set_spell_charflags (", "    char_u *flags,"], "whitespace/parens"]
["src/nvim/spell.c", ["      totlen += len;", "    } else if (fd != NULL)", "      fputc(0, fd);"], "readability/braces"]
["src/nvim/spell.c", ["        f = -1;", "    } else if (STRCMP(buf, \"best\") == 0)", "      f = SPS_BEST;"], "readability/braces"]
["src/nvim/spell.c", ["    end_visual_mode();", "  } else", "  // Find the start of the badly spelled word."], "readability/braces"]
["src/nvim/spell.c", ["", "    msg_scroll = TRUE;", "    for (int i = 0; i < sug.su_ga.ga_len; ++i) {"], "readability/bool"]
["src/nvim/spell.c", ["", "    cmdmsg_rl = FALSE;", "    msg_col = 0;"], "readability/bool"]
["src/nvim/spell.c", ["    STRCAT(p, sug.su_badptr + stp->st_orglen);", "    ml_replace(curwin->w_cursor.lnum, p, FALSE);", "    curwin->w_cursor.col = c;"], "readability/bool"]
["src/nvim/spell.c", ["    changed_bytes(curwin->w_cursor.lnum, c);", "  } else", "    curwin->w_cursor = prev_cursor;"], "readability/braces"]
["src/nvim/spell.c", ["      need_cap = true;", "    else {", "      line = ml_get(lnum - 1);"], "readability/braces"]
["src/nvim/spell.c", ["        need_cap = true;", "      else {", "        // Append a space in place of the line break."], "readability/braces"]
["src/nvim/spell.c", ["    }", "  } else", "    endcol = col;"], "readability/braces"]
["src/nvim/spell.c", ["    regmatch.regprog = curwin->w_s->b_cap_prog;", "    regmatch.rm_ic = FALSE;", "    p = line + endcol;"], "readability/bool"]
["src/nvim/spell.c", ["  frompat = xmalloc(STRLEN(repl_from) + 7);", "  sprintf((char *)frompat, \"\\\\V\\\\<%s\\\\>\", repl_from);", "  p_ws = false;"], "runtime/printf"]
["src/nvim/spell.c", ["      STRCAT(p, line + curwin->w_cursor.col + STRLEN(repl_from));", "      ml_replace(curwin->w_cursor.lnum, p, FALSE);", "      changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);"], "readability/bool"]
["src/nvim/spell.c", ["void", "spell_suggest_list (", "    garray_T *gap,"], "whitespace/parens"]
["src/nvim/spell.c", ["static void", "spell_find_suggest (", "    char_u *badptr,"], "whitespace/parens"]
["src/nvim/spell.c", ["    su->su_badlen = badlen;", "  else {", "    size_t tmplen = spell_check(curwin, su->su_badptr, &attr, NULL, false);"], "readability/braces"]
["src/nvim/spell.c", ["      }", "    } else if (STRNCMP(buf, \"file:\", 5) == 0)", "      // Use list of suggestions in a file."], "readability/braces"]
["src/nvim/spell.c", ["      spell_suggest_file(su, buf + 5);", "    else {", "      // Use internal method."], "readability/braces"]
["src/nvim/spell.c", ["      for (len = 0; p[len] >= ' '; ++len)", "        ;", "      p[len] = NUL;"], "whitespace/semicolon"]
["src/nvim/spell.c", ["    (void)vgetc();", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/spell.c", ["        if (ml_append_buf(slang->sl_sugbuf, (linenr_T)wordnr,", "                ga.ga_data, ga.ga_len, TRUE) == FAIL)", "          goto someerror;"], "readability/bool"]
["src/nvim/spell.c", ["static void", "onecap_copy (", "    char_u *word,"], "whitespace/parens"]
["src/nvim/spell.c", ["    l = mb_char2bytes(c, wcopy);", "  else {", "    l = 1;"], "readability/braces"]
["src/nvim/spell.c", ["      *d++ = c;", "    } else", "      c = SPELL_TOUPPER(c);"], "readability/braces"]
["src/nvim/spell.c", ["//      use \"slang->sl_repsal\" instead of \"lp->lp_replang->sl_rep\"", "static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool soundfold)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["        for (n = 0; n < len && byts[arridx + n] == 0; ++n)", "          ;", "        sp->ts_curi += n;"], "whitespace/semicolon"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "          sprintf(changename[depth], \"prefix\");", "#endif"], "runtime/printf"]
["src/nvim/spell.c", ["        for (c = 0; c < len && pbyts[n + c] == 0; ++c)", "          ;", "        if (c > 0) {"], "whitespace/semicolon"]
["src/nvim/spell.c", ["            preword + sp->ts_prewordlen);", "      else {", "        // Include badflags: If the badword is onecap or allcap"], "readability/braces"]
["src/nvim/spell.c", ["", "      // TODO: how about splitting in the soundfold tree?", "      if (fword_ends"], "readability/todo"]
["src/nvim/spell.c", ["        // different.  It's done like a split.", "        // TODO: word split for soundfold words", "        try_split = (sp->ts_fidx - repextra < su->su_badlen)"], "readability/todo"]
["src/nvim/spell.c", ["          compflags[sp->ts_complen] = NUL;", "        } else", "          sp->ts_flags &= ~TSF_DIDSPLIT;"], "readability/braces"]
["src/nvim/spell.c", ["            if (!try_compound && !fword_ends)", "              sprintf(changename[depth], \"%.*s-%s: split\",", "                  sp->ts_twordlen, tword, fword + sp->ts_fidx);"], "runtime/printf"]
["src/nvim/spell.c", ["            else", "              sprintf(changename[depth], \"%.*s-%s: compound\",", "                  sp->ts_twordlen, tword, fword + sp->ts_fidx);"], "runtime/printf"]
["src/nvim/spell.c", ["                preword[sp->ts_prewordlen] = NUL;", "              } else", "                sp->ts_score -= SCORE_SPLIT - SCORE_SUBST;"], "readability/braces"]
["src/nvim/spell.c", ["          if (newscore > 0)", "            sprintf(changename[depth], \"%.*s-%s: subst %c to %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["          else", "            sprintf(changename[depth], \"%.*s-%s: accept %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["                              ? DIFF_YES : DIFF_NONE;", "            } else if (sp->ts_isdiff == DIFF_INSERT)", "              // When inserting trail bytes don't advance in the"], "readability/braces"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: delete %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: insert %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["          }", "        } else", "          fl = 1;"], "readability/braces"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: swap %c and %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        }", "      } else", "        // If this swap doesn't work then SWAP3 won't either."], "readability/braces"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        }", "      } else", "        sp->ts_state = STATE_REP_INI;"], "readability/braces"]
["src/nvim/spell.c", ["        p = fword + sp->ts_fidx;", "        sprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        }", "      } else", "        sp->ts_state = STATE_REP_INI;"], "readability/braces"]
["src/nvim/spell.c", ["        p = fword + sp->ts_fidx;", "        sprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",", "            sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        }", "      } else", "        sp->ts_state = STATE_REP_INI;"], "readability/braces"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "          sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",", "              sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["  }", "}", ""], "readability/fn_size"]
["src/nvim/spell.c", ["        ulen = mb_cptr2len(uword + uwordidx[depth]);", "      } else", "        ulen = flen = 1;"], "readability/braces"]
["src/nvim/spell.c", ["            lo = m + 1;", "          else {", "            lo = hi = m;"], "readability/braces"]
["src/nvim/spell.c", ["static int", "stp_sal_score (", "    suggest_T *stp,"], "whitespace/parens"]
["src/nvim/spell.c", ["    pbad = badsound;", "  else {", "    // soundfold the bad word with more characters following"], "readability/braces"]
["src/nvim/spell.c", ["    pgood = goodword;", "  } else", "    pgood = stp->st_word;"], "readability/braces"]
["src/nvim/spell.c", ["      // try all kinds of inserts/deletes/swaps/etc.", "      // TODO: also soundfold the next words, so that we can try joining", "      // and splitting"], "readability/todo"]
["src/nvim/spell.c", ["static void", "add_sound_suggest (", "    suginfo_T *su,"], "whitespace/parens"]
["src/nvim/spell.c", ["  // Go over the list of good words that produce this soundfold word", "  nrline = ml_get_buf(slang->sl_sugbuf, (linenr_T)(sfwordnr + 1), FALSE);", "  orgnr = 0;"], "readability/bool"]
["src/nvim/spell.c", ["          p = cword;", "        } else", "          p = theword;"], "readability/braces"]
["src/nvim/spell.c", ["      headc = 0;", "    else {", "      if (headc == 0)"], "readability/braces"]
["src/nvim/spell.c", ["          hash_add_item(&lp->sl_map_hash, hi, b, hash);", "        else {", "          // This should have been checked when generating the .spl"], "readability/braces"]
["src/nvim/spell.c", ["        }", "      } else", "        lp->sl_map_array[c] = headc;"], "readability/braces"]
["src/nvim/spell.c", ["      m1 = mb_ptr2char(hi->hi_key + STRLEN(hi->hi_key) + 1);", "  } else", "    m1 = slang->sl_map_array[c1];"], "readability/braces"]
["src/nvim/spell.c", ["      m2 = mb_ptr2char(hi->hi_key + STRLEN(hi->hi_key) + 1);", "  } else", "    m2 = slang->sl_map_array[c2];"], "readability/braces"]
["src/nvim/spell.c", ["static void", "add_suggestion (", "    suginfo_T *su,"], "whitespace/parens"]
["src/nvim/spell.c", ["        break;", "    } else if (*pgood != *pbad)", "      break;"], "readability/braces"]
["src/nvim/spell.c", ["    i = -1;", "  else {", "    // Check if the word is already there.  Also check the length that is"], "readability/braces"]
["src/nvim/spell.c", ["            rescore_one(su, stp);", "          else {", "            new_sug.st_word = stp->st_word;"], "readability/braces"]
["src/nvim/spell.c", ["static void", "check_suggestions (", "    suginfo_T *su,"], "whitespace/parens"]
["src/nvim/spell.c", ["      p = su->su_sal_badword;", "    else {", "      spell_soundfold(slang, su->su_fbadword, true, sal_badword);"], "readability/braces"]
["src/nvim/spell.c", ["static int", "cleanup_suggestions (", "    garray_T *gap,"], "whitespace/parens"]
["src/nvim/spell.c", ["static void", "spell_soundfold (", "    slang_T *slang,"], "whitespace/parens"]
["src/nvim/spell.c", ["    spell_soundfold_sofo(slang, inword, res);", "  else {", "    // SAL items used.  Requires the word to be case-folded."], "readability/braces"]
["src/nvim/spell.c", ["      word = inword;", "    else {", "      (void)spell_casefold(inword, (int)STRLEN(inword), fword, MAXWLEN);"], "readability/braces"]
["src/nvim/spell.c", ["        c = slang->sl_sal_first[c];", "      else {", "        ip = ((int **)slang->sl_sal.ga_data)[c & 0xff];"], "readability/braces"]
["src/nvim/spell.c", ["    *t = NUL;", "  } else", "    STRLCPY(word, s, MAXWLEN);"], "readability/braces"]
["src/nvim/spell.c", ["static int", "soundalike_score (", "    char_u *goodstart,         // sound-folded good word"], "whitespace/parens"]
["src/nvim/spell.c", ["        CNT(i, j) = CNT(i - 1, j - 1);", "      else {", "        // Use a better score when there is only a case difference."], "readability/braces"]
["src/nvim/spell.c", ["          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);", "        else {", "          // For a similar character use SCORE_SIMILAR."], "readability/braces"]
["src/nvim/spell.c", ["// for multi-byte characters.", "static int spell_edit_score_limit(slang_T *slang, char_u *badword, char_u *goodword, int limit)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["      minscore = score;", "    } else if (bc == NUL)   { // badword ends, insert badword chars", "      do {"], "whitespace/comments"]
["src/nvim/spell.c", ["        score += SCORE_ICASE;", "      else {", "        // For a similar character use SCORE_SIMILAR."], "readability/braces"]
["src/nvim/spell.c", ["// Keep it in sync with the above!", "static int spell_edit_score_limit_w(slang_T *slang, char_u *badword, char_u *goodword, int limit)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["      minscore = score;", "    } else if (bc == NUL)   { // badword ends, insert badword chars", "      do {"], "whitespace/comments"]
["src/nvim/spell.c", ["        score += SCORE_ICASE;", "      else {", "        // For a similar character use SCORE_SIMILAR."], "readability/braces"]
["src/nvim/spell.c", ["  // enable spelling locally in the new window", "  set_option_value((char_u*)\"spell\", TRUE, (char_u*)\"\", OPT_LOCAL);", "  set_option_value((char_u*)\"spl\",  dummy,         spl, OPT_LOCAL);"], "readability/bool"]
["src/nvim/spell.c", ["  if (curbuf->b_ml.ml_line_count > 1)", "    ml_delete(curbuf->b_ml.ml_line_count, FALSE);", ""], "readability/bool"]
["src/nvim/spell.c", ["void", "spell_dump_compl (", "    char_u *pat,           // leading part of the word"], "whitespace/parens"]
["src/nvim/spell.c", ["      dumpflags |= DUMPFLAG_ICASE;", "    else {", "      n = captype(pat, NULL);"], "readability/braces"]
["src/nvim/spell.c", ["      vim_snprintf((char *)IObuff, IOSIZE, \"/regions=%s\", region_names);", "      ml_append(lnum++, IObuff, (colnr_T)0, FALSE);", "    }"], "readability/bool"]
["src/nvim/spell.c", ["    }", "  } else", "    do_region = false;"], "readability/braces"]
["src/nvim/spell.c", ["      vim_snprintf((char *)IObuff, IOSIZE, \"# file: %s\", slang->sl_fname);", "      ml_append(lnum++, IObuff, (colnr_T)0, FALSE);", "    }"], "readability/bool"]
["src/nvim/spell.c", ["// When \"lnum\" is zero add insert mode completion.", "static void dump_word(slang_T *slang, char_u *word, char_u *pat, int *dir, int dumpflags, int wordflags, linenr_T lnum)", "{"], "whitespace/line_length"]
["src/nvim/spell.c", ["          if (flags & (0x10000 << i))", "            sprintf((char *)badword + STRLEN(badword), \"%d\", i + 1);", "      p = badword;"], "runtime/printf"]
["src/nvim/spell.c", ["", "    ml_append(lnum, p, (colnr_T)0, FALSE);", "  } else if (((dumpflags & DUMPFLAG_ICASE)"], "readability/bool"]
["src/nvim/spell.c", ["    ml_append(lnum, p, (colnr_T)0, FALSE);", "  } else if (((dumpflags & DUMPFLAG_ICASE)", "              ? mb_strnicmp(p, pat, STRLEN(pat)) == 0"], "readability/braces"]
["src/nvim/spell.c", ["static linenr_T", "dump_prefixes (", "    slang_T *slang,"], "whitespace/parens"]
["src/nvim/strings.c", ["#include \"nvim/fold.h\"", "#include \"nvim/func_attr.h\"", "#include \"nvim/getchar.h\""], "build/include"]
["src/nvim/strings.c", ["      p += newl;", "    } else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)", "      p += l;                 /* skip multi-byte character */"], "readability/braces"]
["src/nvim/strings.c", ["      p += l;                 /* skip multi-byte character */", "    else {", "      *p = (char_u) TOUPPER_LOC(*p);  // note that toupper() can be a macro"], "readability/braces"]
["src/nvim/strings.c", ["    to[tosize - 1] = NUL;", "  } else", "    STRCPY(to + tolen, from);"], "readability/braces"]
["src/nvim/syntax.c", ["#define SPO_MS_OFF      0       /* match  start offset */", "#define SPO_ME_OFF      1       /* match  end\toffset */", "#define SPO_HS_OFF      2       /* highl. start offset */"], "whitespace/tab"]
["src/nvim/syntax.c", ["#define SPO_HS_OFF      2       /* highl. start offset */", "#define SPO_HE_OFF      3       /* highl. end\toffset */", "#define SPO_RS_OFF      4       /* region start offset */"], "whitespace/tab"]
["src/nvim/syntax.c", ["#define SPO_RS_OFF      4       /* region start offset */", "#define SPO_RE_OFF      5       /* region end\toffset */", "#define SPO_LC_OFF      6       /* leading context offset */"], "whitespace/tab"]
["src/nvim/syntax.c", ["{\"bold\", \"standout\", \"underline\", \"undercurl\",", " \"italic\", \"reverse\", \"inverse\", \"NONE\"};", "static int hl_attr_table[] ="], "whitespace/indent"]
["src/nvim/syntax.c", ["{HL_BOLD, HL_STANDOUT, HL_UNDERLINE, HL_UNDERCURL, HL_ITALIC, HL_INVERSE,", " HL_INVERSE, 0};", ""], "whitespace/indent"]
["src/nvim/syntax.c", ["  struct sp_syn sp_syn;                 /* struct passed to in_id_list() */", "  short sp_syn_match_id;                /* highlight group ID of pattern */", "  char_u      *sp_pattern;              /* regexp to match, pattern */"], "runtime/int"]
["src/nvim/syntax.c", ["  int sp_ic;                            /* ignore-case flag for sp_prog */", "  short sp_off_flags;                   /* see below */", "  int sp_offsets[SPO_COUNT];            /* offsets */"], "runtime/int"]
["src/nvim/syntax.c", ["  int sp_offsets[SPO_COUNT];            /* offsets */", "  short       *sp_cont_list;            /* cont. group IDs, if non-zero */", "  short       *sp_next_list;            /* next group IDs, if non-zero */"], "runtime/int"]
["src/nvim/syntax.c", ["  short       *sp_cont_list;            /* cont. group IDs, if non-zero */", "  short       *sp_next_list;            /* next group IDs, if non-zero */", "  int sp_sync_idx;                      /* sync item index (syncing only) */"], "runtime/int"]
["src/nvim/syntax.c", ["  char_u          *scl_name_u;      /* uppercase of scl_name */", "  short           *scl_list;        /* IDs in this syntax cluster */", "} syn_cluster_T;"], "runtime/int"]
["src/nvim/syntax.c", ["typedef struct state_item {", "  int si_idx;                           /* index of syntax pattern or", "                                           KEYWORD_IDX */"], "readability/multiline_comment"]
["src/nvim/syntax.c", ["  int si_attr;                          /* attributes in this state */", "  long si_flags;                        /* HL_HAS_EOL flag in this state, and", "                                         * HL_SKIP* for si_next_list */"], "readability/multiline_comment"]
["src/nvim/syntax.c", ["  int si_cchar;                         /* substitution character for conceal */", "  short       *si_cont_list;            /* list of contained groups */", "  short       *si_next_list;            /* nextgroup IDs after this item ends */"], "runtime/int"]
["src/nvim/syntax.c", ["  short       *si_cont_list;            /* list of contained groups */", "  short       *si_next_list;            /* nextgroup IDs after this item ends */", "  reg_extmatch_T *si_extmatch;          /* \\z(...\\) matches from start"], "runtime/int"]
["src/nvim/syntax.c", ["  short       *si_next_list;            /* nextgroup IDs after this item ends */", "  reg_extmatch_T *si_extmatch;          /* \\z(...\\) matches from start", "                                         * pattern */"], "readability/multiline_comment"]
["src/nvim/syntax.c", ["  int keyword;                  /* TRUE for \":syn keyword\" */", "  int         *sync_idx;        /* syntax item for \"grouphere\" argument, NULL", "                                   if not allowed */"], "readability/multiline_comment"]
["src/nvim/syntax.c", ["  char has_cont_list;           /* TRUE if \"cont_list\" can be used */", "  short       *cont_list;       /* group IDs for \"contains\" argument */", "  short       *cont_in_list;    /* group IDs for \"containedin\" argument */"], "runtime/int"]
["src/nvim/syntax.c", ["  short       *cont_list;       /* group IDs for \"contains\" argument */", "  short       *cont_in_list;    /* group IDs for \"containedin\" argument */", "  short       *next_list;       /* group IDs for \"nextgroup\" argument */"], "runtime/int"]
["src/nvim/syntax.c", ["  short       *cont_in_list;    /* group IDs for \"containedin\" argument */", "  short       *next_list;       /* group IDs for \"nextgroup\" argument */", "} syn_opt_arg_T;"], "runtime/int"]
["src/nvim/syntax.c", ["#define KE2HIKEY(kp)  ((kp)->keyword)", "#define HIKEY2KE(p)   ((keyentry_T *)((p) - (dumkey.keyword - (char_u *)&dumkey)))", "#define HI2KE(hi)      HIKEY2KE((hi)->hi_key)"], "whitespace/line_length"]
["src/nvim/syntax.c", ["#define KEYWORD_IDX     -1          /* value of si_idx for keywords */", "#define ID_LIST_ALL     (short *)-1 /* valid of si_cont_list for containing all", "                                       but contained groups */"], "readability/multiline_comment"]
["src/nvim/syntax.c", ["#define KEYWORD_IDX     -1          /* value of si_idx for keywords */", "#define ID_LIST_ALL     (short *)-1 /* valid of si_cont_list for containing all", "                                       but contained groups */"], "runtime/int"]
["src/nvim/syntax.c", ["static colnr_T current_col = 0;         /* column of current state */", "static int current_state_stored = 0;      /* TRUE if stored current state", "                                           * after setting current_finished */"], "readability/multiline_comment"]
["src/nvim/syntax.c", ["static colnr_T current_col = 0;         /* column of current state */", "static int current_state_stored = 0;      /* TRUE if stored current state", "                                           * after setting current_finished */"], "readability/bool"]
["src/nvim/syntax.c", ["  = GA_EMPTY_INIT_VALUE;", "static short    *current_next_list = NULL; /* when non-zero, nextgroup list */", "static int current_next_flags = 0;      /* flags for current_next_list */"], "runtime/int"]
["src/nvim/syntax.c", ["", "static int syn_time_on = FALSE;", "# define IF_SYN_TIME(p) (p)"], "readability/bool"]
["src/nvim/syntax.c", ["      && current_lnum < syn_buf->b_ml.ml_line_count) {", "    (void)syn_finish_line(FALSE);", "    if (!current_state_stored) {"], "readability/bool"]
["src/nvim/syntax.c", ["      invalidate_current_state();", "  } else", "    invalidate_current_state();"], "readability/braces"]
["src/nvim/syntax.c", ["      first_stored = current_lnum + syn_block->b_syn_sync_minlines;", "  } else", "    first_stored = current_lnum;"], "readability/braces"]
["src/nvim/syntax.c", ["    syn_start_line();", "    (void)syn_finish_line(FALSE);", "    ++current_lnum;"], "readability/bool"]
["src/nvim/syntax.c", ["       * saved state.  But only when parsed at least 'minlines'. */", "      else if (prev == NULL", "               || current_lnum == lnum"], "whitespace/newline"]
["src/nvim/syntax.c", ["    start_lnum = 1;", "  else {", "    if (syn_block->b_syn_sync_minlines == 1)"], "readability/braces"]
["src/nvim/syntax.c", ["   */", "  else if (syn_block->b_syn_sync_flags & SF_MATCH) {", "    if (syn_block->b_syn_sync_maxlines != 0"], "whitespace/newline"]
["src/nvim/syntax.c", ["        for (;; ) {", "          had_sync_point = syn_finish_line(TRUE);", "          /*"], "readability/bool"]
["src/nvim/syntax.c", ["                break;", "            } else if (found_m_endpos.col > current_col)", "              current_col = found_m_endpos.col;"], "readability/braces"]
["src/nvim/syntax.c", ["            current_col = prev_current_col;", "          } else", "            break;"], "readability/braces"]
["src/nvim/syntax.c", ["            cur_si->si_h_startpos.col = found_current_col;", "            update_si_end(cur_si, (int)current_col, TRUE);", "            check_keepend();"], "readability/bool"]
["src/nvim/syntax.c", ["          current_lnum = found_m_endpos.lnum;", "          (void)syn_finish_line(FALSE);", "          ++current_lnum;"], "readability/bool"]
["src/nvim/syntax.c", ["          ++current_lnum;", "        } else", "          current_lnum = start_lnum;"], "readability/braces"]
["src/nvim/syntax.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["{", "  current_finished = FALSE;", "  current_col = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["  if (!GA_EMPTY(&current_state)) {", "    syn_update_ends(TRUE);", "    check_state_ends();"], "readability/bool"]
["src/nvim/syntax.c", ["        cur_si->si_h_endpos = cur_si->si_m_endpos;", "        cur_si->si_ends = TRUE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  seen_keepend = FALSE;", "  for (; i < current_state.ga_len; ++i) {"], "readability/bool"]
["src/nvim/syntax.c", ["      if (!startofline && (cur_si->si_flags & HL_KEEPEND))", "        seen_keepend = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["             && syn_stack_cleanup())", "        ;", "      if (len < syn_block->b_sst_len - syn_block->b_sst_freecount + 2)"], "whitespace/semicolon"]
["src/nvim/syntax.c", ["  int dist;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["  tick = syn_block->b_sst_lasttick;", "  above = FALSE;", "  prev = syn_block->b_sst_first;"], "readability/bool"]
["src/nvim/syntax.c", ["          tick = p->sst_tick;", "        above = TRUE;", "      } else if (!above && p->sst_tick < tick)"], "readability/bool"]
["src/nvim/syntax.c", ["        above = TRUE;", "      } else if (!above && p->sst_tick < tick)", "        tick = p->sst_tick;"], "readability/braces"]
["src/nvim/syntax.c", ["      p = prev;", "      retval = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["        syn_block->b_sst_first = sp->sst_next;", "      else {", "        /* find the entry just before this one to adjust sst_next */"], "readability/braces"]
["src/nvim/syntax.c", ["      sp = NULL;", "    else {", "      /* Take the first item from the free list and put it in the used"], "readability/braces"]
["src/nvim/syntax.c", ["      bp = SYN_STATE_P(&(sp->sst_union.sst_ga));", "    } else", "      bp = sp->sst_union.sst_stack;"], "readability/braces"]
["src/nvim/syntax.c", ["  }", "  current_state_stored = TRUE;", "  return sp;"], "readability/bool"]
["src/nvim/syntax.c", ["        keepend_level = i;", "      CUR_STATE(i).si_ends = FALSE;", "      CUR_STATE(i).si_m_lnum = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["      || sp->sst_next_list != current_next_list) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["  if (i < 0)", "    return TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["{", "  int retval = TRUE;", "  synstate_T  *sp;"], "readability/bool"]
["src/nvim/syntax.c", ["       */", "      (void)syn_finish_line(FALSE);", ""], "readability/bool"]
["src/nvim/syntax.c", ["      if (syn_stack_equal(sp))", "        retval = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", [" */", "static int ", "syn_finish_line ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static int ", "syn_finish_line (", "    int syncing                    /* called for syncing */"], "whitespace/parens"]
["src/nvim/syntax.c", ["  while (!current_finished) {", "    (void)syn_current_attr(syncing, FALSE, NULL, FALSE);", "    /*"], "readability/bool"]
["src/nvim/syntax.c", ["              & (HL_SYNC_HERE|HL_SYNC_THERE)))", "        return TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", [" */", "int ", "get_syntax_attr ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["int ", "get_syntax_attr (", "    colnr_T col,"], "whitespace/parens"]
["src/nvim/syntax.c", ["  while (current_col <= col) {", "    attr = syn_current_attr(FALSE, TRUE, can_spell,", "        current_col == col ? keep_state : FALSE);"], "readability/bool"]
["src/nvim/syntax.c", ["    attr = syn_current_attr(FALSE, TRUE, can_spell,", "        current_col == col ? keep_state : FALSE);", "    ++current_col;"], "readability/bool"]
["src/nvim/syntax.c", [" */", "static int ", "syn_current_attr ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static int ", "syn_current_attr (", "    int syncing,                           /* When 1: called for syncing */"], "whitespace/parens"]
["src/nvim/syntax.c", ["  int cchar;", "  short       *next_list;", "  int found_match;                          /* found usable match */"], "runtime/int"]
["src/nvim/syntax.c", ["  int found_match;                          /* found usable match */", "  static int try_next_column = FALSE;       /* must try in next col */", "  int do_keywords;"], "readability/bool"]
["src/nvim/syntax.c", ["  reg_extmatch_T *cur_extmatch = NULL;", "  char_u      *line;            /* current line.  NOTE: becomes invalid after", "                                   looking for a pattern match! */"], "readability/multiline_comment"]
["src/nvim/syntax.c", ["  char_u      *line;            /* current line.  NOTE: becomes invalid after", "                                   looking for a pattern match! */", ""], "whitespace/operators"]
["src/nvim/syntax.c", ["  int keep_next_list;", "  int zero_width_next_list = FALSE;", "  garray_T zero_width_next_ga;"], "readability/bool"]
["src/nvim/syntax.c", ["", "    current_finished = TRUE;", "    current_state_stored = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["    current_finished = TRUE;", "    current_state_stored = FALSE;", "    return 0;"], "readability/bool"]
["src/nvim/syntax.c", ["  if (line[current_col] == NUL || line[current_col + 1] == NUL) {", "    current_finished = TRUE;", "    current_state_stored = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["    current_finished = TRUE;", "    current_state_stored = FALSE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["    next_match_idx = -1;", "    try_next_column = FALSE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["  do {", "    found_match = FALSE;", "    keep_next_list = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["    found_match = FALSE;", "    keep_next_list = FALSE;", "    syn_id = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["              cur_si->si_h_endpos.col = endcol;", "              cur_si->si_ends = TRUE;", "              cur_si->si_end_idx = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["                }", "              } else", "                cur_si->si_attr = syn_id2attr(syn_id);"], "readability/braces"]
["src/nvim/syntax.c", ["              if (did_match_already(idx, &zero_width_next_ga)) {", "                try_next_column = TRUE;", "                continue;"], "readability/bool"]
["src/nvim/syntax.c", ["               */", "              else if (spp->sp_type == SPTYPE_MATCH) {", "                syn_add_end_off(&hl_endpos, &regmatch, spp,"], "whitespace/newline"]
["src/nvim/syntax.c", ["                      == regmatch.endpos[0].col)", "                    try_next_column = TRUE;", "                  continue;"], "readability/bool"]
["src/nvim/syntax.c", ["            current_next_flags = lspp->sp_flags;", "            keep_next_list = TRUE;", "            zero_width_next_list = TRUE;"], "readability/bool"]
["src/nvim/syntax.c", ["            keep_next_list = TRUE;", "            zero_width_next_list = TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["            next_match_idx = -1;", "          } else", "            cur_si = push_next_match(cur_si);"], "readability/braces"]
["src/nvim/syntax.c", ["            cur_si = push_next_match(cur_si);", "          found_match = TRUE;", "        }"], "readability/bool"]
["src/nvim/syntax.c", ["      if (!zero_width_next_list)", "        found_match = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["    }", "", "  } while (found_match);"], "whitespace/blank_line"]
["src/nvim/syntax.c", ["          *can_spell = (syn_block->b_syn_spell != SYNSPL_NOTOP);", "        else {", "          sps.inc_tag = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["          *can_spell = (syn_block->b_syn_spell == SYNSPL_TOP);", "        else {", "          sps.inc_tag = 0;"], "readability/braces"]
["src/nvim/syntax.c", ["    }", "  } else if (can_spell != NULL)", "    /* Default: Only do spelling when there is no @Spell cluster or when"], "readability/braces"]
["src/nvim/syntax.c", ["        && CUR_STATE(i).si_idx == idx) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["    if (((int *)(gap->ga_data))[i] == idx) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["      /* Try to find the end pattern in the current line */", "      update_si_end(cur_si, (int)(next_match_m_endpos.col), TRUE);", "      check_keepend();"], "readability/bool"]
["src/nvim/syntax.c", ["      cur_si->si_h_endpos = next_match_h_endpos;", "      cur_si->si_ends = TRUE;", "      cur_si->si_flags |= next_match_flags;"], "readability/bool"]
["src/nvim/syntax.c", ["      cur_si->si_h_endpos = next_match_eos_pos;", "      cur_si->si_ends = TRUE;", "      cur_si->si_end_idx = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["        if (had_extend && keepend_level >= 0) {", "          syn_update_ends(FALSE);", "          if (GA_EMPTY(&current_state))"], "readability/bool"]
["src/nvim/syntax.c", ["            && !(cur_si->si_flags & (HL_MATCH | HL_KEEPEND))) {", "          update_si_end(cur_si, (int)current_col, TRUE);", "          check_keepend();"], "readability/bool"]
["src/nvim/syntax.c", ["      }", "    } else", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["      limit_pos_zero(&sip->si_eoe_pos, &maxpos);", "      sip->si_ends = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", [" */", "static void ", "update_si_end ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static void ", "update_si_end (", "    stateitem_T *sip,"], "whitespace/parens"]
["src/nvim/syntax.c", ["      /* a \"oneline\" never continues in the next line */", "      sip->si_ends = TRUE;", "      sip->si_m_endpos.lnum = current_lnum;"], "readability/bool"]
["src/nvim/syntax.c", ["      /* continues in the next line */", "      sip->si_ends = FALSE;", "      sip->si_m_endpos.lnum = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["    sip->si_eoe_pos = end_endpos;", "    sip->si_ends = TRUE;", "    sip->si_end_idx = end_idx;"], "readability/bool"]
["src/nvim/syntax.c", [" */", "static void ", "find_endpos ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static void ", "find_endpos (", "    int idx,                        /* index of the pattern */"], "whitespace/parens"]
["src/nvim/syntax.c", ["  char_u      *line;", "  int had_match = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["    ++idx;", "  } else", "    spp_skip = NULL;"], "readability/braces"]
["src/nvim/syntax.c", ["", "        line = ml_get_buf(syn_buf, startpos->lnum, FALSE);", ""], "readability/bool"]
["src/nvim/syntax.c", ["               ++matchcol)", "            ;", ""], "whitespace/semicolon"]
["src/nvim/syntax.c", ["", "    had_match = TRUE;", "    break;"], "readability/bool"]
["src/nvim/syntax.c", [" */", "static void ", "syn_add_end_off ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static void ", "syn_add_end_off (", "    lpos_T *result,            /* returned position */"], "whitespace/parens"]
["src/nvim/syntax.c", ["  else if (off != 0) {", "    base = ml_get_buf(syn_buf, result->lnum, FALSE);", "    p = base + col;"], "readability/bool"]
["src/nvim/syntax.c", [" */", "static void ", "syn_add_start_off ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static void ", "syn_add_start_off (", "    lpos_T *result,            /* returned position */"], "whitespace/parens"]
["src/nvim/syntax.c", ["    result->lnum = syn_buf->b_ml.ml_line_count;", "    col = (int)STRLEN(ml_get_buf(syn_buf, result->lnum, FALSE));", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["  if (off != 0) {", "    base = ml_get_buf(syn_buf, result->lnum, FALSE);", "    p = base + col;"], "readability/bool"]
["src/nvim/syntax.c", ["{", "  return ml_get_buf(syn_buf, current_lnum, FALSE);", "}"], "readability/bool"]
["src/nvim/syntax.c", [" */", "static int syn_regexec(regmmatch_T *rmp, linenr_T lnum, colnr_T col, syn_time_T *st)", "{"], "whitespace/line_length"]
["src/nvim/syntax.c", ["    rmp->endpos[0].lnum += lnum;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", [" */", "static int ", "check_keyword_id ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static int ", "check_keyword_id (", "    char_u *line,"], "whitespace/parens"]
["src/nvim/syntax.c", ["    long *flagsp,            /* return: flags of matching keyword */", "    short **next_listp,       /* return: next_list of matching keyword */", "    stateitem_T *cur_si,            /* item at the top of the stack */"], "runtime/int"]
["src/nvim/syntax.c", ["  if (STRNICMP(arg, \"on\", 2) == 0 && next - arg == 2)", "    curwin->w_s->b_syn_conceal = TRUE;", "  else if (STRNICMP(arg, \"off\", 3) == 0 && next - arg == 3)"], "readability/bool"]
["src/nvim/syntax.c", ["  else if (STRNICMP(arg, \"off\", 3) == 0 && next - arg == 3)", "    curwin->w_s->b_syn_conceal = FALSE;", "  else"], "readability/bool"]
["src/nvim/syntax.c", ["  if (STRNICMP(arg, \"match\", 5) == 0 && next - arg == 5)", "    curwin->w_s->b_syn_ic = FALSE;", "  else if (STRNICMP(arg, \"ignore\", 6) == 0 && next - arg == 6)"], "readability/bool"]
["src/nvim/syntax.c", ["  else if (STRNICMP(arg, \"ignore\", 6) == 0 && next - arg == 6)", "    curwin->w_s->b_syn_ic = TRUE;", "  else"], "readability/bool"]
["src/nvim/syntax.c", ["{", "  block->b_syn_error = FALSE;       /* clear previous error */", "  block->b_syn_ic = FALSE;          /* Use case, by default */"], "readability/bool"]
["src/nvim/syntax.c", ["  block->b_syn_error = FALSE;       /* clear previous error */", "  block->b_syn_ic = FALSE;          /* Use case, by default */", "  block->b_syn_spell = SYNSPL_DEFAULT;   /* default spell checking */"], "readability/bool"]
["src/nvim/syntax.c", ["  block->b_syn_spell = SYNSPL_DEFAULT;   /* default spell checking */", "  block->b_syn_containedin = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "whitespace/line_length"]
["src/nvim/syntax.c", ["      syntax_sync_clear();", "    else {", "      syntax_clear(curwin->w_s);"], "readability/braces"]
["src/nvim/syntax.c", ["      if (curwin->w_s == &curwin->w_buffer->b_s)", "        do_unlet((char_u *)\"b:current_syntax\", TRUE);", "      do_unlet((char_u *)\"w:current_syntax\", TRUE);"], "readability/bool"]
["src/nvim/syntax.c", ["        do_unlet((char_u *)\"b:current_syntax\", TRUE);", "      do_unlet((char_u *)\"w:current_syntax\", TRUE);", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["           */", "          short scl_id = id - SYNID_CLUSTER;", ""], "runtime/int"]
["src/nvim/syntax.c", ["          break;", "        } else", "          syn_clear_one(id, syncing);"], "readability/braces"]
["src/nvim/syntax.c", ["  redraw_curbuf_later(SOME_VALID);", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "whitespace/line_length"]
["src/nvim/syntax.c", ["  syn_cmd_onoff(eap, \"syntax\");", "  do_unlet((char_u *)\"g:syntax_cmd\", TRUE);", "}"], "readability/bool"]
["src/nvim/syntax.c", ["    do_cmdline_cmd(\"runtime! syntax/syncolor.vim\");", "    do_unlet((char_u *)\"g:syntax_cmd\", TRUE);", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["  if (!eap->skip) {", "    strcpy(buf, \"so \");", "    vim_snprintf(buf + 3, sizeof(buf) - 3, SYNTAX_FNAME, name);"], "runtime/printf"]
["src/nvim/syntax.c", [" */", "static void ", "syn_cmd_list ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static void ", "syn_cmd_list (", "    exarg_T *eap,"], "whitespace/parens"]
["src/nvim/syntax.c", ["        MSG_PUTS(_(\"no syncing\"));", "      else {", "        MSG_PUTS(_(\"syncing starts \"));"], "readability/braces"]
["src/nvim/syntax.c", ["    }", "  } else", "    MSG_PUTS_TITLE(_(\"\\n--- Syntax items ---\"));"], "readability/braces"]
["src/nvim/syntax.c", ["    for (int id = 1; id <= highlight_ga.ga_len && !got_int; ++id) {", "      syn_list_one(id, syncing, FALSE);", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["    }", "    for (int id = 0; id < curwin->w_s->b_syn_clusters.ga_len && !got_int; ++id) {", "      syn_list_cluster(id);"], "whitespace/line_length"]
["src/nvim/syntax.c", ["        else", "          syn_list_one(id, syncing, TRUE);", "      }"], "readability/bool"]
["src/nvim/syntax.c", [" */", "static void ", "syn_list_one ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static void ", "syn_list_one (", "    int id,"], "whitespace/parens"]
["src/nvim/syntax.c", ["  int attr;", "  int did_header = FALSE;", "  synpat_T    *spp;"], "readability/bool"]
["src/nvim/syntax.c", ["  if (!syncing) {", "    did_header = syn_list_keywords(id, &curwin->w_s->b_keywtab, FALSE, attr);", "    did_header = syn_list_keywords(id, &curwin->w_s->b_keywtab_ic,"], "readability/bool"]
["src/nvim/syntax.c", ["  /* list the patterns for \"id\" */", "  for (int idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len && !got_int; ++idx) {", "    spp = &(SYN_ITEMS(curwin->w_s)[idx]);"], "whitespace/line_length"]
["src/nvim/syntax.c", ["    (void)syn_list_header(did_header, 999, id);", "    did_header = TRUE;", "    last_matchgroup = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["", "static void put_id_list(char_u *name, short *list, int attr)", "{"], "runtime/int"]
["src/nvim/syntax.c", ["{", "  short               *p;", ""], "runtime/int"]
["src/nvim/syntax.c", ["    } else if (*p >= SYNID_CLUSTER)   {", "      short scl_id = *p - SYNID_CLUSTER;", ""], "runtime/int"]
["src/nvim/syntax.c", ["      msg_outtrans(SYN_CLSTR(curwin->w_s)[scl_id].scl_name);", "    } else", "      msg_outtrans(HL_TABLE()[*p - 1].sg_name);"], "readability/braces"]
["src/nvim/syntax.c", ["  /* output any pattern options */", "  first = TRUE;", "  for (i = 0; i < SPO_COUNT; ++i) {"], "readability/bool"]
["src/nvim/syntax.c", ["      msg_outnum(n);", "    first = FALSE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", [" */", "static int ", "syn_list_keywords ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static int ", "syn_list_keywords (", "    int id,"], "whitespace/parens"]
["src/nvim/syntax.c", ["    hashtab_T *ht,", "    int did_header,                         /* header has already been printed */", "    int attr"], "whitespace/line_length"]
["src/nvim/syntax.c", ["  int prev_contained = 0;", "  short       *prev_next_list = NULL;", "  short       *prev_cont_in_list = NULL;"], "runtime/int"]
["src/nvim/syntax.c", ["  short       *prev_next_list = NULL;", "  short       *prev_cont_in_list = NULL;", "  int prev_skipnl = 0;"], "runtime/int"]
["src/nvim/syntax.c", ["        }", "        did_header = TRUE;", "        if (prev_contained != (kp->flags & HL_CONTAINED)) {"], "readability/bool"]
["src/nvim/syntax.c", ["            hi->hi_key = KE2HIKEY(kp_next);", "        } else", "          kp_prev->ke_next = kp_next;"], "readability/braces"]
["src/nvim/syntax.c", ["                        int flags,", "                        short *cont_in_list,", "                        short *next_list,"], "runtime/int"]
["src/nvim/syntax.c", ["                        short *cont_in_list,", "                        short *next_list,", "                        int conceal_char)"], "runtime/int"]
["src/nvim/syntax.c", ["  char_u *name_ic = (curwin->w_s->b_syn_ic)", "   ? str_foldcase(name, (int)STRLEN(name), name_folded, sizeof(name_folded))", "   : name;"], "whitespace/indent"]
["src/nvim/syntax.c", ["   ? str_foldcase(name, (int)STRLEN(name), name_folded, sizeof(name_folded))", "   : name;", ""], "whitespace/indent"]
["src/nvim/syntax.c", ["  if (cont_in_list != NULL) {", "    curwin->w_s->b_syn_containedin = TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["static char_u *", "get_group_name (", "    char_u *arg,               /* start of the argument */"], "whitespace/parens"]
["src/nvim/syntax.c", ["static char_u *", "get_syn_options (", "    char_u *arg,                   /* next argument to be checked */"], "whitespace/parens"]
["src/nvim/syntax.c", ["                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},", "                  {\"nNeExXtTgGrRoOuUpP\",      3,      0},};", "  static char *first_letters = \"cCoOkKeEtTsSgGdDfFnN\";"], "whitespace/comma"]
["src/nvim/syntax.c", ["          *opt->sync_idx = NONE_IDX;", "        else {", "          syn_id = syn_name2id(gname);"], "readability/braces"]
["src/nvim/syntax.c", ["        arg = skipwhite(arg);", "      } else if (flagtab[fidx].flags == HL_FOLD", "                 && foldmethodIsSyntax(curwin))"], "readability/braces"]
["src/nvim/syntax.c", ["    /* We have to alloc this, because syn_combine_list() will free it. */", "    short *grp_list = xmalloc(2 * sizeof(short));", "    int tlg_id = curwin->w_s->b_syn_topgrp - SYNID_CLUSTER;"], "runtime/int"]
["src/nvim/syntax.c", ["  int prev_syn_inc_tag;", "  int source = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["     * \":runtime!\" is used. */", "    source = TRUE;", "    if (expand_filename(eap, syn_cmdlinep, &errormsg) == FAIL) {"], "readability/bool"]
["src/nvim/syntax.c", ["  curwin->w_s->b_syn_topgrp = sgl_id;", "  if (source ? do_source(eap->arg, FALSE, DOSO_NONE) == FAIL", "      : source_runtime(eap->arg, TRUE) == FAIL)"], "readability/bool"]
["src/nvim/syntax.c", ["  if (source ? do_source(eap->arg, FALSE, DOSO_NONE) == FAIL", "      : source_runtime(eap->arg, TRUE) == FAIL)", "    EMSG2(_(e_notopen), eap->arg);"], "readability/bool"]
["src/nvim/syntax.c", ["    syn_opt_arg.flags = 0;", "    syn_opt_arg.keyword = TRUE;", "    syn_opt_arg.sync_idx = NULL;"], "readability/bool"]
["src/nvim/syntax.c", ["    syn_opt_arg.sync_idx = NULL;", "    syn_opt_arg.has_cont_list = FALSE;", "    syn_opt_arg.cont_in_list = NULL;"], "readability/bool"]
["src/nvim/syntax.c", ["  redraw_curbuf_later(SOME_VALID);", "  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */", "}"], "whitespace/line_length"]
["src/nvim/syntax.c", [" */", "static void ", "syn_cmd_match ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static void ", "syn_cmd_match (", "    exarg_T *eap,"], "whitespace/parens"]
["src/nvim/syntax.c", ["  syn_opt_arg.flags = 0;", "  syn_opt_arg.keyword = FALSE;", "  syn_opt_arg.sync_idx = syncing ? &sync_idx : NULL;"], "readability/bool"]
["src/nvim/syntax.c", ["  syn_opt_arg.sync_idx = syncing ? &sync_idx : NULL;", "  syn_opt_arg.has_cont_list = TRUE;", "  syn_opt_arg.cont_list = NULL;"], "readability/bool"]
["src/nvim/syntax.c", ["      rest = NULL;", "    else {", "      if ((syn_id = syn_check_group(arg, (int)(group_name_end - arg))) != 0) {"], "readability/braces"]
["src/nvim/syntax.c", ["        if (syn_opt_arg.cont_in_list != NULL)", "          curwin->w_s->b_syn_containedin = TRUE;", "        spp->sp_next_list = syn_opt_arg.next_list;"], "readability/bool"]
["src/nvim/syntax.c", ["        redraw_curbuf_later(SOME_VALID);", "        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        return;           /* don't free the progs and patterns now */"], "whitespace/line_length"]
["src/nvim/syntax.c", [" */", "static void ", "syn_cmd_region ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static void ", "syn_cmd_region (", "    exarg_T *eap,"], "whitespace/parens"]
["src/nvim/syntax.c", ["  int matchgroup_id = 0;", "  int not_enough = FALSE;                       /* not enough arguments */", "  int illegal = FALSE;                          /* illegal arguments */"], "readability/bool"]
["src/nvim/syntax.c", ["  int not_enough = FALSE;                       /* not enough arguments */", "  int illegal = FALSE;                          /* illegal arguments */", "  int success = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int illegal = FALSE;                          /* illegal arguments */", "  int success = FALSE;", "  syn_opt_arg_T syn_opt_arg;"], "readability/bool"]
["src/nvim/syntax.c", ["  syn_opt_arg.flags = 0;", "  syn_opt_arg.keyword = FALSE;", "  syn_opt_arg.sync_idx = NULL;"], "readability/bool"]
["src/nvim/syntax.c", ["  syn_opt_arg.sync_idx = NULL;", "  syn_opt_arg.has_cont_list = TRUE;", "  syn_opt_arg.cont_list = NULL;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (pat_ptrs[ITEM_SKIP] != NULL) {        /* one skip pattern allowed */", "        illegal = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      item = ITEM_SKIP;", "    } else", "      break;"], "readability/braces"]
["src/nvim/syntax.c", ["    if (*rest == NUL) {", "      not_enough = TRUE;", "      break;"], "readability/bool"]
["src/nvim/syntax.c", ["        matchgroup_id = 0;", "      else {", "        matchgroup_id = syn_check_group(rest, (int)(p - rest));"], "readability/braces"]
["src/nvim/syntax.c", ["        if (matchgroup_id == 0) {", "          illegal = TRUE;", "          break;"], "readability/bool"]
["src/nvim/syntax.c", ["                       pat_ptrs[ITEM_END] == NULL)) {", "    not_enough = TRUE;", "    rest = NULL;"], "readability/bool"]
["src/nvim/syntax.c", ["      rest = NULL;", "    else {", "      ga_grow(&(curwin->w_s->b_syn_patterns), pat_count);"], "readability/braces"]
["src/nvim/syntax.c", ["              if (syn_opt_arg.cont_in_list != NULL)", "                curwin->w_s->b_syn_containedin = TRUE;", "              SYN_ITEMS(curwin->w_s)[idx].sp_next_list ="], "readability/bool"]
["src/nvim/syntax.c", ["        redraw_curbuf_later(SOME_VALID);", "        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */"], "whitespace/line_length"]
["src/nvim/syntax.c", ["        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */", "      }"], "whitespace/line_length"]
["src/nvim/syntax.c", ["        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */", "        success = TRUE;               /* don't free the progs and patterns now */", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["{", "  const short *s1 = v1;", "  const short *s2 = v2;"], "runtime/int"]
["src/nvim/syntax.c", ["  const short *s1 = v1;", "  const short *s2 = v2;", ""], "runtime/int"]
["src/nvim/syntax.c", [" */", "static void syn_combine_list(short **clstr1, short **clstr2, int list_op)", "{"], "runtime/int"]
["src/nvim/syntax.c", ["  int count2 = 0;", "  short       *g1;", "  short       *g2;"], "runtime/int"]
["src/nvim/syntax.c", ["  short       *g1;", "  short       *g2;", "  short       *clstr = NULL;"], "runtime/int"]
["src/nvim/syntax.c", ["  short       *g2;", "  short       *clstr = NULL;", "  int count;"], "runtime/int"]
["src/nvim/syntax.c", ["   */", "  qsort(*clstr1, (size_t)count1, sizeof(short), syn_compare_stub);", "  qsort(*clstr2, (size_t)count2, sizeof(short), syn_compare_stub);"], "runtime/int"]
["src/nvim/syntax.c", ["  qsort(*clstr1, (size_t)count1, sizeof(short), syn_compare_stub);", "  qsort(*clstr2, (size_t)count2, sizeof(short), syn_compare_stub);", ""], "runtime/int"]
["src/nvim/syntax.c", ["      }", "      clstr = xmalloc((count + 1) * sizeof(short));", "      clstr[count] = 0;"], "runtime/int"]
["src/nvim/syntax.c", ["  int scl_id;", "  short       *clstr_list;", "  int got_clstr = FALSE;"], "runtime/int"]
["src/nvim/syntax.c", ["  short       *clstr_list;", "  int got_clstr = FALSE;", "  int opt_len;"], "readability/bool"]
["src/nvim/syntax.c", ["        list_op = CLUSTER_REPLACE;", "      } else", "        break;"], "readability/braces"]
["src/nvim/syntax.c", ["          &clstr_list, list_op);", "      got_clstr = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  end = skip_regexp(arg + 1, *arg, TRUE, NULL);", "  if (*end != *arg) {                       /* end delimiter not found */"], "readability/bool"]
["src/nvim/syntax.c", ["            ++end;", "            *p = getdigits_int(&end);                       /* positive offset */", "          } else if (*end == '-')   {"], "whitespace/line_length"]
["src/nvim/syntax.c", ["            ++end;", "            *p = -getdigits_int(&end);                      /* negative offset */", "          }"], "whitespace/line_length"]
["src/nvim/syntax.c", ["  char_u      *next_arg;", "  int illegal = FALSE;", "  int finished = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int illegal = FALSE;", "  int finished = FALSE;", "  long n;"], "readability/bool"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg_start)) {", "    syn_cmd_list(eap, TRUE);", "    return;"], "readability/bool"]
["src/nvim/syntax.c", ["        next_arg = skipwhite(arg_end);", "      } else if (!eap->skip)", "        curwin->w_s->b_syn_sync_id = syn_name2id((char_u *)\"Comment\");"], "readability/braces"]
["src/nvim/syntax.c", ["      if (arg_end[-1] != '=' || !ascii_isdigit(*arg_end)) {", "        illegal = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (curwin->w_s->b_syn_linecont_pat != NULL) {", "        EMSG(_(\"E403: syntax sync: line continuations pattern specified twice\"));", "        finished = TRUE;"], "whitespace/line_length"]
["src/nvim/syntax.c", ["        EMSG(_(\"E403: syntax sync: line continuations pattern specified twice\"));", "        finished = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      }", "      arg_end = skip_regexp(next_arg + 1, *next_arg, TRUE, NULL);", "      if (*arg_end != *next_arg) {          /* end delimiter not found */"], "readability/bool"]
["src/nvim/syntax.c", ["      if (*arg_end != *next_arg) {          /* end delimiter not found */", "        illegal = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["          curwin->w_s->b_syn_linecont_pat = NULL;", "          finished = TRUE;", "          break;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (STRCMP(key, \"MATCH\") == 0)", "        syn_cmd_match(eap, TRUE);", "      else if (STRCMP(key, \"REGION\") == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["      else if (STRCMP(key, \"REGION\") == 0)", "        syn_cmd_region(eap, TRUE);", "      else if (STRCMP(key, \"CLEAR\") == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["      else if (STRCMP(key, \"CLEAR\") == 0)", "        syn_cmd_clear(eap, TRUE);", "      else"], "readability/bool"]
["src/nvim/syntax.c", ["      else", "        illegal = TRUE;", "      finished = TRUE;"], "readability/bool"]
["src/nvim/syntax.c", ["        illegal = TRUE;", "      finished = TRUE;", "      break;"], "readability/bool"]
["src/nvim/syntax.c", ["    redraw_curbuf_later(SOME_VALID);", "    syn_stack_free_all(curwin->w_s);            /* Need to recompute all syntax. */", "  }"], "whitespace/line_length"]
["src/nvim/syntax.c", [" */", "static int ", "get_id_list ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static int ", "get_id_list (", "    char_u **arg,"], "whitespace/parens"]
["src/nvim/syntax.c", ["    int keylen,                     /* length of keyword */", "    short **list             /* where to store the resulting list, if not", "                                   NULL, the list is silently skipped! */"], "readability/multiline_comment"]
["src/nvim/syntax.c", ["    int keylen,                     /* length of keyword */", "    short **list             /* where to store the resulting list, if not", "                                   NULL, the list is silently skipped! */"], "runtime/int"]
["src/nvim/syntax.c", ["    short **list             /* where to store the resulting list, if not", "                                   NULL, the list is silently skipped! */", ")"], "whitespace/operators"]
["src/nvim/syntax.c", ["  int total_count = 0;", "  short       *retval = NULL;", "  char_u      *name;"], "runtime/int"]
["src/nvim/syntax.c", ["  int id;", "  int failed = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["      for (end = p; *end && !ascii_iswhite(*end) && *end != ','; ++end)", "        ;", "      name = xmalloc((int)(end - p + 3));             /* leave room for \"^$\" */"], "whitespace/semicolon"]
["src/nvim/syntax.c", ["          EMSG2(_(\"E407: %s not allowed here\"), name + 1);", "          failed = TRUE;", "          xfree(name);"], "readability/bool"]
["src/nvim/syntax.c", ["          EMSG2(_(\"E408: %s must be first in contains list\"), name + 1);", "          failed = TRUE;", "          xfree(name);"], "readability/bool"]
["src/nvim/syntax.c", ["          id = syn_check_group(name + 1, (int)(end - p));", "        else {", "          /*"], "readability/braces"]
["src/nvim/syntax.c", ["          if (regmatch.regprog == NULL) {", "            failed = TRUE;", "            xfree(name);"], "readability/bool"]
["src/nvim/syntax.c", ["", "          regmatch.rm_ic = TRUE;", "          id = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["                  round = 1;", "                } else", "                  retval[count] = i + 1;"], "readability/braces"]
["src/nvim/syntax.c", ["        EMSG2(_(\"E409: Unknown group name: %s\"), p);", "        failed = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["            round = 1;", "          } else", "            retval[count] = id;"], "readability/braces"]
["src/nvim/syntax.c", ["    if (round == 1) {", "      retval = xmalloc((count + 1) * sizeof(short));", "      retval[count] = 0;            /* zero means end of the list */"], "runtime/int"]
["src/nvim/syntax.c", [" */", "static short *copy_id_list(short *list)", "{"], "runtime/int"]
["src/nvim/syntax.c", ["  int count;", "  short   *retval;", ""], "runtime/int"]
["src/nvim/syntax.c", ["  for (count = 0; list[count]; ++count)", "    ;", "  len = (count + 1) * sizeof(short);"], "whitespace/semicolon"]
["src/nvim/syntax.c", ["    ;", "  len = (count + 1) * sizeof(short);", "  retval = xmalloc(len);"], "runtime/int"]
["src/nvim/syntax.c", [" */", "static int ", "in_id_list ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static int ", "in_id_list (", "    stateitem_T *cur_si,            /* current item or NULL */"], "whitespace/parens"]
["src/nvim/syntax.c", ["    stateitem_T *cur_si,            /* current item or NULL */", "    short *list,              /* id list */", "    struct sp_syn *ssp,             /* group id and \":syn include\" tag of group */"], "runtime/int"]
["src/nvim/syntax.c", ["    short *list,              /* id list */", "    struct sp_syn *ssp,             /* group id and \":syn include\" tag of group */", "    int contained                  /* group id is contained */"], "whitespace/line_length"]
["src/nvim/syntax.c", ["  int retval;", "  short       *scl_list;", "  short item;"], "runtime/int"]
["src/nvim/syntax.c", ["  short       *scl_list;", "  short item;", "  short id = ssp->id;"], "runtime/int"]
["src/nvim/syntax.c", ["  short item;", "  short id = ssp->id;", "  static int depth = 0;"], "runtime/int"]
["src/nvim/syntax.c", ["            SYN_ITEMS(syn_block)[cur_si->si_idx].sp_flags & HL_CONTAINED))", "      return TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["  if (list == NULL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["      if (item - SYNID_ALLBUT != ssp->inc_tag)", "        return FALSE;", "    } else if (item < SYNID_CONTAINED)   {"], "readability/bool"]
["src/nvim/syntax.c", ["      if (item - SYNID_TOP != ssp->inc_tag || contained)", "        return FALSE;", "    } else {"], "readability/bool"]
["src/nvim/syntax.c", ["      if (item - SYNID_CONTAINED != ssp->inc_tag || !contained)", "        return FALSE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["    item = *++list;", "    retval = FALSE;", "  } else"], "readability/bool"]
["src/nvim/syntax.c", ["    retval = FALSE;", "  } else", "    retval = TRUE;"], "readability/braces"]
["src/nvim/syntax.c", ["  } else", "    retval = TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["  for (subcmd_end = arg; ASCII_ISALPHA(*subcmd_end); ++subcmd_end)", "    ;", "  subcmd_name = vim_strnsave(arg, (int)(subcmd_end - arg));"], "whitespace/semicolon"]
["src/nvim/syntax.c", ["      eap->arg = skipwhite(subcmd_end);", "      (subcommands[i].func)(eap, FALSE);", "      break;"], "readability/bool"]
["src/nvim/syntax.c", ["    memset(curwin->w_s, 0, sizeof(synblock_T));", "    // TODO: Keep the spell checking as it was.", "    curwin->w_p_spell = FALSE;          /* No spell checking */"], "readability/todo"]
["src/nvim/syntax.c", ["    // TODO: Keep the spell checking as it was.", "    curwin->w_p_spell = FALSE;          /* No spell checking */", "    clear_string_option(&curwin->w_s->b_p_spc);"], "readability/bool"]
["src/nvim/syntax.c", ["   * file. */", "  apply_autocmds(EVENT_SYNTAX, eap->arg, curbuf->b_fname, TRUE, curbuf);", ""], "readability/bool"]
["src/nvim/syntax.c", ["  if (old_value == NULL)", "    do_unlet((char_u *)\"b:current_syntax\", TRUE);", "  else {"], "readability/bool"]
["src/nvim/syntax.c", ["    do_unlet((char_u *)\"b:current_syntax\", TRUE);", "  else {", "    set_internal_string_var((char_u *)\"b:current_syntax\", old_value);"], "readability/braces"]
["src/nvim/syntax.c", [" */", "int ", "syn_get_id ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["int ", "syn_get_id (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/syntax.c", ["  if (STRCMP(eap->arg, \"on\") == 0)", "    syn_time_on = TRUE;", "  else if (STRCMP(eap->arg, \"off\") == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["  else if (STRCMP(eap->arg, \"off\") == 0)", "    syn_time_on = FALSE;", "  else if (STRCMP(eap->arg, \"clear\") == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["  MSG_PUTS_TITLE(_(", "          \"  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN\"));", "  MSG_PUTS(\"\\n\");"], "whitespace/line_length"]
["src/nvim/syntax.c", ["{", "  \"Conceal      ctermbg=DarkGrey ctermfg=LightGrey guibg=DarkGrey guifg=LightGrey\",", "  \"DiffText     cterm=bold ctermbg=Red gui=bold guibg=Red\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["  \"DiffChange   ctermbg=LightMagenta guibg=LightMagenta\",", "  \"DiffDelete   ctermfg=Blue ctermbg=LightCyan gui=bold guifg=Blue guibg=LightCyan\",", "  \"Directory    ctermfg=DarkBlue guifg=Blue\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["  \"SpellRare    ctermbg=LightMagenta guisp=Magenta gui=undercurl\",", "  \"TabLine      cterm=underline ctermfg=black ctermbg=LightGrey gui=underline guibg=LightGrey\",", "  \"Title        ctermfg=DarkMagenta gui=bold guifg=Magenta\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["  \"DiffChange   ctermbg=DarkMagenta guibg=DarkMagenta\",", "  \"DiffDelete   ctermfg=Blue ctermbg=DarkCyan gui=bold guifg=Blue guibg=DarkCyan\",", "  \"Directory    ctermfg=LightCyan guifg=Cyan\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["  \"SpellRare    ctermbg=Magenta guisp=Magenta gui=undercurl\",", "  \"TabLine      cterm=underline ctermfg=white ctermbg=DarkGrey gui=underline guibg=DarkGrey\",", "  \"Title        ctermfg=LightMagenta gui=bold guifg=Magenta\","], "whitespace/line_length"]
["src/nvim/syntax.c", ["", "void ", "init_highlight ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["void ", "init_highlight (", "    int both,                   /* include groups where 'bg' doesn't matter */"], "whitespace/parens"]
["src/nvim/syntax.c", ["  char        **pp;", "  static int had_both = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["  if (both) {", "    had_both = TRUE;", "    pp = highlight_init_both;"], "readability/bool"]
["src/nvim/syntax.c", ["    for (i = 0; pp[i] != NULL; ++i)", "      do_highlight((char_u *)pp[i], reset, TRUE);", "  } else if (!had_both)"], "readability/bool"]
["src/nvim/syntax.c", ["      do_highlight((char_u *)pp[i], reset, TRUE);", "  } else if (!had_both)", "    /* Don't do anything before the call with both == TRUE from main()."], "readability/braces"]
["src/nvim/syntax.c", ["  for (i = 0; pp[i] != NULL; ++i)", "    do_highlight((char_u *)pp[i], reset, TRUE);", ""], "readability/bool"]
["src/nvim/syntax.c", ["                   ? \"Visual cterm=NONE ctermbg=LightGrey\"", "                   : \"Visual cterm=NONE ctermbg=DarkGrey\"), FALSE,", "        TRUE);"], "readability/bool"]
["src/nvim/syntax.c", ["                   : \"Visual cterm=NONE ctermbg=DarkGrey\"), FALSE,", "        TRUE);", "  else {"], "readability/bool"]
["src/nvim/syntax.c", ["        TRUE);", "  else {", "    do_highlight((char_u *)\"Visual cterm=reverse ctermbg=NONE\","], "readability/braces"]
["src/nvim/syntax.c", ["    do_highlight((char_u *)\"Visual cterm=reverse ctermbg=NONE\",", "        FALSE, TRUE);", "    if (*p_bg == 'l')"], "readability/bool"]
["src/nvim/syntax.c", ["    if (*p_bg == 'l')", "      do_highlight((char_u *)\"Search ctermfg=black\", FALSE, TRUE);", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["      EMSG(_(\"E679: recursive loop loading syncolor.vim\"));", "    else {", "      ++recursive;"], "readability/braces"]
["src/nvim/syntax.c", ["      ++recursive;", "      (void)source_runtime((char_u *)\"syntax/syncolor.vim\", TRUE);", "      --recursive;"], "readability/bool"]
["src/nvim/syntax.c", ["  int retval = FAIL;", "  static int recursive = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "  recursive = TRUE;", "  buf = xmalloc(STRLEN(name) + 12);"], "readability/bool"]
["src/nvim/syntax.c", ["  buf = xmalloc(STRLEN(name) + 12);", "  sprintf((char *)buf, \"colors/%s.vim\", name);", "  retval = source_runtime(buf, FALSE);"], "runtime/printf"]
["src/nvim/syntax.c", ["  sprintf((char *)buf, \"colors/%s.vim\", name);", "  retval = source_runtime(buf, FALSE);", "  xfree(buf);"], "readability/bool"]
["src/nvim/syntax.c", ["  xfree(buf);", "  apply_autocmds(EVENT_COLORSCHEME, name, curbuf->b_fname, FALSE, curbuf);", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "  recursive = FALSE;", "  ui_refresh();"], "readability/bool"]
["src/nvim/syntax.c", [" */", "void ", "do_highlight ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["void ", "do_highlight (", "    char_u *line,"], "whitespace/parens"]
["src/nvim/syntax.c", ["  int idx;", "  int dodefault = FALSE;", "  int doclear = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int dodefault = FALSE;", "  int doclear = FALSE;", "  int dolink = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int doclear = FALSE;", "  int dolink = FALSE;", "  int error = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int dolink = FALSE;", "  int error = FALSE;", "  int color;"], "readability/bool"]
["src/nvim/syntax.c", ["  int color;", "  int is_normal_group = FALSE;                  /* \"Normal\" group */", ""], "readability/bool"]
["src/nvim/syntax.c", ["  if (STRNCMP(line, \"default\", name_end - line) == 0) {", "    dodefault = TRUE;", "    line = linep;"], "readability/bool"]
["src/nvim/syntax.c", ["  if (STRNCMP(line, \"clear\", name_end - line) == 0)", "    doclear = TRUE;", "  if (STRNCMP(line, \"link\", name_end - line) == 0)"], "readability/bool"]
["src/nvim/syntax.c", ["  if (STRNCMP(line, \"link\", name_end - line) == 0)", "    dolink = TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["    /* Only call highlight_changed() once, after sourcing a syntax file */", "    need_highlight_changed = TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["    if (ends_excmd(*line)) {", "      do_unlet((char_u *)\"colors_name\", TRUE);", "      restore_cterm_colors();"], "readability/bool"]
["src/nvim/syntax.c", ["      }", "      init_highlight(TRUE, TRUE);", "      highlight_changed();"], "readability/bool"]
["src/nvim/syntax.c", ["  /* Return if \"default\" was used and the group already has settings. */", "  if (dodefault && hl_has_settings(idx, TRUE))", "    return;"], "readability/bool"]
["src/nvim/syntax.c", ["  if (STRCMP(HL_TABLE()[idx].sg_name_u, \"NORMAL\") == 0)", "    is_normal_group = TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["        EMSG2(_(\"E415: unexpected equal sign: %s\"), key_start);", "        error = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["        EMSG2(_(\"E416: missing equal sign: %s\"), key_start);", "        error = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["          EMSG2(_(e_invarg2), key_start);", "          error = TRUE;", "          break;"], "readability/bool"]
["src/nvim/syntax.c", ["        EMSG2(_(\"E417: missing argument: %s\"), key_start);", "        error = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["            EMSG2(_(\"E418: Illegal value: %s\"), arg);", "            error = TRUE;", "            break;"], "readability/bool"]
["src/nvim/syntax.c", ["            HL_TABLE()[idx].sg_cterm = attr;", "            HL_TABLE()[idx].sg_cterm_bold = FALSE;", "          }"], "readability/bool"]
["src/nvim/syntax.c", ["            HL_TABLE()[idx].sg_cterm &= ~HL_BOLD;", "            HL_TABLE()[idx].sg_cterm_bold = FALSE;", "          }"], "readability/bool"]
["src/nvim/syntax.c", ["              color = cterm_normal_fg_color - 1;", "            else {", "              EMSG(_(\"E419: FG color unknown\"));"], "readability/braces"]
["src/nvim/syntax.c", ["              EMSG(_(\"E419: FG color unknown\"));", "              error = TRUE;", "              break;"], "readability/bool"]
["src/nvim/syntax.c", ["              color = cterm_normal_bg_color - 1;", "            else {", "              EMSG(_(\"E420: BG color unknown\"));"], "readability/braces"]
["src/nvim/syntax.c", ["              EMSG(_(\"E420: BG color unknown\"));", "              error = TRUE;", "              break;"], "readability/bool"]
["src/nvim/syntax.c", ["                  key_start);", "              error = TRUE;", "              break;"], "readability/bool"]
["src/nvim/syntax.c", ["                    HL_TABLE()[idx].sg_cterm |= HL_BOLD;", "                    HL_TABLE()[idx].sg_cterm_bold = TRUE;", "                  } else"], "readability/bool"]
["src/nvim/syntax.c", ["                    HL_TABLE()[idx].sg_cterm_bold = TRUE;", "                  } else", "                    HL_TABLE()[idx].sg_cterm &= ~HL_BOLD;"], "readability/braces"]
["src/nvim/syntax.c", ["        EMSG2(_(\"E423: Illegal argument: %s\"), key_start);", "        error = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["    syn_unadd_group();", "  else {", "    if (is_normal_group) {"], "readability/braces"]
["src/nvim/syntax.c", ["      ui_refresh();", "    } else", "      set_hl_attr(idx);"], "readability/braces"]
["src/nvim/syntax.c", ["  /* Only call highlight_changed() once, after sourcing a syntax file */", "  need_highlight_changed = TRUE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["  HL_TABLE()[idx].sg_cterm = 0;", "  HL_TABLE()[idx].sg_cterm_bold = FALSE;", "  HL_TABLE()[idx].sg_cterm_fg = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["  attrentry_T *taep;", "  static int recursive = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["    }", "    recursive = TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["", "    recursive = FALSE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  ", "  // This is a new combination of colors and font, add an entry."], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["  struct hl_group     *sgp;", "  int didh = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["    (void)syn_list_header(didh, 9999, id);", "    didh = TRUE;", "    msg_puts_attr((char_u *)\"links to\", hl_attr(HLF_D));"], "readability/bool"]
["src/nvim/syntax.c", ["", "static int highlight_list_arg(int id, int didh, int type, int iarg, char_u *sarg, char *name)", "{"], "whitespace/line_length"]
["src/nvim/syntax.c", ["  if (got_int)", "    return FALSE;", "  if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0)) {"], "readability/bool"]
["src/nvim/syntax.c", ["    if (type == LIST_INT)", "      sprintf((char *)buf, \"%d\", iarg - 1);", "    else if (type == LIST_STRING)"], "runtime/printf"]
["src/nvim/syntax.c", ["      ts = sarg;", "    else {   /* type == LIST_ATTR */", "      buf[0] = NUL;"], "readability/braces"]
["src/nvim/syntax.c", ["        (int)(vim_strsize(ts) + STRLEN(name) + 1), id);", "    didh = TRUE;", "    if (!got_int) {"], "readability/bool"]
["src/nvim/syntax.c", ["char_u *", "highlight_has_attr (", "    int id,"], "whitespace/parens"]
["src/nvim/syntax.c", ["char_u *", "highlight_color (", "    int id,"], "whitespace/parens"]
["src/nvim/syntax.c", ["  int n;", "  int fg = FALSE;", "  int sp = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int fg = FALSE;", "  int sp = FALSE;", "  int font = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int sp = FALSE;", "  int font = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["  if (TOLOWER_ASC(what[0]) == 'f' && TOLOWER_ASC(what[1]) == 'g')", "    fg = TRUE;", "  else if (TOLOWER_ASC(what[0]) == 'f' && TOLOWER_ASC(what[1]) == 'o'"], "readability/bool"]
["src/nvim/syntax.c", ["           && TOLOWER_ASC(what[2]) == 'n' && TOLOWER_ASC(what[3]) == 't')", "    font = TRUE;", "  else if (TOLOWER_ASC(what[0]) == 's' && TOLOWER_ASC(what[1]) == 'p')"], "readability/bool"]
["src/nvim/syntax.c", ["  else if (TOLOWER_ASC(what[0]) == 's' && TOLOWER_ASC(what[1]) == 'p')", "    sp = TRUE;", "  else if (!(TOLOWER_ASC(what[0]) == 'b' && TOLOWER_ASC(what[1]) == 'g'))"], "readability/bool"]
["src/nvim/syntax.c", ["      n = HL_TABLE()[id - 1].sg_cterm_bg - 1;", "    sprintf((char *)name, \"%d\", n);", "    return name;"], "runtime/printf"]
["src/nvim/syntax.c", [" */", "static int ", "syn_list_header ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static int ", "syn_list_header (", "    int did_header,                 /* did header already */"], "whitespace/parens"]
["src/nvim/syntax.c", ["  int endcol = 19;", "  int newline = TRUE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["    if (got_int)", "      return TRUE;", "    msg_outtrans(HL_TABLE()[id - 1].sg_name);"], "readability/bool"]
["src/nvim/syntax.c", ["    if (got_int)", "      return TRUE;", "  } else {"], "readability/bool"]
["src/nvim/syntax.c", ["    if (msg_col >= endcol)      /* wrap around is like starting a new line */", "      newline = FALSE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", [" */", "static void ", "set_hl_attr ("], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["static void ", "set_hl_attr (", "    int idx                    /* index in array */"], "whitespace/parens"]
["src/nvim/syntax.c", ["", "  need_highlight_changed = FALSE;", ""], "readability/bool"]
["src/nvim/syntax.c", ["  for (int i = 0; i < 9; i++) {", "    sprintf((char *)userhl, \"User%d\", i + 1);", "    id = syn_name2id(userhl);"], "runtime/printf"]
["src/nvim/syntax.c", ["        hlt[hlcnt + i].sg_gui = highlight_attr[HLF_SNC];", "      } else", "        memmove(&hlt[hlcnt + i],"], "readability/braces"]
["src/nvim/syntax.c", ["{", "  //TODO: 'xp' is unused", "  if (idx == highlight_ga.ga_len && include_none != 0)"], "whitespace/comments"]
["src/nvim/syntax.c", ["{", "  //TODO: 'xp' is unused", "  if (idx == highlight_ga.ga_len && include_none != 0)"], "readability/todo"]
["src/nvim/syntax.c", ["  {\"White\", RGB(0xff, 0xff, 0xff)},", "  // The color names below were taken from gui_x11.c in vim source ", "  {\"LightRed\", RGB(0xff, 0xbb, 0xbb)},"], "whitespace/end_of_line"]
["src/nvim/syntax.c", ["  {\"LightRed\", RGB(0xff, 0xbb, 0xbb)},", "  {\"LightMagenta\",RGB(0xff, 0xbb, 0xff)},", "  {\"DarkYellow\", RGB(0xbb, 0xbb, 0x00)},"], "whitespace/comma"]
["src/nvim/syntax.c", ["{", "", "  if (name[0] == '#' && isxdigit(name[1]) && isxdigit(name[2])"], "whitespace/blank_line"]
["src/nvim/tag.c", [" */", "int ", "do_tag ("], "whitespace/end_of_line"]
["src/nvim/tag.c", ["int ", "do_tag (", "    char_u *tag,               /* tag (pattern) to jump to */"], "whitespace/parens"]
["src/nvim/tag.c", ["  int prev_num_matches;", "  int new_tag = FALSE;", "  int other_name;"], "readability/bool"]
["src/nvim/tag.c", ["  char_u      *name;", "  int no_regexp = FALSE;", "  int error_cur_match = 0;"], "readability/bool"]
["src/nvim/tag.c", ["  char_u      *command_end;", "  int save_pos = FALSE;", "  fmark_T saved_fmark;"], "readability/bool"]
["src/nvim/tag.c", ["  int taglen;", "  int jumped_to_tag = FALSE;", "  tagptrs_T tagp, tagp2;"], "readability/bool"]
["src/nvim/tag.c", ["  int use_tagstack;", "  int skip_msg = FALSE;", "  char_u      *buf_ffname = curbuf->b_ffname;       /* name to use for"], "readability/bool"]
["src/nvim/tag.c", ["  int skip_msg = FALSE;", "  char_u      *buf_ffname = curbuf->b_ffname;       /* name to use for", "                                                       priority computation */"], "readability/multiline_comment"]
["src/nvim/tag.c", ["    num_matches = 0;", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/tag.c", ["    type = DT_TAG;", "    no_regexp = TRUE;", "  }"], "readability/bool"]
["src/nvim/tag.c", ["  if (!p_tgst && *tag != NUL) {", "    use_tagstack = FALSE;", "    new_tag = TRUE;"], "readability/bool"]
["src/nvim/tag.c", ["    use_tagstack = FALSE;", "    new_tag = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/tag.c", ["    if (g_do_tagpreview != 0)", "      use_tagstack = FALSE;", "    else"], "readability/bool"]
["src/nvim/tag.c", ["    else", "      use_tagstack = TRUE;", ""], "readability/bool"]
["src/nvim/tag.c", ["            || type == DT_CSCOPE", "            )) {", "      if (g_do_tagpreview != 0) {"], "whitespace/parens"]
["src/nvim/tag.c", ["", "        save_pos = TRUE;                /* save the cursor position below */", "      }"], "readability/bool"]
["src/nvim/tag.c", ["", "      new_tag = TRUE;", "    } else {"], "readability/bool"]
["src/nvim/tag.c", ["        curwin->w_cursor.col = saved_fmark.mark.col;", "        curwin->w_set_curswant = TRUE;", "        check_cursor();"], "readability/bool"]
["src/nvim/tag.c", ["          /* \":tag\" (no argument): go to newer pattern */", "          save_pos = TRUE;              /* save the cursor position below */", "          if ((tagstackidx += count - 1) >= tagstacklen) {"], "readability/bool"]
["src/nvim/tag.c", ["            EMSG(_(topmsg));", "            save_pos = FALSE;", "          } else if (tagstackidx < 0)   {       /* must have been count == 0 */"], "readability/bool"]
["src/nvim/tag.c", ["        }", "        new_tag = TRUE;", "      } else {                                /* go to other matching tag */"], "readability/bool"]
["src/nvim/tag.c", ["          EMSG(_(\"E425: Cannot go before first matching tag\"));", "          skip_msg = TRUE;", "          cur_match = 0;"], "readability/bool"]
["src/nvim/tag.c", ["        ++name;", "      } else", "        flags = TAG_NOIC;"], "readability/braces"]
["src/nvim/tag.c", ["          && new_num_matches < max_num_matches)", "        max_num_matches = MAXCOL;         /* If less than max_num_matches", "                                             found: all matches found. */"], "readability/multiline_comment"]
["src/nvim/tag.c", ["    } else {", "      int ask_for_selection = FALSE;", ""], "readability/bool"]
["src/nvim/tag.c", ["        cs_print_tags();", "        ask_for_selection = TRUE;", "      } else if (type == DT_SELECT ||"], "readability/bool"]
["src/nvim/tag.c", ["        if (msg_col == 0)", "          msg_didout = FALSE;           /* overwrite previous message */", "        msg_start();"], "readability/bool"]
["src/nvim/tag.c", ["                 *p && *p != '\\r' && *p != '\\n'; ++p)", "              ;", "            command_end = p;"], "whitespace/semicolon"]
["src/nvim/tag.c", ["              ++p;", "            } else", "              p = msg_outtrans_one(p, 0);"], "readability/braces"]
["src/nvim/tag.c", ["        if (got_int)", "          got_int = FALSE;              /* only stop the listing */", "        ask_for_selection = TRUE;"], "readability/bool"]
["src/nvim/tag.c", ["          got_int = FALSE;              /* only stop the listing */", "        ask_for_selection = TRUE;", "      } else if (type == DT_LTAG)   {"], "readability/bool"]
["src/nvim/tag.c", ["            lnum = atol((char *)tagp.command);", "          else {", "            char_u *cmd_start, *cmd_end;"], "readability/braces"]
["src/nvim/tag.c", ["                   *p && *p != '\\r' && *p != '\\n'; ++p)", "                ;", "              cmd_end = p;"], "whitespace/semicolon"]
["src/nvim/tag.c", ["", "        list_free(list, TRUE);", "        xfree(fname);"], "readability/bool"]
["src/nvim/tag.c", ["", "      if (ask_for_selection == TRUE) {", "        /*"], "readability/bool"]
["src/nvim/tag.c", ["          cs_free_tags();", "          jumped_to_tag = TRUE;", "          break;"], "readability/bool"]
["src/nvim/tag.c", ["            EMSG(_(\"E428: Cannot go beyond last matching tag\"));", "          skip_msg = TRUE;", "        }"], "readability/bool"]
["src/nvim/tag.c", ["        /* Give an indication of the number of matching tags */", "        sprintf((char *)IObuff, _(\"tag %d of %d%s\"),", "            cur_match + 1,"], "runtime/printf"]
["src/nvim/tag.c", ["            msg(IObuff);", "          msg_scroll = TRUE;            /* don't overwrite this message */", "        } else"], "readability/bool"]
["src/nvim/tag.c", ["          msg_scroll = TRUE;            /* don't overwrite this message */", "        } else", "          give_warning(IObuff, ic);"], "readability/braces"]
["src/nvim/tag.c", ["            --cur_match;", "          else {", "            type = DT_NEXT;"], "readability/braces"]
["src/nvim/tag.c", ["          tagstackidx = curwin->w_tagstackidx;", "        jumped_to_tag = TRUE;", "      }"], "readability/bool"]
["src/nvim/tag.c", ["  return jumped_to_tag;", "}", ""], "readability/fn_size"]
["src/nvim/tag.c", ["    msg_advance(24);", "  } else", "    msg_advance(13 + l);"], "readability/braces"]
["src/nvim/tag.c", ["      msg_putchar('\\n');", "      sprintf((char *)IObuff, \"%c%2d %2d %-15s %5ld  \",", "          i == tagstackidx ? '>' : ' ',"], "runtime/printf"]
["src/nvim/tag.c", [" */", "int ", "find_tags ("], "whitespace/end_of_line"]
["src/nvim/tag.c", ["int ", "find_tags (", "    char_u *pat,                       /* pattern to search for */"], "whitespace/parens"]
["src/nvim/tag.c", ["    int flags,", "    int mincount,                           /*  MAXCOL: find all matches", "                                             other: minimal number of matches */"], "readability/multiline_comment"]
["src/nvim/tag.c", ["  tagptrs_T tagp;", "  int did_open = FALSE;                 /* did open a tag file */", "  int stop_searching = FALSE;           /* stop when match found or error */"], "readability/bool"]
["src/nvim/tag.c", ["  int did_open = FALSE;                 /* did open a tag file */", "  int stop_searching = FALSE;           /* stop when match found or error */", "  int retval = FAIL;                    /* return value */"], "readability/bool"]
["src/nvim/tag.c", ["  int is_current;                       /* file name matches */", "  int eof = FALSE;                      /* found end-of-file */", "  char_u      *p;"], "readability/bool"]
["src/nvim/tag.c", ["  {", "    off_t low_offset;           /* offset for first char of first line that", "                                   could match */"], "readability/multiline_comment"]
["src/nvim/tag.c", ["                                   could match */", "    off_t high_offset;          /* offset of char after last line that could", "                                   match */"], "readability/multiline_comment"]
["src/nvim/tag.c", ["  /* find all matching tags */", "  int sort_error = FALSE;                       /* tags file not sorted */", "  int linear;                                   /* do a linear search */"], "readability/bool"]
["src/nvim/tag.c", ["  int linear;                                   /* do a linear search */", "  int sortic = FALSE;                           /* tag file sorted in nocase */", "  int line_error = FALSE;                       /* syntax error */"], "readability/bool"]
["src/nvim/tag.c", ["  int sortic = FALSE;                           /* tag file sorted in nocase */", "  int line_error = FALSE;                       /* syntax error */", "  int has_re = (flags & TAG_REGEXP);            /* regexp used */"], "readability/bool"]
["src/nvim/tag.c", ["  int noic = (flags & TAG_NOIC);", "  int get_it_again = FALSE;", "  int use_cscope = (flags & TAG_CSCOPE);"], "readability/bool"]
["src/nvim/tag.c", ["  save_emsg_off = emsg_off;", "  emsg_off = TRUE;    /* don't want error for invalid RE here */", "  prepare_pats(&orgpat, has_re);"], "readability/bool"]
["src/nvim/tag.c", ["     */", "    for (first_file = TRUE;", "         use_cscope ||"], "readability/bool"]
["src/nvim/tag.c", ["         get_tagfname(&tn, first_file, tag_fname) == OK;", "         first_file = FALSE) {", "      /*"], "readability/bool"]
["src/nvim/tag.c", ["        fp = NULL;          /* avoid GCC warning */", "      else {", "        if (curbuf->b_help) {"], "readability/braces"]
["src/nvim/tag.c", ["            help_pri = 0;", "          else {", "            help_pri = 1;"], "readability/braces"]
["src/nvim/tag.c", ["      }", "      did_open = TRUE;      /* remember that we found at least one file */", ""], "readability/bool"]
["src/nvim/tag.c", ["        if (got_int || compl_interrupted) {", "          stop_searching = TRUE;", "          break;"], "readability/bool"]
["src/nvim/tag.c", ["        if (mincount == TAG_MANY && match_count >= TAG_MANY) {", "          stop_searching = TRUE;", "          retval = OK;"], "readability/bool"]
["src/nvim/tag.c", ["         */", "        else if (state == TS_SKIP_BACK) {", "          search_info.curr_offset -= LSIZE * 2;"], "whitespace/newline"]
["src/nvim/tag.c", ["         */", "        else {", "          /* skip empty and blank lines */"], "whitespace/newline"]
["src/nvim/tag.c", ["         */", "        else {", "          /* skip empty and blank lines */"], "readability/braces"]
["src/nvim/tag.c", ["              for (p = lbuf + 20; *p > ' ' && *p < 127; ++p)", "                ;", "              *p = NUL;"], "whitespace/semicolon"]
["src/nvim/tag.c", ["            state = TS_BINARY;", "            sortic = TRUE;", "            orgpat.regmatch.rm_ic = (p_ic || !noic);"], "readability/bool"]
["src/nvim/tag.c", ["            orgpat.regmatch.rm_ic = (p_ic || !noic);", "          } else", "            state = TS_LINEAR;"], "readability/braces"]
["src/nvim/tag.c", ["             * search. */", "            linear = TRUE;", "            state = TS_LINEAR;"], "readability/bool"]
["src/nvim/tag.c", ["                /* Avoid getting stuck. */", "                linear = TRUE;", "                state = TS_LINEAR;"], "readability/bool"]
["src/nvim/tag.c", ["            /* Corrupted tag line. */", "            line_error = TRUE;", "            break;"], "readability/bool"]
["src/nvim/tag.c", ["            if (i < search_info.low_char || i > search_info.high_char)", "              sort_error = TRUE;", ""], "readability/bool"]
["src/nvim/tag.c", ["            }", "          } else", "          /* skip this match if it can't match */"], "readability/braces"]
["src/nvim/tag.c", ["            i = OK;", "        } else", "          i = parse_tag_line(lbuf,"], "readability/braces"]
["src/nvim/tag.c", ["        if (i == FAIL) {", "          line_error = TRUE;", "          break;"], "readability/bool"]
["src/nvim/tag.c", ["        if (orgpat.len != cmplen)", "          match = FALSE;", "        else {"], "readability/bool"]
["src/nvim/tag.c", ["          match = FALSE;", "        else {", "          if (orgpat.regmatch.rm_ic) {"], "readability/braces"]
["src/nvim/tag.c", ["                                 cmplen) == 0);", "          } else", "            match = (STRNCMP(tagp.tagname, orgpat.pat, cmplen) == 0);"], "readability/braces"]
["src/nvim/tag.c", ["         */", "        match_re = FALSE;", "        if (!match && orgpat.regmatch.regprog != NULL) {"], "readability/bool"]
["src/nvim/tag.c", ["            if (orgpat.regmatch.rm_ic) {", "              orgpat.regmatch.rm_ic = FALSE;", "              match_no_ic = vim_regexec(&orgpat.regmatch, tagp.tagname,"], "readability/bool"]
["src/nvim/tag.c", ["                  (colnr_T)0);", "              orgpat.regmatch.rm_ic = TRUE;", "            }"], "readability/bool"]
["src/nvim/tag.c", ["          *tagp.tagname_end = cc;", "          match_re = TRUE;", "        }"], "readability/bool"]
["src/nvim/tag.c", ["              if (tagp.tagname != lbuf)", "                is_static = TRUE;               /* detected static tag before */", "              else"], "readability/bool"]
["src/nvim/tag.c", ["              STRCPY(p + len + 1, help_lang);", "              sprintf((char *)p + len + 1 + ML_EXTRA, \"%06d\",", "                  help_heuristic(tagp.tagname,"], "runtime/printf"]
["src/nvim/tag.c", ["                  + help_pri", "                  );", ""], "whitespace/parens"]
["src/nvim/tag.c", ["                  STRLCPY(p, tagp.command + 2, len + 1);", "                } else", "                  mfp = NULL;"], "readability/braces"]
["src/nvim/tag.c", ["                  mfp = NULL;", "                get_it_again = FALSE;", "              } else {"], "readability/bool"]
["src/nvim/tag.c", ["                ++match_count;", "              } else", "                xfree(mfp);"], "readability/braces"]
["src/nvim/tag.c", ["          EMSGN(_(\"Before byte %\" PRId64), ftell(fp));", "        stop_searching = TRUE;", "        line_error = FALSE;"], "readability/bool"]
["src/nvim/tag.c", ["        stop_searching = TRUE;", "        line_error = FALSE;", "      }"], "readability/bool"]
["src/nvim/tag.c", ["        EMSG2(_(\"E432: Tags file not sorted: %s\"), tag_fname);", "        sort_error = FALSE;", "      }"], "readability/bool"]
["src/nvim/tag.c", ["        retval = OK;", "        stop_searching = TRUE;", "      }"], "readability/bool"]
["src/nvim/tag.c", ["        break;", "", "    }   /* end of for-each-file loop */"], "whitespace/blank_line"]
["src/nvim/tag.c", ["      break;", "    orgpat.regmatch.rm_ic = TRUE;       /* try another time while ignoring case */", "  }"], "whitespace/line_length"]
["src/nvim/tag.c", ["      break;", "    orgpat.regmatch.rm_ic = TRUE;       /* try another time while ignoring case */", "  }"], "readability/bool"]
["src/nvim/tag.c", ["        xfree(mfp);", "      else {", "        /* To avoid allocating memory again we turn the struct"], "readability/braces"]
["src/nvim/tag.c", ["  return retval;", "}", ""], "readability/fn_size"]
["src/nvim/tag.c", [" */", "int ", "get_tagfname ("], "whitespace/end_of_line"]
["src/nvim/tag.c", ["int ", "get_tagfname (", "    tagname_T *tnp,       /* holds status info */"], "whitespace/parens"]
["src/nvim/tag.c", ["          \"doc/tags doc/tags-??\"", "          , TRUE, found_tagfile_cb, NULL);", "    }"], "readability/bool"]
["src/nvim/tag.c", ["      STRCPY(path_tail(buf), \"tags\");", "    } else", "      STRLCPY(buf, ((char_u **)(tag_fnames.ga_data))["], "readability/braces"]
["src/nvim/tag.c", ["", "      tnp->tn_did_filefind_init = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/tag.c", ["          r_ptr, 100,", "          FALSE,                   /* don't free visited list */", "          FINDFILE_FILE,           /* we search for a file */"], "readability/bool"]
["src/nvim/tag.c", ["          FINDFILE_FILE,           /* we search for a file */", "          tnp->tn_search_ctx, TRUE, curbuf->b_ffname);", "      if (tnp->tn_search_ctx != NULL)"], "readability/bool"]
["src/nvim/tag.c", ["      if (tnp->tn_search_ctx != NULL)", "        tnp->tn_did_filefind_init = TRUE;", "    }"], "readability/bool"]
["src/nvim/tag.c", [" */", "static int ", "parse_tag_line ("], "whitespace/end_of_line"]
["src/nvim/tag.c", ["static int ", "parse_tag_line (", "    char_u *lbuf,              /* line to be parsed */"], "whitespace/parens"]
["src/nvim/tag.c", ["    tagp->tagname = p + 1;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/tag.c", ["    if (STRNCMP(p, \"file:\", 5) == 0)", "      return TRUE;", "  }"], "readability/bool"]
["src/nvim/tag.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/tag.c", [" */", "static int ", "parse_match ("], "whitespace/end_of_line"]
["src/nvim/tag.c", ["static int ", "parse_match (", "    char_u *lbuf,          /* input: matching line */"], "whitespace/parens"]
["src/nvim/tag.c", ["           *p && *p != '\\t' && *p != '\\r' && *p != '\\n'; ++p)", "        ;", "      tagp->tagkind_end = p;"], "whitespace/semicolon"]
["src/nvim/tag.c", ["  *tagp->fname_end = NUL;", "  char_u *fullname = expand_tag_fname(tagp->fname, tagp->tag_fname, FALSE);", "  *tagp->fname_end = c;"], "readability/bool"]
["src/nvim/tag.c", [" */", "static int ", "jumpto_tag ("], "whitespace/end_of_line"]
["src/nvim/tag.c", ["static int ", "jumpto_tag (", "    char_u *lbuf,              /* line from the tags file for this tag */"], "whitespace/parens"]
["src/nvim/tag.c", ["   */", "  fname = expand_tag_fname(fname, tagp.tag_fname, TRUE);", "  tofree_fname = fname;         /* free() it later */"], "readability/bool"]
["src/nvim/tag.c", ["    if (!curwin->w_p_pvw) {", "      full_fname = (char_u *)FullName_save((char *)fname, FALSE);", "      fname = full_fname;"], "readability/bool"]
["src/nvim/tag.c", ["  }", "  getfile_result = getfile(0, fname, NULL, TRUE, (linenr_T)0, forceit);", "  keep_help_flag = FALSE;"], "readability/bool"]
["src/nvim/tag.c", ["  getfile_result = getfile(0, fname, NULL, TRUE, (linenr_T)0, forceit);", "  keep_help_flag = FALSE;", ""], "readability/bool"]
["src/nvim/tag.c", ["  if (getfile_result <= 0) {            /* got to the right file */", "    curwin->w_set_curswant = TRUE;", "    postponed_split = 0;"], "readability/bool"]
["src/nvim/tag.c", ["    save_magic = p_magic;", "    p_magic = FALSE;            /* always execute with 'nomagic' */", "    /* Save value of no_hlsearch, jumping to a tag is not a real search */"], "readability/bool"]
["src/nvim/tag.c", ["    if (pbuf[0] == '/' || pbuf[0] == '?')", "      str = skip_regexp(pbuf + 1, pbuf[0], FALSE, NULL) + 1;", "    if (str > pbuf_end - 1) {   /* search command with nothing following */"], "readability/bool"]
["src/nvim/tag.c", ["      p_ws = true;              /* need 'wrapscan' for backward searches */", "      p_ic = FALSE;             /* don't ignore case now */", "      p_scs = FALSE;"], "readability/bool"]
["src/nvim/tag.c", ["      p_ic = FALSE;             /* don't ignore case now */", "      p_scs = FALSE;", "      save_lnum = curwin->w_cursor.lnum;"], "readability/bool"]
["src/nvim/tag.c", ["        retval = OK;", "      else {", "        int found = 1;"], "readability/braces"]
["src/nvim/tag.c", ["         */", "        p_ic = TRUE;", "        if (!do_search(NULL, pbuf[0], pbuf + 1, (long)1,"], "readability/bool"]
["src/nvim/tag.c", ["          *tagp.tagname_end = NUL;", "          sprintf((char *)pbuf, \"^%s\\\\s\\\\*(\", tagp.tagname);", "          if (!do_search(NULL, '/', pbuf, (long)1,"], "runtime/printf"]
["src/nvim/tag.c", ["            /* Guess again: \"^char * \\<func  (\" */", "            sprintf((char *)pbuf, \"^\\\\[#a-zA-Z_]\\\\.\\\\*\\\\<%s\\\\s\\\\*(\",", "                tagp.tagname);"], "runtime/printf"]
["src/nvim/tag.c", ["    if (secure == 2)", "      wait_return(TRUE);", "    secure = save_secure;"], "readability/bool"]
["src/nvim/tag.c", ["    if (postponed_split) {              /* close the window */", "      win_close(curwin, FALSE);", "      postponed_split = 0;"], "readability/bool"]
["src/nvim/tag.c", ["    simplify_filename(retval);", "  } else", "    retval = vim_strsave(fname);"], "readability/braces"]
["src/nvim/tag.c", [" */", "static int test_for_current(char_u *fname, char_u *fname_end, char_u *tag_fname, char_u *buf_ffname)", "{"], "whitespace/line_length"]
["src/nvim/tag.c", ["  int c;", "  int retval = FALSE;", "  char_u  *fullname;"], "readability/bool"]
["src/nvim/tag.c", ["    }", "    fullname = expand_tag_fname(fname, tag_fname, TRUE);", "    retval = (path_full_compare(fullname, buf_ffname, TRUE) & kEqualFiles);"], "readability/bool"]
["src/nvim/tag.c", ["    fullname = expand_tag_fname(fname, tag_fname, TRUE);", "    retval = (path_full_compare(fullname, buf_ffname, TRUE) & kEqualFiles);", "    xfree(fullname);"], "readability/bool"]
["src/nvim/tag.c", ["    else if (*str == '/' || *str == '?') {", "      str = skip_regexp(str + 1, *str, FALSE, NULL);", "      if (*str != **pp)"], "readability/bool"]
["src/nvim/tag.c", ["        ++str;", "    } else", "      str = NULL;"], "readability/braces"]
["src/nvim/tag.c", ["", "int ", "expand_tags ("], "whitespace/end_of_line"]
["src/nvim/tag.c", ["int ", "expand_tags (", "    int tagnames,                   /* expand tag names */"], "whitespace/parens"]
["src/nvim/tag.c", [" */", "static int ", "add_tag_field ("], "whitespace/end_of_line"]
["src/nvim/tag.c", ["static int ", "add_tag_field (", "    dict_T *dict,"], "whitespace/parens"]
["src/nvim/tag.c", ["              n[len] = ':';", "            } else", "              /* Skip field without colon. */"], "readability/braces"]
["src/nvim/terminal.c", ["  Terminal *term;", "  void *stub; (void)(stub);", "  // don't process autocommands while updating terminal buffers"], "whitespace/newline"]
["src/nvim/tui/input.c", ["", "  row--; col--;  // Termkey uses 1-based coordinates", "  buf[len++] = '<';"], "whitespace/newline"]
["src/nvim/ui.c", ["#include \"nvim/misc2.h\"", "#include \"nvim/mbyte.h\"", "#include \"nvim/garray.h\""], "build/include"]
["src/nvim/undo.c", [" */", "static int undo_undoes = FALSE;", ""], "readability/bool"]
["src/nvim/undo.c", ["    EMSG(\"uh_magic wrong (may be using freed memory)\");", "  else {", "    /* Check pointers back are correct. */"], "readability/braces"]
["src/nvim/undo.c", ["", "  return u_savecommon(top, bot, (linenr_T)0, FALSE);", "}"], "readability/bool"]
["src/nvim/undo.c", ["", "  return u_savecommon(lnum - 1, lnum + 1, lnum + 1, FALSE);", "}"], "readability/bool"]
["src/nvim/undo.c", ["", "  return u_savecommon(lnum - 1, lnum, lnum + 1, FALSE);", "}"], "readability/bool"]
["src/nvim/undo.c", ["  return u_savecommon(lnum - 1, lnum + nlines,", "      nlines == curbuf->b_ml.ml_line_count ? 2 : lnum, FALSE);", "}"], "readability/bool"]
["src/nvim/undo.c", ["    EMSG(_(e_modifiable));", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/undo.c", ["    EMSG(_(e_sandbox));", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/undo.c", ["    EMSG(_(e_secure));", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/undo.c", ["", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["#endif", "    } else", "      uhp = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["        u_freeheader(curbuf, uhfree, &old_curhead);", "      else {", "        /* Free the oldest alternate branch as a whole. */"], "readability/braces"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "      u_check(TRUE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["        curbuf->b_u_oldhead = uhp;", "    } else", "      uhp->uh_alt_prev.ptr = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["            uep->ue_bot = 0;", "          else {", "            uep->ue_lcount = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/undo.c", ["    uep->ue_bot = 0;", "  else {", "    uep->ue_lcount = curbuf->b_ml.ml_line_count;"], "readability/braces"]
["src/nvim/undo.c", ["    }", "  } else", "    uep->ue_array = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["  curbuf->b_u_synced = false;", "  undo_undoes = FALSE;", ""], "readability/bool"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["  /* Check there is no problem in undo info before writing. */", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["  /* Undo must be synced. */", "  u_sync(TRUE);", ""], "readability/bool"]
["src/nvim/undo.c", ["  memset(uhp_table_used, 0, amount);", "# define SET_FLAG(j) ++ uhp_table_used[j]", "#else"], "whitespace/operators"]
["src/nvim/undo.c", ["  // a pointer corresponding to the header with that sequence number.", "  short old_idx = -1, new_idx = -1, cur_idx = -1;", "  for (int i = 0; i < num_head; i++) {"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      old_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      new_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      cur_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["  xfree(uhp_table_used);", "  u_check(TRUE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["  if (curbuf->b_u_synced == false) {", "    u_sync(TRUE);", "    count = 1;"], "readability/bool"]
["src/nvim/undo.c", ["  if (vim_strchr(p_cpo, CPO_UNDO) == NULL)", "    undo_undoes = TRUE;", "  else"], "readability/bool"]
["src/nvim/undo.c", ["  if (vim_strchr(p_cpo, CPO_UNDO) == NULL)", "    undo_undoes = FALSE;", "  u_doit(count);"], "readability/bool"]
["src/nvim/undo.c", ["", "      u_undoredo(TRUE);", "    } else {"], "readability/bool"]
["src/nvim/undo.c", ["", "      u_undoredo(FALSE);", ""], "readability/bool"]
["src/nvim/undo.c", ["  }", "  u_undo_end(undo_undoes, FALSE);", "}"], "readability/bool"]
["src/nvim/undo.c", ["  int dofile = file;", "  int above = FALSE;", "  int did_undo = TRUE;"], "readability/bool"]
["src/nvim/undo.c", ["  int above = FALSE;", "  int did_undo = TRUE;", ""], "readability/bool"]
["src/nvim/undo.c", ["  if (curbuf->b_u_synced == false)", "    u_sync(TRUE);", ""], "readability/bool"]
["src/nvim/undo.c", ["           * the sequence number for that. */", "          dofile = FALSE;", "      } else {"], "readability/bool"]
["src/nvim/undo.c", ["          target = curbuf->b_u_seq_last + 1;", "          dofile = FALSE;", "        }"], "readability/bool"]
["src/nvim/undo.c", ["      }", "    } else", "      target = curbuf->b_u_seq_cur + step;"], "readability/braces"]
["src/nvim/undo.c", ["    target = closest_seq;", "    dosec = FALSE;", "    dofile = FALSE;"], "readability/bool"]
["src/nvim/undo.c", ["    dosec = FALSE;", "    dofile = FALSE;", "    if (step < 0)"], "readability/bool"]
["src/nvim/undo.c", ["    if (step < 0)", "      above = TRUE;             /* stop above the header */", "  }"], "readability/bool"]
["src/nvim/undo.c", ["      curbuf->b_u_curhead = uhp;", "      u_undoredo(TRUE);", "      uhp->uh_walk = nomark;            /* don't go back down here */"], "readability/bool"]
["src/nvim/undo.c", ["", "      u_undoredo(FALSE);", ""], "readability/bool"]
["src/nvim/undo.c", ["      curbuf->b_u_curhead = uhp->uh_prev.ptr;", "      did_undo = FALSE;", ""], "readability/bool"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "    empty_buffer = FALSE;", ""], "readability/bool"]
["src/nvim/undo.c", ["        if (curbuf->b_ml.ml_line_count == 1)", "          empty_buffer = TRUE;", "        ml_delete(lnum, FALSE);"], "readability/bool"]
["src/nvim/undo.c", ["          empty_buffer = TRUE;", "        ml_delete(lnum, FALSE);", "      }"], "readability/bool"]
["src/nvim/undo.c", ["      }", "    } else", "      newarray = NULL;"], "readability/braces"]
["src/nvim/undo.c", ["        if (empty_buffer && lnum == 0)", "          ml_replace((linenr_T)1, uep->ue_array[i], TRUE);", "        else"], "readability/bool"]
["src/nvim/undo.c", ["        else", "          ml_append(lnum, uep->ue_array[i], (colnr_T)0, FALSE);", "        xfree(uep->ue_array[i]);"], "readability/bool"]
["src/nvim/undo.c", ["  else", "    unchanged(curbuf, FALSE);", ""], "readability/bool"]
["src/nvim/undo.c", ["        curwin->w_cursor.coladd = 0;", "    } else", "      beginline(BL_SOL | BL_FIX);"], "readability/braces"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", [" */", "static void ", "u_undo_end ("], "whitespace/end_of_line"]
["src/nvim/undo.c", ["static void ", "u_undo_end (", "    int did_undo,                   /* just did an undo */"], "whitespace/parens"]
["src/nvim/undo.c", ["    msgstr = N_(\"fewer lines\");", "  else {", "    u_oldcount = u_newcount;"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = curbuf->b_u_curhead->uh_next.ptr;", "      did_undo = FALSE;", "    } else if (did_undo)"], "readability/bool"]
["src/nvim/undo.c", ["      did_undo = FALSE;", "    } else if (did_undo)", "      uhp = curbuf->b_u_curhead;"], "readability/braces"]
["src/nvim/undo.c", ["      uhp = curbuf->b_u_curhead->uh_next.ptr;", "  } else", "    uhp = curbuf->b_u_newhead;"], "readability/braces"]
["src/nvim/undo.c", [" */", "void ", "u_sync ("], "whitespace/end_of_line"]
["src/nvim/undo.c", ["void ", "u_sync (", "    int force              /* Also sync when no_u_sync is set. */"], "whitespace/parens"]
["src/nvim/undo.c", ["    curbuf->b_u_synced = true;      /* no entries, nothing to do */", "  else {", "    u_getbot();                     /* compute ue_bot of previous u_save */"], "readability/braces"]
["src/nvim/undo.c", ["    /* go to alternate branch if we haven't been there */", "    else if (uhp->uh_alt_next.ptr != NULL", "             && uhp->uh_alt_next.ptr->uh_walk != nomark"], "whitespace/newline"]
["src/nvim/undo.c", ["        uhp = uhp->uh_alt_prev.ptr;", "      else {", "        uhp = uhp->uh_next.ptr;"], "readability/braces"]
["src/nvim/undo.c", ["    MSG(_(\"Nothing to undo\"));", "  else {", "    sort_strings((char_u **)ga.ga_data, ga.ga_len);"], "readability/braces"]
["src/nvim/undo.c", ["      (void)strftime((char *)buf, buflen, \"%Y/%m/%d %H:%M:%S\", &curtime);", "  } else", "  vim_snprintf((char *)buf, buflen, _(\"%\" PRId64 \" seconds ago\"),"], "readability/braces"]
["src/nvim/undo.c", ["    return;                 /* no entries, nothing to do */", "  else {", "    /* Go back to the last entry */"], "readability/braces"]
["src/nvim/undo.c", ["       && lnum <= uep->ue_size; ++lnum)", "    if (STRCMP(ml_get_buf(curbuf, lnum, FALSE),", "            uep->ue_array[lnum - 1]) != 0) {"], "readability/bool"]
["src/nvim/undo.c", ["      EMSG(_(\"E440: undo line missing\"));", "      uep->ue_bot = uep->ue_top + 1;        /* assume all lines deleted, will", "                                             * get all the old lines back"], "readability/multiline_comment"]
["src/nvim/undo.c", [" */", "static void ", "u_freeheader ("], "whitespace/end_of_line"]
["src/nvim/undo.c", ["static void ", "u_freeheader (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/undo.c", [" */", "static void ", "u_freebranch ("], "whitespace/end_of_line"]
["src/nvim/undo.c", ["static void ", "u_freebranch (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/undo.c", [" */", "static void ", "u_freeentries ("], "whitespace/end_of_line"]
["src/nvim/undo.c", ["static void ", "u_freeentries (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/undo.c", ["  if (u_savecommon(curbuf->b_u_line_lnum - 1,", "          curbuf->b_u_line_lnum + 1, (linenr_T)0, FALSE) == FAIL)", "    return;"], "readability/bool"]
["src/nvim/undo.c", ["  oldp = u_save_line(curbuf->b_u_line_lnum);", "  ml_replace(curbuf->b_u_line_lnum, curbuf->b_u_line_ptr, TRUE);", "  changed_bytes(curbuf->b_u_line_lnum, 0);"], "readability/bool"]
["src/nvim/version.c", ["    if (included_patches[i] == n) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/version.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/version.c", ["      && (vim_strchr(p_shm, SHM_INTRO) == NULL)) {", "    intro_message(FALSE);", "  }"], "readability/bool"]
["src/nvim/version.c", ["    assert(row <= INT_MAX && col <= INT_MAX);", "    screen_puts_len(p, l, (int)row, (int)col, *p == '<' ? hl_attr(HLF_8) : attr);", "    col += clen;"], "whitespace/line_length"]
["src/nvim/version.c", ["  screenclear();", "  intro_message(TRUE);", "  wait_return(TRUE);"], "readability/bool"]
["src/nvim/version.c", ["  intro_message(TRUE);", "  wait_return(TRUE);", "}"], "readability/bool"]
["src/nvim/window.c", [" */", "void ", "do_window ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "do_window (", "    int nchar,"], "whitespace/parens"]
["src/nvim/window.c", ["", "# define CHECK_CMDWIN if (cmdwin_type != 0) { EMSG(_(e_cmdwin)); break; }", ""], "whitespace/newline"]
["src/nvim/window.c", ["    if (nchar == 'v' || nchar == Ctrl_V)", "      strcat(cbuf, \"v\");", "    strcat(cbuf, \"new\");"], "runtime/printf"]
["src/nvim/window.c", ["      strcat(cbuf, \"v\");", "    strcat(cbuf, \"new\");", "    do_cmdline_cmd(cbuf);"], "runtime/printf"]
["src/nvim/window.c", ["      beep_flush();", "    else {", "      if (Prenum) {                             /* go to specified window */"], "readability/braces"]
["src/nvim/window.c", ["  case Ctrl_J:", "    CHECK_CMDWIN win_goto_ver(FALSE, Prenum1);", "    break;"], "readability/bool"]
["src/nvim/window.c", ["  case Ctrl_K:", "    CHECK_CMDWIN win_goto_ver(TRUE, Prenum1);", "    break;"], "readability/bool"]
["src/nvim/window.c", ["  case K_BS:", "    CHECK_CMDWIN win_goto_hor(TRUE, Prenum1);", "    break;"], "readability/bool"]
["src/nvim/window.c", ["  case Ctrl_L:", "    CHECK_CMDWIN win_goto_hor(FALSE, Prenum1);", "    break;"], "readability/bool"]
["src/nvim/window.c", ["      MSG(_(m_onlyone));", "    else {", "      tabpage_T   *oldtab = curtab;"], "readability/braces"]
["src/nvim/window.c", ["        newtab = curtab;", "        goto_tabpage_tp(oldtab, TRUE, TRUE);", "        if (curwin == wp)"], "readability/bool"]
["src/nvim/window.c", ["        if (curwin == wp)", "          win_close(curwin, FALSE);", "        if (valid_tabpage(newtab))"], "readability/bool"]
["src/nvim/window.c", ["        if (valid_tabpage(newtab))", "          goto_tabpage_tp(newtab, TRUE, TRUE);", "      }"], "readability/bool"]
["src/nvim/window.c", ["    CHECK_CMDWIN reset_VIsual_and_resel();      /* stop Visual mode */", "    win_rotate(FALSE, (int)Prenum1);                /* downwards */", "    break;"], "readability/bool"]
["src/nvim/window.c", ["    CHECK_CMDWIN reset_VIsual_and_resel();      /* stop Visual mode */", "    win_rotate(TRUE, (int)Prenum1);                 /* upwards */", "    break;"], "readability/bool"]
["src/nvim/window.c", ["      break;", "    find_pattern_in_path(ptr, 0, len, TRUE,", "                         Prenum == 0 ? TRUE : FALSE,"], "readability/bool"]
["src/nvim/window.c", ["    find_pattern_in_path(ptr, 0, len, TRUE,", "                         Prenum == 0 ? TRUE : FALSE,", "                         type, Prenum1, ACTION_SPLIT, 1, MAXLNUM);"], "readability/bool"]
["src/nvim/window.c", ["                         type, Prenum1, ACTION_SPLIT, 1, MAXLNUM);", "    curwin->w_set_curswant = TRUE;", "    break;"], "readability/bool"]
["src/nvim/window.c", ["    if (bt_quickfix(curbuf)) {", "      sprintf(cbuf, \"split +%\" PRId64 \"%s\",", "              (int64_t)curwin->w_cursor.lnum,"], "runtime/printf"]
["src/nvim/window.c", ["    CHECK_CMDWIN", "    ++ no_mapping;", "    ++allow_keys;               /* no mapping for xchar, but allow key codes */"], "whitespace/operators"]
["src/nvim/window.c", ["      xchar = plain_vgetc();", "    LANGMAP_ADJUST(xchar, TRUE);", "    --no_mapping;"], "readability/bool"]
["src/nvim/window.c", ["  int need_status = 0;", "  int do_equal = FALSE;", "  int needed;"], "readability/bool"]
["src/nvim/window.c", ["    if (oldwin->w_width - new_size - 1 < p_wmw)", "      do_equal = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["                                          - new_size - 1)) {", "          do_equal = TRUE;", "          break;"], "readability/bool"]
["src/nvim/window.c", ["    if (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)", "      do_equal = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["                - STATUS_HEIGHT)) {", "          do_equal = TRUE;", "          break;"], "readability/bool"]
["src/nvim/window.c", ["    if (new_wp == NULL)", "      wp = win_alloc(oldwin, FALSE);", "    else"], "readability/bool"]
["src/nvim/window.c", ["    if (new_wp == NULL)", "      wp = win_alloc(oldwin->w_prev, FALSE);", "    else"], "readability/bool"]
["src/nvim/window.c", ["          curfrp = curfrp->fr_next;", "    } else", "      curfrp = topframe;"], "readability/braces"]
["src/nvim/window.c", ["    if (flags & WSP_BELOW)", "      before = FALSE;", "    else if (flags & WSP_ABOVE)"], "readability/bool"]
["src/nvim/window.c", ["    else if (flags & WSP_ABOVE)", "      before = TRUE;", "    else if (flags & WSP_VERT)"], "readability/bool"]
["src/nvim/window.c", ["      wp->w_vsep_width = 1;", "    else {", "      wp->w_vsep_width = oldwin->w_vsep_width;"], "readability/braces"]
["src/nvim/window.c", ["          - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,", "          FALSE);", "    } else"], "readability/bool"]
["src/nvim/window.c", ["          FALSE);", "    } else", "      win_new_width(oldwin, oldwin->w_width - (new_size + 1));"], "readability/braces"]
["src/nvim/window.c", ["      oldwin->w_wincol += new_size + 1;", "    } else              /* new window right of current one */", "      wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;"], "readability/braces"]
["src/nvim/window.c", ["      frame_new_height(curfrp, curfrp->fr_height", "          - (new_size + STATUS_HEIGHT), flags & WSP_TOP, FALSE);", "    else"], "readability/bool"]
["src/nvim/window.c", ["  redraw_win_later(wp, NOT_VALID);", "  wp->w_redr_status = TRUE;", "  redraw_win_later(oldwin, NOT_VALID);"], "readability/bool"]
["src/nvim/window.c", ["  redraw_win_later(oldwin, NOT_VALID);", "  oldwin->w_redr_status = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["    newp->w_llist_ref = NULL;", "  } else", "    copy_loclist(oldp, newp);"], "readability/braces"]
["src/nvim/window.c", ["  if (win == NULL)", "    return FALSE;", "  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {"], "readability/bool"]
["src/nvim/window.c", ["    if (wp == win) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/window.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/window.c", [" */", "int ", "make_windows ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["int ", "make_windows (", "    int count,"], "whitespace/parens"]
["src/nvim/window.c", ["  if (count > 1)", "    last_status(TRUE);", ""], "readability/bool"]
["src/nvim/window.c", ["      frp = frp->fr_next;", "  } else if (curwin->w_frame->fr_next != NULL)  /* Swap with next */", "    frp = curwin->w_frame->fr_next;"], "readability/braces"]
["src/nvim/window.c", ["      for (; frp->fr_next != NULL; frp = frp->fr_next)", "        ;", "      win_append(frp->fr_win, wp1);"], "whitespace/semicolon"]
["src/nvim/window.c", ["           frp = frp->fr_next)", "        ;", "      wp1 = frp->fr_win;"], "whitespace/semicolon"]
["src/nvim/window.c", ["  win_remove(curwin, NULL);", "  last_status(FALSE);       /* may need to remove last status line */", "  (void)win_comp_pos();     /* recompute window positions */"], "readability/bool"]
["src/nvim/window.c", ["  }", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["      topfr->fr_win->w_winrow = row;", "      frame_new_height(topfr, height, FALSE, FALSE);", "      topfr->fr_win->w_wincol = col;"], "readability/bool"]
["src/nvim/window.c", ["      topfr->fr_win->w_wincol = col;", "      frame_new_width(topfr, width, FALSE, FALSE);", "      redraw_all_later(CLEAR);"], "readability/bool"]
["src/nvim/window.c", ["              new_size = p_wiw;", "          } else", "            /* These windows don't use up room. */"], "readability/braces"]
["src/nvim/window.c", ["            room -= next_curwin_size - p_wiw;", "          } else", "            next_curwin_size = p_wiw;"], "readability/braces"]
["src/nvim/window.c", ["        else", "          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */"], "readability/bool"]
["src/nvim/window.c", ["          room -= new_size - next_curwin_size;", "        } else", "          room -= new_size;"], "readability/braces"]
["src/nvim/window.c", ["              new_size = p_wh;", "          } else", "            /* These windows don't use up room. */"], "readability/braces"]
["src/nvim/window.c", ["            room -= next_curwin_size - p_wh;", "          } else", "            next_curwin_size = p_wh;"], "readability/braces"]
["src/nvim/window.c", ["        else", "          hnc = FALSE;", "        if (hnc)                    /* don't count next_curwin */"], "readability/bool"]
["src/nvim/window.c", ["          room -= new_size - next_curwin_size;", "        } else", "          room -= new_size;"], "readability/braces"]
["src/nvim/window.c", [" */", "void ", "close_windows ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "close_windows (", "    buf_T *buf,"], "whitespace/parens"]
["src/nvim/window.c", ["        ) {", "      win_close(wp, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["      wp = firstwin;", "    } else", "      wp = wp->w_next;"], "readability/braces"]
["src/nvim/window.c", ["            ) {", "          win_close_othertab(wp, FALSE, tp);", ""], "readability/bool"]
["src/nvim/window.c", ["", "  redraw_tabline = TRUE;", "  if (h != tabline_height())"], "readability/bool"]
["src/nvim/window.c", [" */", "static int close_last_window_tabpage(win_T *win, int free_buf, tabpage_T *prev_curtab)", "{"], "whitespace/line_length"]
["src/nvim/window.c", ["  if (firstwin != lastwin) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/window.c", ["   */", "  goto_tabpage_tp(alt_tabpage(), FALSE, TRUE);", "  redraw_tabline = TRUE;"], "readability/bool"]
["src/nvim/window.c", ["  goto_tabpage_tp(alt_tabpage(), FALSE, TRUE);", "  redraw_tabline = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["  char_u prev_idx[NUMBUFLEN];", "  sprintf((char *)prev_idx, \"%i\", tabpage_index(prev_curtab));", ""], "runtime/printf"]
["src/nvim/window.c", ["   * that now. */", "  apply_autocmds(EVENT_TABCLOSED, prev_idx, prev_idx, FALSE, curbuf);", "  apply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);"], "readability/bool"]
["src/nvim/window.c", ["  apply_autocmds(EVENT_TABCLOSED, prev_idx, prev_idx, FALSE, curbuf);", "  apply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);", "  apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);"], "readability/bool"]
["src/nvim/window.c", ["  apply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);", "  apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);", "  if (old_curbuf != curbuf)"], "readability/bool"]
["src/nvim/window.c", ["  if (old_curbuf != curbuf)", "    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);", "  return TRUE;"], "readability/bool"]
["src/nvim/window.c", ["    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/window.c", ["  win_T       *wp;", "  int other_buffer = FALSE;", "  int close_curwin = FALSE;"], "readability/bool"]
["src/nvim/window.c", ["  int other_buffer = FALSE;", "  int close_curwin = FALSE;", "  int dir;"], "readability/bool"]
["src/nvim/window.c", ["  int dir;", "  int help_window = FALSE;", "  tabpage_T   *prev_curtab = curtab;"], "readability/bool"]
["src/nvim/window.c", ["  if (win->w_buffer != NULL && win->w_buffer->b_help)", "    help_window = TRUE;", "  else"], "readability/bool"]
["src/nvim/window.c", ["    if (wp->w_buffer != curbuf) {", "      other_buffer = TRUE;", "      win->w_closing = true;"], "readability/bool"]
["src/nvim/window.c", ["      win->w_closing = true;", "      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      if (!win_valid(win))"], "readability/bool"]
["src/nvim/window.c", ["    win->w_closing = true;", "    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);", "    if (!win_valid(win))"], "readability/bool"]
["src/nvim/window.c", ["    win->w_closing = true;", "    close_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0, TRUE);", "    if (win_valid(win))"], "readability/bool"]
["src/nvim/window.c", ["   * other window or moved to another tab page. */", "  else if (!win_valid(win) || last_window() || curtab != prev_curtab", "           || close_last_window_tabpage(win, free_buf, prev_curtab))"], "whitespace/newline"]
["src/nvim/window.c", ["    curbuf = curwin->w_buffer;", "    close_curwin = TRUE;", "  }"], "readability/bool"]
["src/nvim/window.c", ["  if (close_curwin) {", "    win_enter_ext(wp, false, TRUE, TRUE, TRUE);", "    if (other_buffer)"], "readability/bool"]
["src/nvim/window.c", ["      /* careful: after this wp and win may be invalid! */", "      apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/window.c", ["   */", "  last_status(FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["  tabpage_T   *ptp = NULL;", "  int free_tp = FALSE;", ""], "readability/bool"]
["src/nvim/window.c", ["  /* Close the link to the buffer. */", "  close_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["  for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)", "    ;", "  if (ptp == NULL || tp == curtab)"], "whitespace/semicolon"]
["src/nvim/window.c", ["      first_tabpage = tp->tp_next;", "    else {", "      for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;"], "readability/braces"]
["src/nvim/window.c", ["           ptp = ptp->tp_next)", "        ;", "      if (ptp == NULL) {"], "whitespace/semicolon"]
["src/nvim/window.c", ["    }", "    free_tp = TRUE;", "  }"], "readability/bool"]
["src/nvim/window.c", ["static win_T *", "win_free_mem (", "    win_T *win,"], "whitespace/parens"]
["src/nvim/window.c", ["  while (first_tabpage->tp_next != NULL)", "    tabpage_close(TRUE);", ""], "readability/bool"]
["src/nvim/window.c", ["win_T *", "winframe_remove (", "    win_T *win,"], "whitespace/parens"]
["src/nvim/window.c", ["    frame_new_height(frp2, frp2->fr_height + frp_close->fr_height,", "        frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);", "    *dirp = 'v';"], "readability/bool"]
["src/nvim/window.c", ["    frame_new_width(frp2, frp2->fr_width + frp_close->fr_width,", "        frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);", "    *dirp = 'h';"], "readability/bool"]
["src/nvim/window.c", ["static frame_T *", "win_altframe (", "    win_T *win,"], "whitespace/parens"]
["src/nvim/window.c", ["  for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)", "    ;", "  return tp;"], "whitespace/semicolon"]
["src/nvim/window.c", ["    if (frame_has_win(p, wp))", "      return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/window.c", ["      return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/window.c", [" */", "static void ", "frame_new_height ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static void ", "frame_new_height (", "    frame_T *topfrp,"], "whitespace/parens"]
["src/nvim/window.c", ["    int topfirst,                   /* resize topmost contained frame first */", "    int wfh                        /* obey 'winfixheight' when there is a choice;", "                                   may cause the height not to be set */"], "readability/multiline_comment"]
["src/nvim/window.c", ["    int topfirst,                   /* resize topmost contained frame first */", "    int wfh                        /* obey 'winfixheight' when there is a choice;", "                                   may cause the height not to be set */"], "whitespace/line_length"]
["src/nvim/window.c", ["            frp = frp->fr_next;", "          while (wfh && frp != NULL && frame_fixed_height(frp));", "        } else {"], "whitespace/empty_loop_body"]
["src/nvim/window.c", ["            frp = frp->fr_prev;", "          while (wfh && frp != NULL && frame_fixed_height(frp));", "        }"], "whitespace/empty_loop_body"]
["src/nvim/window.c", ["      if (frame_fixed_height(frp))", "        return TRUE;", "    return FALSE;"], "readability/bool"]
["src/nvim/window.c", ["        return TRUE;", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/window.c", ["    if (!frame_fixed_height(frp))", "      return FALSE;", "  return TRUE;"], "readability/bool"]
["src/nvim/window.c", ["      return FALSE;", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/window.c", ["      if (frame_fixed_width(frp))", "        return TRUE;", "    return FALSE;"], "readability/bool"]
["src/nvim/window.c", ["        return TRUE;", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/window.c", ["    if (!frame_fixed_width(frp))", "      return FALSE;", "  return TRUE;"], "readability/bool"]
["src/nvim/window.c", ["      return FALSE;", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/window.c", ["    for (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)", "      ;", "    frame_add_statusline(frp);"], "whitespace/semicolon"]
["src/nvim/window.c", [" */", "static void ", "frame_new_width ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static void ", "frame_new_width (", "    frame_T *topfrp,"], "whitespace/parens"]
["src/nvim/window.c", ["    int leftfirst,                  /* resize leftmost contained frame first */", "    int wfw                        /* obey 'winfixwidth' when there is a choice;", "                                   may cause the width not to be set */"], "readability/multiline_comment"]
["src/nvim/window.c", ["            frp = frp->fr_next;", "          while (wfw && frp != NULL && frame_fixed_width(frp));", "        } else {"], "whitespace/empty_loop_body"]
["src/nvim/window.c", ["            frp = frp->fr_prev;", "          while (wfw && frp != NULL && frame_fixed_width(frp));", "        }"], "whitespace/empty_loop_body"]
["src/nvim/window.c", ["      m = p_wh + topfrp->fr_win->w_status_height;", "    else {", "      /* window: minimal height of the window plus status line */"], "readability/braces"]
["src/nvim/window.c", [" */", "static int ", "frame_minwidth ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static int ", "frame_minwidth (", "    frame_T *topfrp,"], "whitespace/parens"]
["src/nvim/window.c", ["      m = p_wiw + topfrp->fr_win->w_vsep_width;", "    else {", "      /* window: minimal width of the window plus separator column */"], "readability/braces"]
["src/nvim/window.c", [" */", "void ", "close_others ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "close_others (", "    int message,"], "whitespace/parens"]
["src/nvim/window.c", ["      if (message && (p_confirm || cmdmod.confirm) && p_write) {", "        dialog_changed(wp->w_buffer, FALSE);", "        if (!win_valid(wp)) {                 /* autocommands messed wp up */"], "readability/bool"]
["src/nvim/window.c", ["{", "  aucmd_win = win_alloc(NULL, TRUE);", "  win_init_some(aucmd_win, curwin);"], "readability/bool"]
["src/nvim/window.c", ["{", "  curwin = win_alloc(NULL, FALSE);", "  if (oldwin == NULL) {"], "readability/bool"]
["src/nvim/window.c", ["  init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);", "  tp->tp_diff_invalid = TRUE;", "  tp->tp_ch_used = p_ch;"], "readability/bool"]
["src/nvim/window.c", ["  /* Remember the current windows in this Tab page. */", "  if (leave_tabpage(curbuf, TRUE) == FAIL) {", "    xfree(newtp);"], "readability/bool"]
["src/nvim/window.c", ["    newtp->tp_topframe = topframe;", "    last_status(FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["    redraw_all_later(CLEAR);", "    apply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);", "    apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);"], "readability/bool"]
["src/nvim/window.c", ["    apply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);", "    apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);", "    return OK;"], "readability/bool"]
["src/nvim/window.c", ["  /* Failed, get back the previous Tab page */", "  enter_tabpage(curtab, curbuf, TRUE, TRUE);", "  return FAIL;"], "readability/bool"]
["src/nvim/window.c", [" */", "static int ", "leave_tabpage ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static int ", "leave_tabpage (", "    buf_T *new_curbuf,        /* what is going to be the new curbuf,"], "whitespace/parens"]
["src/nvim/window.c", ["leave_tabpage (", "    buf_T *new_curbuf,        /* what is going to be the new curbuf,", "                                          NULL if unknown */"], "readability/multiline_comment"]
["src/nvim/window.c", ["    if (new_curbuf != curbuf) {", "      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      if (curtab != tp)"], "readability/bool"]
["src/nvim/window.c", ["    }", "    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);", "    if (curtab != tp)"], "readability/bool"]
["src/nvim/window.c", ["      return FAIL;", "    apply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);", "    if (curtab != tp)"], "readability/bool"]
["src/nvim/window.c", [" */", "static void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds)", "{"], "whitespace/line_length"]
["src/nvim/window.c", ["   * This triggers autocommands, thus may make \"tp\" invalid. */", "  win_enter_ext(tp->tp_curwin, false, TRUE,", "      trigger_enter_autocmds, trigger_leave_autocmds);"], "readability/bool"]
["src/nvim/window.c", ["", "  last_status(FALSE);           /* status line may appear or disappear */", "  (void)win_comp_pos();         /* recompute w_winrow for all windows */"], "readability/bool"]
["src/nvim/window.c", ["  must_redraw = CLEAR;          /* need to redraw everything */", "  diff_need_scrollbind = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["  if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow", "                                      ))", "    shell_new_rows();"], "whitespace/parens"]
["src/nvim/window.c", ["  if (trigger_enter_autocmds) {", "    apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);", "    if (old_curbuf != curbuf)"], "readability/bool"]
["src/nvim/window.c", ["    if (old_curbuf != curbuf)", "      apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/window.c", ["           tp = tp->tp_next)", "        ;", "      ttp = tp;"], "whitespace/semicolon"]
["src/nvim/window.c", ["    for (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)", "      ;", "  } else {"], "whitespace/semicolon"]
["src/nvim/window.c", ["", "  goto_tabpage_tp(tp, TRUE, TRUE);", ""], "readability/bool"]
["src/nvim/window.c", ["  goto_tabpage_tp(tp, TRUE, TRUE);", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", [" */", "void goto_tabpage_tp(tabpage_T *tp, int trigger_enter_autocmds, int trigger_leave_autocmds)", "{"], "whitespace/line_length"]
["src/nvim/window.c", ["{", "  goto_tabpage_tp(tp, TRUE, TRUE);", "  if (curtab == tp && win_valid(wp)) {"], "readability/bool"]
["src/nvim/window.c", ["    first_tabpage = curtab->tp_next;", "  else {", "    for (tp = first_tabpage; tp != NULL; tp = tp->tp_next)"], "readability/braces"]
["src/nvim/window.c", ["  /* Need to redraw the tabline.  Tab page contents doesn't change. */", "  redraw_tabline = TRUE;", "}"], "readability/bool"]
["src/nvim/window.c", ["  if (curwin->w_p_cole > 0 && !msg_scrolled)", "    need_cursor_line_redraw = TRUE;", "}"], "readability/bool"]
["src/nvim/window.c", [" */", "static void ", "win_goto_ver ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static void ", "win_goto_ver (", "    int up,                         /* TRUE to go to win above */"], "whitespace/parens"]
["src/nvim/window.c", [" */", "static void ", "win_goto_hor ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static void ", "win_goto_hor (", "    int left,                       /* TRUE to go to left win */"], "whitespace/parens"]
["src/nvim/window.c", ["{", "  win_enter_ext(wp, undo_sync, FALSE, TRUE, TRUE);", "}"], "readability/bool"]
["src/nvim/window.c", [" */", "static void win_enter_ext(win_T *wp, bool undo_sync, int curwin_invalid, int trigger_enter_autocmds, int trigger_leave_autocmds)", "{"], "whitespace/line_length"]
["src/nvim/window.c", ["{", "  int other_buffer = FALSE;", ""], "readability/bool"]
["src/nvim/window.c", ["    if (wp->w_buffer != curbuf) {", "      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      other_buffer = TRUE;"], "readability/bool"]
["src/nvim/window.c", ["      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);", "      other_buffer = TRUE;", "      if (!win_valid(wp))"], "readability/bool"]
["src/nvim/window.c", ["    }", "    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);", "    if (!win_valid(wp))"], "readability/bool"]
["src/nvim/window.c", ["  if (undo_sync && curbuf != wp->w_buffer) {", "    u_sync(FALSE);", "  }"], "readability/bool"]
["src/nvim/window.c", ["    prevwin = curwin;           /* remember for CTRL-W p */", "    curwin->w_redr_status = TRUE;", "  }"], "readability/bool"]
["src/nvim/window.c", ["    if (os_chdir((char *)curwin->w_localdir) == 0)", "      shorten_fnames(TRUE);", "  } else if (globaldir != NULL) {"], "readability/bool"]
["src/nvim/window.c", ["    globaldir = NULL;", "    shorten_fnames(TRUE);", "  }"], "readability/bool"]
["src/nvim/window.c", ["  if (trigger_enter_autocmds) {", "    apply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);", "    if (other_buffer)"], "readability/bool"]
["src/nvim/window.c", ["    if (other_buffer)", "      apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);", "  }"], "readability/bool"]
["src/nvim/window.c", ["  maketitle();", "  curwin->w_redr_status = TRUE;", "  redraw_tabline = TRUE;"], "readability/bool"]
["src/nvim/window.c", ["  curwin->w_redr_status = TRUE;", "  redraw_tabline = TRUE;", "  if (restart_edit)"], "readability/bool"]
["src/nvim/window.c", ["{", "", "  // First try the current tab page."], "whitespace/blank_line"]
["src/nvim/window.c", [" */", "static void ", "win_free ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["static void ", "win_free (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/window.c", [" */", "void ", "win_remove ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "win_remove (", "    win_T *wp,"], "whitespace/parens"]
["src/nvim/window.c", ["{", "  // TODO: why would wp be NULL here?", "  if (wp != NULL) {"], "readability/todo"]
["src/nvim/window.c", ["   * that doesn't result in the right height, forget about that option. */", "  frame_new_height(topframe, h, FALSE, TRUE);", "  if (!frame_check_height(topframe, h))"], "readability/bool"]
["src/nvim/window.c", ["  if (!frame_check_height(topframe, h))", "    frame_new_height(topframe, h, FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["  curtab->tp_ch_used = p_ch;", "", "}"], "whitespace/blank_line"]
["src/nvim/window.c", ["   * doesn't result in the right width, forget about that option. */", "  frame_new_width(topframe, (int)Columns, FALSE, TRUE);", "  if (!frame_check_width(topframe, Columns))"], "readability/bool"]
["src/nvim/window.c", ["  if (!frame_check_width(topframe, Columns))", "    frame_new_width(topframe, (int)Columns, FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["      redraw_win_later(wp, NOT_VALID);", "      wp->w_redr_status = TRUE;", "    }"], "readability/bool"]
["src/nvim/window.c", ["    if (height > 0)", "      frame_new_height(curfrp, height, FALSE, FALSE);", "  } else if (curfrp->fr_parent->fr_layout == FR_ROW) {"], "readability/bool"]
["src/nvim/window.c", ["        room_cmdline = 0;", "      else {", "        room_cmdline = Rows - p_ch - (lastwin->w_winrow"], "readability/braces"]
["src/nvim/window.c", ["     */", "    frame_new_height(curfrp, height, FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["            room_reserved -= frp->fr_height;", "          else {", "            if (frp->fr_height - room_reserved > take)"], "readability/braces"]
["src/nvim/window.c", ["            take -= frp->fr_height - room_reserved;", "            frame_new_height(frp, room_reserved, FALSE, FALSE);", "            room_reserved = 0;"], "readability/bool"]
["src/nvim/window.c", ["            take -= frp->fr_height - h;", "            frame_new_height(frp, h, FALSE, FALSE);", "          } else {"], "readability/bool"]
["src/nvim/window.c", ["            frame_new_height(frp, frp->fr_height - take,", "                FALSE, FALSE);", "            take = 0;"], "readability/bool"]
["src/nvim/window.c", ["     */", "    frame_new_width(curfrp, width, FALSE, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["            room_reserved -= frp->fr_width;", "          else {", "            if (frp->fr_width - room_reserved > take)"], "readability/braces"]
["src/nvim/window.c", ["            take -= frp->fr_width - room_reserved;", "            frame_new_width(frp, room_reserved, FALSE, FALSE);", "            room_reserved = 0;"], "readability/bool"]
["src/nvim/window.c", ["            take -= frp->fr_width - w;", "            frame_new_width(frp, w, FALSE, FALSE);", "          } else {"], "readability/bool"]
["src/nvim/window.c", ["            frame_new_width(frp, frp->fr_width - take,", "                FALSE, FALSE);", "            take = 0;"], "readability/bool"]
["src/nvim/window.c", ["  int room;", "  int first = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["      EMSG(_(e_noroom));", "      first = FALSE;", "    }"], "readability/bool"]
["src/nvim/window.c", ["  if (offset < 0) { /* drag up */", "    up = TRUE;", "    offset = -offset;"], "readability/bool"]
["src/nvim/window.c", ["  } else { /* drag down */", "    up = FALSE;", "    /*"], "readability/bool"]
["src/nvim/window.c", ["  if (fr != NULL)", "    frame_new_height(fr, fr->fr_height + offset, up, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["      offset -= fr->fr_height - n;", "      frame_new_height(fr, n, !up, FALSE);", "    } else {"], "readability/bool"]
["src/nvim/window.c", ["    } else {", "      frame_new_height(fr, fr->fr_height - offset, !up, FALSE);", "      break;"], "readability/bool"]
["src/nvim/window.c", ["  if (offset < 0) { /* drag left */", "    left = TRUE;", "    offset = -offset;"], "readability/bool"]
["src/nvim/window.c", ["  } else { /* drag right */", "    left = FALSE;", "    /* sum up the room of frames right of the current one */"], "readability/bool"]
["src/nvim/window.c", ["  /* grow frame fr by offset lines */", "  frame_new_width(fr, fr->fr_width + offset, left, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["      offset -= fr->fr_width - n;", "      frame_new_width(fr, n, !left, FALSE);", "    } else {"], "readability/bool"]
["src/nvim/window.c", ["    } else {", "      frame_new_width(fr, fr->fr_width - offset, !left, FALSE);", "      break;"], "readability/bool"]
["src/nvim/window.c", ["      /* Make sure the whole cursor line is visible, if possible. */", "      int rows = plines_win(wp, lnum, FALSE);", ""], "readability/bool"]
["src/nvim/window.c", ["        if (lnum == wp->w_topline)", "          line_size = plines_win_nofill(wp, lnum, TRUE)", "                      + wp->w_topfill;"], "readability/bool"]
["src/nvim/window.c", ["        else", "          line_size = plines_win(wp, lnum, TRUE);", "        sline -= line_size;"], "readability/bool"]
["src/nvim/window.c", ["      update_topline();", "    curs_columns(FALSE);        /* validate w_wrow */", "  }"], "readability/bool"]
["src/nvim/window.c", ["  redraw_win_later(wp, SOME_VALID);", "  wp->w_redr_status = TRUE;", "  invalidate_botline_win(wp);"], "readability/bool"]
["src/nvim/window.c", ["    update_topline();", "    curs_columns(TRUE);         /* validate w_wrow */", "  }"], "readability/bool"]
["src/nvim/window.c", ["  redraw_win_later(wp, NOT_VALID);", "  wp->w_redr_status = TRUE;", ""], "readability/bool"]
["src/nvim/window.c", ["      msg_row = cmdline_row;", "      redraw_cmdline = TRUE;", "      return;"], "readability/bool"]
["src/nvim/window.c", ["      msg_row = cmdline_row;", "    redraw_cmdline = TRUE;", "  }"], "readability/bool"]
["src/nvim/window.c", ["{", "  frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);", "  for (;; ) {"], "readability/bool"]
["src/nvim/window.c", ["char_u *", "file_name_in_line (", "    char_u *line,"], "whitespace/parens"]
["src/nvim/window.c", [" */", "void ", "last_status ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "last_status (", "    int morewin                    /* pretend there are two or more windows */"], "whitespace/parens"]
["src/nvim/window.c", ["  last_status_rec(topframe, (p_ls == 2", "                             || (p_ls == 1 && (morewin || lastwin != firstwin))));", "}"], "whitespace/line_length"]
["src/nvim/window.c", ["      if (fp != fr) {", "        frame_new_height(fp, fp->fr_height - 1, FALSE, FALSE);", "        frame_fix_height(wp);"], "readability/bool"]
["src/nvim/window.c", ["        (void)win_comp_pos();", "      } else", "        win_new_height(wp, wp->w_height - 1);"], "readability/braces"]
["src/nvim/window.c", ["    for (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)", "      ;", "    last_status_rec(fp, statusline);"], "whitespace/semicolon"]
["src/nvim/window.c", ["  if (first_tabpage->tp_next != NULL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/window.c", ["              || wp->w_p_pvw", "              ) || wp == curwin)", "        && wp != aucmd_win"], "whitespace/parens"]
["src/nvim/window.c", [" */", "void ", "restore_snapshot ("], "whitespace/end_of_line"]
["src/nvim/window.c", ["void ", "restore_snapshot (", "    int idx,"], "whitespace/parens"]
["src/nvim/window.c", ["  if (fr->fr_layout == FR_LEAF) {", "    frame_new_height(fr, fr->fr_height, FALSE, FALSE);", "    frame_new_width(fr, fr->fr_width, FALSE, FALSE);"], "readability/bool"]
["src/nvim/window.c", ["    frame_new_height(fr, fr->fr_height, FALSE, FALSE);", "    frame_new_width(fr, fr->fr_width, FALSE, FALSE);", "    wp = sn->fr_win;"], "readability/bool"]
["src/nvim/window.c", [" */", "int switch_win(win_T **save_curwin, tabpage_T **save_curtab, win_T *win, tabpage_T *tp, int no_display)", "{"], "whitespace/line_length"]
["src/nvim/window.c", ["      lastwin = curtab->tp_lastwin;", "    } else", "      goto_tabpage_tp(tp, FALSE, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["    } else", "      goto_tabpage_tp(tp, FALSE, FALSE);", "  }"], "readability/bool"]
["src/nvim/window.c", ["      lastwin = curtab->tp_lastwin;", "    } else", "      goto_tabpage_tp(save_curtab, FALSE, FALSE);"], "readability/braces"]
["src/nvim/window.c", ["    } else", "      goto_tabpage_tp(save_curtab, FALSE, FALSE);", "  }"], "readability/bool"]
["src/nvim/window.c", [" */", "int match_add(win_T *wp, char_u *grp, char_u *pat, int prio, int id, list_T *pos_list)", "{"], "whitespace/line_length"]
["src/nvim/window.c", ["  m->match.regprog = regprog;", "  m->match.rmm_ic = FALSE;", "  m->match.rmm_maxcol = 0;"], "readability/bool"]
["src/nvim/window.c", ["  {", "    linenr_T\ttoplnum = 0;", "    linenr_T\tbotlnum = 0;"], "whitespace/tab"]
["src/nvim/window.c", ["    linenr_T\ttoplnum = 0;", "    linenr_T\tbotlnum = 0;", "    listitem_T\t*li;"], "whitespace/tab"]
["src/nvim/window.c", ["    linenr_T\tbotlnum = 0;", "    listitem_T\t*li;", "    int\t\ti;"], "whitespace/tab"]
["src/nvim/window.c", ["    listitem_T\t*li;", "    int\t\ti;", ""], "whitespace/tab"]
["src/nvim/window.c", ["        i++, li = li->li_next) {", "      linenr_T\t  lnum = 0;", "      colnr_T\t  col = 0;"], "whitespace/tab"]
["src/nvim/window.c", ["      linenr_T\t  lnum = 0;", "      colnr_T\t  col = 0;", "      int\t  len = 1;"], "whitespace/tab"]
["src/nvim/window.c", ["      colnr_T\t  col = 0;", "      int\t  len = 1;", "      list_T\t  *subl;"], "whitespace/tab"]
["src/nvim/window.c", ["      int\t  len = 1;", "      list_T\t  *subl;", "      listitem_T  *subli;"], "whitespace/tab"]
["src/nvim/window.c", ["      listitem_T  *subli;", "      int\t  error = false;", ""], "whitespace/tab"]
["src/nvim/window.c", ["", "    // Calculate top and bottom lines for redrawing area ", "    if (toplnum != 0){"], "whitespace/end_of_line"]
["src/nvim/window.c", ["    // Calculate top and bottom lines for redrawing area ", "    if (toplnum != 0){", "      if (wp->w_buffer->b_mod_set) {"], "whitespace/braces"]
["src/nvim/window.c", ["  }", " ", "  /* Insert new match.  The match list is in ascending order with regard to"], "whitespace/end_of_line"]
["src/nvim/window.c", ["  if (id < 1) {", "    if (perr == TRUE)", "      EMSGN(\"E802: Invalid ID: %\" PRId64"], "readability/bool"]
["src/nvim/window.c", ["  if (cur == NULL) {", "    if (perr == TRUE)", "      EMSGN(\"E803: ID not found: %\" PRId64, id);"], "readability/bool"]
["src/nvim/window.c", ["  if (topfrp->fr_height != height)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/window.c", ["      if (frp->fr_height != height)", "        return FALSE;", ""], "readability/bool"]
["src/nvim/window.c", ["", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/window.c", ["  if (topfrp->fr_width != width)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/window.c", ["      if (frp->fr_width != width)", "        return FALSE;", ""], "readability/bool"]
["src/nvim/window.c", ["", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ascii.h", ["", "#endif /* NVIM_ASCII_H */", ""], "build/header_guard"]
["src/nvim/ascii.h", ["", "#define Ctrl_chr(x)     (TOUPPER_ASC(x) ^ 0x40) /* '?' -> DEL, '@' -> ^@, etc. */", "#define Meta(x)         ((x) | 0x80)"], "whitespace/line_length"]
["src/nvim/ascii.h", ["static inline bool ascii_isdigit(int) REAL_FATTR_ALWAYS_INLINE REAL_FATTR_CONST;", "static inline bool ascii_isxdigit(int) REAL_FATTR_ALWAYS_INLINE REAL_FATTR_CONST;", "static inline bool ascii_isspace(int) REAL_FATTR_ALWAYS_INLINE REAL_FATTR_CONST;"], "whitespace/line_length"]
["src/nvim/assert.h", ["// _Static_assert but we need to suppress warnings, this is pretty ugly.", "#elif (!defined(__clang__) && !defined(__INTEL_COMPILER)) && \\", "  (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))"], "whitespace/parens"]
["src/nvim/assert.h", ["  #define STATIC_ASSERT(cond, msg) \\", "\t_Pragma(\"GCC diagnostic push\") \\", "\t_Pragma(\"GCC diagnostic ignored \\\"-pedantic\\\"\") \\"], "whitespace/tab"]
["src/nvim/assert.h", ["\t_Pragma(\"GCC diagnostic push\") \\", "\t_Pragma(\"GCC diagnostic ignored \\\"-pedantic\\\"\") \\", "\t_Static_assert(cond, msg); \\"], "whitespace/tab"]
["src/nvim/assert.h", ["\t_Pragma(\"GCC diagnostic ignored \\\"-pedantic\\\"\") \\", "\t_Static_assert(cond, msg); \\", "\t_Pragma(\"GCC diagnostic pop\") \\"], "whitespace/tab"]
["src/nvim/assert.h", ["\t_Static_assert(cond, msg); \\", "\t_Pragma(\"GCC diagnostic pop\") \\", ""], "whitespace/tab"]
["src/nvim/assert.h", ["  #define STATIC_ASSERT(cond, msg) \\", "\t_Pragma(\"clang diagnostic push\") \\", "\t_Pragma(\"clang diagnostic ignored \\\"-Wc11-extensions\\\"\") \\"], "whitespace/tab"]
["src/nvim/assert.h", ["\t_Pragma(\"clang diagnostic push\") \\", "\t_Pragma(\"clang diagnostic ignored \\\"-Wc11-extensions\\\"\") \\", "\t_Static_assert(cond, msg); \\"], "whitespace/tab"]
["src/nvim/assert.h", ["\t_Pragma(\"clang diagnostic ignored \\\"-Wc11-extensions\\\"\") \\", "\t_Static_assert(cond, msg); \\", "\t_Pragma(\"clang diagnostic pop\") \\"], "whitespace/tab"]
["src/nvim/assert.h", ["\t_Static_assert(cond, msg); \\", "\t_Pragma(\"clang diagnostic pop\") \\", ""], "whitespace/tab"]
["src/nvim/assert.h", ["  #ifdef __COUNTER__", "\t#define STATIC_ASSERT(e,m) \\", "\t  { enum { ASSERT_CONCAT(static_assert_, __COUNTER__) = 1/(!!(e)) }; }"], "whitespace/tab"]
["src/nvim/assert.h", ["  #ifdef __COUNTER__", "\t#define STATIC_ASSERT(e,m) \\", "\t  { enum { ASSERT_CONCAT(static_assert_, __COUNTER__) = 1/(!!(e)) }; }"], "whitespace/comma"]
["src/nvim/assert.h", ["\t#define STATIC_ASSERT(e,m) \\", "\t  { enum { ASSERT_CONCAT(static_assert_, __COUNTER__) = 1/(!!(e)) }; }", "  #else"], "whitespace/tab"]
["src/nvim/assert.h", ["  #else", "\t// This can't be used twice on the same line so ensure if using in headers", "\t// that the headers are not included twice (by wrapping in #ifndef...#endif)"], "whitespace/tab"]
["src/nvim/assert.h", ["\t// This can't be used twice on the same line so ensure if using in headers", "\t// that the headers are not included twice (by wrapping in #ifndef...#endif)", "\t// Note it doesn't cause an issue when used on same line of separate modules"], "whitespace/tab"]
["src/nvim/assert.h", ["\t// that the headers are not included twice (by wrapping in #ifndef...#endif)", "\t// Note it doesn't cause an issue when used on same line of separate modules", "\t// compiled with gcc -combine -fwhole-program."], "whitespace/tab"]
["src/nvim/assert.h", ["\t// Note it doesn't cause an issue when used on same line of separate modules", "\t// compiled with gcc -combine -fwhole-program.", "\t#define STATIC_ASSERT(e,m) \\"], "whitespace/tab"]
["src/nvim/assert.h", ["\t// compiled with gcc -combine -fwhole-program.", "\t#define STATIC_ASSERT(e,m) \\", "\t  { enum { ASSERT_CONCAT(assert_line_, __LINE__) = 1/(!!(e)) }; }"], "whitespace/tab"]
["src/nvim/assert.h", ["\t// compiled with gcc -combine -fwhole-program.", "\t#define STATIC_ASSERT(e,m) \\", "\t  { enum { ASSERT_CONCAT(assert_line_, __LINE__) = 1/(!!(e)) }; }"], "whitespace/comma"]
["src/nvim/assert.h", ["\t#define STATIC_ASSERT(e,m) \\", "\t  { enum { ASSERT_CONCAT(assert_line_, __LINE__) = 1/(!!(e)) }; }", "  #endif"], "whitespace/tab"]
["src/nvim/buffer_defs.h", ["", "#endif // NVIM_BUFFER_DEFS_H", ""], "build/header_guard"]
["src/nvim/buffer_defs.h", ["", "typedef struct file_buffer buf_T; // Forward declaration", ""], "whitespace/comments"]
["src/nvim/buffer_defs.h", ["#define BF_RECOVERED    0x01    /* buffer has been recovered */", "#define BF_CHECK_RO     0x02    /* need to check readonly when loading file", "                                   into buffer (set by \":e\", may be reset by"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["#define BF_CHECK_RO     0x02    /* need to check readonly when loading file", "                                   into buffer (set by \":e\", may be reset by", "                                   \":buf\" */"], "whitespace/parens"]
["src/nvim/buffer_defs.h", ["                                   \":buf\" */", "#define BF_NEVERLOADED  0x04    /* file has never been loaded into buffer,", "                                   many variables still need to be set */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["                                   many variables still need to be set */", "#define BF_NOTEDITED    0x08    /* Set when file name is changed after", "                                   starting to edit, reset when file is"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  int wo_bri;", "# define w_p_bri w_onebuf_opt.wo_bri\t/* 'breakindent' */", "  char_u *wo_briopt;"], "whitespace/tab"]
["src/nvim/buffer_defs.h", ["  int wo_fdc_save;", "# define w_p_fdc_save w_onebuf_opt.wo_fdc_save  /* 'foldenable' saved for diff mode */", "  int wo_fen;"], "whitespace/line_length"]
["src/nvim/buffer_defs.h", ["  int wo_fen_save;", "# define w_p_fen_save w_onebuf_opt.wo_fen_save  /* 'foldenable' saved for diff mode */", "  char_u      *wo_fdi;"], "whitespace/line_length"]
["src/nvim/buffer_defs.h", ["  int wo_fdl_save;", "# define w_p_fdl_save w_onebuf_opt.wo_fdl_save  /* 'foldlevel' state saved for diff mode */", "  char_u      *wo_fdm;"], "whitespace/line_length"]
["src/nvim/buffer_defs.h", ["  int b_nospell_cluster_id;             /* @NoSpell cluster ID or 0 */", "  int b_syn_containedin;                /* TRUE when there is an item with a", "                                           \"containedin\" argument */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  int b_nospell_cluster_id;             /* @NoSpell cluster ID or 0 */", "  int b_syn_containedin;                /* TRUE when there is an item with a", "                                           \"containedin\" argument */"], "readability/bool"]
["src/nvim/buffer_defs.h", ["  int b_syn_sync_flags;                 /* flags about how to sync */", "  short b_syn_sync_id;                  /* group to sync on */", "  long b_syn_sync_minlines;             /* minimal sync lines offset */"], "runtime/int"]
["src/nvim/buffer_defs.h", ["  int b_syn_conceal;                    /* auto-conceal for :syn cmds */", "  int b_syn_folditems;                  /* number of patterns with the HL_FOLD", "                                           flag set */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  uint64_t handle;              // unique identifier for the buffer", "  memline_T b_ml;               /* associated memline (also contains line", "                                   count) */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  uint64_t handle;              // unique identifier for the buffer", "  memline_T b_ml;               /* associated memline (also contains line", "                                   count) */"], "whitespace/parens"]
["src/nvim/buffer_defs.h", ["  int b_flags;                  /* various BF_ flags */", "  bool b_closing;               /* buffer is being closed, don't let", "                                   autocommands close it too. */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  bool b_changed;               /* 'modified': Set to true if something in the", "                                   file has been changed and not written out. */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  bool b_saving;                /* Set to true if we are in the middle of", "                                   saving the buffer. */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["   */", "  bool b_mod_set;               /* true when there are changes since the last", "                                   time the display was updated */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  linenr_T b_mod_top;           /* topmost lnum that was changed */", "  linenr_T b_mod_bot;           /* lnum below last changed line, AFTER the", "                                   change */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["                                   change */", "  long b_mod_xlines;            /* number of extra buffer lines inserted;", "                                   negative when lines were deleted */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["                                   change */", "  long b_mod_xlines;            /* number of extra buffer lines inserted;", "                                   negative when lines were deleted */"], "whitespace/newline"]
["src/nvim/buffer_defs.h", ["  u_header_T  *b_u_oldhead;     /* pointer to oldest header */", "  u_header_T  *b_u_newhead;     /* pointer to newest header; may not be valid", "                                   if b_u_curhead is not NULL */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  u_header_T  *b_u_oldhead;     /* pointer to oldest header */", "  u_header_T  *b_u_newhead;     /* pointer to newest header; may not be valid", "                                   if b_u_curhead is not NULL */"], "whitespace/newline"]
["src/nvim/buffer_defs.h", ["  long b_p_imsearch;            /* input mode for search */", "#define B_IMODE_USE_INSERT -1   /*\tUse b_p_iminsert value for search */", "#define B_IMODE_NONE 0          /*\tInput via none */"], "whitespace/tab"]
["src/nvim/buffer_defs.h", ["#define B_IMODE_USE_INSERT -1   /*\tUse b_p_iminsert value for search */", "#define B_IMODE_NONE 0          /*\tInput via none */", "#define B_IMODE_LMAP 1          /*\tInput via langmap */"], "whitespace/tab"]
["src/nvim/buffer_defs.h", ["#define B_IMODE_NONE 0          /*\tInput via none */", "#define B_IMODE_LMAP 1          /*\tInput via langmap */", "# define B_IMODE_LAST 1"], "whitespace/tab"]
["src/nvim/buffer_defs.h", ["", "  short b_kmap_state;           /* using \"lmap\" mappings */", "# define KEYMAP_INIT    1       /* 'keymap' was set, call keymap_init() */"], "runtime/int"]
["src/nvim/buffer_defs.h", ["", "  linenr_T b_no_eol_lnum;       /* non-zero lnum when last line of next binary", "                                 * write should not have an end-of-line */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  bool b_may_swap;", "  bool b_did_warn;              /* Set to true if user has been warned on first", "                                   change of a read-only file */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["   */", "  bool b_help;                  /* TRUE for help file buffer (when set b_p_bt", "                                   is \"help\") */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["   */", "  bool b_help;                  /* TRUE for help file buffer (when set b_p_bt", "                                   is \"help\") */"], "readability/bool"]
["src/nvim/buffer_defs.h", ["                                   is \"help\") */", "  bool b_spell;                 /* True for a spell file buffer, most fields", "                                   are not used!  Use the B_SPELL macro to"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  bool b_spell;                 /* True for a spell file buffer, most fields", "                                   are not used!  Use the B_SPELL macro to", "                                   access b_spell without #ifdef. */"], "whitespace/operators"]
["src/nvim/buffer_defs.h", ["  bool b_spell;                 /* True for a spell file buffer, most fields", "                                   are not used!  Use the B_SPELL macro to", "                                   access b_spell without #ifdef. */"], "readability/alt_tokens"]
["src/nvim/buffer_defs.h", ["", "  synblock_T b_s;               /* Info related to syntax highlighting.  w_s", "                                 * normally points to this, but some windows"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  long tp_old_Columns;              /* Columns when Tab page was left */", "  long tp_ch_used;                  /* value of 'cmdheight' when frame size", "                                       was set */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  frame_T     *fr_parent;       /* containing frame or NULL */", "  frame_T     *fr_next;         /* frame right or below in same parent, NULL", "                                   for first */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["                                   for first */", "  frame_T     *fr_prev;         /* frame left or above in same parent, NULL", "                                   for last */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["typedef struct {", "  regmmatch_T rm;       /* points to the regexp program; contains last found", "                           match (may continue in next line) */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["typedef struct {", "  regmmatch_T rm;       /* points to the regexp program; contains last found", "                           match (may continue in next line) */"], "whitespace/newline"]
["src/nvim/buffer_defs.h", ["  regmmatch_T rm;       /* points to the regexp program; contains last found", "                           match (may continue in next line) */", "  buf_T       *buf;     /* the buffer to search for a match */"], "whitespace/parens"]
["src/nvim/buffer_defs.h", ["{", "    linenr_T    lnum;\t///< line number", "    colnr_T     col;\t///< column number"], "whitespace/tab"]
["src/nvim/buffer_defs.h", ["{", "    linenr_T    lnum;\t///< line number", "    colnr_T     col;\t///< column number"], "whitespace/comments"]
["src/nvim/buffer_defs.h", ["    linenr_T    lnum;\t///< line number", "    colnr_T     col;\t///< column number", "    int         len;\t///< length: 0 - to the end of line"], "whitespace/tab"]
["src/nvim/buffer_defs.h", ["    linenr_T    lnum;\t///< line number", "    colnr_T     col;\t///< column number", "    int         len;\t///< length: 0 - to the end of line"], "whitespace/comments"]
["src/nvim/buffer_defs.h", ["    colnr_T     col;\t///< column number", "    int         len;\t///< length: 0 - to the end of line", "} llpos_T;"], "whitespace/tab"]
["src/nvim/buffer_defs.h", ["    colnr_T     col;\t///< column number", "    int         len;\t///< length: 0 - to the end of line", "} llpos_T;"], "whitespace/comments"]
["src/nvim/buffer_defs.h", ["{", "    llpos_T     pos[MAXPOSMATCH];\t///< array of positions", "    int         cur;\t\t\t///< internal position counter "], "whitespace/tab"]
["src/nvim/buffer_defs.h", ["{", "    llpos_T     pos[MAXPOSMATCH];\t///< array of positions", "    int         cur;\t\t\t///< internal position counter "], "whitespace/comments"]
["src/nvim/buffer_defs.h", ["    llpos_T     pos[MAXPOSMATCH];\t///< array of positions", "    int         cur;\t\t\t///< internal position counter ", "    linenr_T    toplnum;\t\t///< top buffer line"], "whitespace/tab"]
["src/nvim/buffer_defs.h", ["    llpos_T     pos[MAXPOSMATCH];\t///< array of positions", "    int         cur;\t\t\t///< internal position counter ", "    linenr_T    toplnum;\t\t///< top buffer line"], "whitespace/end_of_line"]
["src/nvim/buffer_defs.h", ["    int         cur;\t\t\t///< internal position counter ", "    linenr_T    toplnum;\t\t///< top buffer line", "    linenr_T    botlnum;\t\t///< bottom buffer line"], "whitespace/tab"]
["src/nvim/buffer_defs.h", ["    linenr_T    toplnum;\t\t///< top buffer line", "    linenr_T    botlnum;\t\t///< bottom buffer line", "};"], "whitespace/tab"]
["src/nvim/buffer_defs.h", ["  uint64_t handle;", "  buf_T       *w_buffer;            /* buffer we are a window into (used", "                                       often, keep it the first item!) */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  uint64_t handle;", "  buf_T       *w_buffer;            /* buffer we are a window into (used", "                                       often, keep it the first item!) */"], "whitespace/parens"]
["src/nvim/buffer_defs.h", ["  win_T       *w_next;              /* link to next window */", "  bool w_closing;                   /* window is being closed, don't let", "                                       autocommands close it too. */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  colnr_T w_curswant;               /* The column we'd like to be at.  This is", "                                       used to try to stay in the same column"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  int w_set_curswant;               /* If set, then update w_curswant the next", "                                       time through cursupdate() to the"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["   */", "  linenr_T w_topline;               /* buffer line number of the line at the", "                                       top of the window */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["                                       top of the window */", "  char w_topline_was_set;           /* flag set to TRUE when topline is set,", "                                       e.g. by winrestview() */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["                                       top of the window */", "  char w_topline_was_set;           /* flag set to TRUE when topline is set,", "                                       e.g. by winrestview() */"], "readability/bool"]
["src/nvim/buffer_defs.h", ["  int w_old_topfill;                /* w_topfill at last redraw */", "  bool w_botfill;                   /* true when filler lines are actually", "                                       below w_topline (at end of file) */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  bool w_botfill;                   /* true when filler lines are actually", "                                       below w_topline (at end of file) */", "  bool w_old_botfill;               /* w_botfill at last redraw */"], "whitespace/parens"]
["src/nvim/buffer_defs.h", ["  bool w_old_botfill;               /* w_botfill at last redraw */", "  colnr_T w_leftcol;                /* window column number of the left most", "                                       character in the window; used when"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["                                       'wrap' is off */", "  colnr_T w_skipcol;                /* starting column when a single line", "                                       doesn't fit in the window */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  int w_winrow;                     /* first row of window in screen */", "  int w_height;                     /* number of rows in window, excluding", "                                       status/command line(s) */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  int w_valid;", "  pos_T w_valid_cursor;             /* last known position of w_cursor, used", "                                       to adjust w_valid */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  colnr_T w_virtcol;                /* column number of the cursor in the", "                                       buffer line, as opposed to the column"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["                                       makes a difference on lines which span", "                                       more than one screen line or when", "                                       w_leftcol is non-zero */"], "readability/alt_tokens"]
["src/nvim/buffer_defs.h", ["", "  linenr_T w_botline;               /* number of the line below the bottom of", "                                       the screen */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  int w_empty_rows;                 /* number of ~ rows in window */", "  int w_filler_rows;                /* number of filler rows at the end of the", "                                       window */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  garray_T w_folds;                 /* array of nested folds */", "  bool w_fold_manual;               /* when true: some folds are opened/closed", "                                       manually */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["                                       manually */", "  bool w_foldinvalid;               /* when true: folding needs to be", "                                       recomputed */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["                                       recomputed */", "  int w_nrwidth;                    /* width of 'number' and 'relativenumber'", "                                       column being used */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  int w_redr_type;                  /* type of redraw to be performed on win */", "  int w_upd_rows;                   /* number of window lines to update when", "                                       w_redr_type is REDRAW_TOP */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  alist_T     *w_alist;             /* pointer to arglist for this window */", "  int w_arg_idx;                    /* current index in argument list (can be", "                                       out of range!) */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  alist_T     *w_alist;             /* pointer to arglist for this window */", "  int w_arg_idx;                    /* current index in argument list (can be", "                                       out of range!) */"], "whitespace/parens"]
["src/nvim/buffer_defs.h", ["", "  char_u      *w_localdir;          /* absolute path of local directory or", "                                       NULL */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  linenr_T w_nrwidth_line_count;        /* line count when ml_nrwidth_width", "                                         * was computed. */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "#endif // NVIM_BUFFER_DEFS_H", ""], "whitespace/comments"]
["src/nvim/buffer.h", ["enum getf_values {", "  GETF_SETMARK = 0x01, // set pcmark before jumping", "  GETF_ALT     = 0x02, // jumping to alternate file (not buf num)"], "whitespace/comments"]
["src/nvim/buffer.h", ["  GETF_SETMARK = 0x01, // set pcmark before jumping", "  GETF_ALT     = 0x02, // jumping to alternate file (not buf num)", "  GETF_SWITCH  = 0x04, // respect 'switchbuf' settings when jumping"], "whitespace/comments"]
["src/nvim/buffer.h", ["  GETF_ALT     = 0x02, // jumping to alternate file (not buf num)", "  GETF_SWITCH  = 0x04, // respect 'switchbuf' settings when jumping", "};"], "whitespace/comments"]
["src/nvim/buffer.h", ["enum bln_values {", "  BLN_CURBUF = 1, // May re-use curbuf for new buffer", "  BLN_LISTED = 2, // Put new buffer in buffer list"], "whitespace/comments"]
["src/nvim/buffer.h", ["  BLN_CURBUF = 1, // May re-use curbuf for new buffer", "  BLN_LISTED = 2, // Put new buffer in buffer list", "  BLN_DUMMY  = 4, // Allocating dummy buffer"], "whitespace/comments"]
["src/nvim/buffer.h", ["  BLN_LISTED = 2, // Put new buffer in buffer list", "  BLN_DUMMY  = 4, // Allocating dummy buffer", "};"], "whitespace/comments"]
["src/nvim/buffer.h", ["enum dobuf_action_values {", "  DOBUF_GOTO   = 0, // go to specified buffer", "  DOBUF_SPLIT  = 1, // split window and go to specified buffer"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_GOTO   = 0, // go to specified buffer", "  DOBUF_SPLIT  = 1, // split window and go to specified buffer", "  DOBUF_UNLOAD = 2, // unload specified buffer(s)"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_SPLIT  = 1, // split window and go to specified buffer", "  DOBUF_UNLOAD = 2, // unload specified buffer(s)", "  DOBUF_DEL    = 3, // delete specified buffer(s) from buflist"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_UNLOAD = 2, // unload specified buffer(s)", "  DOBUF_DEL    = 3, // delete specified buffer(s) from buflist", "  DOBUF_WIPE   = 4, // delete specified buffer(s) really"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_DEL    = 3, // delete specified buffer(s) from buflist", "  DOBUF_WIPE   = 4, // delete specified buffer(s) really", "};"], "whitespace/comments"]
["src/nvim/buffer.h", ["enum dobuf_start_values {", "  DOBUF_CURRENT = 0, // \"count\" buffer from current buffer", "  DOBUF_FIRST   = 1, // \"count\" buffer from first buffer"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_CURRENT = 0, // \"count\" buffer from current buffer", "  DOBUF_FIRST   = 1, // \"count\" buffer from first buffer", "  DOBUF_LAST    = 2, // \"count\" buffer from last buffer"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_FIRST   = 1, // \"count\" buffer from first buffer", "  DOBUF_LAST    = 2, // \"count\" buffer from last buffer", "  DOBUF_MOD     = 3, // \"count\" mod. buffer from current buffer"], "whitespace/comments"]
["src/nvim/buffer.h", ["  DOBUF_LAST    = 2, // \"count\" buffer from last buffer", "  DOBUF_MOD     = 3, // \"count\" mod. buffer from current buffer", "};"], "whitespace/comments"]
["src/nvim/buffer.h", ["enum bfa_values {", "  BFA_DEL       = 1, // buffer is going to be deleted", "  BFA_WIPE      = 2, // buffer is going to be wiped out"], "whitespace/comments"]
["src/nvim/buffer.h", ["  BFA_DEL       = 1, // buffer is going to be deleted", "  BFA_WIPE      = 2, // buffer is going to be wiped out", "  BFA_KEEP_UNDO = 4, // do not free undo information"], "whitespace/comments"]
["src/nvim/buffer.h", ["  BFA_WIPE      = 2, // buffer is going to be wiped out", "  BFA_KEEP_UNDO = 4, // do not free undo information", "};"], "whitespace/comments"]
["src/nvim/eval_defs.h", ["#define VAR_SCOPE     1 /* a:, v:, s:, etc. scope dictionaries */", "#define VAR_DEF_SCOPE 2 /* l:, g: scope dictionaries: here funcrefs are not", "                           allowed to mask existing functions */"], "readability/multiline_comment"]
["src/nvim/ex_cmds_defs.h", ["#define DFLALL          0x020   /* default file range is 1,$ */", "#define WHOLEFOLD       0x040   /* extend range to include whole fold also", "                                   when less than two numbers given */"], "readability/multiline_comment"]
["src/nvim/ex_cmds_defs.h", ["#ifndef BACKSLASH_IN_FILENAME", "  int xp_shell;                         /* TRUE for a shell command, more", "                                           characters need to be escaped */"], "readability/multiline_comment"]
["src/nvim/ex_cmds_defs.h", ["#ifndef BACKSLASH_IN_FILENAME", "  int xp_shell;                         /* TRUE for a shell command, more", "                                           characters need to be escaped */"], "readability/bool"]
["src/nvim/ex_cmds_defs.h", ["#endif", "  int xp_numfiles;                      /* number of files found by", "                                                    file name completion */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.h", ["#define ECMD_HIDE       0x01    /* don't free the current buffer */", "#define ECMD_SET_HELP   0x02    /* set b_help flag of (new) buffer before", "                                   opening file */"], "readability/multiline_comment"]
["src/nvim/ex_eval.h", ["struct condstack {", "  short cs_flags[CSTACK_LEN];           /* CSF_ flags */", "  char cs_pending[CSTACK_LEN];          /* CSTP_: what's pending in \":finally\"*/"], "runtime/int"]
["src/nvim/fold.h", ["  linenr_T fi_lnum;             /* line number where fold starts */", "  int fi_level;                 /* level of the fold; when this is zero the", "                                   other fields are invalid */"], "readability/multiline_comment"]
["src/nvim/fold.h", ["  linenr_T fi_lnum;             /* line number where fold starts */", "  int fi_level;                 /* level of the fold; when this is zero the", "                                   other fields are invalid */"], "whitespace/newline"]
["src/nvim/fold.h", ["                                   other fields are invalid */", "  int fi_low_level;             /* lowest fold level that starts in the same", "                                   line */"], "readability/multiline_comment"]
["src/nvim/func_attr.h", ["", "#ifndef DID_REAL_ATTR", "  #define DID_REAL_ATTR"], "build/header_guard"]
["src/nvim/func_attr.h", ["  #define FUNC_ATTR_NONNULL_RET", "#endif", ""], "build/header_guard"]
["src/nvim/func_attr.h", ["// marker so line numbers and indices both start at 1", "// If DEFINE_FUNC_ATTRIBUTES macro is not defined then all function attributes ", "// are defined as empty values."], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["//", "// If DO_NOT_DEFINE_EMPTY_ATTRIBUTES then empty macros are not defined. Thus ", "// undefined DEFINE_FUNC_ATTRIBUTES and defined DO_NOT_DEFINE_EMPTY_ATTRIBUTES "], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["// If DO_NOT_DEFINE_EMPTY_ATTRIBUTES then empty macros are not defined. Thus ", "// undefined DEFINE_FUNC_ATTRIBUTES and defined DO_NOT_DEFINE_EMPTY_ATTRIBUTES ", "// leaves file with untouched FUNC_ATTR_* macros. This variant is used for "], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["// undefined DEFINE_FUNC_ATTRIBUTES and defined DO_NOT_DEFINE_EMPTY_ATTRIBUTES ", "// leaves file with untouched FUNC_ATTR_* macros. This variant is used for ", "// scripts/gendeclarations.lua."], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["//", "// Empty macros are used for *.c files. (undefined DEFINE_FUNC_ATTRIBUTES and ", "// undefined DO_NOT_DEFINE_EMPTY_ATTRIBUTES)"], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["//", "// Macros defined as __attribute__((*)) are used by generated header files. ", "// (defined DEFINE_FUNC_ATTRIBUTES and undefined "], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["// Macros defined as __attribute__((*)) are used by generated header files. ", "// (defined DEFINE_FUNC_ATTRIBUTES and undefined ", "// DO_NOT_DEFINE_EMPTY_ATTRIBUTES)"], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["//", "// Defined DEFINE_FUNC_ATTRIBUTES and defined DO_NOT_DEFINE_EMPTY_ATTRIBUTES is ", "// not used by anything."], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["", "// FUNC_ATTR_* macros should be in *.c files for declarations generator. If you ", "// define a function for which declaration is not generated by "], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["// FUNC_ATTR_* macros should be in *.c files for declarations generator. If you ", "// define a function for which declaration is not generated by ", "// gendeclarations.lua (e.g. template hash implementation) then you should use "], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["// define a function for which declaration is not generated by ", "// gendeclarations.lua (e.g. template hash implementation) then you should use ", "// REAL_FATTR_* macros."], "whitespace/end_of_line"]
["src/nvim/func_attr.h", ["      #define REAL_FATTR_ALLOC_SIZE(x) __attribute__((alloc_size(x)))", "      #define REAL_FATTR_ALLOC_SIZE_PROD(x,y) __attribute__((alloc_size(x,y)))", "      #if GCC_VERSION >= 40900"], "whitespace/comma"]
["src/nvim/func_attr.h", ["  #ifndef REAL_FATTR_ALLOC_SIZE_PROD", "    #define REAL_FATTR_ALLOC_SIZE_PROD(x,y)", "  #endif"], "whitespace/comma"]
["src/nvim/func_attr.h", ["  #define FUNC_ATTR_ALLOC_SIZE(x) REAL_FATTR_ALLOC_SIZE(x)", "  #define FUNC_ATTR_ALLOC_SIZE_PROD(x,y) REAL_FATTR_ALLOC_SIZE_PROD(x,y)", "  #define FUNC_ATTR_ALLOC_ALIGN(x) REAL_FATTR_ALLOC_ALIGN(x)"], "whitespace/comma"]
["src/nvim/func_attr.h", ["  #define FUNC_ATTR_ALLOC_SIZE(x)", "  #define FUNC_ATTR_ALLOC_SIZE_PROD(x,y)", "  #define FUNC_ATTR_ALLOC_ALIGN(x)"], "whitespace/comma"]
["src/nvim/globals.h", ["", "#endif /* NVIM_GLOBALS_H */", ""], "build/header_guard"]
["src/nvim/globals.h", ["# define MSG_BUF_LEN 480                 // length of buffer for small messages", "# define MSG_BUF_CLEN  (MSG_BUF_LEN / 6) // cell length (worst case: utf-8", "                                         // takes 6 bytes for one cell)"], "whitespace/comments"]
["src/nvim/globals.h", ["#endif", ";", "EXTERN long Columns INIT(= DFLT_COLS);         /* nr of columns in the screen */"], "whitespace/semicolon"]
["src/nvim/globals.h", ["typedef char_u schar_T;", "typedef unsigned short sattr_T;", ""], "runtime/int"]
["src/nvim/globals.h", ["EXTERN u8char_T *ScreenLinesC[MAX_MCO];         /* composing characters */", "EXTERN int Screen_mco INIT(= 0);                /* value of p_mco used when", "                                                   allocating ScreenLinesC[] */"], "readability/multiline_comment"]
["src/nvim/globals.h", [" */", "EXTERN short    *TabPageIdxs INIT(= NULL);", ""], "runtime/int"]
["src/nvim/globals.h", ["", "EXTERN int redraw_cmdline INIT(= FALSE);        /* cmdline must be redrawn */", "EXTERN int clear_cmdline INIT(= FALSE);         /* cmdline must be cleared */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int redraw_cmdline INIT(= FALSE);        /* cmdline must be redrawn */", "EXTERN int clear_cmdline INIT(= FALSE);         /* cmdline must be cleared */", "EXTERN int mode_displayed INIT(= FALSE);        /* mode is being displayed */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int clear_cmdline INIT(= FALSE);         /* cmdline must be cleared */", "EXTERN int mode_displayed INIT(= FALSE);        /* mode is being displayed */", "EXTERN int cmdline_star INIT(= FALSE);          /* cmdline is crypted */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int mode_displayed INIT(= FALSE);        /* mode is being displayed */", "EXTERN int cmdline_star INIT(= FALSE);          /* cmdline is crypted */", ""], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int exec_from_reg INIT(= FALSE);         /* executing register */", ""], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int screen_cleared INIT(= FALSE);        /* screen has been cleared */", ""], "readability/bool"]
["src/nvim/globals.h", [" * stop looking for matches. */", "EXTERN int compl_interrupted INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", ["# define CONT_N_ADDS    4       /* next ^X<> will add-new or expand-current */", "# define CONT_S_IPOS    8       /* next ^X<> will set initial_pos?", "                                 * if so, word-wise-expansion will set SOL */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["                                 * if so, word-wise-expansion will set SOL */", "# define CONT_SOL       16      /* pattern includes start of line, just for", "                                 * word-wise expansion, not set for ^X^L */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["                                 * word-wise expansion, not set for ^X^L */", "# define CONT_LOCAL     32      /* for ctrl_x_mode 0, ^X^P/^X^N do a local", "                                 * expansion, (eg use complete=.) */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["# define CONT_LOCAL     32      /* for ctrl_x_mode 0, ^X^P/^X^N do a local", "                                 * expansion, (eg use complete=.) */", ""], "whitespace/operators"]
["src/nvim/globals.h", [" */", "EXTERN int cmdmsg_rl INIT(= FALSE);         /* cmdline is drawn right to left */", "EXTERN int msg_col;"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int msg_row;", "EXTERN int msg_scrolled;        /* Number of screen lines that windows have", "                                * scrolled because of printing messages. */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["                                * scrolled because of printing messages. */", "EXTERN int msg_scrolled_ign INIT(= FALSE);", "/* when TRUE don't set need_wait_return in"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int keep_msg_attr INIT(= 0);         /* highlight attr for keep_msg */", "EXTERN int keep_msg_more INIT(= FALSE);      /* keep_msg was set by msgmore() */", "EXTERN int need_fileinfo INIT(= FALSE);     /* do fileinfo() after redraw */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int keep_msg_more INIT(= FALSE);      /* keep_msg was set by msgmore() */", "EXTERN int need_fileinfo INIT(= FALSE);     /* do fileinfo() after redraw */", "EXTERN int msg_scroll INIT(= FALSE);        /* msg_start() will scroll */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int need_fileinfo INIT(= FALSE);     /* do fileinfo() after redraw */", "EXTERN int msg_scroll INIT(= FALSE);        /* msg_start() will scroll */", "EXTERN int msg_didout INIT(= FALSE);        /* msg_outstr() was used in line */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int msg_scroll INIT(= FALSE);        /* msg_start() will scroll */", "EXTERN int msg_didout INIT(= FALSE);        /* msg_outstr() was used in line */", "EXTERN int msg_didany INIT(= FALSE);        /* msg_outstr() was used at all */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int msg_didout INIT(= FALSE);        /* msg_outstr() was used in line */", "EXTERN int msg_didany INIT(= FALSE);        /* msg_outstr() was used at all */", "EXTERN int msg_nowait INIT(= FALSE);        /* don't wait for this msg */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int msg_didany INIT(= FALSE);        /* msg_outstr() was used at all */", "EXTERN int msg_nowait INIT(= FALSE);        /* don't wait for this msg */", "EXTERN int emsg_off INIT(= 0);              /* don't display errors for now,"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int msg_nowait INIT(= FALSE);        /* don't wait for this msg */", "EXTERN int emsg_off INIT(= 0);              /* don't display errors for now,", "                                               unless 'debug' is set. */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["                                               unless 'debug' is set. */", "EXTERN int info_message INIT(= FALSE);      /* printing informative message */", "EXTERN int msg_hist_off INIT(= FALSE);      /* don't add messages to history */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int info_message INIT(= FALSE);      /* printing informative message */", "EXTERN int msg_hist_off INIT(= FALSE);      /* don't add messages to history */", "EXTERN int need_clr_eos INIT(= FALSE);      /* need to clear text before"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int msg_hist_off INIT(= FALSE);      /* don't add messages to history */", "EXTERN int need_clr_eos INIT(= FALSE);      /* need to clear text before", "                                               displaying a message. */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN int msg_hist_off INIT(= FALSE);      /* don't add messages to history */", "EXTERN int need_clr_eos INIT(= FALSE);      /* need to clear text before", "                                               displaying a message. */"], "readability/bool"]
["src/nvim/globals.h", ["                                               displaying a message. */", "EXTERN int emsg_skip INIT(= 0);             /* don't display errors for", "                                               expression that is skipped */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["                                               expression that is skipped */", "EXTERN int emsg_severe INIT(= FALSE);        /* use message of next of several", "                                                emsg() calls for throw */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["                                               expression that is skipped */", "EXTERN int emsg_severe INIT(= FALSE);        /* use message of next of several", "                                                emsg() calls for throw */"], "readability/bool"]
["src/nvim/globals.h", ["                                                emsg() calls for throw */", "EXTERN int did_endif INIT(= FALSE);         /* just had \":endif\" */", "EXTERN dict_T vimvardict;                   /* Dictionary with v: variables */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN dict_T globvardict;                  /* Dictionary with g: variables */", "EXTERN int did_emsg;                        /* set by emsg() when the message", "                                               is displayed or thrown */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["                                               is displayed or thrown */", "EXTERN int did_emsg_syntax;                 /* did_emsg set because of a", "                                               syntax error */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN int ex_exitval INIT(= 0);            /* exit value for ex mode */", "EXTERN int emsg_on_display INIT(= FALSE);       /* there is an error message */", "EXTERN int rc_did_emsg INIT(= FALSE);       /* vim_regcomp() called emsg() */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int emsg_on_display INIT(= FALSE);       /* there is an error message */", "EXTERN int rc_did_emsg INIT(= FALSE);       /* vim_regcomp() called emsg() */", ""], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int need_wait_return INIT(= 0);      /* need to wait for return later */", "EXTERN int did_wait_return INIT(= FALSE);       /* wait_return() was used and", "                                                   nothing written since then */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN int need_wait_return INIT(= 0);      /* need to wait for return later */", "EXTERN int did_wait_return INIT(= FALSE);       /* wait_return() was used and", "                                                   nothing written since then */"], "readability/bool"]
["src/nvim/globals.h", ["                                                   nothing written since then */", "EXTERN int need_maketitle INIT(= TRUE);      /* call maketitle() soon */", ""], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int quit_more INIT(= FALSE);         /* 'q' hit at \"--more--\" msg */", "#if defined(UNIX) || defined(MACOS_X)"], "readability/bool"]
["src/nvim/globals.h", ["#if defined(UNIX) || defined(MACOS_X)", "EXTERN int newline_on_exit INIT(= FALSE);       /* did msg in altern. screen */", "EXTERN int intr_char INIT(= 0);             /* extra interrupt character */"], "readability/bool"]
["src/nvim/globals.h", ["#endif", "EXTERN int ex_keep_indent INIT(= FALSE);      /* getexmodeline(): keep indent */", "EXTERN int vgetc_busy INIT(= 0);            /* when inside vgetc() then > 0 */"], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int didset_vim INIT(= FALSE);        /* did set $VIM ourselves */", "EXTERN int didset_vimruntime INIT(= FALSE);        /* idem for $VIMRUNTIME */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int didset_vim INIT(= FALSE);        /* did set $VIM ourselves */", "EXTERN int didset_vimruntime INIT(= FALSE);        /* idem for $VIMRUNTIME */", ""], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int lines_left INIT(= -1);           /* lines left for listing */", "EXTERN int msg_no_more INIT(= FALSE);       /* don't use more prompt, truncate", "                                               messages */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN int lines_left INIT(= -1);           /* lines left for listing */", "EXTERN int msg_no_more INIT(= FALSE);       /* don't use more prompt, truncate", "                                               messages */"], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN char_u   *sourcing_name INIT( = NULL); /* name of error message source */", "EXTERN linenr_T sourcing_lnum INIT(= 0);    /* line number of the source file */"], "whitespace/parens"]
["src/nvim/globals.h", ["EXTERN int debug_break_level INIT(= -1);        /* break below this level */", "EXTERN int debug_did_msg INIT(= FALSE);         /* did \"debug mode\" message */", "EXTERN int debug_tick INIT(= 0);                /* breakpoint change count */"], "readability/bool"]
["src/nvim/globals.h", [" */", "EXTERN int did_throw INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", [" */", "EXTERN int need_rethrow INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", [" */", "EXTERN int check_cstack INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", [" */", "EXTERN int force_abort INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", [" */", "EXTERN int suppress_errthrow INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", [" */", "EXTERN int may_garbage_collect INIT(= FALSE);", "EXTERN int want_garbage_collect INIT(= FALSE);"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int may_garbage_collect INIT(= FALSE);", "EXTERN int want_garbage_collect INIT(= FALSE);", "EXTERN int garbage_collect_at_exit INIT(= FALSE);"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int want_garbage_collect INIT(= FALSE);", "EXTERN int garbage_collect_at_exit INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", ["  scid_T SID;", "  uint8_t *sourcing_name, *autocmd_fname, *autocmd_match; ", "  linenr_T sourcing_lnum;"], "whitespace/end_of_line"]
["src/nvim/globals.h", [" */", "EXTERN int highlight_match INIT(= FALSE);       /* show search match pos */", "EXTERN linenr_T search_match_lines;             /* lines of of matched string */"], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int no_smartcase INIT(= FALSE);          /* don't use 'smartcase' once */", ""], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int need_check_timestamps INIT(= FALSE);      /* need to check file", "                                                        timestamps asap */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["", "EXTERN int need_check_timestamps INIT(= FALSE);      /* need to check file", "                                                        timestamps asap */"], "readability/bool"]
["src/nvim/globals.h", ["                                                        timestamps asap */", "EXTERN int did_check_timestamps INIT(= FALSE);      /* did check timestamps", "                                                       recently */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["                                                        timestamps asap */", "EXTERN int did_check_timestamps INIT(= FALSE);      /* did check timestamps", "                                                       recently */"], "readability/bool"]
["src/nvim/globals.h", ["typedef enum {", "  HLF_8 = 0         /* Meta & special keys listed with \":map\", text that is", "                       displayed different from what it is */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["                       displayed different from what it is */", "  , HLF_EOB         //< after the last line in the buffer", "  , HLF_TERM        //< terminal cursor focused"], "whitespace/comments"]
["src/nvim/globals.h", ["  , HLF_EOB         //< after the last line in the buffer", "  , HLF_TERM        //< terminal cursor focused", "  , HLF_TERMNC      //< terminal cursor unfocused"], "whitespace/comments"]
["src/nvim/globals.h", ["  , HLF_TERM        //< terminal cursor focused", "  , HLF_TERMNC      //< terminal cursor unfocused", "  , HLF_AT          /* @ characters at end of screen, characters that"], "whitespace/comments"]
["src/nvim/globals.h", ["  , HLF_TERMNC      //< terminal cursor unfocused", "  , HLF_AT          /* @ characters at end of screen, characters that", "                       don't really exist in the text */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["", "EXTERN int autocmd_busy INIT(= FALSE);          /* Is apply_autocmds() busy? */", "EXTERN int autocmd_no_enter INIT(= FALSE);      /* *Enter autocmds disabled */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int autocmd_busy INIT(= FALSE);          /* Is apply_autocmds() busy? */", "EXTERN int autocmd_no_enter INIT(= FALSE);      /* *Enter autocmds disabled */", "EXTERN int autocmd_no_leave INIT(= FALSE);      /* *Leave autocmds disabled */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int autocmd_no_enter INIT(= FALSE);      /* *Enter autocmds disabled */", "EXTERN int autocmd_no_leave INIT(= FALSE);      /* *Leave autocmds disabled */", "EXTERN int modified_was_set;                    /* did \":set modified\" */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int modified_was_set;                    /* did \":set modified\" */", "EXTERN int did_filetype INIT(= FALSE);          /* FileType event found */", "EXTERN int keep_filetype INIT(= FALSE);         /* value for did_filetype when"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int did_filetype INIT(= FALSE);          /* FileType event found */", "EXTERN int keep_filetype INIT(= FALSE);         /* value for did_filetype when", "                                                   starting to execute"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN int did_filetype INIT(= FALSE);          /* FileType event found */", "EXTERN int keep_filetype INIT(= FALSE);         /* value for did_filetype when", "                                                   starting to execute"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN bool mouse_past_eol INIT(= false);       /* mouse right of line */", "EXTERN int mouse_dragging INIT(= 0);            /* extending Visual area with", "                                                   mouse dragging */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN int diff_foldcolumn INIT(= 2);           /* 'foldcolumn' for diff mode */", "EXTERN int diff_need_scrollbind INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", [" */", "EXTERN int sys_menu INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", [" * ('lines' and 'rows') must not be changed. */", "EXTERN int updating_screen INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", ["EXTERN win_T    *aucmd_win;     /* window used in aucmd_prepbuf() */", "EXTERN int aucmd_win_used INIT(= FALSE);        /* aucmd_win is being used */", ""], "readability/bool"]
["src/nvim/globals.h", ["EXTERN tabpage_T    *curtab;", "EXTERN int redraw_tabline INIT(= FALSE);           /* need to redraw tabline */", ""], "readability/bool"]
["src/nvim/globals.h", ["// Iterates over all tabs in the tab list", "# define FOR_ALL_TABS(tp) for (tabpage_T *tp = first_tabpage; tp != NULL; tp = tp->tp_next)", ""], "whitespace/line_length"]
["src/nvim/globals.h", ["// Iterates over all buffers in the buffer list.", "# define FOR_ALL_BUFFERS(buf) for (buf_T *buf = firstbuf; buf != NULL; buf = buf->b_next)", ""], "whitespace/line_length"]
["src/nvim/globals.h", [" * are to be loaded into memory.  Shouldn't be global... */", "EXTERN int mf_dont_release INIT(= FALSE);       /* don't release blocks */", ""], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int max_alist_id INIT(= 0);     ///< the previous argument list id", "EXTERN int arg_had_last INIT(= FALSE);      /* accessed last file in", "                                               global_alist */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN int max_alist_id INIT(= 0);     ///< the previous argument list id", "EXTERN int arg_had_last INIT(= FALSE);      /* accessed last file in", "                                               global_alist */"], "readability/bool"]
["src/nvim/globals.h", [" * set to 0 when starting up finished */", "EXTERN int exiting INIT(= FALSE);", "/* TRUE when planning to exit Vim.  Might"], "readability/bool"]
["src/nvim/globals.h", ["/* volatile because it is used in signal handler deathtrap(). */", "EXTERN volatile int full_screen INIT(= FALSE);", "/* TRUE when doing full-screen output"], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int restricted INIT(= FALSE);", "// TRUE when started in restricted mode (-Z)"], "readability/bool"]
["src/nvim/globals.h", ["// TRUE when started in restricted mode (-Z)", "EXTERN int secure INIT(= FALSE);", "/* non-zero when only \"safe\" commands are"], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int silent_mode INIT(= FALSE);", "/* set to TRUE when \"-s\" commandline argument"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN pos_T VIsual;            /* start position of active Visual selection */", "EXTERN int VIsual_active INIT(= FALSE);", "/* whether Visual mode is active */"], "readability/bool"]
["src/nvim/globals.h", ["/* whether Visual mode is active */", "EXTERN int VIsual_select INIT(= FALSE);", "/* whether Select mode is active */"], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int redo_VIsual_busy INIT(= FALSE);", "/* TRUE when redoing Visual */"], "readability/bool"]
["src/nvim/globals.h", [" */", "EXTERN int did_ai INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", [" */", "EXTERN int did_syncbind INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", [" */", "EXTERN int did_si INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", [" */", "EXTERN int can_si INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", [" */", "EXTERN int can_si_back INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", ["#endif", ";", ""], "whitespace/semicolon"]
["src/nvim/globals.h", [" */", "EXTERN pos_T Insstart;                  /* This is where the latest", "                                         * insert/append mode started. */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["", "EXTERN int enc_dbcs INIT(= 0);                  /* One of DBCS_xxx values if", "                                                   DBCS encoding */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN bool enc_utf8 INIT(= false);             /* UTF-8 encoded Unicode */", "EXTERN int enc_latin1like INIT(= TRUE);         /* 'encoding' is latin1 comp. */", "EXTERN int has_mbyte INIT(= 0);                 /* any multi-byte encoding */"], "readability/bool"]
["src/nvim/globals.h", ["/* idem, with limit on string length */", "EXTERN int (*mb_ptr2len_len)(const char_u *p, int size) INIT(= latin_ptr2len_len);", "/* byte length of char */"], "whitespace/line_length"]
["src/nvim/globals.h", ["EXTERN int (*mb_ptr2char)(const char_u *p) INIT(= latin_ptr2char);", "EXTERN int (*mb_head_off)(const char_u *base, const char_u *p) INIT(= latin_head_off);", ""], "whitespace/line_length"]
["src/nvim/globals.h", [" */", "EXTERN int State INIT(= NORMAL);        /* This is the current state of the", "                                         * command interpreter. */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["", "EXTERN int finish_op INIT(= FALSE);     /* TRUE while an operator is pending */", "EXTERN long opcount INIT(= 0);          /* count for pending operator */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int exmode_active INIT(= 0);     /* zero, EXMODE_NORMAL or EXMODE_VIM */", "EXTERN int ex_no_reprint INIT(= FALSE); /* no need to print after z or p */", ""], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int Recording INIT(= FALSE);     /* TRUE when recording into a reg. */", "EXTERN int Exec_reg INIT(= FALSE);      /* TRUE when executing a register */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int Recording INIT(= FALSE);     /* TRUE when recording into a reg. */", "EXTERN int Exec_reg INIT(= FALSE);      /* TRUE when executing a register */", ""], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int no_mapping INIT(= FALSE);    /* currently no mapping allowed */", "EXTERN int no_zero_mapping INIT(= 0);   /* mapping zero not allowed */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int no_zero_mapping INIT(= 0);   /* mapping zero not allowed */", "EXTERN int allow_keys INIT(= FALSE);    /* allow key codes when no_mapping", "                                         * is set */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN int no_zero_mapping INIT(= 0);   /* mapping zero not allowed */", "EXTERN int allow_keys INIT(= FALSE);    /* allow key codes when no_mapping", "                                         * is set */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int no_u_sync INIT(= 0);         /* Don't call u_sync() */", "EXTERN int u_sync_once INIT(= 0);       /* Call u_sync() once when evaluating", "                                           an expression. */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN int restart_edit INIT(= 0);      /* call edit when next cmd finished */", "EXTERN int arrow_used;                  /* Normally FALSE, set to TRUE after", "                                         * hitting cursor key in insert mode."], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN int restart_edit INIT(= 0);      /* call edit when next cmd finished */", "EXTERN int arrow_used;                  /* Normally FALSE, set to TRUE after", "                                         * hitting cursor key in insert mode."], "readability/bool"]
["src/nvim/globals.h", ["                                         * to call u_sync() */", "EXTERN int ins_at_eol INIT(= FALSE);      /* put cursor after eol when", "                                             restarting edit after CTRL-O */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["                                         * to call u_sync() */", "EXTERN int ins_at_eol INIT(= FALSE);      /* put cursor after eol when", "                                             restarting edit after CTRL-O */"], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int no_abbr INIT(= TRUE);        /* TRUE when no abbreviations loaded */", ""], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int mapped_ctrl_c INIT(= FALSE);      /* CTRL-C is mapped */", ""], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int emsg_silent INIT(= 0);       /* don't print error messages */", "EXTERN int cmd_silent INIT(= FALSE);      /* don't echo the command line */", ""], "readability/bool"]
["src/nvim/globals.h", [" * exists. */", "EXTERN int swap_exists_did_quit INIT(= FALSE);", "/* Selected \"quit\" at the dialog. */"], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int readonlymode INIT(= FALSE);      /* Set to TRUE for \"view\" */", "EXTERN int recoverymode INIT(= FALSE);      /* Set to TRUE for \"-r\" option */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int readonlymode INIT(= FALSE);      /* Set to TRUE for \"view\" */", "EXTERN int recoverymode INIT(= FALSE);      /* Set to TRUE for \"-r\" option */", ""], "readability/bool"]
["src/nvim/globals.h", ["#endif", ";", "EXTERN int ex_normal_busy INIT(= 0);      /* recursiveness of ex_normal() */"], "whitespace/semicolon"]
["src/nvim/globals.h", ["EXTERN int ex_normal_lock INIT(= 0);      /* forbid use of ex_normal() */", "EXTERN int ignore_script INIT(= FALSE);       /* ignore script input */", "EXTERN int stop_insert_mode;            /* for \":stopinsert\" and 'insertmode' */"], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN char_u chartab[256];             /* table used in charset.c; See", "                                           init_chartab() for explanation */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["", "EXTERN char_u chartab[256];             /* table used in charset.c; See", "                                           init_chartab() for explanation */"], "whitespace/newline"]
["src/nvim/globals.h", ["EXTERN int must_redraw INIT(= 0);           /* type of redraw necessary */", "EXTERN int skip_redraw INIT(= FALSE);       /* skip redraw once */", "EXTERN int do_redraw INIT(= FALSE);         /* extra redraw once */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int skip_redraw INIT(= FALSE);       /* skip redraw once */", "EXTERN int do_redraw INIT(= FALSE);         /* extra redraw once */", ""], "readability/bool"]
["src/nvim/globals.h", ["/* volatile because it is used in signal handler catch_sigint(). */", "EXTERN volatile int got_int INIT(= FALSE);    /* set to TRUE when interrupt", "                                                 signal occurred */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["/* volatile because it is used in signal handler catch_sigint(). */", "EXTERN volatile int got_int INIT(= FALSE);    /* set to TRUE when interrupt", "                                                 signal occurred */"], "readability/bool"]
["src/nvim/globals.h", ["                                                 signal occurred */", "EXTERN int bangredo INIT(= FALSE);          /* set to TRUE with ! command */", "EXTERN int searchcmdlen;                    /* length of previous search cmd */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int searchcmdlen;                    /* length of previous search cmd */", "EXTERN int reg_do_extmatch INIT(= 0);       /* Used when compiling regexp:", "                                             * REX_SET to allow \\z\\(...\\),"], "readability/multiline_comment"]
["src/nvim/globals.h", ["                                             * REX_USE to allow \\z\\1 et al. */", "EXTERN reg_extmatch_T *re_extmatch_in INIT(= NULL); /* Used by vim_regexec():", "                                                     * strings for \\z\\1...\\z\\9 */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN reg_extmatch_T *re_extmatch_in INIT(= NULL); /* Used by vim_regexec():", "                                                     * strings for \\z\\1...\\z\\9 */", "EXTERN reg_extmatch_T *re_extmatch_out INIT(= NULL); /* Set by vim_regexec()"], "whitespace/line_length"]
["src/nvim/globals.h", ["                                                     * strings for \\z\\1...\\z\\9 */", "EXTERN reg_extmatch_T *re_extmatch_out INIT(= NULL); /* Set by vim_regexec()", "                                                      * to store \\z\\(...\\) matches */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN reg_extmatch_T *re_extmatch_out INIT(= NULL); /* Set by vim_regexec()", "                                                      * to store \\z\\(...\\) matches */", ""], "whitespace/line_length"]
["src/nvim/globals.h", ["", "EXTERN int did_outofmem_msg INIT(= FALSE);", "/* set after out of memory msg */"], "readability/bool"]
["src/nvim/globals.h", ["/* set after out of memory msg */", "EXTERN int did_swapwrite_msg INIT(= FALSE);", "/* set after swap write error msg */"], "readability/bool"]
["src/nvim/globals.h", ["/* set after swap write error msg */", "EXTERN int undo_off INIT(= FALSE);          /* undo switched off for now */", "EXTERN int global_busy INIT(= 0);           /* set when :global is executing */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int global_busy INIT(= 0);           /* set when :global is executing */", "EXTERN int listcmd_busy INIT(= FALSE);      /* set when :argdo, :windo or", "                                               :bufdo is executing */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["EXTERN int global_busy INIT(= 0);           /* set when :global is executing */", "EXTERN int listcmd_busy INIT(= FALSE);      /* set when :argdo, :windo or", "                                               :bufdo is executing */"], "readability/bool"]
["src/nvim/globals.h", ["                                               :bufdo is executing */", "EXTERN int need_start_insertmode INIT(= FALSE);", "/* start insert mode soon */"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN char_u   *autocmd_match INIT(= NULL); /* name for <amatch> on cmdline */", "EXTERN int did_cursorhold INIT(= FALSE);      /* set when CursorHold t'gerd */", "EXTERN pos_T last_cursormoved                 /* for CursorMoved event */"], "readability/bool"]
["src/nvim/globals.h", ["# endif", ";", "EXTERN int last_changedtick INIT(= 0);        /* for TextChanged event */"], "whitespace/semicolon"]
["src/nvim/globals.h", ["EXTERN int postponed_split_tab INIT(= 0);       /* cmdmod.tab */", "EXTERN int g_do_tagpreview INIT(= 0);       /* for tag preview commands:", "                                               height of preview window */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["", "EXTERN int keep_help_flag INIT(= FALSE);      /* doing :ta from help file */", ""], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int redir_off INIT(= FALSE);     /* no redirection for a moment */", "EXTERN FILE *redir_fd INIT(= NULL);     /* message redirection file */"], "readability/bool"]
["src/nvim/globals.h", ["/* Whether 'keymodel' contains \"stopsel\" and \"startsel\". */", "EXTERN int km_stopsel INIT(= FALSE);", "EXTERN int km_startsel INIT(= FALSE);"], "readability/bool"]
["src/nvim/globals.h", ["EXTERN int km_stopsel INIT(= FALSE);", "EXTERN int km_startsel INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", ["/* don't use 'hlsearch' temporarily */", "EXTERN int no_hlsearch INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", ["", "EXTERN int typebuf_was_filled INIT(= FALSE);      /* received text from client", "                                                     or from feedkeys() */"], "readability/multiline_comment"]
["src/nvim/globals.h", ["", "EXTERN int typebuf_was_filled INIT(= FALSE);      /* received text from client", "                                                     or from feedkeys() */"], "readability/bool"]
["src/nvim/globals.h", ["# endif", ";", "#endif"], "whitespace/semicolon"]
["src/nvim/globals.h", ["/* Set when the cursor line needs to be redrawn. */", "EXTERN int need_cursor_line_redraw INIT(= FALSE);", ""], "readability/bool"]
["src/nvim/globals.h", ["# endif", ";", "#endif"], "whitespace/semicolon"]
["src/nvim/globals.h", ["EXTERN char_u e_argreq[] INIT(= N_(\"E471: Argument required\"));", "EXTERN char_u e_backslash[] INIT(= N_(\"E10: \\\\ should be followed by /, ? or &\"));", "EXTERN char_u e_cmdwin[] INIT(= N_("], "whitespace/line_length"]
["src/nvim/globals.h", ["EXTERN char_u e_curdir[] INIT(= N_(", "        \"E12: Command not allowed from exrc/vimrc in current dir or tag search\"));", "EXTERN char_u e_endif[] INIT(= N_(\"E171: Missing :endif\"));"], "whitespace/line_length"]
["src/nvim/globals.h", ["EXTERN char_u e_zerocount[] INIT(= N_(\"Zero count\"));", "EXTERN char_u e_usingsid[] INIT(= N_(\"E81: Using <SID> not in a script context\"));", "EXTERN char_u e_intern2[] INIT(= N_(\"E685: Internal error: %s\"));"], "whitespace/line_length"]
["src/nvim/globals.h", ["        \"E682: Invalid search pattern or delimiter\"));", "EXTERN char_u e_bufloaded[] INIT(= N_(\"E139: File is loaded in another buffer\"));", "EXTERN char_u e_notset[] INIT(= N_(\"E764: Option '%s' is not set\"));"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#else", "typedef unsigned long long khint64_t;", "#endif"], "runtime/int"]
["src/nvim/lib/khash.h", ["", "#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)", "#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)", "#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)", "#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)", "#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))", ""], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#ifndef kroundup32", "#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))", "#endif"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#ifndef kcalloc", "#define kcalloc(N,Z) xcalloc(N,Z)", "#endif"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["#ifndef krealloc", "#define krealloc(P,Z) xrealloc(P,Z)", "#endif"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["#define __KHASH_TYPE(name, khkey_t, khval_t) \\", "\ttypedef struct { \\", "\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\ttypedef struct { \\", "\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\", "\t\tkhint32_t *flags; \\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\", "\t\tkhint32_t *flags; \\", "\t\tkhkey_t *keys; \\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tkhint32_t *flags; \\", "\t\tkhkey_t *keys; \\", "\t\tkhval_t *vals; \\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tkhkey_t *keys; \\", "\t\tkhval_t *vals; \\", "\t} kh_##name##_t;"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tkhval_t *vals; \\", "\t} kh_##name##_t;", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["      mask = h->n_buckets - 1; \\", "      k = __hash_func(key); i = k & mask; \\", "      last = i; \\"], "whitespace/newline"]
["src/nvim/lib/khash.h", ["", "#define KHASH_DECLARE(name, khkey_t, khval_t)\t\t \t\t\t\t\t\\", "\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_DECLARE(name, khkey_t, khval_t)\t\t \t\t\t\t\t\\", "\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_PROTOTYPES(name, khkey_t, khval_t)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_PROTOTYPES(name, khkey_t, khval_t)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["", "#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\", "\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)", ""], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["", "#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\tKHASH_INIT2(name, static kh_inline, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)"], "whitespace/line_length"]
["src/nvim/lib/khash.h", ["#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\tKHASH_INIT2(name, static kh_inline, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\", "\tKHASH_INIT2(name, static kh_inline, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)", ""], "whitespace/line_length"]
["src/nvim/lib/khash.h", [" */", "#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)", "/*! @function"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["{", "\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\tkhint_t h = (khint_t)*s;", "\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;", "\treturn h;"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;", "\treturn h;", "}"], "whitespace/tab"]
["src/nvim/lib/khash.h", [" */", "#define kh_foreach(h, kvar, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define kh_foreach(h, kvar, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t} }"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t} }", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", [" */", "#define kh_foreach_value(h, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define kh_foreach_value(h, vvar, code) { khint_t __i;\t\t\\", "\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\", "\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\", "\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/comma"]
["src/nvim/lib/khash.h", ["\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\", "\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t} }"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t} }", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_SET_INIT_INT(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_SET_INIT_INT(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_MAP_INIT_INT(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_MAP_INIT_INT(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_SET_INIT_INT64(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_SET_INIT_INT64(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)", ""], "whitespace/line_length"]
["src/nvim/lib/khash.h", [" */", "#define KHASH_SET_INIT_STR(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)"], "whitespace/tab"]
["src/nvim/lib/khash.h", ["#define KHASH_SET_INIT_STR(name)\t\t\t\t\t\t\t\t\t\t\\", "\tKHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)", ""], "whitespace/tab"]
["src/nvim/lib/klist.h", ["", "#ifndef _AC_KLIST_H", "#define _AC_KLIST_H"], "build/header_guard"]
["src/nvim/lib/klist.h", ["", "#endif", ""], "build/header_guard"]
["src/nvim/lib/klist.h", ["        for (k = 0; k < mp->n; ++k) {                                   \\", "            kmpfree_f(mp->buf[k]); xfree(mp->buf[k]);                   \\", "        }                                                               \\"], "whitespace/newline"]
["src/nvim/lib/klist.h", ["        }                                                               \\", "        xfree(mp->buf); xfree(mp);                                      \\", "    }                                                                   \\"], "whitespace/newline"]
["src/nvim/lib/klist.h", ["        if (mp->n == mp->max) {                                         \\", "            mp->max = mp->max? mp->max<<1 : 16;                         \\", "            mp->buf = xrealloc(mp->buf, sizeof(kmptype_t *) * mp->max); \\"], "whitespace/operators"]
["src/nvim/lib/klist.h", ["        kl1_##name *q, *p = kmp_alloc(name, kl->mp);                    \\", "        q = kl->tail; p->next = 0; kl->tail->next = p; kl->tail = p;    \\", "        ++kl->size;                                                     \\"], "whitespace/newline"]
["src/nvim/lib/klist.h", ["    }                                                                   \\", "    ", ""], "whitespace/end_of_line"]
["src/nvim/lib/kvec.h", ["", "#ifndef AC_KVEC_H", "#define AC_KVEC_H"], "build/header_guard"]
["src/nvim/lib/kvec.h", ["", "#endif", ""], "build/header_guard"]
["src/nvim/lib/kvec.h", ["", "#define kv_roundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))", ""], "whitespace/line_length"]
["src/nvim/lib/kvec.h", ["", "#define kvec_t(type) struct { size_t size, capacity; type *items; }", "#define kv_init(v) ((v).size = (v).capacity = 0, (v).items = 0)"], "whitespace/newline"]
["src/nvim/lib/kvec.h", ["", "#define kv_resize(type, v, s)  ((v).capacity = (s), (v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity))", ""], "whitespace/line_length"]
["src/nvim/lib/kvec.h", ["", "#define kv_copy(type, v1, v0) do {\t\t\t\t\t\t\t\\", "\t\tif ((v1).capacity < (v0).size) kv_resize(type, v1, (v0).size);\t\\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["#define kv_copy(type, v1, v0) do {\t\t\t\t\t\t\t\\", "\t\tif ((v1).capacity < (v0).size) kv_resize(type, v1, (v0).size);\t\\", "\t\t(v1).size = (v0).size;\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["\t\tif ((v1).capacity < (v0).size) kv_resize(type, v1, (v0).size);\t\\", "\t\t(v1).size = (v0).size;\t\t\t\t\t\t\t\t\t\\", "\t\tmemcpy((v1).items, (v0).items, sizeof(type) * (v0).size);\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["\t\t(v1).size = (v0).size;\t\t\t\t\t\t\t\t\t\\", "\t\tmemcpy((v1).items, (v0).items, sizeof(type) * (v0).size);\t\t\\", "\t} while (0)\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["\t\tmemcpy((v1).items, (v0).items, sizeof(type) * (v0).size);\t\t\\", "\t} while (0)\t\t\t\t\t\t\t\t\t\t\t\t\\", ""], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["", "#define kv_push(type, v, x) do {\t\t\t\t\t\t\t\t\t\\", "\t\tif ((v).size == (v).capacity) {\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["#define kv_push(type, v, x) do {\t\t\t\t\t\t\t\t\t\\", "\t\tif ((v).size == (v).capacity) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t(v).capacity = (v).capacity? (v).capacity<<1 : 8;\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["\t\tif ((v).size == (v).capacity) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t(v).capacity = (v).capacity? (v).capacity<<1 : 8;\t\t\t\t\t\t\t\\", "\t\t\t(v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity);\t\\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["\t\tif ((v).size == (v).capacity) {\t\t\t\t\t\t\t\t\t\t\\", "\t\t\t(v).capacity = (v).capacity? (v).capacity<<1 : 8;\t\t\t\t\t\t\t\\", "\t\t\t(v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity);\t\\"], "whitespace/operators"]
["src/nvim/lib/kvec.h", ["\t\t\t(v).capacity = (v).capacity? (v).capacity<<1 : 8;\t\t\t\t\t\t\t\\", "\t\t\t(v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity);\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["\t\t\t(v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity);\t\\", "\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t(v).items[(v).size++] = (x);\t\t\t\t\t\t\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\", "\t\t(v).items[(v).size++] = (x);\t\t\t\t\t\t\t\t\t\t\\", "\t} while (0)"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["\t\t(v).items[(v).size++] = (x);\t\t\t\t\t\t\t\t\t\t\\", "\t} while (0)", ""], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["", "#define kv_pushp(type, v) (((v).size == (v).capacity)?\t\t\t\t\t\t\t\\", "\t\t\t\t\t\t   ((v).capacity = ((v).capacity? (v).capacity<<1 : 8),\t\t\t\t\\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["#define kv_pushp(type, v) (((v).size == (v).capacity)?\t\t\t\t\t\t\t\\", "\t\t\t\t\t\t   ((v).capacity = ((v).capacity? (v).capacity<<1 : 8),\t\t\t\t\\", "\t\t\t\t\t\t\t(v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity), 0)\t\\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["#define kv_pushp(type, v) (((v).size == (v).capacity)?\t\t\t\t\t\t\t\\", "\t\t\t\t\t\t   ((v).capacity = ((v).capacity? (v).capacity<<1 : 8),\t\t\t\t\\", "\t\t\t\t\t\t\t(v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity), 0)\t\\"], "whitespace/operators"]
["src/nvim/lib/kvec.h", ["\t\t\t\t\t\t   ((v).capacity = ((v).capacity? (v).capacity<<1 : 8),\t\t\t\t\\", "\t\t\t\t\t\t\t(v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity), 0)\t\\", "\t\t\t\t\t\t   : 0), ((v).items + ((v).size++))"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["\t\t\t\t\t\t\t(v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity), 0)\t\\", "\t\t\t\t\t\t   : 0), ((v).items + ((v).size++))", ""], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["#define kv_a(type, v, i) (((v).capacity <= (size_t)(i)? \\", "\t\t\t\t\t\t  ((v).capacity = (v).size = (i) + 1, kv_roundup32((v).capacity), \\", "\t\t\t\t\t\t   (v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity), 0) \\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["\t\t\t\t\t\t  ((v).capacity = (v).size = (i) + 1, kv_roundup32((v).capacity), \\", "\t\t\t\t\t\t   (v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity), 0) \\", "\t\t\t\t\t\t  : (v).size <= (size_t)(i)? (v).size = (i) + 1 \\"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["\t\t\t\t\t\t  ((v).capacity = (v).size = (i) + 1, kv_roundup32((v).capacity), \\", "\t\t\t\t\t\t   (v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity), 0) \\", "\t\t\t\t\t\t  : (v).size <= (size_t)(i)? (v).size = (i) + 1 \\"], "whitespace/line_length"]
["src/nvim/lib/kvec.h", ["\t\t\t\t\t\t   (v).items = (type*)xrealloc((v).items, sizeof(type) * (v).capacity), 0) \\", "\t\t\t\t\t\t  : (v).size <= (size_t)(i)? (v).size = (i) + 1 \\", "\t\t\t\t\t\t  : 0), (v).items[(i)])"], "whitespace/tab"]
["src/nvim/lib/kvec.h", ["\t\t\t\t\t\t  : (v).size <= (size_t)(i)? (v).size = (i) + 1 \\", "\t\t\t\t\t\t  : 0), (v).items[(i)])", ""], "whitespace/tab"]
["src/nvim/lib/queue.h", ["", "#ifndef QUEUE_H_", "#define QUEUE_H_"], "build/header_guard"]
["src/nvim/lib/queue.h", ["", "#endif /* QUEUE_H_ */", ""], "build/header_guard"]
["src/nvim/macros.h", ["                         ((a).coladd == (b).coladd))", "# define clearpos(a) {(a)->lnum = 0; (a)->col = 0; (a)->coladd = 0; }", ""], "whitespace/newline"]
["src/nvim/macros.h", ["        c = langmap_mapchar[c]; \\", "      else \\", "        c = langmap_adjust_mb(c); \\"], "whitespace/newline"]
["src/nvim/macros.h", ["/* Backup multi-byte pointer. Only use with \"p\" > \"s\" ! */", "# define mb_ptr_back(s, p)  (p -= has_mbyte ? ((*mb_head_off)((char_u *)s, (char_u *)p - 1) + 1) : 1)", "/* get length of multi-byte char, not including composing chars */"], "whitespace/line_length"]
["src/nvim/macros.h", ["  if (has_mbyte) mb_copy_char((const char_u **)(&f), &t); \\", "  else *t++ = *f++", "# define MB_CHARLEN(p)      (has_mbyte ? mb_charlen(p) : (int)STRLEN(p))"], "whitespace/newline"]
["src/nvim/macros.h", ["", "# define RESET_BINDING(wp)  (wp)->w_p_scb = FALSE; (wp)->w_p_crb = FALSE", ""], "readability/bool"]
["src/nvim/macros.h", ["/// This should be called with a real array. Calling this with a pointer is an", "/// error. A mechanism to detect many (though not all) of those errors at compile", "/// time is implemented. It works by the second division producing a division by"], "whitespace/line_length"]
["src/nvim/macros.h", ["/// zero in those cases (-Wdiv-by-zero in GCC).", "#define ARRAY_SIZE(arr) ((sizeof(arr)/sizeof((arr)[0])) / ((size_t)(!(sizeof(arr) % sizeof((arr)[0])))))", ""], "whitespace/line_length"]
["src/nvim/mark_defs.h", ["", "#endif // NVIM_MARK_DEFS_H", ""], "build/header_guard"]
["src/nvim/mark_defs.h", ["", "#endif // NVIM_MARK_DEFS_H", ""], "whitespace/comments"]
["src/nvim/memline_defs.h", ["", "#endif // NVIM_MEMLINE_DEFS_H", ""], "build/header_guard"]
["src/nvim/memline_defs.h", ["", "#endif // NVIM_MEMLINE_DEFS_H", ""], "whitespace/comments"]
["src/nvim/menu.h", ["  char_u      *dname;               /* Displayed Name (\"name\" without '&') */", "  char_u      *en_name;             /* \"name\" untranslated, NULL when \"name\"", "                                     * was not translated */"], "readability/multiline_comment"]
["src/nvim/menu.h", ["                                     * was not translated */", "  char_u      *en_dname;            /* \"dname\" untranslated, NULL when \"dname\"", "                                     * was not translated */"], "readability/multiline_comment"]
["src/nvim/normal.h", ["  int motion_force;             /* force motion type: 'v', 'V' or CTRL-V */", "  bool use_reg_one;             /* true if delete uses reg 1 even when not", "                                   linewise */"], "readability/multiline_comment"]
["src/nvim/normal.h", ["                                   linewise */", "  bool inclusive;               /* true if char motion is inclusive (only", "                                   valid when motion_type is MCHAR */"], "readability/multiline_comment"]
["src/nvim/normal.h", ["                                   valid when motion_type is MCHAR */", "  bool end_adjusted;            /* backuped b_op_end one char (only used by", "                                   do_format()) */"], "readability/multiline_comment"]
["src/nvim/normal.h", ["                                   valid when motion_type is MCHAR */", "  bool end_adjusted;            /* backuped b_op_end one char (only used by", "                                   do_format()) */"], "whitespace/parens"]
["src/nvim/normal.h", ["", "  long line_count;              /* number of lines from op_start to op_end", "                                   (inclusive) */"], "readability/multiline_comment"]
["src/nvim/normal.h", ["                                   (inclusive) */", "  bool empty;                   /* op_start and op_end the same (only used by", "                                   op_change()) */"], "readability/multiline_comment"]
["src/nvim/normal.h", ["                                   (inclusive) */", "  bool empty;                   /* op_start and op_end the same (only used by", "                                   op_change()) */"], "whitespace/parens"]
["src/nvim/option_defs.h", ["", "#endif // NVIM_OPTION_DEFS_H", ""], "build/header_guard"]
["src/nvim/option_defs.h", ["// Option types for various functions in option.c", "#define SREQ_GLOBAL 0 // Request global option", "#define SREQ_WIN 1    // Request window-local option"], "whitespace/comments"]
["src/nvim/option_defs.h", ["#define DFLT_EFM \\", "  \"%*[^\\\"]\\\"%f\\\"%*\\\\D%l: %m,\\\"%f\\\"%*\\\\D%l: %m,%-G%f:%l: (Each undeclared identifier is reported only once,%-G%f:%l: for each function it appears in.),%-GIn file included from %f:%l:%c:,%-GIn file included from %f:%l:%c\\\\,,%-GIn file included from %f:%l:%c,%-GIn file included from %f:%l,%-G%*[ ]from %f:%l:%c,%-G%*[ ]from %f:%l:,%-G%*[ ]from %f:%l\\\\,,%-G%*[ ]from %f:%l,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\\\"%f\\\"\\\\, line %l%*\\\\D%c%*[^ ] %m,%D%*\\\\a[%*\\\\d]: Entering directory %*[`']%f',%X%*\\\\a[%*\\\\d]: Leaving directory %*[`']%f',%D%*\\\\a: Entering directory %*[`']%f',%X%*\\\\a: Leaving directory %*[`']%f',%DMaking %*\\\\a in %f,%f|%l| %m\"", ""], "whitespace/line_length"]
["src/nvim/option_defs.h", ["#define CPO_REGAPPEND   '>'     /* insert NL when appending to a register */", "#define CPO_SCOLON      ';'     /* using \",\" and \";\" will skip over char if", "                                 * cursor would not move */"], "readability/multiline_comment"]
["src/nvim/option_defs.h", ["#define LISPWORD_VALUE \\", "  \"defun,define,defmacro,set!,lambda,if,case,let,flet,let*,letrec,do,do*,define-syntax,let-syntax,letrec-syntax,destructuring-bind,defpackage,defparameter,defstruct,deftype,defvar,do-all-symbols,do-external-symbols,do-symbols,dolist,dotimes,ecase,etypecase,eval-when,labels,macrolet,multiple-value-bind,multiple-value-call,multiple-value-prog1,multiple-value-setq,prog1,progv,typecase,unless,unwind-protect,when,with-input-from-string,with-open-file,with-open-stream,with-output-to-string,with-package-iterator,define-condition,handler-bind,handler-case,restart-bind,restart-case,with-simple-restart,store-value,use-value,muffle-warning,abort,continue,with-slots,with-slots*,with-accessors,with-accessors*,defclass,defmethod,print-unreadable-object\"", ""], "whitespace/line_length"]
["src/nvim/option_defs.h", ["", "#endif // NVIM_OPTION_DEFS_H", ""], "whitespace/comments"]
["src/nvim/os_unix.h", ["#define NODE_NORMAL     0       /* file or directory, check with os_isdir()*/", "#define NODE_WRITABLE   1       /* something we can write to (character", "                                   device, fifo, socket, ..) */"], "readability/multiline_comment"]
["src/nvim/path.h", ["#endif", "#endif", ""], "build/header_guard"]
["src/nvim/regexp_defs.h", ["typedef struct {", "  short refcnt;", "  char_u              *matches[NSUBEXP];"], "runtime/int"]
["src/nvim/regexp.h", ["", "#endif /* NVIM_REGEXP_H */", ""], "build/header_guard"]
["src/nvim/screen.h", [" */", "#define VALID                   10  /* buffer not changed, or changes marked", "                                       with b_mod_* */"], "readability/multiline_comment"]
["src/nvim/sign_defs.h", ["", "#endif // NVIM_SIGN_DEFS_H", ""], "build/header_guard"]
["src/nvim/sign_defs.h", ["/* type argument for buf_getsigntype() */", "#define SIGN_ANY\t0", "#define SIGN_LINEHL\t1"], "whitespace/tab"]
["src/nvim/sign_defs.h", ["#define SIGN_ANY\t0", "#define SIGN_LINEHL\t1", "#define SIGN_ICON\t2"], "whitespace/tab"]
["src/nvim/sign_defs.h", ["#define SIGN_LINEHL\t1", "#define SIGN_ICON\t2", "#define SIGN_TEXT\t3"], "whitespace/tab"]
["src/nvim/sign_defs.h", ["#define SIGN_ICON\t2", "#define SIGN_TEXT\t3", ""], "whitespace/tab"]
["src/nvim/sign_defs.h", ["", "#endif // NVIM_SIGN_DEFS_H", ""], "whitespace/comments"]
["src/nvim/syntax_defs.h", ["", "#endif // NVIM_SYNTAX_DEFS_H", ""], "build/header_guard"]
["src/nvim/syntax_defs.h", ["", "typedef unsigned short disptick_T;      /* display tick type */", ""], "runtime/int"]
["src/nvim/syntax_defs.h", ["  int inc_tag;                  /* \":syn include\" unique tag */", "  short id;                     /* highlight group ID of item */", "  short       *cont_in_list;    /* cont.in group IDs, if non-zero */"], "runtime/int"]
["src/nvim/syntax_defs.h", ["  short id;                     /* highlight group ID of item */", "  short       *cont_in_list;    /* cont.in group IDs, if non-zero */", "};"], "runtime/int"]
["src/nvim/syntax_defs.h", ["  struct sp_syn k_syn;          /* struct passed to in_id_list() */", "  short       *next_list;       /* ID list for next match (if non-zero) */", "  int flags;"], "runtime/int"]
["src/nvim/syntax_defs.h", ["  int sst_stacksize;            /* number of states on the stack */", "  short       *sst_next_list;   /* \"nextgroup\" list in this state", "                                 * (this is a copy, don't free it! */"], "readability/multiline_comment"]
["src/nvim/syntax_defs.h", ["  int sst_stacksize;            /* number of states on the stack */", "  short       *sst_next_list;   /* \"nextgroup\" list in this state", "                                 * (this is a copy, don't free it! */"], "runtime/int"]
["src/nvim/syntax_defs.h", ["  short       *sst_next_list;   /* \"nextgroup\" list in this state", "                                 * (this is a copy, don't free it! */", "  disptick_T sst_tick;          /* tick when last displayed */"], "whitespace/operators"]
["src/nvim/syntax_defs.h", ["  disptick_T sst_tick;          /* tick when last displayed */", "  linenr_T sst_change_lnum;     /* when non-zero, change in this line", "                                 * may have made the state invalid */"], "readability/multiline_comment"]
["src/nvim/syntax_defs.h", ["typedef struct attr_entry {", "  short rgb_ae_attr, cterm_ae_attr;  // HL_BOLD, etc.", "  RgbValue rgb_fg_color, rgb_bg_color;"], "runtime/int"]
["src/nvim/syntax_defs.h", ["", "#endif // NVIM_SYNTAX_DEFS_H", ""], "whitespace/comments"]
["src/nvim/syntax.h", ["#define HL_CONTAINED   0x01    /* not used on toplevel */", "#define HL_TRANSP      0x02    /* has no highlighting\t*/", "#define HL_ONELINE     0x04    /* match within one line only */"], "whitespace/tab"]
["src/nvim/tag.h", ["", "#define TAG_MANY        300     /* When finding many tags (for completion),", "                                   find up to this many tags */"], "readability/multiline_comment"]
["src/nvim/undo_defs.h", ["", "#endif // NVIM_UNDO_DEFS_H", ""], "build/header_guard"]
["src/nvim/undo_defs.h", ["  time_t uh_time;               /* timestamp when the change was made */", "  long uh_save_nr;              /* set when the file was saved after the", "                                   changes in this block */"], "readability/multiline_comment"]
["src/nvim/undo_defs.h", ["", "#endif // NVIM_UNDO_DEFS_H", ""], "whitespace/comments"]
["src/nvim/vim.h", ["", "#endif /* NVIM_VIM_H */", ""], "build/header_guard"]
["src/nvim/vim.h", ["# if (SIZEOF_INT == 0)", "Error: configure did not run properly.Check auto/config.log.", "# endif"], "readability/alt_tokens"]
["src/nvim/vim.h", ["#define VISUAL          0x02    /* Visual mode - use get_real_state() */", "#define OP_PENDING      0x04    /* Normal mode, operator is pending - use", "                                   get_real_state() */"], "readability/multiline_comment"]
["src/nvim/vim.h", ["#define INSERT          0x10    /* Insert mode */", "#define LANGMAP         0x20    /* Language mapping, can be combined with", "                                   INSERT and CMDLINE */"], "readability/multiline_comment"]
["src/nvim/vim.h", [" */", "#ifndef TRUE", "# define FALSE  0           /* note: this is an int, not a long! */"], "readability/bool"]
["src/nvim/vim.h", ["#ifndef TRUE", "# define FALSE  0           /* note: this is an int, not a long! */", "# define TRUE   1"], "readability/bool"]
["src/nvim/vim.h", ["# define FALSE  0           /* note: this is an int, not a long! */", "# define TRUE   1", "#endif"], "readability/bool"]
["src/nvim/vim.h", ["#define STRLEN(s)           strlen((char *)(s))", "#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))", "#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))"], "runtime/printf"]
["src/nvim/vim.h", ["", "#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))", "#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))"], "runtime/printf"]
["src/nvim/window.h", ["#define FNAME_INCL      8       /* apply 'includeexpr' */", "#define FNAME_REL       16      /* \"..\" and \"./\" are relative to the (current)", "                                   file instead of the current directory */"], "readability/multiline_comment"]
